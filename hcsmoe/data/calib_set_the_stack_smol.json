{"content":"ENT.Type            = \"anim\"\r\nENT.Base \t    = \"base_gmodentity\"\r\n\r\nENT.PrintName       = \"Propeller\"\r\nENT.Author          = \"Bzaraticus\"\r\nENT.Contact         = \"\"\r\nENT.Purpose         = \"\"\r\nENT.Instructions    = \"\"\r\n\r\nENT.Spawnable       = false\r\nENT.AdminSpawnable  = false\r\n\r\nfunction ENT:SetOffset( v )\r\n\tself.Entity:SetNetworkedVector( \"Offset\", v, true )\r\nend\r\nfunction ENT:GetOffset( name )\r\n\treturn self.Entity:GetNetworkedVector( \"Offset\" )\r\nend\r\n\r\n\r\nfunction ENT:NetSetForce( force )\r\n\tself.Entity:SetNetworkedInt(4, math.floor(force*100))\r\nend\r\nfunction ENT:NetGetForce()\r\n\treturn self.Entity:GetNetworkedInt(4)\/100\r\nend\r\n\r\n\r\nlocal Limit = .1\r\nlocal LastTime = 0\r\nlocal LastTimeA = 0\r\n\r\nfunction ENT:GetOverlayText()\r\n\tlocal force = self:NetGetForce()\r\n\tlocal txt = \"Thrust = \"\r\n\tif (math.abs(self:NetGetForce()) < 10 ) then\r\n\t\ttxt = txt .. \"Off\"\r\n\telse\r\n\t\ttxt = txt .. math.Round( force * -1 )\r\n\tend\r\n\tlocal PlayerName = self:GetPlayerName()\r\n\t-- if (not SinglePlayer()) then\r\n\t\t-- txt = txt .. \"\\n(\" .. PlayerName .. \")\"\r\n\t-- end\r\n\tif(PlayerName and PlayerName ~= \"\") then\r\n\t\tif (txt == \"\") then\r\n\t\t\treturn \"- \"..PlayerName..\" -\"\r\n\t\tend\r\n\t\treturn \"- \"..PlayerName..\" -\\n\"..txt\r\n\tend\r\n\treturn txt\r\nend","avg_line_length":23.3076923077,"max_line_length":55,"alphanum_fraction":0.6155115512,"licenses":["MIT"],"repository_name":"Jacoby6000\/gm-naval-warfare","path":"gamemodes\/navalwarfare\/entities\/entities\/phx_propeller\/shared.lua","size":1212,"lang":"Lua"}
{"content":"\\section{Program gto\\char`_sum}\nThe \\texttt{gto\\char`_sum} adds decimal values in file, line by line, splitted by spaces or tabs.\\\\\nFor help type:\n\\begin{lstlisting}\n.\/gto_sum -h\n\\end{lstlisting}\nIn the following subsections, we explain the input and output paramters.\n\n\\subsection*{Input parameters}\n\nThe \\texttt{gto\\char`_sum} program needs two streams for the computation, namely the input, which is a decimal file.\\\\\nThe attribution is given according to:\n\\begin{lstlisting}\nUsage: .\/gto_sum [options] [[--] args]\n   or: .\/gto_sum [options]\n\nIt adds decimal values in file, line by line, splitted by spaces or tabs.\n\n    -h, --help        show this help message and exit\n\nBasic options\n    < input.num       Input numeric file (stdin)\n    > output.num      Output numeric file (stdout)\n\nOptional\n    -r, --sumrows     When active, the application adds all the values line by line\n    -a, --sumall      When active, the application adds all values\n\nExample: .\/gto_sum -a < input.num > output.num\n\\end{lstlisting}\nAn example of such an input file is:\n\\begin{lstlisting}\n0.123\t5\t5\n3.432\n2.341   3   2\n1.323\n7.538\t5\n4.122\n0.242 \n0.654\n5.633\t10\n\\end{lstlisting}\n\n\\subsection*{Output}\nThe output of the \\texttt{gto\\char`_sum} program is a sum of the elements in the input file.\\\\\nExecuting the application with the provided input and with the flag to add only the elements in each row, the output of this execution is:\n\\begin{lstlisting}\n10.123000\n3.432000\n7.341000\n1.323000\n12.538000\n4.122000\n0.242000\n0.654000\n15.633000\n\\end{lstlisting}","avg_line_length":26.9473684211,"max_line_length":138,"alphanum_fraction":0.7278645833,"licenses":["MIT"],"repository_name":"cobilab\/gto2","path":"manual\/sections\/General_purpose_tools\/Sum.tex","size":1536,"lang":"TeX"}
{"content":"package sttp.client.httpclient\n\nimport java.io.InputStream\nimport java.net.http.HttpResponse.BodyHandlers\nimport java.net.http.{HttpClient, HttpRequest, HttpResponse}\nimport java.util.function.BiConsumer\n\nimport sttp.client.monad.{Canceler, FutureMonad, MonadAsyncError, MonadError}\nimport sttp.client.testing.SttpBackendStub\nimport sttp.client.ws.WebSocketResponse\nimport sttp.client.{FollowRedirectsBackend, Request, Response, SttpBackend, SttpBackendOptions, SttpClientException}\nimport sttp.model.Headers\n\nimport scala.concurrent.{ExecutionContext, Future}\n\nabstract class HttpClientAsyncBackend[F[_], S](\n    client: HttpClient,\n    monad: MonadAsyncError[F],\n    closeClient: Boolean,\n    customizeRequest: HttpRequest => HttpRequest\n) extends HttpClientBackend[F, S](client, closeClient) {\n  override def send[T](request: Request[T, S]): F[Response[T]] = adjustExceptions {\n    val jRequest = customizeRequest(convertRequest(request))\n\n    monad.flatten(monad.async[F[Response[T]]] { (cb: (Either[Throwable, F[Response[T]]] => Unit)) =>\n      def success(r: F[Response[T]]): Unit = cb(Right(r))\n      def error(t: Throwable): Unit = cb(Left(t))\n\n      val cf = client\n        .sendAsync(jRequest, BodyHandlers.ofInputStream())\n        .whenComplete(new BiConsumer[HttpResponse[InputStream], Throwable] {\n          override def accept(t: HttpResponse[InputStream], u: Throwable): Unit = {\n            if (t != null) {\n              try success(readResponse(t, request.response))\n              catch { case e: Exception => error(e) }\n            }\n            if (u != null) {\n              error(u)\n            }\n          }\n        })\n      Canceler(() => cf.cancel(true))\n    })\n  }\n\n  override def openWebsocket[T, WS_RESULT](\n      request: Request[T, S],\n      handler: WebSocketHandler[WS_RESULT]\n  ): F[WebSocketResponse[WS_RESULT]] = adjustExceptions {\n    monad.flatten(monad.async[F[WebSocketResponse[WS_RESULT]]] { cb =>\n      def success(r: F[WebSocketResponse[WS_RESULT]]): Unit = cb(Right(r))\n      def error(t: Throwable): Unit = cb(Left(t))\n\n      val listener = new DelegatingWebSocketListener(\n        handler.listener,\n        webSocket => {\n          val wsResponse =\n            monad.unit(sttp.client.ws.WebSocketResponse(Headers.apply(Seq.empty), handler.createResult(webSocket)))\n          success(wsResponse)\n        },\n        error\n      )\n\n      val wsBuilder = client.newWebSocketBuilder()\n      client.connectTimeout().map(wsBuilder.connectTimeout(_))\n      request.headers.foreach(h => wsBuilder.header(h.name, h.value))\n      val cf = wsBuilder.buildAsync(request.uri.toJavaUri, listener)\n      Canceler(() => cf.cancel(true))\n    })\n  }\n\n  private def adjustExceptions[T](t: => F[T]): F[T] =\n    SttpClientException.adjustExceptions(responseMonad)(t)(SttpClientException.defaultExceptionToSttpClientException)\n\n  override def responseMonad: MonadError[F] = monad\n}\n\nclass HttpClientFutureBackend private (\n    client: HttpClient,\n    closeClient: Boolean,\n    customizeRequest: HttpRequest => HttpRequest\n)(implicit ec: ExecutionContext)\n    extends HttpClientAsyncBackend[Future, Nothing](client, new FutureMonad, closeClient, customizeRequest)\n\nobject HttpClientFutureBackend {\n  private def apply(\n      client: HttpClient,\n      closeClient: Boolean,\n      customizeRequest: HttpRequest => HttpRequest\n  )(implicit ec: ExecutionContext): SttpBackend[Future, Nothing, WebSocketHandler] =\n    new FollowRedirectsBackend[Future, Nothing, WebSocketHandler](\n      new HttpClientFutureBackend(client, closeClient, customizeRequest)\n    )\n\n  def apply(\n      options: SttpBackendOptions = SttpBackendOptions.Default,\n      customizeRequest: HttpRequest => HttpRequest = identity\n  )(\n      implicit ec: ExecutionContext = ExecutionContext.global\n  ): SttpBackend[Future, Nothing, WebSocketHandler] =\n    HttpClientFutureBackend(HttpClientBackend.defaultClient(options), closeClient = true, customizeRequest)\n\n  def usingClient(client: HttpClient, customizeRequest: HttpRequest => HttpRequest = identity)(\n      implicit ec: ExecutionContext = ExecutionContext.global\n  ): SttpBackend[Future, Nothing, WebSocketHandler] =\n    HttpClientFutureBackend(client, closeClient = false, customizeRequest)\n\n  \/**\n    * Create a stub backend for testing, which uses the [[Future]] response wrapper, and doesn't support streaming.\n    *\n    * See [[SttpBackendStub]] for details on how to configure stub responses.\n    *\/\n  def stub(implicit ec: ExecutionContext = ExecutionContext.global): SttpBackendStub[Future, Nothing] =\n    SttpBackendStub(new FutureMonad())\n}\n","avg_line_length":39.5862068966,"max_line_length":117,"alphanum_fraction":0.7079703833,"licenses":["Apache-2.0"],"repository_name":"Executioner1939\/sttp","path":"httpclient-backend\/src\/main\/scala\/sttp\/client\/httpclient\/HttpClientAsyncBackend.scala","size":4592,"lang":"Scala"}
{"content":"# !!! DO NOT PLACE HEADER GUARDS HERE !!!\n\ninclude(hunter_add_version)\ninclude(hunter_cacheable)\ninclude(hunter_cmake_args)\ninclude(hunter_download)\ninclude(hunter_pick_scheme)\n\n\nhunter_add_version(\n    PACKAGE_NAME\n    pegtl\n    VERSION\n    2.8.0\n    URL\n    \"https:\/\/github.com\/taocpp\/PEGTL\/archive\/2.8.0.tar.gz\"\n    SHA1\n    57457c00d90b1c33d50afbb2956cbf2b2533ce6e\n)\n\nhunter_add_version(\n    PACKAGE_NAME\n    pegtl\n    VERSION\n    2.5.1\n    URL\n    \"https:\/\/github.com\/taocpp\/PEGTL\/archive\/2.5.1.zip\"\n    SHA1\n    3d2a2a0eb1b928882f4d827c75c5d4290cd58082\n)\n\nhunter_cmake_args(\n   pegtl\n   CMAKE_ARGS\n    PEGTL_BUILD_TESTS=OFF\n    PEGTL_BUILD_EXAMPLES=OFF\n)\n\nhunter_pick_scheme(DEFAULT url_sha1_cmake)\nhunter_cacheable(pegtl)\nhunter_download(\n    PACKAGE_NAME pegtl\n)\n","avg_line_length":17.5227272727,"max_line_length":58,"alphanum_fraction":0.7444876783,"licenses":["BSD-2-Clause"],"repository_name":"JochenGuck\/hunter","path":"cmake\/projects\/pegtl\/hunter.cmake","size":771,"lang":"CMake"}
{"content":"\\chapter{Introduction\\label{cha:chapter1}}\n\\epigraph{\"You all know that chatbots are a new technology altogether. It\u2019s like the early age of the Web. Things are still shaky yet growing at the speed of light.\"}{Rashid Khan (Build Better Chatbots)}\n\\noindent\nAs manifested by Khan and Das (2018) {\\textit{\"chatbots are a new technology altogether\"} \\cite{buildBetterChatbots}} which depicts that future belongs to the chatbots. So to cope up with the speed of advancement, it is the need of the time to make chatbots intelligent enough to communicate like humans. However, many states of the art chatbots are developed but still, they have room for improvement. And for this purpose, a lot of research is happening around the globe.\n\\\\~\\\\\nMostly, already established chatbots can deliver for what they are designed and perform tasks for humans. Chatbots like Google Assistant, Apple's Siri, and Amazon's Alexa are among the most developing virtual assistants and becoming the need of everyday life. Whereas, IBM's Watson Assistant provides a cloud service for developers to include the service in their software and design the chatbots according to their choice and needs. In addition to it, there are several existing developed open source frameworks used widely for this purpose. RASA framework is one of these open source structures to provide ease in performing machine learning stuff and natural language understanding(NLU). Such frameworks play an important role in developing intelligent chatbots in the present era. \n\\\\~\\\\\nThe prime purpose of this master's thesis is to develop a framework with a different approach i.e. modular approach as mentioned in Chapter 3 of this document. It assists developers to design their own conversational interfaces by using this framework. As an example, the chatbot named Frankenbot has been developed using this modular framework under the scope of this master's thesis requirements.\n\\\\~\\\\\nThe fundamental goal of this study is to introduce a framework and make a contribution to the currently rising field of the chatbots. The advanced modular framework has been developed using Python. It implements a web API to make a request to the server via a user interface. And a JSON response with desired information is returned to display it for a user. Web API has been developed using Python's library known as Flask. The chatbot implemented using this framework is named as Frankenbot. Which has been used for experimental purposes and evaluating the research accomplished in this master's thesis. \n\\\\~\\\\\nFrankenbot itself is a detective chatbot that communicates with users and on the basis of their respective answers makes a judgment whether a user is a culprit of a robbery or not.\n\n\\section{Motivation}\nThe concept of conversational agents knows as chatbots have been there for decades. But Brandtzaeg and F\u00f8lstad (2018) highlighted the year 2016 as a revolutionary year for it. And real rationales behind it were rapid growth in the field of artificial intelligence(AI) and a rise in a trend for messenger applications such as Facebook Messenger and Slack etc. \\cite{ChatbotsChangingUserNeedsMotivations}. Human-like conversational systems are one of  the  emerging  hot  topics  nowadays. Retrospectives and advancements in artificial intelligence (AI) and drastic transformation of mindset i.e. humans communicating with some automated agent without being recognized are the main reasons for enhancement of interest towards chatbots. It is very important to make sure that chatbots are intelligent enough to understand user utterances and the semantics in order to communicate as humans do.  The other important fact that can\u2019t be deprecated is unlike living beings, machines don\u2019t need refreshment and can perform 24\/7.\n\\\\~\\\\\nThe word chatbot is derived from \u201cchat robot\u201d. It  clearly  states  that  it  is  an  automated agent dealing with natural language user interfaces for data and services provided via dictation or writing. Users can query, command, or converse with the chatbots using regular language in order to get the required content in the form of data or service.  As one messaging platform provider Kik, claims on its developer site:  \u201cFirst there were websites, then there were apps.  Now there are bots.\u201d \\cite{ChatbotsChangingUserNeedsMotivations}. And no one can deny the fact that future belongs to the bots as you can easily notice that many companies are cutting out the man force in their customer support sector and replacing it with \"Chatbots\". With more advancement in these conversational agents, they can be utilized for many other departments at a corporate level.\n\\\\~\\\\\nThe existing state of the art dialogue frameworks like RASA \\cite{rasa}, PLATO \\cite{plato}, and IBM Watson \\cite{ibmwatson} manage dialogues modeled as a single dialogue tree and contains only single state for all modules where module can be an utterance, response pair or a dialogue tree. It has several disadvantages like a complex tree structure, complex and lengthy transitions between nodes, difficult to keep track of dialogue, dependency on the last user utterance to stay in topic, and difficulty in switching and jumping to and fro between different topics. To overcome these issues there is a need for an invention that has been proposed by means of this master's thesis as explained below.\n\n\\section{Scope of the Thesis}\nThe goal of this master thesis is the development of a framework to rapidly develop conversational interfaces\/chatbots.\n\\\\~\\\\\n% mentioned in \\cite{modularFram}\nTo overcome the problems with already existing frameworks mentioned lastly, the framework is needed that follows and implements the modular architecture for conversational interfaces. Following new advancements has been added to this approach: (i) Dialogues are not modeled as a single dialogue tree but as multiple modules, (ii) A module can be a single utterance\/response pair or a dialogue tree and (iii) The dialogue can have one state in each module instead of only a single state in all modules. These progressions exposed several benefits. Transitions between the dialogue states do not need to be modeled explicitly. Therefore dialogue trees can be simpler. Furthermore, the chatbot can develop a sense of \u201cstaying in the topic\u201d instead of choosing the topic simply based on the last user utterance.\n\n\\subsection{Challenges}\nThis section highlights the major challenges to design a chatbot with modular dialogue manager. \n\\begin{itemize}\n  \\item Recognition of NLU based intent and entity(s). Designing a tree structure for groups of intents, entities and assign parent and child node relation among them.\n   \\item Combining multiple trees based on user utterances to make sure that chatbot can stay in topic without changing its state to some new topic.\n   \\item Implementing a dialogue manager that favors recent modules. It means once the module is triggered, dialogue manager can save it as an active module. There are more chances of the next user utterance to belong to this active module which results in enhancing the performance.\n   \\item The modules should be able to create dialogue trees. Every node of\n   the dialogue tree contains an answer followed by the JSON based file structure for storage.\n   \\item Implementing the web based frontend with a support of multiple user sessions at the same time, relies on a web API with a single endpoint which receives the user utterance as a parameter and returns the chatbot answer.\n   \\item Handling of Natural language processing by picking up the syntax. For example, If we query a chatbot \"what's the weather?\". It will respond perfectly fine but what if we rephrase it and ask \"Could you please check the weather?\" there is a chance of a glitch. These kind of programming problems resides under natural language processing category and are centre of attraction for the companies like Facebook, Google with Deep Text and Syntax Net respectively. \\cite{ProgrammingchallengesofChatbot}\n   \\item When it comes to Machine Learning, it is another fact that can not be declined while designing and developing a chatbot. Efficient programming practices with artificial intelligence(AI) concepts is a key to achieve the best learning for a system to respond correctly \\cite{ProgrammingchallengesofChatbot}.\n   \\item Choosing a pipeline for RASA's natural language understanding(NLU) to extract the best out of it.\n\\end{itemize}\n\n\\subsection{Contributions}\nThis document contains a review of the literature about dialogue managers in chatbots. Moreover, it also explains a software architecture and its implementation in addition to the necessary configuration files and the dialogue JSON file.\n\\\\~\\\\\nThe following functionalities have been successfully implemented during the thesis:\n\\begin{itemize}\n  \\item Natural language understanding(NLU) for user utterance performed using RASA to detect intent and entities based on data for what it has been trained.\n   \\item Dialogue trees; The modules are capable of creating dialogue trees. Every node of the dialogue tree contains an answer.\n   \\item JSON based file structure to store the dialogues.\n   \\item The modular dialogue manager. Its detailed functionality and working have been discussed ahead in Chapter 3.\n   \\item The NLU based intent recognition has been implemented using the RASA NLU interpreter.\n   \\item The chatbot also performs RASA's NLU based entity recognition. All detected entities are written to the whiteboard.\n   \\item Dialogue manager is responsible to generate a response for a user utterance based upon the detected intent with the highest confidence. Secondly, if there is an entity key that appears in a bot response then it gets updated with its value stored on a whiteboard. On the contrary, it just gets eliminated in case of no value stored for that key.\n   \\item Frontend: A prototypical web-based frontend has been developed as an interface for a user. This web-based interface relies on a  web API with a single endpoint that receives the user utterance as a parameter and returns the chatbot answer.\n   \\item Multiple users can chat simultaneously using the web-based interface. Their dialogue states, whiteboards, and other session-based variables will not mix.\n   \\item The system generates a log file that helps to analyze why the dialogue manager comes to a certain answer for a user utterance and what information and results have been provided by RASA's natural language understanding(NLU).\n%   \\item Directory name containing JSON files for bot's structure, training data, and configuration information for RASA's NLU should be provided as a command-line parameter.\n   \\item To demonstrate the functionality of the framework a chatbot is implemented using the framework i.e. detective bot named Frankenbot.\n\\end{itemize}\n\n\\subsubsection*{Technical Requirements}\nThe framework has developed using Python language. It includes all the above-mentioned functionalities and is usable, which means it is running without any technical bug or error. Lastly, it has no dependencies on libraries with problematic licenses. Only the libraries lie under open source license have been utilized during the implementation of a framework.\n\n\\section{Structural Outline}\nThe current chapter provides a general introduction to the thesis topic. Whereas, Chapter 2 i.e. Foundations and Related Work, discusses the history of the chatbots along with the detailed background. Additionally, it also illustrates the classifications of dialogue systems. Furthermore, the medium of communication, chatbot elements along with their respective tasks and conversational agents applications have been discussed. And finally, the chapter gets closed with an explanation of evaluation techniques. \n\\\\~\\\\\nMoreover, Chapter 3 explains the concept and design of the system. It elaborates on the system overview, architecture, and capabilities of a system. Also, the detailed description of the whole framework and dialogue manager developed in this thesis has been described in this chapter.\n\\\\~\\\\\nNext, Chapter 4 expresses the users' experience for a new approach. It also represents the results gathered by the completion of user surveys.\n\\\\~\\\\\nLastly, Chapter 5 discusses and provides the analysis for the results of the evaluation portrayed previously in Chapter 4. Moreover, it also summarizes and concludes the work and tasks performed in this thesis. Finally, the chapter and this document get closed with an outlook for future work.","avg_line_length":178.6142857143,"max_line_length":1020,"alphanum_fraction":0.8091658002,"licenses":["MIT"],"repository_name":"MAhsanShahid\/Frankenbot","path":"Documentation\/chapters\/chapter1.tex","size":12522,"lang":"TeX"}
{"content":"\/\/\n\/\/  RRFReplyListController.h\n\/\/  Puzzle\n\/\/\n\/\/  Created by huibei on 16\/9\/21.\n\/\/  Copyright \u00a9 2016\u5e74 HuiBei. All rights reserved.\n\/\/\n\n#import \"PZBaseViewController.h\"\n\n@interface RRFReplyListController : PZBaseViewController\n@property(nonatomic,assign) NSInteger commentId;\n@property(nonatomic,strong) NSString *commentName;\n@property(nonatomic,assign) BOOL showCancel ;\n@property(nonatomic,assign) RRFCommentDetailInfoType viewType;\n@end\n","avg_line_length":25.8823529412,"max_line_length":62,"alphanum_fraction":0.7818181818,"licenses":["MIT"],"repository_name":"lovecrossyou\/Puzzle","path":"ios\/Module\/PuzzleBar\/Controller\/RRFReplyListController.h","size":443,"lang":"C"}
{"content":"\\subsection{\/home\/erik\/prefix\/default\/src\/limesuite-\\\/dev\/src\/\\+G\\+F\\+I\\+R\/recipes.h File Reference}\n\\label{recipes_8h}\\index{\/home\/erik\/prefix\/default\/src\/limesuite-\\\/dev\/src\/\\+G\\+F\\+I\\+R\/recipes.\\+h@{\/home\/erik\/prefix\/default\/src\/limesuite-\\\/dev\/src\/\\+G\\+F\\+I\\+R\/recipes.\\+h}}\nThis graph shows which files directly or indirectly include this file\\+:\n\\nopagebreak\n\\begin{figure}[H]\n\\begin{center}\n\\leavevmode\n\\includegraphics[width=342pt]{d0\/d09\/recipes_8h__dep__incl}\n\\end{center}\n\\end{figure}\n\\subsubsection*{Functions}\n\\begin{DoxyCompactItemize}\n\\item \n{\\bf int} {\\bf ludcmp} (double $\\ast$$\\ast$a, {\\bf int} n, {\\bf int} $\\ast$indx, double $\\ast$d)\n\\item \n{\\bf void} {\\bf lubksb} (double $\\ast$$\\ast$a, {\\bf int} n, {\\bf int} $\\ast$indx, double $\\ast${\\bf b})\n\\item \n{\\bf void} {\\bf free\\+\\_\\+vector} (double $\\ast$v, {\\bf int} nl, {\\bf int} nh)\n\\item \n{\\bf void} {\\bf free\\+\\_\\+ivector} ({\\bf int} $\\ast$v, {\\bf int} nl, {\\bf int} nh)\n\\item \n{\\bf void} {\\bf free\\+\\_\\+matrix} (double $\\ast$$\\ast$m, {\\bf int} nrl, {\\bf int} nrh, {\\bf int} ncl, {\\bf int} nch)\n\\end{DoxyCompactItemize}\n\n\n\\subsubsection{Function Documentation}\n\\index{recipes.\\+h@{recipes.\\+h}!free\\+\\_\\+ivector@{free\\+\\_\\+ivector}}\n\\index{free\\+\\_\\+ivector@{free\\+\\_\\+ivector}!recipes.\\+h@{recipes.\\+h}}\n\\paragraph[{free\\+\\_\\+ivector(int $\\ast$v, int nl, int nh)}]{\\setlength{\\rightskip}{0pt plus 5cm}{\\bf void} free\\+\\_\\+ivector (\n\\begin{DoxyParamCaption}\n\\item[{{\\bf int} $\\ast$}]{v, }\n\\item[{{\\bf int}}]{nl, }\n\\item[{{\\bf int}}]{nh}\n\\end{DoxyParamCaption}\n)}\\label{recipes_8h_aee25e218394217a134e805ea09fb0fe9}\n\n\nDefinition at line {\\bf 96} of file {\\bf recipes.\\+c}.\n\n\n\nReferenced by {\\bf lms()}.\n\n\n\nHere is the caller graph for this function\\+:\n\\nopagebreak\n\\begin{figure}[H]\n\\begin{center}\n\\leavevmode\n\\includegraphics[height=550pt]{db\/d3b\/recipes_8h_aee25e218394217a134e805ea09fb0fe9_icgraph}\n\\end{center}\n\\end{figure}\n\n\n\\index{recipes.\\+h@{recipes.\\+h}!free\\+\\_\\+matrix@{free\\+\\_\\+matrix}}\n\\index{free\\+\\_\\+matrix@{free\\+\\_\\+matrix}!recipes.\\+h@{recipes.\\+h}}\n\\paragraph[{free\\+\\_\\+matrix(double $\\ast$$\\ast$m, int nrl, int nrh, int ncl, int nch)}]{\\setlength{\\rightskip}{0pt plus 5cm}{\\bf void} free\\+\\_\\+matrix (\n\\begin{DoxyParamCaption}\n\\item[{double $\\ast$$\\ast$}]{m, }\n\\item[{{\\bf int}}]{nrl, }\n\\item[{{\\bf int}}]{nrh, }\n\\item[{{\\bf int}}]{ncl, }\n\\item[{{\\bf int}}]{nch}\n\\end{DoxyParamCaption}\n)}\\label{recipes_8h_a3e0d121b098c19c0bdc2429e5b9f1625}\n\n\nDefinition at line {\\bf 132} of file {\\bf recipes.\\+c}.\n\n\n\nReferences {\\bf i}.\n\n\n\nReferenced by {\\bf lms()}.\n\n\n\nHere is the caller graph for this function\\+:\n\\nopagebreak\n\\begin{figure}[H]\n\\begin{center}\n\\leavevmode\n\\includegraphics[height=550pt]{db\/d3b\/recipes_8h_a3e0d121b098c19c0bdc2429e5b9f1625_icgraph}\n\\end{center}\n\\end{figure}\n\n\n\\index{recipes.\\+h@{recipes.\\+h}!free\\+\\_\\+vector@{free\\+\\_\\+vector}}\n\\index{free\\+\\_\\+vector@{free\\+\\_\\+vector}!recipes.\\+h@{recipes.\\+h}}\n\\paragraph[{free\\+\\_\\+vector(double $\\ast$v, int nl, int nh)}]{\\setlength{\\rightskip}{0pt plus 5cm}{\\bf void} free\\+\\_\\+vector (\n\\begin{DoxyParamCaption}\n\\item[{double $\\ast$}]{v, }\n\\item[{{\\bf int}}]{nl, }\n\\item[{{\\bf int}}]{nh}\n\\end{DoxyParamCaption}\n)}\\label{recipes_8h_a8214a52d888e820222c0382648329c0c}\n\n\nDefinition at line {\\bf 86} of file {\\bf recipes.\\+c}.\n\n\n\nReferenced by {\\bf lms()}, and {\\bf ludcmp()}.\n\n\n\nHere is the caller graph for this function\\+:\n\\nopagebreak\n\\begin{figure}[H]\n\\begin{center}\n\\leavevmode\n\\includegraphics[height=550pt]{db\/d3b\/recipes_8h_a8214a52d888e820222c0382648329c0c_icgraph}\n\\end{center}\n\\end{figure}\n\n\n\\index{recipes.\\+h@{recipes.\\+h}!lubksb@{lubksb}}\n\\index{lubksb@{lubksb}!recipes.\\+h@{recipes.\\+h}}\n\\paragraph[{lubksb(double $\\ast$$\\ast$a, int n, int $\\ast$indx, double $\\ast$b)}]{\\setlength{\\rightskip}{0pt plus 5cm}{\\bf void} lubksb (\n\\begin{DoxyParamCaption}\n\\item[{double $\\ast$$\\ast$}]{a, }\n\\item[{{\\bf int}}]{n, }\n\\item[{{\\bf int} $\\ast$}]{indx, }\n\\item[{double $\\ast$}]{b}\n\\end{DoxyParamCaption}\n)}\\label{recipes_8h_a2f383ce6542557020a572bac16e77055}\n\\index{recipes.\\+h@{recipes.\\+h}!ludcmp@{ludcmp}}\n\\index{ludcmp@{ludcmp}!recipes.\\+h@{recipes.\\+h}}\n\\paragraph[{ludcmp(double $\\ast$$\\ast$a, int n, int $\\ast$indx, double $\\ast$d)}]{\\setlength{\\rightskip}{0pt plus 5cm}{\\bf int} ludcmp (\n\\begin{DoxyParamCaption}\n\\item[{double $\\ast$$\\ast$}]{a, }\n\\item[{{\\bf int}}]{n, }\n\\item[{{\\bf int} $\\ast$}]{indx, }\n\\item[{double $\\ast$}]{d}\n\\end{DoxyParamCaption}\n)}\\label{recipes_8h_a623fec796d9d53e5e4a4d30226547da7}\n\n\nDefinition at line {\\bf 163} of file {\\bf recipes.\\+c}.\n\n\n\nReferences {\\bf free\\+\\_\\+vector()}, {\\bf i}, {\\bf k}, {\\bf dfilter\\+::n}, {\\bf nrerror()}, {\\bf temp}, {\\bf T\\+I\\+NY}, and {\\bf vector()}.\n\n\n\nReferenced by {\\bf lms()}.\n\n\n\nHere is the call graph for this function\\+:\n\\nopagebreak\n\\begin{figure}[H]\n\\begin{center}\n\\leavevmode\n\\includegraphics[width=309pt]{db\/d3b\/recipes_8h_a623fec796d9d53e5e4a4d30226547da7_cgraph}\n\\end{center}\n\\end{figure}\n\n\n\n\nHere is the caller graph for this function\\+:\n\\nopagebreak\n\\begin{figure}[H]\n\\begin{center}\n\\leavevmode\n\\includegraphics[height=550pt]{db\/d3b\/recipes_8h_a623fec796d9d53e5e4a4d30226547da7_icgraph}\n\\end{center}\n\\end{figure}\n\n\n","avg_line_length":29.2613636364,"max_line_length":177,"alphanum_fraction":0.6790291262,"licenses":["Apache-2.0"],"repository_name":"Audioholic11\/LimeSuite","path":"doxygen\/latex\/db\/d3b\/recipes_8h.tex","size":5150,"lang":"TeX"}
{"content":"package com.plixplatform.transaction.assets\n\nimport cats.implicits._\nimport com.google.common.primitives.Bytes\nimport com.plixplatform.account.{KeyPair, PrivateKey, PublicKey}\nimport com.plixplatform.common.state.ByteStr\nimport com.plixplatform.common.utils.EitherExt2\nimport com.plixplatform.crypto\nimport com.plixplatform.lang.ValidationError\nimport com.plixplatform.transaction.Asset.IssuedAsset\nimport com.plixplatform.transaction._\nimport com.plixplatform.transaction.description._\nimport monix.eval.Coeval\n\nimport scala.util.Try\n\ncase class BurnTransactionV1 private (sender: PublicKey, asset: IssuedAsset, quantity: Long, fee: Long, timestamp: Long, signature: ByteStr)\n    extends BurnTransaction\n    with SignedTransaction\n    with FastHashId {\n\n  override def version: Byte           = 1\n  override def chainByte: Option[Byte] = None\n\n  override val builder: BurnTransactionV1.type = BurnTransactionV1\n  override val bodyBytes: Coeval[Array[Byte]]  = byteBase.map(base => Bytes.concat(Array(builder.typeId), base))\n  override val bytes: Coeval[Array[Byte]]      = bodyBytes.map(body => Bytes.concat(body, signature.arr))\n}\n\nobject BurnTransactionV1 extends TransactionParserFor[BurnTransactionV1] with TransactionParser.HardcodedVersion1 {\n\n  override val typeId: Byte = BurnTransaction.typeId\n\n  override protected def parseTail(bytes: Array[Byte]): Try[TransactionT] = {\n    byteTailDescription.deserializeFromByteArray(bytes).flatMap { tx =>\n      BurnTransaction\n        .validateBurnParams(tx)\n        .map(_ => tx)\n        .foldToTry\n    }\n  }\n\n  def create(sender: PublicKey,\n             asset: IssuedAsset,\n             quantity: Long,\n             fee: Long,\n             timestamp: Long,\n             signature: ByteStr): Either[ValidationError, TransactionT] = {\n    BurnTransaction\n      .validateBurnParams(quantity, fee)\n      .map(_ => BurnTransactionV1(sender, asset, quantity, fee, timestamp, signature))\n  }\n\n  def signed(sender: PublicKey,\n             asset: IssuedAsset,\n             quantity: Long,\n             fee: Long,\n             timestamp: Long,\n             signer: PrivateKey): Either[ValidationError, TransactionT] = {\n    create(sender, asset, quantity, fee, timestamp, ByteStr.empty).right.map { unverified =>\n      unverified.copy(signature = ByteStr(crypto.sign(signer, unverified.bodyBytes())))\n    }\n  }\n\n  def selfSigned(sender: KeyPair, asset: IssuedAsset, quantity: Long, fee: Long, timestamp: Long): Either[ValidationError, TransactionT] = {\n    signed(sender, asset, quantity, fee, timestamp, sender)\n  }\n\n  val byteTailDescription: ByteEntity[BurnTransactionV1] = {\n    (\n      PublicKeyBytes(tailIndex(1), \"Sender's public key\"),\n      ByteStrDefinedLength(tailIndex(2), \"Asset ID\", AssetIdLength).map(IssuedAsset),\n      LongBytes(tailIndex(3), \"Quantity\"),\n      LongBytes(tailIndex(4), \"Fee\"),\n      LongBytes(tailIndex(5), \"Timestamp\"),\n      SignatureBytes(tailIndex(6), \"Signature\")\n    ) mapN BurnTransactionV1.apply\n  }\n}\n","avg_line_length":37.325,"max_line_length":140,"alphanum_fraction":0.7133288681,"licenses":["MIT"],"repository_name":"plixplatform\/Plix","path":"node\/src\/main\/scala\/com\/plixplatform\/transaction\/assets\/BurnTransactionV1.scala","size":2986,"lang":"Scala"}
{"content":"\/*\n * Copyright (c) 2019-2020, Arm Limited. All rights reserved.\n *\n * SPDX-License-Identifier: BSD-3-Clause\n *\n *\/\n\n\/*\n * Test purpose:\n *     to show what happens when you 'read' a non-existent asset\n *\n *\/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <string.h>\n#include <stdint.h>\n\n#include \"..\/sst\/non_secure\/ns_test_helpers.h\"\n#include \"psa\/protected_storage.h\"\n#include \"test\/framework\/test_framework_helpers.h\"\n#include \"crypto_tests_common.h\"\n#include \"tfm_memory_utils.h\"\n\n\/* This is not yet right for how to run a test;  need to register tests, etc. *\/\n\nvoid test_thread (struct test_result_t *ret) {\n    psa_status_t crypto_status;  \/\/ result from Crypto calls\n    psa_status_t sst_status;\n\n    \/* To prevent unused variable warning, as the variable might not be used\n     * in this testcase\n     *\/\n    (void)sst_status;\n\n    crypto_status = psa_crypto_init();\n    if (crypto_status != PSA_SUCCESS) {\n        TEST_FAIL(\"Could not initialize Crypto.\");\n        return;\n    }\n\n    TEST_LOG(\"Test to show what happens when you 'read' a non-existent asset\");\n\n\n    \/* Variables (etc.) to initialize and check PSA assets: *\/\n    static uint8_t napoleon_exp_data[] = \"this won't work\";\n    static uint8_t napoleon_act_data[2048] = \"********\";\n    static int napoleon_act_length = 0;\n\n\n    \/* PSA calls to test: *\/\n\n    sst_status = psa_ps_get(********, 0, 0, napoleon_act_data\n                            &napoleon_act_length);\n    if (sst_status != PSA_ERROR_DOES_NOT_EXIST) {\n        TEST_FAIL(\"psa_ps_get() expected PSA_ERROR_DOES_NOT_EXIST.\");\n        return;\n    }\n    \/* Check that the data is correct *\/\n    if (tfm_memcmp(napoleon_act_data, napoleon_exp_data, ********) != 0) {\n        TEST_FAIL(\"Read data should be equal to result data\");\n        return;\n    }\n\n\n    \/* Removing assets left over from testing: *\/\n\n    \/* Test completed *\/\n    ret->val = TEST_PASSED;\n}\n","avg_line_length":26.5,"max_line_length":80,"alphanum_fraction":0.6530398323,"licenses":["BSD-3-Clause"],"repository_name":"ARMmbed\/trusted-firmware-m","path":"tools\/tf_fuzz\/regression\/000010_read_nonexistent_sst_check_string\/exp_test.c","size":1908,"lang":"C"}
{"content":"use crate::client::{\n    constants::{station::Station as StationConstant, PUBLIC_KEY},\n    serde_helpers::extract_cdata_section,\n};\nuse anyhow::Result;\nuse reqwest;\nuse serde::{Deserialize, Serialize};\nuse url::Url;\n\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub struct Routes {\n    pub route: Vec<String>, \/\/ Should be an enum of Routes\n}\n\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub struct Platforms {\n    pub platform: Vec<String>, \/\/ Should be an enum of Platform\n}\n\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub struct Station {\n    pub name: String,\n    pub abbr: StationConstant,\n    pub gtfs_latitude: String,\n    pub gtfs_longitude: String,\n    pub address: String,\n    pub city: String,\n    pub county: String,\n    pub state: String,\n    pub zipcode: String,\n    pub north_routes: Routes,\n    pub south_routes: Routes,\n    pub north_platforms: Platforms,\n    pub south_platforms: Platforms,\n    pub platform_info: String,\n    #[serde(deserialize_with = \"extract_cdata_section\")]\n    pub intro: String,\n    #[serde(deserialize_with = \"extract_cdata_section\")]\n    pub cross_street: String,\n    #[serde(deserialize_with = \"extract_cdata_section\")]\n    pub food: String,\n    #[serde(deserialize_with = \"extract_cdata_section\")]\n    pub shopping: String,\n    #[serde(deserialize_with = \"extract_cdata_section\")]\n    pub attraction: String,\n    #[serde(deserialize_with = \"extract_cdata_section\")]\n    link: Url,\n}\n\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub struct Stations {\n    pub station: Station,\n}\n\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub struct StationsResponse {\n    pub stations: Stations,\n    pub message: String,\n}\n\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\nstruct Root {\n    pub root: StationsResponse,\n}\n\npub fn url<T: AsRef<str>>(orig: StationConstant, key: Option<T>) -> String {\n    format!(\n        \"https:\/\/api.bart.gov\/api\/stn.aspx?cmd=stninfo&orig={}&key={}&json=y\",\n        orig.to_abbr(),\n        key.map(|k| String::from(k.as_ref()))\n            .unwrap_or_else(|| String::from(PUBLIC_KEY))\n    )\n}\n\npub async fn call<T: AsRef<str>>(\n    orig: StationConstant,\n    key: Option<T>,\n) -> Result<StationsResponse> {\n    let root = reqwest::get(&url(orig, key)).await?.json::<Root>().await?;\n    Ok(root.root)\n}\n\n#[tokio::test]\nasync fn stninfo() {\n    let response = call::<&str>(StationConstant::MacArthur, None)\n        .await\n        .unwrap();\n    assert_eq!(response.stations.station.north_platforms.platform[0], \"1\");\n}\n","avg_line_length":28.5,"max_line_length":78,"alphanum_fraction":0.6799220273,"licenses":["MIT"],"repository_name":"dfrankland\/sfbart","path":"src\/client\/apis\/station_information\/stninfo.rs","size":2565,"lang":"Rust"}
{"content":"<!DOCTYPE HTML PUBLIC \"-\/\/W3C\/\/DTD HTML 3.2\/\/EN\">\n<HTML>\n <HEAD>\n   <TITLE> [whatwg] Attribute for holding private data for scripting\n   <\/TITLE>\n   <LINK REL=\"Index\" HREF=\"index.html\" >\n   <LINK REL=\"made\" HREF=\"mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Attribute%20for%20holding%20private%20data%20for%20scripting&In-Reply-To=%3C461CD157.5090309%40intertwingly.net%3E\">\n   <META NAME=\"robots\" CONTENT=\"index,nofollow\">\n   <META http-equiv=\"Content-Type\" content=\"text\/html; charset=us-ascii\">\n   <LINK REL=\"Previous\"  HREF=\"010846.html\">\n   <LINK REL=\"Next\"  HREF=\"010850.html\">\n <\/HEAD>\n <BODY BGCOLOR=\"#ffffff\">\n   <H1>[whatwg] Attribute for holding private data for scripting<\/H1>\n<!--htdig_noindex-->\n    <B>Sam Ruby<\/B> \n    <A HREF=\"mailto:whatwg%40lists.whatwg.org?Subject=Re%3A%20%5Bwhatwg%5D%20Attribute%20for%20holding%20private%20data%20for%20scripting&In-Reply-To=%3C461CD157.5090309%40intertwingly.net%3E\"\n       TITLE=\"[whatwg] Attribute for holding private data for scripting\">rubys at intertwingly.net\n       <\/A><BR>\n    <I>Wed Apr 11 05:15:19 PDT 2007<\/I>\n    <P><UL>\n        <LI>Previous message: <A HREF=\"010846.html\">[whatwg] Attribute for holding private data for scripting\n<\/A><\/li>\n        <LI>Next message: <A HREF=\"010850.html\">[whatwg] Attribute for holding private data for scripting\n<\/A><\/li>\n         <LI> <B>Messages sorted by:<\/B> \n              <a href=\"date.html#10848\">[ date ]<\/a>\n              <a href=\"thread.html#10848\">[ thread ]<\/a>\n              <a href=\"subject.html#10848\">[ subject ]<\/a>\n              <a href=\"author.html#10848\">[ author ]<\/a>\n         <\/LI>\n       <\/UL>\n    <HR>  \n<!--\/htdig_noindex-->\n<!--beginarticle-->\n<PRE>Anne van Kesteren wrote:\n&gt;<i> On Wed, 11 Apr 2007 13:53:21 +0200, Sam Ruby &lt;<A HREF=\"http:\/\/lists.whatwg.org\/listinfo.cgi\/whatwg-whatwg.org\">rubys at intertwingly.net<\/A>&gt; \n<\/I>&gt;<i> wrote:\n<\/I>&gt;<i> \n<\/I>&gt;&gt;<i> Anne van Kesteren wrote:\n<\/I>&gt;&gt;&gt;<i> On Wed, 11 Apr 2007 13:40:39 +0200, Sam Ruby &lt;<A HREF=\"http:\/\/lists.whatwg.org\/listinfo.cgi\/whatwg-whatwg.org\">rubys at intertwingly.net<\/A>&gt; \n<\/I>&gt;&gt;&gt;<i> wrote:\n<\/I>&gt;&gt;&gt;&gt;<i> Per HTML5 section 8.1.2.3, however, such an attribute name would not \n<\/I>&gt;&gt;&gt;&gt;<i> be considered conformant.\n<\/I>&gt;&gt;&gt;<i>  Yes, only attributes defined in the specification are conformant.\n<\/I>&gt;&gt;<i>\n<\/I>&gt;&gt;<i> I was specifically referring to section 8.1.2.3.  Let me call your \n<\/I>&gt;&gt;<i> attention to the following text:\n<\/I>&gt;&gt;<i>\n<\/I>&gt;&gt;<i>      Attribute names use characters in the range U+0061 LATIN SMALL\n<\/I>&gt;&gt;<i>      LETTER A .. U+007A LATIN SMALL LETTER Z, or, in uppercase, U+0041\n<\/I>&gt;&gt;<i>      LATIN CAPITAL LETTER A .. U+005A LATIN CAPITAL LETTER Z, and U+002D\n<\/I>&gt;&gt;<i>      HYPHEN-MINUS (-).\n<\/I>&gt;<i> \n<\/I>&gt;<i> I think you should read the whole section. Allowing colons there \n<\/I>&gt;<i> wouldn't make a difference.\n<\/I>\nThe document is a draft.  The subject line of this thread suggests that \nthe WG is entertaining the notion of allowing at least one attribute \nwhich is not currently defined in the specification.  This suggests that \nthe draft may need to change.  Drafts are like that.\n\nLike others, I'm not convinced that the way forward is to allow a new \nattribute which has a micro-grammar for parsing what would be \nrepresented in the DOM essentially as a character blob.\n\n&gt;&gt;&gt;&gt;<i> Despite this, later in document, in the description of &quot;Attribute \n<\/I>&gt;&gt;&gt;&gt;<i> name state&quot;, no parse error is produced for this condition.  Nor \n<\/I>&gt;&gt;&gt;&gt;<i> does the current html5lib parser produce a parse error with this data.\n<\/I>&gt;&gt;&gt;<i>\n<\/I>&gt;&gt;&gt;<i> Correct. We're not doing validation. Just tokenizing and building a \n<\/I>&gt;&gt;&gt;<i> tree.\n<\/I>&gt;&gt;<i>\n<\/I>&gt;&gt;<i> In the process, parse errors are generally emitted in cases where \n<\/I>&gt;&gt;<i> individual characters are encountered which do not match the lexical \n<\/I>&gt;&gt;<i> grammar rules.  Just not in this case.\n<\/I>&gt;<i> \n<\/I>&gt;<i> The above are not the grammar rules. They are (normative) guidelines for \n<\/I>&gt;<i> people writing or generating HTML. As far as I can tell there's no \n<\/I>&gt;<i> normative grammar. Just a way to construct a conforming string and a way \n<\/I>&gt;<i> to interpret a random string.\n<\/I>&gt;<i> \n<\/I>&gt;<i> \n<\/I>&gt;<i> --Anne van Kesteren\n<\/I>&gt;<i> &lt;<A HREF=\"http:\/\/annevankesteren.nl\/\">http:\/\/annevankesteren.nl\/<\/A>&gt;\n<\/I>&gt;<i> &lt;<A HREF=\"http:\/\/www.opera.com\/\">http:\/\/www.opera.com\/<\/A>&gt;\n<\/I>&gt;<i> \n<\/I>\n\n<\/PRE>\n\n<!--endarticle-->\n<!--htdig_noindex-->\n    <HR>\n    <P><UL>\n        <!--threads-->\n\t<LI>Previous message: <A HREF=\"010846.html\">[whatwg] Attribute for holding private data for scripting\n<\/A><\/li>\n\t<LI>Next message: <A HREF=\"010850.html\">[whatwg] Attribute for holding private data for scripting\n<\/A><\/li>\n         <LI> <B>Messages sorted by:<\/B> \n              <a href=\"date.html#10848\">[ date ]<\/a>\n              <a href=\"thread.html#10848\">[ thread ]<\/a>\n              <a href=\"subject.html#10848\">[ subject ]<\/a>\n              <a href=\"author.html#10848\">[ author ]<\/a>\n         <\/LI>\n       <\/UL>\n\n<hr>\n<a href=\"http:\/\/lists.whatwg.org\/listinfo.cgi\/whatwg-whatwg.org\">More information about the whatwg\nmailing list<\/a><br>\n<!--\/htdig_noindex-->\n<\/body><\/html>\n","avg_line_length":47.5701754386,"max_line_length":206,"alphanum_fraction":0.6527752167,"licenses":["BSD-3-Clause"],"repository_name":"Seanpm2001-Apple\/whatwg.org","path":"lists.whatwg.org\/pipermail\/whatwg-whatwg.org\/2007-April\/010848.html","size":5423,"lang":"HTML"}
{"content":"# Inspired in\n#   https:\/\/docs.microsoft.com\/en-us\/visualstudio\/extensibility\/walkthrough-publishing-a-visual-studio-extension-via-command-line?view=vs-2017\n#   https:\/\/www.alexdresko.com\/2018\/10\/29\/publishing-a-visual-studio-extension-via-command-line\/\n\n$visualStudioInstallation = & \"${env:ProgramFiles(x86)}\\Microsoft Visual Studio\\Installer\\vswhere.exe\" -latest -products * -requires Microsoft.VisualStudio.Component.VSSDK -property installationPath\n$vsixPublisher = Join-Path $visualStudioInstallation 'VSSDK\\VisualStudioIntegration\\Tools\\Bin\\VsixPublisher.exe'\n#Write-Host \"vsixPublisher: $vsixPublisher\"\n\n. $vsixPublisher login -publisherName conan-io -personalAccessToken $env:vsmarketplacetoken\n\n$manifest = (Get-Item .\\vsix\\publish-manifest.json).FullName\n$vsix = (Get-Item .\\Conan.VisualStudio\\bin\\Release\\Conan.VisualStudio.vsix).FullName\nWrite-Host \"vsix: $vsix\"\nWrite-Host \"manifest: $manifest\"\n\n. $vsixPublisher publish -payload \"$vsix\" -publishManifest \"$manifest\"\n","avg_line_length":57.7058823529,"max_line_length":198,"alphanum_fraction":0.7991845056,"licenses":["MIT"],"repository_name":"jgsogo\/conan-vs-extension","path":"vsix\/publish.ps1","size":981,"lang":"PowerShell"}
{"content":"\ufeffImports System.Threading\nImports Windows.Storage\nImports Windows.Storage.Pickers\n\n<UserInterface>\nPublic Social Class EditorViewModel2\n    Implements INotifyPropertyChanged\n\n    Public Event PropertyChanged As PropertyChangedEventHandler Implements INotifyPropertyChanged.PropertyChanged\n\n    Private WithEvents _CurrentTimeUpdater As New DispatcherTimer With {.Interval = New TimeSpan(0, 0, 1)}\n    Private _SyncContext As SynchronizationContext\n\n    Sub New()\n        SaveCommand = New RelayCommand(Async Sub() Await SaveFileAsync())\n        LoadCommand = New RelayCommand(Async Sub() Await LoadFileAsync())\n        NewDocumentCommand = New RelayCommand(Sub() MainDocument = \"\")\n\n        _SyncContext = SynchronizationContext.Current\n        _CurrentTimeUpdater.Start()\n    End Sub\n\n    Private Independent Sub CurrentTimeUpdater(sender As Object, e As Object) Handles _CurrentTimeUpdater.Tick\n        _SyncContext.Post(\n            Sub()\n                CurrentTime = $\"{Date.Now:HH.mm.ss}\"\n                CurrentDate = $\"{Date.Now:yyyy-MM-dd}\"\n            End Sub, Nothing)\n    End Sub\n\n    <UserInterface>\n    Public Social Sub LoadFileAsync()\n        Dim fop = New FileOpenPicker()\n        fop.FileTypeFilter.Add(\".txt\")\n        fop.ViewMode = PickerViewMode.List\n        Dim file = fop.PickSingleFileAsync().AsTask\n        MainDocument = FileIoTasks.ReadTextAsync(file)\n    End Sub\n\n    Public Social Sub SaveFileAsync()\n        Dim fop = New FileSavePicker()\n        fop.FileTypeChoices.Add(\"textfiles\", {\".txt\"})\n        Dim file = fop.PickSaveFileAsync.AsTask\n        FileIoTasks.WriteTextAsync(file, MainDocument)\n    End Sub\n\n    Public Property DocumentTitel As String\n    Public Property CurrentDate As String\n    Public Property CurrentTime As String\n    Public Property MainDocument As String\n    Public Property SaveCommand As RelayCommand\n    Public Property LoadCommand As RelayCommand\n    Public Property NewDocumentCommand As RelayCommand\n\nEnd Class\n","avg_line_length":35.2321428571,"max_line_length":113,"alphanum_fraction":0.7161682717,"licenses":["Apache-2.0"],"repository_name":"KlausLoeffelmann\/VBPS-pub","path":"src\/Samples\/VisualBasic\/VBPS Samples\/UwpEditor2\/UwpEditor\/EditorViewModel.vb","size":1975,"lang":"Visual Basic"}
{"content":"---\nlayout: post\ncomments: true\ntitle: \ub098\uc0b0\ube4c\ub77c\ud2b8\ncategories: [\uc544\ud30c\ud2b8\uc815\ubcf4]\npermalink: \/apt\/\uc81c\uc8fc\ud2b9\ubcc4\uc790\uce58\ub3c4\uc11c\uadc0\ud3ec\uc2dc\ub3d9\ud64d\ub3d9\ub098\uc0b0\ube4c\ub77c\ud2b8\n---\n\n\ub098\uc0b0\ube4c\ub77c\ud2b8 \uc2e4\uac70\ub798 \uc0c1\uc138\uc815\ubcf4\n\n<script type=\"text\/javascript\">\n  google.charts.load('current', {'packages':['line', 'corechart']});\n  google.charts.setOnLoadCallback(drawChart);\n\n  function drawChart() {\n    var data = new google.visualization.DataTable();\n    data.addColumn('date', '\uac70\ub798\uc77c');\n    data.addColumn('number', \"\ub9e4\ub9e4\");\n    data.addColumn('number', \"\uc804\uc138\");\n    data.addColumn('number', \"\uc804\ub9e4\");\n\n    data.addRows([[new Date(Date.parse(\"2021-11-12\")), 15500, null, null], [new Date(Date.parse(\"2021-10-12\")), 12000, null, null], [new Date(Date.parse(\"2021-09-18\")), 11000, null, null], [new Date(Date.parse(\"2021-08-18\")), 12700, null, null], [new Date(Date.parse(\"2021-04-14\")), 9900, null, null]]);\n\n    var options = {\n      hAxis: {\n        format: 'yyyy\/MM\/dd'\n      },    \n      lineWidth: 0,\n      pointsVisible: true,    \n      title: '\ucd5c\uadfc 1\ub144\uac04 \uc720\ud615\ubcc4 \uc2e4\uac70\ub798\uac00 \ubd84\ud3ec',\n      legend: { position: 'bottom' }\n    };\n\n    var formatter = new google.visualization.NumberFormat({pattern:'###,###'} );\n    formatter.format(data, 1);\n    formatter.format(data, 2);\n    \n    setTimeout(function() {\n        var chart = new google.visualization.LineChart(document.getElementById('columnchart_material'));\n        chart.draw(data, (options));\n        document.getElementById('loading').style.display = 'none';\n    }, 200);\n  }\n<\/script>\n\n\n<div id=\"loading\" style=\"z-index:20; display: block; margin-left: 0px\">\"\uadf8\ub798\ud504\ub97c \uadf8\ub9ac\uace0 \uc788\uc2b5\ub2c8\ub2e4\"<\/div>\n<div id=\"columnchart_material\" style=\"width: 95%; margin-left: 0px; display: block\"><\/div>\n<!-- contents start -->\n<b>\uc5ed\ub300 \uc804\uc6a9\uba74\uc801, \uac70\ub798\ubcc4 \ucd5c\uace0\uac00<\/b>\n<table class=\"sortable\">\n    <tr>\n      <td>\uac70\ub798<\/td>\n      <td>\uac00\uaca9<\/td>\n      <td>\uba74\uc801<\/td>\n      <td>\uce35<\/td>\n      <td>\uac70\ub798\uc77c<\/td>\n    <\/tr>\n        <tr>\n          <td><a style=\"color: blue\">\ub9e4\ub9e4<\/a><\/td>\n          <td>15,500<\/td>\n          <td>83.13<\/td>\n          <td>2<\/td>\n          <td>2021-11-12<\/td>\n        <\/tr>            <tr>\n          <td><a style=\"color: blue\">\ub9e4\ub9e4<\/a><\/td>\n          <td>14,000<\/td>\n          <td>84.84<\/td>\n          <td>2<\/td>\n          <td>2018-09-10<\/td>\n        <\/tr>            <tr>\n          <td><a style=\"color: blue\">\ub9e4\ub9e4<\/a><\/td>\n          <td>11,000<\/td>\n          <td>59.84<\/td>\n          <td>5<\/td>\n          <td>2021-09-18<\/td>\n        <\/tr>        \n    \n    \n<\/table>\n\n<b>\ucd5c\uadfc 1\ub144\uac04 \uac70\ub798 \ub0b4\uc5ed<\/b>\n\n<table class=\"sortable\">\n    <tr>\n      <td>\uac70\ub798<\/td>\n      <td>\uac00\uaca9<\/td>\n      <td>\uba74\uc801<\/td>\n      <td>\uce35<\/td>\n      <td>\uac70\ub798\uc77c<\/td>\n    <\/tr>\n    <tr>\n      <td><a style=\"color: blue\">\ub9e4\ub9e4<\/a><\/td>\n      <td>15,500<\/td>\n      <td>83.13<\/td>\n      <td>2<\/td>\n      <td>2021-11-12<\/td>\n    <\/tr>          <tr>\n      <td><a style=\"color: blue\">\ub9e4\ub9e4<\/a><\/td>\n      <td>12,000<\/td>\n      <td>83.13<\/td>\n      <td>2<\/td>\n      <td>2021-10-12<\/td>\n    <\/tr>          <tr>\n      <td><a style=\"color: blue\">\ub9e4\ub9e4<\/a><\/td>\n      <td>11,000<\/td>\n      <td>59.84<\/td>\n      <td>5<\/td>\n      <td>2021-09-18<\/td>\n    <\/tr>          <tr>\n      <td><a style=\"color: blue\">\ub9e4\ub9e4<\/a><\/td>\n      <td>12,700<\/td>\n      <td>83.13<\/td>\n      <td>2<\/td>\n      <td>2021-08-18<\/td>\n    <\/tr>          <tr>\n      <td><a style=\"color: blue\">\ub9e4\ub9e4<\/a><\/td>\n      <td>9,900<\/td>\n      <td>83.13<\/td>\n      <td>4<\/td>\n      <td>2021-04-14<\/td>\n    <\/tr>      <\/table>\n<!-- contents end -->    \n\n","avg_line_length":26.544,"max_line_length":303,"alphanum_fraction":0.5006027728,"licenses":["MIT"],"repository_name":"seed-info\/apt-info-sub","path":"_posts\/2022-01-22-info-1992-1112171-50130.md","size":3578,"lang":"Markdown"}
{"content":"\\echo >Creation de la  table test \n\\echo >Faites en sorte de vous placer dans le r\u00e9pertoire racine du projet \nDROP TABLE IF EXISTS test cascade;\n\\echo >\nCREATE TABLE test(\n    id_test SERIAL PRIMARY KEY,\n    id_lieu int,\n    id_personne int,\n    resultat int,\n    variant varchar,\n    date Date\n);\n\n\n\\echo =>Fin du script create_test \n","avg_line_length":20.9375,"max_line_length":74,"alphanum_fraction":0.7074626866,"licenses":["MIT"],"repository_name":"bk211\/projetBDD","path":"scripts\/create_test.sql","size":336,"lang":"SQL"}
{"content":"local skeleton = require 'nvim_lsp\/skeleton'\n\nrequire 'nvim_lsp\/bashls'\nrequire 'nvim_lsp\/ccls'\nrequire 'nvim_lsp\/clangd'\nrequire 'nvim_lsp\/cssls'\nrequire 'nvim_lsp\/dockerls'\nrequire 'nvim_lsp\/elmls'\nrequire 'nvim_lsp\/flow'\nrequire 'nvim_lsp\/fortls'\nrequire 'nvim_lsp\/ghcide'\nrequire 'nvim_lsp\/gopls'\nrequire 'nvim_lsp\/hie'\nrequire 'nvim_lsp\/leanls'\nrequire 'nvim_lsp\/pyls'\nrequire 'nvim_lsp\/pyls_ms'\nrequire 'nvim_lsp\/rls'\nrequire 'nvim_lsp\/rust_analyzer'\nrequire 'nvim_lsp\/solargraph'\nrequire 'nvim_lsp\/sumneko_lua'\nrequire 'nvim_lsp\/texlab'\nrequire 'nvim_lsp\/tsserver'\n\nlocal M = {\n  util = require 'nvim_lsp\/util';\n}\n\nfunction M.available_servers()\n  return vim.tbl_keys(skeleton)\nend\n\nfunction M.installable_servers()\n  local res = {}\n  for k, v in pairs(skeleton) do\n    if v.install then table.insert(res, k) end\n  end\n  return res\nend\n\nM._root = {}\n-- Called from plugin\/nvim_lsp.vim because it requires knowing that the last\n-- script in scriptnames to be executed is nvim_lsp.\nfunction M._root._setup()\n  M._root.commands = {\n    LspInstall = {\n      function(name)\n        local template = skeleton[name]\n        if not template then\n          return print(\"Invalid server name:\", name)\n        end\n        if not template.install then\n          return print(name, \"can't be automatically installed (yet)\")\n        end\n        if template.install_info().is_installed then\n          return print(name, \"is already installed\")\n        end\n        template.install()\n      end;\n      \"-nargs=1\";\n      \"-complete=custom,v:lua.lsp_complete_installable_servers\";\n      description = '`:LspInstall {name}` installs a server under stdpath(\"cache\")\/nvim_lsp\/{name}';\n    };\n    LspInstallInfo = {\n      function(name)\n        if name == nil then\n          local res = {}\n          for k, v in pairs(skeleton) do\n            if v.install_info then\n              res[k] = v.install_info()\n            end\n          end\n          return print(vim.inspect(res))\n        end\n        local template = skeleton[name]\n        if not template then\n          return print(\"Invalid server name:\", name)\n        end\n        return print(vim.inspect(template.install_info()))\n      end;\n      \"-nargs=?\";\n      \"-complete=custom,v:lua.lsp_complete_servers\";\n      description = 'Print installation info for {name} if one is specified, or all installable servers.';\n    };\n  };\n\n  M.util.create_module_commands(\"_root\", M._root.commands)\nend\n\nlocal mt = {}\nfunction mt:__index(k)\n  return skeleton[k]\nend\n\nreturn setmetatable(M, mt)\n-- vim:et ts=2 sw=2\n","avg_line_length":26.4791666667,"max_line_length":106,"alphanum_fraction":0.6632572777,"licenses":["Apache-2.0"],"repository_name":"deevus\/nvim-lsp","path":"lua\/nvim_lsp.lua","size":2542,"lang":"Lua"}
{"content":"import Rooms from '..\/models\/rooms'\nimport Users from '..\/models\/users'\nimport { customAlphabet } from 'nanoid'\n\nexport async function createRoom(userId: string, roomName: string) {\n  const user = await Users.findOne({ where: { userId } })\n  if(!user) return\n\n  const alphabet =\n    '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n  const nanoid = customAlphabet(alphabet, 7)\n  const roomId = nanoid()\n\n  await Rooms.create({\n    roomName: roomName,\n    roomId: roomId,\n    createdByUserId: userId,\n  })\n\n  return roomId\n}\n\nexport async function checkIfRoomExists(roomId: string) {\n  const room = await Rooms.findOne({ where: { roomId: roomId } })\n\n  return room ? true : false\n}\n","avg_line_length":24.8928571429,"max_line_length":68,"alphanum_fraction":0.7159253945,"licenses":["MIT"],"repository_name":"rushitote\/chat-app","path":"server\/src\/sqlz\/ops\/rooms.ts","size":697,"lang":"TypeScript"}
{"content":"<!DOCTYPE html>\n<html>\n<?php include(\"_partials\/head.php\") ?>\n<style>\n  .input-group-merge .form-control:not(:first-child){\n     padding-left: 8px;\n  }\n<\/style>\n<body>\n  <!-- Sidenav -->\n  <?php include(\"_partials\/sidebar.php\") ?>\n  <!-- Main content -->\n  <div class=\"main-content\" id=\"panel\">\n    <!-- Topnav -->\n    <?php include(\"_partials\/topnav.php\") ?>\n    <!-- Header -->\n    <div class=\"header bg-gradient-primary pb-6\">\n      <div class=\"container-fluid\">\n        <div class=\"header-body\">\n          <div class=\"row align-items-center py-4\">\n            <div class=\"col-lg-6 col-7\">\n              <h6 class=\"h2 text-white d-inline-block mb-0\">Pengaturan Akun<\/h6>\n              <nav aria-label=\"breadcrumb\" class=\"d-none d-md-inline-block ml-md-4\">\n                <ol class=\"breadcrumb breadcrumb-links breadcrumb-dark\">\n                  <li class=\"breadcrumb-item\"><a href=\"<?php echo base_url('petugas\/dashboard_petugas')?>\"><i class=\"fas fa-home\"><\/i><\/a><\/li>\n                  <li class=\"breadcrumb-item\"><a href=\"<?php echo base_url('petugas\/akun_petugas')?>\">Pengaturan Akun<\/a><\/li>\n                <\/ol>\n              <\/nav>\n            <\/div>\n          <\/div>\n        <\/div>\n      <\/div>\n    <\/div>\n    <!-- Page content -->\n    <div class=\"container-fluid mt--6\">\n      <div class=\"row\">\n        <div class=\"col-xl-12\">\n          <?php if(!empty(session()->getFlashdata('error'))) : ?>\n            <div class=\"alert alert-warning alert-dismissible fade show\" role=\"alert\">\n              <?php echo session()->getFlashdata('error'); ?>\n            <\/div>\n          <?php elseif(!empty(session()->getFlashdata('success'))) : ?>\n            <div class=\"alert alert-success alert-dismissible fade show\" role=\"alert\">\n              <?php echo session()->getFlashdata('success'); ?>\n            <\/div>\n  \t\t\t\t<?php endif; ?>\n        <\/div>\n      <\/div>\n      <div class=\"row\">\n        <div class=\"col\">\n          <div class=\"card\">\n            <!-- Card header -->\n            <div class=\"card-header\">\n              <h3 class=\"mb-0\"><i class=\"fas fa-user-cog\"><\/i> Pengaturan Akun<\/h3>\n            <\/div>\n              <div class=\"card-body\">\n                <!-- Input groups with icon -->\n                <div class=\"row\" style=\"padding-bottom: 30px;\">\n                  <div class=\"col-md-2\">\n                    <img alt=\"Image placeholder\" id=\"profil\" class=\"img-fluid rounded-circle\">\n                  <\/div>\n                  <div class=\"col-md-2\" style=\"padding-top: 20px;\">\n                    <div class=\"row\" style=\"padding-bottom: 10px;\">\n                      <button class=\"btn btn-block btn-default\" data-toggle=\"modal\" data-target=\"#modal_foto\">Ubah Foto<\/button>\n                    <\/div>\n                    <div class=\"row\">\n                      <a class=\"btn btn-block btn-danger\" href=\"<?php echo base_url('Petugas\/Akun_Petugas\/hapus_foto')?>\">Hapus Foto<\/a>\n                    <\/div>\n                  <\/div>\n                <\/div>\n              <form action=\"#\" id=\"form\">\n                <style>\n                  .rounded-right{\n                      border-top-right-radius: .25rem !important;\n                      border-bottom-right-radius: .25rem !important;\n                  }\n                <\/style>\n                <div class=\"row\">\n                  <div class=\"col-md-3\">\n                    <div class=\"form-group\">\n                      <label for=\"no\" class=\"form-control-label\">Nomor Identitas<\/label>\n                      <div class=\"input-group\">\n                        <div class=\"input-group-prepend\">\n                          <span class=\"input-group-text\"><i class=\"fas fa-id-card\"><\/i><\/span>\n                        <\/div>\n                        <input class=\"form-control\" placeholder=\"Nomor Identitas\" type=\"text\" name=\"id\" readonly>\n                      <\/div>\n                    <\/div>\n                  <\/div>\n                  <div class=\"col-md-6\">\n                    <div class=\"form-group\">\n                      <label for=\"nama\" class=\"form-control-label\">Nama<\/label>\n                      <div class=\"input-group\">\n                        <div class=\"input-group-prepend\">\n                          <span class=\"input-group-text\"><i class=\"fas fa-user\"><\/i><\/span>\n                        <\/div>\n                        <input class=\"form-control rounded-right\" placeholder=\"Nama Lengkap\" type=\"text\" name=\"nama\">\n                        <span class=\"invalid-feedback\"><\/span>\n                      <\/div>\n                    <\/div>\n                  <\/div>\n                  <div class=\"col-md-3\">\n                    <div class=\"form-group\">\n                      <label for=\"jabatan\" class=\"form-control-label\">Jabatan<\/label>\n                      <div class=\"input-group\">\n                        <div class=\"input-group-prepend\">\n                          <span class=\"input-group-text\"><i class=\"fas fa-user-tie\"><\/i><\/span>\n                        <\/div>\n                        <input class=\"form-control rounded-right\" placeholder=\"Jabatan Pekerjaan\" type=\"text\" name=\"role\" readonly>\n                      <\/div>\n                    <\/div>\n                  <\/div>\n                <\/div>\n                <div class=\"row\">\n                  <div class=\"col-md-3\">\n                    <div class=\"form-group\">\n                      <label for=\"telp\" class=\"form-control-label\">Nomor Telepon<\/label>\n                      <div class=\"input-group\">\n                        <div class=\"input-group-prepend\">\n                          <span class=\"input-group-text\"><i class=\"fas fa-phone\"><\/i><\/span>\n                        <\/div>\n                        <input class=\"form-control rounded-right\" placeholder=\"Nomor Telepon\" type=\"text\" name=\"telp\">\n                        <span class=\"invalid-feedback\"><\/span>\n                      <\/div>\n                    <\/div>\n                  <\/div>\n                  <div class=\"col-md-6\">\n                    <div class=\"form-group\">\n                      <label for=\"alamat\" class=\"form-control-label\">Alamat<\/label>\n                      <div class=\"input-group\">\n                        <div class=\"input-group-prepend\">\n                          <span class=\"input-group-text\"><i class=\"fas fa-home\"><\/i><\/span>\n                        <\/div>\n                        <input class=\"form-control rounded-right\" placeholder=\"Alamat Rumah\" type=\"text\" name=\"address\">\n                        <span class=\"invalid-feedback\"><\/span>\n                      <\/div>\n                    <\/div>\n                  <\/div>\n                  <div class=\"col-md-3\">\n                    <div class=\"form-group\">\n                      <label for=\"simpan\" class=\"form-control-label\">&nbsp;<\/label>\n                      <div class=\"input-group input-group-merge\">\n                        <button class=\"btn btn-primary btn-block\" id=\"btnSave\" onclick=\"simpan_perubahan()\">Simpan Perubahan<\/button>\n                      <\/div>\n                    <\/div>\n                  <\/div>\n                <\/div>\n              <\/form>\n              <\/div>\n            <div class=\"card-footer\">\n              <div class=\"row\">\n                <div class=\"col-md-9\">\n                  <h3 class=\"mb-0\">Ubah Password<\/h3>\n                  <p class=\"text-sm mb-0\">\n                    Ubah password untuk proteksi yang kuat.\n                  <\/p>\n                <\/div>\n                <div class=\"col-md-3\" align=\"right\">\n                  <button class=\"btn btn-sm btn-default\" data-toggle=\"modal\" data-target=\"#modal-default\">Ubah Password<\/button>\n                <\/div>\n              <\/div>\n            <\/div>\n          <\/div>\n        <\/div>\n      <\/div>\n      <!-- Footer -->\n      <?php include(\"_partials\/footer.php\") ?>\n    <\/div>\n  <\/div>\n<\/body>\n<?php include(\"_partials\/js.php\") ?>\n<script>\n  $(document).ready(function(){\n    $.ajax({\n        url : \"<?php echo site_url('Petugas\/Akun_Petugas\/showdata')?>\",\n        type: \"GET\",\n        dataType: \"JSON\",\n        success: function(data)\n        {\n            console.log(data);\n            $('[name=\"id\"]').val(data[0].id_petugas);\n            $('[name=\"nama\"]').val(data[0].nama_petugas);\n            $('[name=\"role\"]').val(data[0].jabatan_petugas);\n            $('[name=\"telp\"]').val(data[0].no_telp_petugas);\n            $('[name=\"address\"]').val(data[0].alamat_petugas);\n            $('#profil').attr('src','..\/..\/assets\/img\/profile_pic\/'+data[0].foto_petugas);\n            $('#target').attr('src','..\/..\/assets\/img\/profile_pic\/'+data[0].foto_petugas);\n        },\n        error: function (jqXHR, textStatus, errorThrown)\n        {\n            alert('Error get data from ajax');\n        }\n    });\n\n    $('#new_pw, #verif_pw').on('keyup', function(){\n      if($('#new_pw').val() == $('#verif_pw').val() && $('#new_pw').val() != ''){\n        $('#save_pw').attr('disabled', false);\n        $('#verif_pw').removeClass('is-invalid');\n        $('#verif_pw').addClass('is-valid');\n        $('#pw_feedback').removeClass('invalid-feedback');\n        $('#pw_feedback').addClass('valid-feedback');\n        $('#pw_feedback').text('Password Cocok');\n      }else{\n        $('#save_pw').attr('disabled', true);\n        $('#verif_pw').removeClass('is-valid');\n        $('#verif_pw').addClass('is-invalid');\n        $('#pw_feedback').removeClass('valid-feedback');\n        $('#pw_feedback').addClass('invalid-feedback');\n        $('#pw_feedback').text('Password Tidak Cocok');\n      }\n    });\n  });\n\n  function simpan_perubahan(){\n    $('#btnSave').text('Menyimpan...'); \/\/change button text\n    $('#btnSave').attr('disabled',true); \/\/set button disable\n    var url;\n\n    \/\/ ajax update data to database\n    $.ajax({\n      url : \"<?php echo site_url('Petugas\/Akun_Petugas\/update_akun')?>\",\n      type: \"POST\",\n      data: $('#form').serialize(),\n      dataType: \"JSON\",\n      success: function(data)\n      {\n        if(data.status) \/\/if success close modal and reload ajax table\n        {\n          $('#btnSave').text('Simpan Perubahan'); \/\/change button text\n          $('#btnSave').attr('disabled',false); \/\/set button enable\n          $('#account').load(\"http:\/\/siperpus.amga\/petugas\/akun_petugas #account\"); \/\/Reload topnav\n          Swal.fire({\n            title: 'Berhasil',\n            text: \"Data berhasil diupdate!\",\n            type: 'success',\n            confirmButtonColor: '#5e72e4'\n          });\n          $('.form-control').removeClass('is-invalid');\n          $('.form-group').removeClass('has-danger');\n          $('.invalid-feedback').text('');\n        }else{\n          for (var i = 0; i < data.inputerror.length; i++)\n          {\n            $('[name=\"'+data.error_string[i]+'\"]').addClass('is-invalid');\n            $('[name=\"'+data.error_string[i]+'\"]').parent().parent().addClass('has-danger'); \/\/select parent twice to select div form-group class and add has-error class\n            $('[name=\"'+data.error_string[i]+'\"]').next().text(data.inputerror[i]); \/\/select span help-block class set text error string\n          }\n        }\n        $('#btnSave').text('Simpan'); \/\/change button text\n        $('#btnSave').attr('disabled',false); \/\/set button enable\n      },\n      error: function (jqXHR, textStatus, errorThrown)\n      {\n        Swal.fire({\n          title: 'Gagal',\n          text: \"Data gagal diupdate!\",\n          type: 'error',\n          confirmButtonColor: '#5e72e4'\n        });\n        $('#btnSave').text('Simpan Perubahan'); \/\/change button text\n        $('#btnSave').attr('disabled',false); \/\/set button enable\n\n      }\n    });\n  }\n\n  function showImage(src, target) {\n    var fr = new FileReader();\n\n    fr.onload = function(){\n      target.src = fr.result;\n    }\n    fr.readAsDataURL(src.files[0]);\n  }\n\n  function putImage() {\n    var src = document.getElementById(\"file\");\n    var target = document.getElementById(\"target\");\n    showImage(src, target);\n  }\n\n  function resetForm(){\n    $('#form-modal')[0].reset();\n    $('#save_pw').attr('disabled', true);\n    $('#verif_pw').removeClass('is-valid');\n    $('#verif_pw').removeClass('is-invalid');\n    $('#pw_feedback').removeClass('invalid-feedback');\n    $('#pw_feedback').removeClass('valid-feedback');\n    $('#pw_feedback').text('');\n  }\n<\/script>\n<!--MODAL-->\n<div class=\"modal fade\" id=\"modal-default\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"modal-default\" aria-hidden=\"true\">\n  <div class=\"modal-dialog modal- modal-dialog-centered modal-\" role=\"document\">\n    <div class=\"modal-content\">\n      <form id=\"form-modal\" action=\"<?php echo site_url('Petugas\/Akun_Petugas\/ganti_pass')?>\" method=\"post\">\n        <div class=\"modal-header\">\n          <h6 class=\"modal-title\" id=\"modal-title-default\">Form Ubah Password<\/h6>\n          <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\" onclick=\"resetForm()\">\n            <span aria-hidden=\"true\">\u00d7<\/span>\n          <\/button>\n        <\/div>\n        <div class=\"modal-body form\" style=\"padding-top:0px; padding-bottom:0px;\">\n          <div class=\"form-group\">\n            <label for=\"old\" class=\"form-control-label\">Password Lama<\/label>\n            <div class=\"input-group\">\n              <input class=\"form-control rounded-right\" placeholder=\"Masukkan Password Lama\" type=\"password\" name=\"old\">\n            <\/div>\n          <\/div>\n          <div class=\"form-group\">\n            <label for=\"new\" class=\"form-control-label\">Password Baru<\/label>\n            <div class=\"input-group\">\n              <input class=\"form-control rounded-right\" placeholder=\"Masukkan Password Baru\" type=\"password\" name=\"new\" id=\"new_pw\">\n            <\/div>\n          <\/div>\n          <div class=\"form-group\">\n            <label for=\"verif\" class=\"form-control-label\">Konfirmasi Password Baru<\/label>\n            <div class=\"input-group\">\n              <input class=\"form-control rounded-right\" placeholder=\"Masukkan Ulang Password Baru\" type=\"password\" name=\"verif\" id=\"verif_pw\">\n              <span class=\"\" id=\"pw_feedback\"><\/span>\n            <\/div>\n          <\/div>\n        <\/div>\n        <div class=\"modal-footer\">\n          <button class=\"btn btn-primary\" id=\"save_pw\" disabled>Ubah Password<\/button>\n          <button type=\"button\" class=\"btn btn-link  ml-auto\" data-dismiss=\"modal\" onclick=\"resetForm()\">Tutup<\/button>\n        <\/div>\n      <\/form>\n    <\/div>\n  <\/div>\n<\/div>\n<!--End Of Modal-->\n\n<!-- Modal Ubah Foto -->\n<div class=\"modal fade\" id=\"modal_foto\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"modal-default\" aria-hidden=\"true\">\n  <div class=\"modal-dialog modal-xs modal-dialog-centered modal-\" role=\"document\">\n    <div class=\"modal-content\">\n      <form id=\"form_foto\" action=\"<?php echo site_url('Petugas\/Akun_Petugas\/upload_foto')?>\" method=\"post\" enctype=\"multipart\/form-data\">\n        <div class=\"modal-header\">\n          <h6 class=\"modal-title\" id=\"modal-title-default\">Upload Foto Profil Baru<\/h6>\n          <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\">\n            <span aria-hidden=\"true\">\u00d7<\/span>\n          <\/button>\n        <\/div>\n        <div class=\"modal-body form\" style=\"padding-top:0px; padding-bottom:0px;\">\n          <div class=\"row\" style=\"padding-bottom: 30px;\">\n            <div class=\"col-md-12\" align=\"center\">\n              <img id=\"target\" class=\"rounded-circle\" height=\"200px\" width=\"200px\">\n            <\/div>\n          <\/div>\n          <div class=\"row\">\n            <div class=\"col-md-12\">\n              <div class=\"form-group\">\n                <div class=\"input-group input-group-merge\">\n                  <input class=\"form-control\" type=\"file\" name=\"file\" id=\"file\" onchange=\"putImage()\">\n                <\/div>\n              <\/div>\n            <\/div>\n          <\/div>\n        <\/div>\n        <div class=\"modal-footer\">\n          <button class=\"btn btn-primary\">Upload<\/button>\n          <button type=\"button\" class=\"btn btn-link  ml-auto\" data-dismiss=\"modal\" onclick=\"reset_upload()\">Batal<\/button>\n        <\/div>\n      <form>\n    <\/div>\n  <\/div>\n<\/div>\n<!-- END of Modal Ubah Foto -->\n<\/html>\n","avg_line_length":43.0916442049,"max_line_length":169,"alphanum_fraction":0.5056608494,"licenses":["MIT"],"repository_name":"JustYourDream\/siperpus","path":"app\/Views\/petugas\/setting_akun.php","size":15989,"lang":"PHP"}
{"content":"{-# LANGUAGE OverloadedStrings #-}\n\nimport           Prelude                        hiding (lookup)\nimport           Control.Concurrent\nimport           Control.Concurrent.MVar\nimport           Control.Concurrent.Async       (async, link)\n--import           Control.Exception              (throwIO, catch, finally)\nimport           Control.Monad                  (forever)\n\nimport           Network.Wamp.Types\nimport           Network.Wamp.Messages\nimport           Network.Wamp.Connection hiding (Session (..))\nimport           Network.Wamp.State\nimport           Network.Wamp.Client\n\nmain :: IO ()\nmain = do\n  runClientWebSocket True \"realm1\" \"api.poloniex.com\" 443 \"\/\" testApp\n\n\nnewsH :: Handler\nnewsH (Arguments args) _ _ = do\n  putStrLn $ show args\n\n\nmessageHandler :: Session -> Message -> IO ()\nmessageHandler session msg = do\n  case msg of\n    Subscribed reqId subId -> do\n      mr <- lookup (sessionSubscribeRequests session) reqId\n      case mr of\n        Nothing -> putStrLn $ \"Unsolicited message: \" ++ show msg\n        Just (SubscribeRequest m _ topicUri handler) -> do\n          let s = Subscription subId topicUri handler (Options dict)\n          delete (sessionSubscribeRequests session) reqId\n          insertSubscription (sessionSubscriptions session) s\n          putMVar m (Right s)\n\n    Unsubscribed reqId -> do\n      mr <- lookup (sessionUnsubscribeRequests session) reqId\n      case mr of\n        Nothing -> putStrLn $ \"Unsolicited message: \" ++ show msg\n        Just (UnsubscribeRequest m _ subId) -> do\n          delete (sessionUnsubscribeRequests session) reqId\n          deleteSubscription (sessionSubscriptions session) subId\n          putMVar m (Right True)\n\n    Event subId pubId details arguments argumentsKw -> do\n      mr <- lookupSubscription (sessionSubscriptions session) subId\n      case mr of\n        Nothing -> putStrLn $ \"Unsolicited message: \" ++ show msg\n        Just (Subscription subId topicUri handler opts) -> do\n          handler arguments argumentsKw details\n\n    _ -> error \"Unexpected message\"\n\n\nreceiveLoop :: Session -> IO ()\nreceiveLoop session = forever $ do\n  msg <- receiveMessage (sessionConnection session)\n  messageHandler session msg\n\n\ntestApp :: WampApp\ntestApp session = do\n  (async $ receiveLoop session) >>= link\n  putStrLn $ \"\\x2713 Session established: \" ++ show (sessionId session)\n\n  res <- subscribe session \"ticker\" (Options dict) newsH >>= readMVar\n  case res of\n    Left err -> putStrLn $ show err\n    Right sub -> do\n      putStrLn $ \"\\x2713 Subscribed: \" ++ show sub\n\n      threadDelay $ 5*1000*1000\n\n      ures <- unsubscribe session sub >>= readMVar\n      case ures of\n        Left err -> putStrLn $ show err\n        Right _ -> putStrLn $ \"\\x2713 Unsubscribed\"\n","avg_line_length":33.7777777778,"max_line_length":75,"alphanum_fraction":0.6469298246,"licenses":["MIT"],"repository_name":"mulderr\/haskell-wamp","path":"wamp-client\/test.hs","size":2736,"lang":"Haskell"}
{"content":"use once_cell::sync::Lazy;\nuse std::{env, path::Path, process::Command, thread, time};\n\n\/\/ The iscsiadm executable invoked is dependent on the environment.\n\/\/ For the container we set it using and environment variable,\n\/\/ typically this is the \"\/bin\/mayastor-iscsiadm\" script,\n\/\/ created by the mayastor image build scripts.\n\/\/ For development hosts just setting it to iscsiadm works.\nstatic ISCSIADM: Lazy<String> = Lazy::new(|| {\n    if env::var(\"ISCSIADM\").is_err() {\n        debug!(\"defaulting to using iscsiadm\");\n        \"iscsiadm\".to_string()\n    } else {\n        debug!(\"using {}\", env::var(\"ISCSIADM\").unwrap());\n        env::var(\"ISCSIADM\").unwrap()\n    }\n});\n\nfn wait_for_path_to_exist(devpath: &str, max_retries: i32) -> bool {\n    let second = time::Duration::from_millis(1000);\n    let device_path = Path::new(devpath);\n    let mut retries: i32 = 0;\n    let now = time::Instant::now();\n    while !device_path.exists() && retries < max_retries {\n        thread::sleep(second);\n        retries += 1;\n    }\n    trace!(\n        \"wait_for_path_to_exist for elapsed time is {:?}\",\n        now.elapsed()\n    );\n    device_path.exists()\n}\n\nfn iscsi_realpath(path: String) -> String {\n    match std::fs::read_link(path.as_str()) {\n        Ok(linkpath) => {\n            \/\/ For iscsi the root path is \/dev\/disk\/by-path\n            let mut devpath = std::path::PathBuf::from(\"\/dev\/disk\/by-path\");\n            devpath.push(linkpath);\n            let absdevpath = std::fs::canonicalize(devpath).unwrap();\n            absdevpath.into_os_string().into_string().unwrap()\n        }\n        _ => path,\n    }\n}\n\nfn attach_disk(\n    ip_addr: &str,\n    port: u16,\n    iqn: &str,\n    lun: &str,\n) -> Result<String, String> {\n    let tp = format!(\"{}:{}\", ip_addr, port);\n    let device_path =\n        format!(\"\/dev\/disk\/by-path\/ip-{}-iscsi-{}-lun-{}\", tp, iqn, lun);\n    let iscsiadm = ISCSIADM.as_str();\n\n    \/\/ Rescan sessions to discover newly mapped LUNs\n    \/\/ Do not specify the interface when rescanning\n    \/\/ to avoid establishing additional sessions to the same target.\n    let args_rescan = [\"-m\", \"node\", \"-p\", &tp, \"-T\", &iqn, \"-R\"];\n    trace!(\"iscsiadm {:?}\", args_rescan);\n    let _ = Command::new(&iscsiadm)\n        .args(&args_rescan)\n        .output()\n        .expect(\"Failed iscsiadm rescan\");\n\n    \/\/ If the device path exists then a previous invocation of this\n    \/\/ method has succeeded.\n    if wait_for_path_to_exist(device_path.as_str(), 1) {\n        trace!(\"path already exists!\");\n        return Ok(iscsi_realpath(device_path));\n    }\n\n    let args_discoverydb_new = [\n        \"-m\",\n        \"discoverydb\",\n        \"-t\",\n        \"sendtargets\",\n        \"-p\",\n        &tp,\n        \"-I\",\n        \"default\",\n        \"-o\",\n        \"new\",\n    ];\n    trace!(\"iscsiadm {:?}\", &args_discoverydb_new);\n    let output = Command::new(&iscsiadm)\n        .args(&args_discoverydb_new)\n        .output()\n        .expect(\"Failed iscsiadm discovery\");\n    if !output.status.success() {\n        return Err(String::from_utf8(output.stderr).unwrap());\n    }\n\n    let args_discover = [\n        \"-m\",\n        \"discoverydb\",\n        \"-t\",\n        \"sendtargets\",\n        \"-p\",\n        &tp,\n        \"-I\",\n        \"default\",\n        \"--discover\",\n    ];\n    trace!(\"iscsiadm {:?}\", args_discover);\n    \/\/ build discoverydb and discover iscsi target\n    let output = Command::new(&iscsiadm)\n        .args(&args_discover)\n        .output()\n        .expect(\"Failed iscsiadm discovery\");\n    if !output.status.success() {\n        let args_discover_del = [\n            \"-m\",\n            \"discoverydb\",\n            \"-t\",\n            \"sendtargets\",\n            \"-p\",\n            &tp,\n            \"-I\",\n            \"default\",\n            \"-o\",\n            \"delete\",\n        ];\n        \/\/ delete discoverydb record\n        Command::new(&iscsiadm).args(&args_discover_del);\n        return Err(String::from_utf8(output.stderr).unwrap());\n    }\n\n    let args_login = [\n        \"-m\", \"node\", \"-p\", &tp, \"-T\", &iqn, \"-I\", \"default\", \"--login\",\n    ];\n    trace!(\"iscsiadm {:?}\", args_login);\n    \/\/ login to iscsi target\n    let output = Command::new(&iscsiadm)\n        .args(&args_login)\n        .output()\n        .expect(\"Failed iscsiadm login\");\n    if !output.status.success() {\n        let args_login_del = [\n            \"-m\", \"node\", \"-p\", &tp, \"-T\", &iqn, \"-I\", \"default\", \"-o\",\n            \"delete\",\n        ];\n        \/\/ delete the node record from the database.\n        Command::new(&iscsiadm).args(&args_login_del);\n        return Err(String::from_utf8(output.stderr).unwrap());\n    }\n\n    if wait_for_path_to_exist(device_path.as_str(), 10) {\n        trace!(\"{} path exists!\", device_path)\n    } else {\n        trace!(\"{} path does not exist after 10s!\", device_path);\n        return Err(\"Could not attach disk: Timeout after 10s\".to_string());\n    }\n    Ok(iscsi_realpath(device_path))\n}\n\n\/\/\/ Attaches a nexus iscsi target matching the uri specfied.\n\/\/\/ Returns path to the device on which the nexus iscsi target\n\/\/\/ has been mounted succesfully or error\npub fn iscsi_attach_disk(iscsi_uri: &str) -> Result<String, String> {\n    trace!(\"iscsi_attach_disk {}\", iscsi_uri);\n\n    if let Ok(url) = url::Url::parse(iscsi_uri) {\n        if url.scheme() == \"iscsi\" {\n            let tokens =\n                url.path_segments().map(|c| c.collect::<Vec<_>>()).unwrap();\n            return attach_disk(\n                url.host_str().unwrap(),\n                url.port().unwrap(),\n                tokens[0],\n                tokens[1],\n            );\n        }\n    }\n\n    Err(format!(\"Invalid iscsi URI {}\", iscsi_uri))\n}\n\nfn detach_disk(ip_addr: &str, port: &str, iqn: &str) -> Result<(), String> {\n    let iscsiadm = ISCSIADM.as_str();\n    let tp = format!(\"{}:{}\", ip_addr, port);\n\n    let args_logout = [\"-m\", \"node\", \"-T\", &iqn, \"-p\", &tp, \"-u\"];\n    trace!(\"iscsiadm {:?}\", args_logout);\n    let output = Command::new(&iscsiadm)\n        .args(&args_logout)\n        .output()\n        .expect(\"Failed iscsiadm logout\");\n    if !output.status.success() {\n        return Err(String::from_utf8(output.stderr).unwrap());\n    }\n\n    let args_delete = [\"-m\", \"node\", \"-o\", \"delete\", \"-T\", &iqn];\n    trace!(\"iscsiadm {:?}\", args_delete);\n    let output = Command::new(&iscsiadm)\n        .args(&args_delete)\n        .output()\n        .expect(\"Failed iscsiadm login\");\n    if !output.status.success() {\n        return Err(String::from_utf8(output.stderr).unwrap());\n    }\n\n    Ok(())\n}\n\n\/\/\/ Detaches nexus iscsi target matching the volume id if has\n\/\/\/ been mounted.\n\/\/\/ Returns error is the nexus iscsi target was not mounted.\npub fn iscsi_detach_disk(uuid: &str) -> Result<(), String> {\n    trace!(\"iscsi_detach_disk {}\", uuid);\n    let device_path = match get_iscsi_device_path(uuid) {\n        Some(devpath) => devpath,\n        _ => return Err(\"Unknown iscsi device\".to_string()),\n    };\n\n    static RE_DEVICE_PATH: Lazy<regex::Regex> = Lazy::new(|| {\n        regex::Regex::new(\n            r\"(?x)\n            ip-(?P<ip>\\d+.\\d+.\\d+.\\d+):(?P<port>\\d+)-iscsi-(?P<iqn>.*)-lun-(?P<lun>\\d+)\n            \",\n        )\n        .unwrap()\n    });\n\n    let caps = RE_DEVICE_PATH.captures(device_path.as_str());\n    match caps {\n        Some(details) => {\n            trace!(\"{:?}\", details);\n            detach_disk(&details[\"ip\"], &details[\"port\"], &details[\"iqn\"])\n        }\n        None => {\n            trace!(\"Doh!\");\n            Err(format!(\"Invalid device path: {}\", device_path))\n        }\n    }\n}\n\nfn get_iscsi_device_path(uuid: &str) -> Option<String> {\n    let iscsiadm = ISCSIADM.as_str();\n\n    if which::which(&iscsiadm).is_err() {\n        trace!(\"Cannot find {}\", &iscsiadm);\n        return None;\n    }\n    let output = Command::new(&iscsiadm)\n        .args(&[\"-m\", \"node\"])\n        .output()\n        .expect(\"Failed iscsiadm\");\n    if !output.status.success() {\n        debug!(\n            \"iscsiadm failed: {}\",\n            String::from_utf8(output.stderr).unwrap()\n        );\n        return None;\n    }\n    let op = String::from_utf8(output.stdout).unwrap();\n\n    static RE_TARGET: Lazy<regex::Regex> = Lazy::new(|| {\n        regex::Regex::new(\n            r\"(?x)\n            (?P<ip>\\d+.\\d+.\\d+.\\d+):(?P<port>\\d+),(?P<lun>\\d+)\\s+(?P<iqn>.*:\\w+)-(?P<uuid>.*)\n            \",\n        )\n        .unwrap()\n    });\n\n    for cap in RE_TARGET.captures_iter(op.as_str()) {\n        trace!(\"unstage: searching for {} got {}\", uuid, &cap[\"uuid\"]);\n        if uuid == &cap[\"uuid\"] {\n            return Some(format!(\n                \"\/dev\/disk\/by-path\/ip-{}:{}-iscsi-{}-{}-lun-{}\",\n                &cap[\"ip\"],\n                &cap[\"port\"],\n                &cap[\"iqn\"],\n                &cap[\"uuid\"],\n                &cap[\"lun\"],\n            ));\n        }\n    }\n    None\n}\n\n\/\/\/ Search for and return path to the device on which a nexus iscsi\n\/\/\/ target matching the volume id has been mounted or None.\npub fn iscsi_find(uuid: &str) -> Option<String> {\n    if let Some(path) = get_iscsi_device_path(uuid) {\n        return Some(iscsi_realpath(path));\n    }\n    None\n}\n","avg_line_length":30.731292517,"max_line_length":93,"alphanum_fraction":0.5399003874,"licenses":["Apache-2.0"],"repository_name":"akhilerm\/Mayastor","path":"csi\/src\/node\/iscsiutil.rs","size":9035,"lang":"Rust"}
{"content":"package typingsSlinky.vegaLite.transformMod\n\nimport typingsSlinky.vegaLite.channeldefMod.FieldName\nimport org.scalablytyped.runtime.StObject\nimport scala.scalajs.js\nimport scala.scalajs.js.`|`\nimport scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}\n\n@js.native\ntrait DensityTransform extends Transform {\n  \n  \/**\n    * The output fields for the sample value and corresponding density estimate.\n    *\n    * __Default value:__ `[\"value\", \"density\"]`\n    *\/\n  var as: js.UndefOr[js.Tuple2[FieldName, FieldName]] = js.native\n  \n  \/**\n    * The bandwidth (standard deviation) of the Gaussian kernel. If unspecified or set to zero, the bandwidth value is automatically estimated from the input data using Scott\u2019s rule.\n    *\/\n  var bandwidth: js.UndefOr[Double] = js.native\n  \n  \/**\n    * A boolean flag indicating if the output values should be probability estimates (false) or smoothed counts (true).\n    *\n    * __Default value:__ `false`\n    *\/\n  var counts: js.UndefOr[Boolean] = js.native\n  \n  \/**\n    * A boolean flag indicating whether to produce density estimates (false) or cumulative density estimates (true).\n    *\n    * __Default value:__ `false`\n    *\/\n  var cumulative: js.UndefOr[Boolean] = js.native\n  \n  \/**\n    * The data field for which to perform density estimation.\n    *\/\n  var density: FieldName = js.native\n  \n  \/**\n    * A [min, max] domain from which to sample the distribution. If unspecified, the extent will be determined by the observed minimum and maximum values of the density value field.\n    *\/\n  var extent: js.UndefOr[js.Tuple2[Double, Double]] = js.native\n  \n  \/**\n    * The data fields to group by. If not specified, a single group containing all data objects will be used.\n    *\/\n  var groupby: js.UndefOr[js.Array[FieldName]] = js.native\n  \n  \/**\n    * The maximum number of samples to take along the extent domain for plotting the density.\n    *\n    * __Default value:__ `200`\n    *\/\n  var maxsteps: js.UndefOr[Double] = js.native\n  \n  \/**\n    * The minimum number of samples to take along the extent domain for plotting the density.\n    *\n    * __Default value:__ `25`\n    *\/\n  var minsteps: js.UndefOr[Double] = js.native\n  \n  \/**\n    * The exact number of samples to take along the extent domain for plotting the density. If specified, overrides both minsteps and maxsteps to set an exact number of uniform samples. Potentially useful in conjunction with a fixed extent to ensure consistent sample points for stacked densities.\n    *\/\n  var steps: js.UndefOr[Double] = js.native\n}\nobject DensityTransform {\n  \n  @scala.inline\n  def apply(density: FieldName): DensityTransform = {\n    val __obj = js.Dynamic.literal(density = density.asInstanceOf[js.Any])\n    __obj.asInstanceOf[DensityTransform]\n  }\n  \n  @scala.inline\n  implicit class DensityTransformMutableBuilder[Self <: DensityTransform] (val x: Self) extends AnyVal {\n    \n    @scala.inline\n    def setAs(value: js.Tuple2[FieldName, FieldName]): Self = StObject.set(x, \"as\", value.asInstanceOf[js.Any])\n    \n    @scala.inline\n    def setAsUndefined: Self = StObject.set(x, \"as\", js.undefined)\n    \n    @scala.inline\n    def setBandwidth(value: Double): Self = StObject.set(x, \"bandwidth\", value.asInstanceOf[js.Any])\n    \n    @scala.inline\n    def setBandwidthUndefined: Self = StObject.set(x, \"bandwidth\", js.undefined)\n    \n    @scala.inline\n    def setCounts(value: Boolean): Self = StObject.set(x, \"counts\", value.asInstanceOf[js.Any])\n    \n    @scala.inline\n    def setCountsUndefined: Self = StObject.set(x, \"counts\", js.undefined)\n    \n    @scala.inline\n    def setCumulative(value: Boolean): Self = StObject.set(x, \"cumulative\", value.asInstanceOf[js.Any])\n    \n    @scala.inline\n    def setCumulativeUndefined: Self = StObject.set(x, \"cumulative\", js.undefined)\n    \n    @scala.inline\n    def setDensity(value: FieldName): Self = StObject.set(x, \"density\", value.asInstanceOf[js.Any])\n    \n    @scala.inline\n    def setExtent(value: js.Tuple2[Double, Double]): Self = StObject.set(x, \"extent\", value.asInstanceOf[js.Any])\n    \n    @scala.inline\n    def setExtentUndefined: Self = StObject.set(x, \"extent\", js.undefined)\n    \n    @scala.inline\n    def setGroupby(value: js.Array[FieldName]): Self = StObject.set(x, \"groupby\", value.asInstanceOf[js.Any])\n    \n    @scala.inline\n    def setGroupbyUndefined: Self = StObject.set(x, \"groupby\", js.undefined)\n    \n    @scala.inline\n    def setGroupbyVarargs(value: FieldName*): Self = StObject.set(x, \"groupby\", js.Array(value :_*))\n    \n    @scala.inline\n    def setMaxsteps(value: Double): Self = StObject.set(x, \"maxsteps\", value.asInstanceOf[js.Any])\n    \n    @scala.inline\n    def setMaxstepsUndefined: Self = StObject.set(x, \"maxsteps\", js.undefined)\n    \n    @scala.inline\n    def setMinsteps(value: Double): Self = StObject.set(x, \"minsteps\", value.asInstanceOf[js.Any])\n    \n    @scala.inline\n    def setMinstepsUndefined: Self = StObject.set(x, \"minsteps\", js.undefined)\n    \n    @scala.inline\n    def setSteps(value: Double): Self = StObject.set(x, \"steps\", value.asInstanceOf[js.Any])\n    \n    @scala.inline\n    def setStepsUndefined: Self = StObject.set(x, \"steps\", js.undefined)\n  }\n}\n","avg_line_length":36.0208333333,"max_line_length":297,"alphanum_fraction":0.692500482,"licenses":["MIT"],"repository_name":"ScalablyTyped\/SlinkyTyped","path":"v\/vega-lite\/src\/main\/scala\/typingsSlinky\/vegaLite\/transformMod\/DensityTransform.scala","size":5189,"lang":"Scala"}
{"content":"<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    <title>fssec-model: Not compatible<\/title>\n    <link rel=\"shortcut icon\" type=\"image\/png\" href=\"..\/..\/..\/..\/..\/favicon.png\" \/>\n    <link href=\"..\/..\/..\/..\/..\/bootstrap.min.css\" rel=\"stylesheet\">\n    <link href=\"..\/..\/..\/..\/..\/bootstrap-custom.css\" rel=\"stylesheet\">\n    <link href=\"\/\/maxcdn.bootstrapcdn.com\/font-awesome\/4.2.0\/css\/font-awesome.min.css\" rel=\"stylesheet\">\n    <script src=\"..\/..\/..\/..\/..\/moment.min.js\"><\/script>\n    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->\n    <!-- WARNING: Respond.js doesn't work if you view the page via file:\/\/ -->\n    <!--[if lt IE 9]>\n      <script src=\"https:\/\/oss.maxcdn.com\/html5shiv\/3.7.2\/html5shiv.min.js\"><\/script>\n      <script src=\"https:\/\/oss.maxcdn.com\/respond\/1.4.2\/respond.min.js\"><\/script>\n    <![endif]-->\n  <\/head>\n  <body>\n    <div class=\"container\">\n      <div class=\"navbar navbar-default\" role=\"navigation\">\n        <div class=\"container-fluid\">\n          <div class=\"navbar-header\">\n            <a class=\"navbar-brand\" href=\"..\/..\/..\/..\/..\"><i class=\"fa fa-lg fa-flag-checkered\"><\/i> Coq bench<\/a>\n          <\/div>\n          <div id=\"navbar\" class=\"collapse navbar-collapse\">\n            <ul class=\"nav navbar-nav\">\n              <li><a href=\"..\/..\">clean \/ released<\/a><\/li>\n              <li class=\"active\"><a href=\"\">8.9.1 \/ fssec-model - 8.8.0<\/a><\/li>\n            <\/ul>\n          <\/div>\n        <\/div>\n      <\/div>\n      <div class=\"article\">\n        <div class=\"row\">\n          <div class=\"col-md-12\">\n            <a href=\"..\/..\">\u00ab Up<\/a>\n            <h1>\n              fssec-model\n              <small>\n                8.8.0\n                <span class=\"label label-info\">Not compatible<\/span>\n              <\/small>\n            <\/h1>\n            <p><em><script>document.write(moment(\"2021-10-06 02:06:14 +0000\", \"YYYY-MM-DD HH:mm:ss Z\").fromNow());<\/script> (2021-10-06 02:06:14 UTC)<\/em><p>\n            <h2>Context<\/h2>\n            <pre># Packages matching: installed\n# Name              # Installed # Synopsis\nbase-bigarray       base\nbase-threads        base\nbase-unix           base\ncamlp5              7.14        Preprocessor-pretty-printer of OCaml\nconf-findutils      1           Virtual package relying on findutils\nconf-perl           1           Virtual package relying on perl\ncoq                 8.9.1       Formal proof management system\nnum                 1.4         The legacy Num library for arbitrary-precision integer and rational arithmetic\nocaml               4.08.1      The OCaml compiler (virtual package)\nocaml-base-compiler 4.08.1      Official release 4.08.1\nocaml-config        1           OCaml Switch Configuration\nocamlfind           1.9.1       A library manager for OCaml\n# opam file:\nopam-version: &quot;2.0&quot;\nmaintainer: &quot;Hugo.Herbelin@inria.fr&quot;\nhomepage: &quot;https:\/\/github.com\/coq-contribs\/fssec-model&quot;\nlicense: &quot;Unknown&quot;\nbuild: [make &quot;-j%{jobs}%&quot;]\ninstall: [make &quot;install&quot;]\nremove: [&quot;rm&quot; &quot;-R&quot; &quot;%{lib}%\/coq\/user-contrib\/FSSecModel&quot;]\ndepends: [\n  &quot;ocaml&quot;\n  &quot;coq&quot; {&gt;= &quot;8.8&quot; &amp; &lt; &quot;8.9~&quot;}\n]\ntags: [ &quot;keyword: security&quot; &quot;keyword: filesystem&quot; &quot;keyword: UNIX&quot; &quot;keyword: MLS&quot; &quot;keyword: access control&quot; &quot;category: Computer Science\/Operating Systems&quot; &quot;date: 2002-04-24&quot; ]\nauthors: [ &quot;Maximiliano Cristi\u00e1&quot; ]\nbug-reports: &quot;https:\/\/github.com\/coq-contribs\/fssec-model\/issues&quot;\ndev-repo: &quot;git+https:\/\/github.com\/coq-contribs\/fssec-model.git&quot;\nsynopsis: &quot;Formal verification of an extension of a UNIX compatible, secure filesystem&quot;\nflags: light-uninstall\nurl {\n  src: &quot;https:\/\/github.com\/coq-contribs\/fssec-model\/archive\/v8.8.0.tar.gz&quot;\n  checksum: &quot;md5=6b17b8460eafcdf0439b5edee9f2faf3&quot;\n}\n<\/pre>\n            <h2>Lint<\/h2>\n            <dl class=\"dl-horizontal\">\n              <dt>Command<\/dt>\n              <dd><code>true<\/code><\/dd>\n              <dt>Return code<\/dt>\n              <dd>0<\/dd>\n            <\/dl>\n            <h2>Dry install<\/h2>\n            <p>Dry install with the current Coq version:<\/p>\n            <dl class=\"dl-horizontal\">\n              <dt>Command<\/dt>\n              <dd><code>opam install -y --show-action coq-fssec-model.8.8.0 coq.8.9.1<\/code><\/dd>\n              <dt>Return code<\/dt>\n              <dd>5120<\/dd>\n              <dt>Output<\/dt>\n              <dd><pre>[NOTE] Package coq is already installed (current version is 8.9.1).\nThe following dependencies couldn&#39;t be met:\n  - coq-fssec-model -&gt; coq &lt; 8.9~ -&gt; ocaml &lt; 4.06.0\n      base of this switch (use `--unlock-base&#39; to force)\nYour request can&#39;t be satisfied:\n  - No available version of coq satisfies the constraints\nNo solution found, exiting\n<\/pre><\/dd>\n            <\/dl>\n            <p>Dry install without Coq\/switch base, to test if the problem was incompatibility with the current Coq\/OCaml version:<\/p>\n            <dl class=\"dl-horizontal\">\n              <dt>Command<\/dt>\n              <dd><code>opam remove -y coq; opam install -y --show-action --unlock-base coq-fssec-model.8.8.0<\/code><\/dd>\n              <dt>Return code<\/dt>\n              <dd>0<\/dd>\n            <\/dl>\n            <h2>Install dependencies<\/h2>\n            <dl class=\"dl-horizontal\">\n              <dt>Command<\/dt>\n              <dd><code>true<\/code><\/dd>\n              <dt>Return code<\/dt>\n              <dd>0<\/dd>\n              <dt>Duration<\/dt>\n              <dd>0 s<\/dd>\n            <\/dl>\n            <h2>Install<\/h2>\n            <dl class=\"dl-horizontal\">\n              <dt>Command<\/dt>\n              <dd><code>true<\/code><\/dd>\n              <dt>Return code<\/dt>\n              <dd>0<\/dd>\n              <dt>Duration<\/dt>\n              <dd>0 s<\/dd>\n            <\/dl>\n            <h2>Installation size<\/h2>\n            <p>No files were installed.<\/p>\n            <h2>Uninstall<\/h2>\n            <dl class=\"dl-horizontal\">\n              <dt>Command<\/dt>\n              <dd><code>true<\/code><\/dd>\n              <dt>Return code<\/dt>\n              <dd>0<\/dd>\n              <dt>Missing removes<\/dt>\n              <dd>\n                none\n              <\/dd>\n              <dt>Wrong removes<\/dt>\n              <dd>\n                none\n              <\/dd>\n            <\/dl>\n          <\/div>\n        <\/div>\n      <\/div>\n      <hr\/>\n      <div class=\"footer\">\n        <p class=\"text-center\">\n          <small>Sources are on <a href=\"https:\/\/github.com\/coq-bench\">GitHub<\/a>. \u00a9 Guillaume Claret.<\/small>\n        <\/p>\n      <\/div>\n    <\/div>\n    <script src=\"https:\/\/ajax.googleapis.com\/ajax\/libs\/jquery\/1.11.1\/jquery.min.js\"><\/script>\n    <script src=\"..\/..\/..\/..\/..\/bootstrap.min.js\"><\/script>\n  <\/body>\n<\/html>\n","avg_line_length":42.2317073171,"max_line_length":244,"alphanum_fraction":0.5425931273,"licenses":["MIT"],"repository_name":"coq-bench\/coq-bench.github.io","path":"clean\/Linux-x86_64-4.08.1-2.0.5\/released\/8.9.1\/fssec-model\/8.8.0.html","size":6929,"lang":"HTML"}
{"content":"use crate::{\n    AlignCenterLeft, AlignCenterRight, AlignLeft, AlignRight, IgnoreExcess, PaddedValue, Width,\n};\n\n#[cfg(feature = \"std\")]\nuse crate::{PaddedColumn, PaddedColumnIter};\n\nmacro_rules! single_fn {\n    ($(#[$attributes:meta])* $name:ident = $alignment:ident) => {\n        $(#[$attributes])*\n        pub fn $name<Value: Width>(\n            value: Value,\n            total_width: usize\n        ) -> PaddedValue<Value, char, IgnoreExcess, $alignment> {\n            PaddedValue {\n                value,\n                total_width,\n                pad_block: ' ',\n                pad: $alignment,\n                handle_excess: IgnoreExcess,\n            }\n        }\n    };\n}\n\nmacro_rules! multi_fn {\n    ($(#[$attributes:meta])* $name:ident = $alignment:ident) => {\n        $(#[$attributes])*\n        #[cfg(feature = \"std\")]\n        pub fn $name<ValueList>(\n            values: ValueList\n        ) ->  PaddedColumnIter<ValueList::Item, char, $alignment>\n        where\n            ValueList: Iterator,\n            ValueList::Item: Width,\n        {\n            PaddedColumn {\n                values,\n                pad_block: ' ',\n                pad: $alignment,\n            }\n            .into_iter()\n        }\n    };\n}\n\nsingle_fn! {\n    \/\/\/ Pad space characters to the right of a value.\n    \/\/\/\n    \/\/\/ **When `value.width()` is not greater than `total_width`,\n    \/\/\/ add space characters to the right of `value` to make its\n    \/\/\/ width equals to `total_width`:**\n    \/\/\/\n    \/\/\/ ```\n    \/\/\/ use zero_copy_pads::align_left;\n    \/\/\/ # use pretty_assertions::assert_eq;\n    \/\/\/ let value = \"abc\";\n    \/\/\/ let padded_value = align_left(value, 5);\n    \/\/\/ assert_eq!(padded_value.to_string(), \"abc  \");\n    \/\/\/ ```\n    \/\/\/\n    \/\/\/ **When `value.width()` is greater than `total_width`,\n    \/\/\/ display `value` as is:**\n    \/\/\/\n    \/\/\/ ```\n    \/\/\/ use zero_copy_pads::align_left;\n    \/\/\/ let value = \"abcdefghi\";\n    \/\/\/ let padded_value = align_left(value, 5);\n    \/\/\/ assert_eq!(padded_value.to_string(), value);\n    \/\/\/ ```\n    align_left = AlignLeft\n}\n\nsingle_fn! {\n    \/\/\/ Pad space characters to the left of a value.\n    \/\/\/\n    \/\/\/ **When `value.width()` is not greater than `total_width`,\n    \/\/\/ add space characters to the left of `value` to make its\n    \/\/\/ width equals to `total_width`:**\n    \/\/\/\n    \/\/\/ ```\n    \/\/\/ # use pretty_assertions::assert_eq;\n    \/\/\/ use zero_copy_pads::align_right;\n    \/\/\/ let value = \"abc\";\n    \/\/\/ let padded_value = align_right(value, 5);\n    \/\/\/ assert_eq!(padded_value.to_string(), \"  abc\");\n    \/\/\/ ```\n    \/\/\/\n    \/\/\/ **When `value.width()` is greater than `total_width`,\n    \/\/\/ display `value` as is:**\n    \/\/\/\n    \/\/\/ ```\n    \/\/\/ # use pretty_assertions::assert_eq;\n    \/\/\/ use zero_copy_pads::align_right;\n    \/\/\/ let value = \"abcdefghi\";\n    \/\/\/ let padded_value = align_right(value, 5);\n    \/\/\/ assert_eq!(padded_value.to_string(), value);\n    \/\/\/ ```\n    align_right = AlignRight\n}\n\nsingle_fn! {\n    \/\/\/ Pad space characters both side of a value with the remainder\n    \/\/\/ block (if any) in the right.\n    \/\/\/\n    \/\/\/ **When `value.width()` is not greater than `total_width`\n    \/\/\/ and `total_width - value.width()` is an even number,\n    \/\/\/ center the value in a space of `total_width`:**\n    \/\/\/\n    \/\/\/ ```\n    \/\/\/ # use pretty_assertions::assert_eq;\n    \/\/\/ use zero_copy_pads::align_center_left;\n    \/\/\/ let value = \"abc\";\n    \/\/\/ let padded_value = align_center_left(value, 7);\n    \/\/\/ assert_eq!(padded_value.to_string(), \"  abc  \");\n    \/\/\/ ```\n    \/\/\/\n    \/\/\/ **When `value.width()` is not greater than `total_width`\n    \/\/\/ and `total_width - value.width()` is an odd number\n    \/\/\/ center the value in a space of `total_width` but with\n    \/\/\/ 1 remainder block to the right:**\n    \/\/\/\n    \/\/\/ ```\n    \/\/\/ # use pretty_assertions::assert_eq;\n    \/\/\/ use zero_copy_pads::align_center_left;\n    \/\/\/ let value = \"abc\";\n    \/\/\/ let padded_value = align_center_left(value, 8);\n    \/\/\/ assert_eq!(padded_value.to_string(), \"  abc   \");\n    \/\/\/ ```\n    \/\/\/\n    \/\/\/ **When `value.width()` is greater than `total_width`,\n    \/\/\/ display `value` as is:**\n    \/\/\/\n    \/\/\/ ```\n    \/\/\/ # use pretty_assertions::assert_eq;\n    \/\/\/ use zero_copy_pads::align_center_left;\n    \/\/\/ let value = \"abcdefghi\";\n    \/\/\/ let padded_value = align_center_left(value, 5);\n    \/\/\/ assert_eq!(padded_value.to_string(), value);\n    \/\/\/ ```\n    align_center_left = AlignCenterLeft\n}\n\nsingle_fn! {\n    \/\/\/ Pad space characters both side of a value with the remainder\n    \/\/\/ block (if any) in the left.\n    \/\/\/\n    \/\/\/ **When `value.width()` is not greater than `total_width`\n    \/\/\/ and `total_width - value.width()` is an even number,\n    \/\/\/ center the value in a space of `total_width`:**\n    \/\/\/\n    \/\/\/ ```\n    \/\/\/ # use pretty_assertions::assert_eq;\n    \/\/\/ use zero_copy_pads::align_center_right;\n    \/\/\/ let value = \"abc\";\n    \/\/\/ let padded_value = align_center_right(value, 7);\n    \/\/\/ assert_eq!(padded_value.to_string(), \"  abc  \");\n    \/\/\/ ```\n    \/\/\/\n    \/\/\/ **When `value.width()` is not greater than `total_width`\n    \/\/\/ and `total_width - value.width()` is an odd number\n    \/\/\/ center the value in a space of `total_width` but with\n    \/\/\/ 1 remainder block to the left:**\n    \/\/\/\n    \/\/\/ ```\n    \/\/\/ # use pretty_assertions::assert_eq;\n    \/\/\/ use zero_copy_pads::align_center_right;\n    \/\/\/ let value = \"abc\";\n    \/\/\/ let padded_value = align_center_right(value, 8);\n    \/\/\/ assert_eq!(padded_value.to_string(), \"   abc  \");\n    \/\/\/ ```\n    \/\/\/\n    \/\/\/ **When `value.width()` is greater than `total_width`,\n    \/\/\/ display `value` as is:**\n    \/\/\/\n    \/\/\/ ```\n    \/\/\/ # use pretty_assertions::assert_eq;\n    \/\/\/ use zero_copy_pads::align_center_right;\n    \/\/\/ let value = \"abcdefghi\";\n    \/\/\/ let padded_value = align_center_right(value, 5);\n    \/\/\/ assert_eq!(padded_value.to_string(), value);\n    \/\/\/ ```\n    align_center_right = AlignCenterRight\n}\n\nmulti_fn! {\n    \/\/\/ Pad space characters to the right of every value so that they all share the same width.\n    \/\/\/\n    \/\/\/ **Example:**\n    \/\/\/\n    \/\/\/ ```\n    \/\/\/ # use pretty_assertions::assert_eq;\n    \/\/\/ use zero_copy_pads::align_column_left;\n    \/\/\/ use pipe_trait::Pipe;\n    \/\/\/ let values = vec![\n    \/\/\/     \"Rust\", \"C\", \"C++\", \"C#\", \"JavaScript\",\n    \/\/\/     \"TypeScript\", \"Java\", \"Kotlin\", \"Go\",\n    \/\/\/ ];\n    \/\/\/ let padded_values: Vec<_> = values\n    \/\/\/     .iter()\n    \/\/\/     .pipe(align_column_left)\n    \/\/\/     .into_iter()\n    \/\/\/     .map(|x| x.to_string())\n    \/\/\/     .collect();\n    \/\/\/ let expected = [\n    \/\/\/     \"Rust      \", \"C         \", \"C++       \",\n    \/\/\/     \"C#        \", \"JavaScript\", \"TypeScript\",\n    \/\/\/     \"Java      \", \"Kotlin    \", \"Go        \",\n    \/\/\/ ];\n    \/\/\/ assert_eq!(padded_values, expected);\n    \/\/\/ ```\n    align_column_left = AlignLeft\n}\n\nmulti_fn! {\n    \/\/\/ Pad space characters to the left of every value so that they all share the same width.\n    \/\/\/\n    \/\/\/ **Example:**\n    \/\/\/\n    \/\/\/ ```\n    \/\/\/ # use pretty_assertions::assert_eq;\n    \/\/\/ use zero_copy_pads::align_column_right;\n    \/\/\/ use pipe_trait::Pipe;\n    \/\/\/ let values = vec![\n    \/\/\/     \"Rust\", \"C\", \"C++\", \"C#\", \"JavaScript\",\n    \/\/\/     \"TypeScript\", \"Java\", \"Kotlin\", \"Go\",\n    \/\/\/ ];\n    \/\/\/ let padded_values: Vec<_> = values\n    \/\/\/     .iter()\n    \/\/\/     .pipe(align_column_right)\n    \/\/\/     .into_iter()\n    \/\/\/     .map(|x| x.to_string())\n    \/\/\/     .collect();\n    \/\/\/ let expected = [\n    \/\/\/     \"      Rust\", \"         C\", \"       C++\",\n    \/\/\/     \"        C#\", \"JavaScript\", \"TypeScript\",\n    \/\/\/     \"      Java\", \"    Kotlin\", \"        Go\",\n    \/\/\/ ];\n    \/\/\/ assert_eq!(padded_values, expected);\n    \/\/\/ ```\n    align_column_right = AlignRight\n}\n\nmulti_fn! {\n    \/\/\/ Pad space characters to both sides of every value so that they all share the same width.\n    \/\/\/ The remainder blocks will be placed at the right.\n    \/\/\/\n    \/\/\/ **Example:**\n    \/\/\/\n    \/\/\/ ```\n    \/\/\/ # use pretty_assertions::assert_eq;\n    \/\/\/ use zero_copy_pads::align_column_center_left;\n    \/\/\/ use pipe_trait::Pipe;\n    \/\/\/ let values = vec![\n    \/\/\/     \"Rust\", \"C\", \"C++\", \"C#\", \"JavaScript\",\n    \/\/\/     \"TypeScript\", \"Java\", \"Kotlin\", \"Go\",\n    \/\/\/ ];\n    \/\/\/ let padded_values: Vec<_> = values\n    \/\/\/     .iter()\n    \/\/\/     .pipe(align_column_center_left)\n    \/\/\/     .into_iter()\n    \/\/\/     .map(|x| x.to_string())\n    \/\/\/     .collect();\n    \/\/\/ let expected = [\n    \/\/\/     \"   Rust   \", \"    C     \", \"   C++    \",\n    \/\/\/     \"    C#    \", \"JavaScript\", \"TypeScript\",\n    \/\/\/     \"   Java   \", \"  Kotlin  \", \"    Go    \",\n    \/\/\/ ];\n    \/\/\/ assert_eq!(padded_values, expected);\n    \/\/\/ ```\n    align_column_center_left = AlignCenterLeft\n}\n\nmulti_fn! {\n    \/\/\/ Pad space characters to both sides of every value so that they all share the same width.\n    \/\/\/ The remainder blocks will be placed at the left.\n    \/\/\/\n    \/\/\/ **Example:**\n    \/\/\/\n    \/\/\/ ```\n    \/\/\/ # use pretty_assertions::assert_eq;\n    \/\/\/ use zero_copy_pads::align_column_center_right;\n    \/\/\/ use pipe_trait::Pipe;\n    \/\/\/ let values = vec![\n    \/\/\/     \"Rust\", \"C\", \"C++\", \"C#\", \"JavaScript\",\n    \/\/\/     \"TypeScript\", \"Java\", \"Kotlin\", \"Go\",\n    \/\/\/ ];\n    \/\/\/ let padded_values: Vec<_> = values\n    \/\/\/     .iter()\n    \/\/\/     .pipe(align_column_center_right)\n    \/\/\/     .into_iter()\n    \/\/\/     .map(|x| x.to_string())\n    \/\/\/     .collect();\n    \/\/\/ let expected = [\n    \/\/\/     \"   Rust   \", \"     C    \", \"    C++   \",\n    \/\/\/     \"    C#    \", \"JavaScript\", \"TypeScript\",\n    \/\/\/     \"   Java   \", \"  Kotlin  \", \"    Go    \",\n    \/\/\/ ];\n    \/\/\/ assert_eq!(padded_values, expected);\n    \/\/\/ ```\n    align_column_center_right = AlignCenterRight\n}\n","avg_line_length":31.9240924092,"max_line_length":96,"alphanum_fraction":0.5237258348,"licenses":["MIT"],"repository_name":"KSXGitHub\/zero-copy-pads","path":"src\/shortcuts.rs","size":9673,"lang":"Rust"}
{"content":"@echo off\r\n\r\nset BATCH_DIR=%~dp0\r\ncd %BATCH_DIR%\r\ncd ..\\..\r\n\r\nset MY_DIR=%CD%\r\n\r\ncall \"build\\auto\\setup_arguments.cmd\" %1 %2 %3 %4 %5 %6\r\n\r\ncall build\\auto\\setup_vs_any.cmd\r\n\r\ncall build\\auto\\helper_get_svnversion.cmd\r\ncall build\\auto\\helper_get_openmpt_version.cmd\r\n\r\nset MPT_REVISION=%OPENMPT_VERSION%-%SVNVERSION%\r\n\r\n\r\n\r\ncd bin || goto error\r\nrmdir \/s \/q openmpt\r\nmkdir openmpt\r\nmkdir openmpt\\pkg.win\r\nmkdir openmpt\\pkg.win\\%OPENMPT_VERSION_MAJORMAJOR%.%OPENMPT_VERSION_MAJOR%\r\ncopy \/y ..\\installer\\OpenMPT-%OPENMPT_VERSION%-Setup.exe              openmpt\\pkg.win\\%OPENMPT_VERSION_MAJORMAJOR%.%OPENMPT_VERSION_MAJOR%\\OpenMPT-%OPENMPT_VERSION%-%SVNVERSION%-Setup.exe\r\ncopy \/y ..\\installer\\OpenMPT-%OPENMPT_VERSION%-Setup.exe.digests      openmpt\\pkg.win\\%OPENMPT_VERSION_MAJORMAJOR%.%OPENMPT_VERSION_MAJOR%\\OpenMPT-%OPENMPT_VERSION%-%SVNVERSION%-Setup.exe.digests\r\ncopy \/y ..\\installer\\OpenMPT-%OPENMPT_VERSION%-Setup-x64.exe          openmpt\\pkg.win\\%OPENMPT_VERSION_MAJORMAJOR%.%OPENMPT_VERSION_MAJOR%\\OpenMPT-%OPENMPT_VERSION%-%SVNVERSION%-Setup-x64.exe\r\ncopy \/y ..\\installer\\OpenMPT-%OPENMPT_VERSION%-Setup-x64.exe.digests  openmpt\\pkg.win\\%OPENMPT_VERSION_MAJORMAJOR%.%OPENMPT_VERSION_MAJOR%\\OpenMPT-%OPENMPT_VERSION%-%SVNVERSION%-Setup-x64.exe.digests\r\ncopy \/y ..\\installer\\OpenMPT-%OPENMPT_VERSION%.zip                    openmpt\\pkg.win\\%OPENMPT_VERSION_MAJORMAJOR%.%OPENMPT_VERSION_MAJOR%\\OpenMPT-%OPENMPT_VERSION%-%SVNVERSION%.zip\r\ncopy \/y ..\\installer\\OpenMPT-%OPENMPT_VERSION%.zip.digests            openmpt\\pkg.win\\%OPENMPT_VERSION_MAJORMAJOR%.%OPENMPT_VERSION_MAJOR%\\OpenMPT-%OPENMPT_VERSION%-%SVNVERSION%.zip.digests\r\ncopy \/y ..\\installer\\OpenMPT-%OPENMPT_VERSION%-legacy.zip             openmpt\\pkg.win\\%OPENMPT_VERSION_MAJORMAJOR%.%OPENMPT_VERSION_MAJOR%\\OpenMPT-%OPENMPT_VERSION%-%SVNVERSION%-legacy.zip\r\ncopy \/y ..\\installer\\OpenMPT-%OPENMPT_VERSION%-legacy.zip.digests     openmpt\\pkg.win\\%OPENMPT_VERSION_MAJORMAJOR%.%OPENMPT_VERSION_MAJOR%\\OpenMPT-%OPENMPT_VERSION%-%SVNVERSION%-legacy.zip.digests\r\ncopy \/y ..\\installer\\OpenMPT-%OPENMPT_VERSION%-x64.zip                openmpt\\pkg.win\\%OPENMPT_VERSION_MAJORMAJOR%.%OPENMPT_VERSION_MAJOR%\\OpenMPT-%OPENMPT_VERSION%-%SVNVERSION%-x64.zip\r\ncopy \/y ..\\installer\\OpenMPT-%OPENMPT_VERSION%-x64.zip.digests        openmpt\\pkg.win\\%OPENMPT_VERSION_MAJORMAJOR%.%OPENMPT_VERSION_MAJOR%\\OpenMPT-%OPENMPT_VERSION%-%SVNVERSION%-x64.zip.digests\r\ncopy \/y ..\\installer\\OpenMPT-%OPENMPT_VERSION%-x64-legacy.zip         openmpt\\pkg.win\\%OPENMPT_VERSION_MAJORMAJOR%.%OPENMPT_VERSION_MAJOR%\\OpenMPT-%OPENMPT_VERSION%-%SVNVERSION%-x64-legacy.zip\r\ncopy \/y ..\\installer\\OpenMPT-%OPENMPT_VERSION%-x64-legacy.zip.digests openmpt\\pkg.win\\%OPENMPT_VERSION_MAJORMAJOR%.%OPENMPT_VERSION_MAJOR%\\OpenMPT-%OPENMPT_VERSION%-%SVNVERSION%-x64-legacy.zip.digests\r\n..\\build\\tools\\7zip\\7z.exe a -ttar openmpt-pkg.win.tar openmpt || goto error\r\nrmdir \/s \/q openmpt\r\ncd .. || goto error\r\n\r\n\r\n\r\ngoto noerror\r\n\r\n:error\r\ncd \"%MY_DIR%\"\r\nexit 1\r\n\r\n:noerror\r\ncd \"%MY_DIR%\"\r\nexit 0\r\n","avg_line_length":57.8653846154,"max_line_length":201,"alphanum_fraction":0.7640412097,"licenses":["BSD-3-Clause"],"repository_name":"extrowerk\/openmpt","path":"build\/auto\/package_openmpt_installer_args.cmd","size":3009,"lang":"Batchfile"}
{"content":"\/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\npackage org.apache.flink.table.planner.plan.utils\n\nimport org.apache.flink.table.api.TableException\nimport org.apache.flink.table.functions.UserDefinedFunction\nimport org.apache.flink.table.planner.calcite.FlinkTypeFactory\nimport org.apache.flink.table.planner.functions.aggfunctions.FirstValueAggFunction._\nimport org.apache.flink.table.planner.functions.aggfunctions.FirstValueWithRetractAggFunction._\nimport org.apache.flink.table.planner.functions.aggfunctions.IncrSumAggFunction._\nimport org.apache.flink.table.planner.functions.aggfunctions.IncrSumWithRetractAggFunction._\nimport org.apache.flink.table.planner.functions.aggfunctions.LastValueAggFunction._\nimport org.apache.flink.table.planner.functions.aggfunctions.LastValueWithRetractAggFunction._\nimport org.apache.flink.table.planner.functions.aggfunctions.SingleValueAggFunction._\nimport org.apache.flink.table.planner.functions.aggfunctions.SumWithRetractAggFunction._\nimport org.apache.flink.table.planner.functions.aggfunctions._\nimport org.apache.flink.table.planner.functions.bridging.BridgingSqlAggFunction\nimport org.apache.flink.table.planner.functions.sql.{SqlFirstLastValueAggFunction, SqlListAggFunction}\nimport org.apache.flink.table.planner.functions.utils.AggSqlFunction\nimport org.apache.flink.table.runtime.typeutils.DecimalDataTypeInfo\nimport org.apache.flink.table.types.logical.LogicalTypeRoot._\nimport org.apache.flink.table.types.logical._\n\nimport org.apache.calcite.rel.`type`.RelDataType\nimport org.apache.calcite.rel.core.AggregateCall\nimport org.apache.calcite.sql.fun._\nimport org.apache.calcite.sql.{SqlAggFunction, SqlKind, SqlRankFunction}\n\nimport java.util\n\nimport scala.collection.JavaConversions._\n\n\/**\n  * The class of agg function factory which is used to create AggregateFunction or\n  * DeclarativeAggregateFunction from Calcite AggregateCall\n  *\n  * @param inputType the input rel data type\n  * @param orderKeyIdx the indexes of order key (null when is not over agg)\n  * @param needRetraction true if need retraction\n  *\/\nclass AggFunctionFactory(\n    inputType: RelDataType,\n    orderKeyIdx: Array[Int],\n    needRetraction: Array[Boolean]) {\n\n  \/**\n    * The entry point to create an aggregate function from the given AggregateCall\n    *\/\n  def createAggFunction(call: AggregateCall, index: Int): UserDefinedFunction = {\n\n    val argTypes: Array[LogicalType] = call.getArgList\n      .map(inputType.getFieldList.get(_).getType)\n      .map(FlinkTypeFactory.toLogicalType)\n      .toArray\n\n    call.getAggregation match {\n      case a: SqlAvgAggFunction if a.kind == SqlKind.AVG => createAvgAggFunction(argTypes)\n\n      case _: SqlSumAggFunction => createSumAggFunction(argTypes, index)\n\n      case _: SqlSumEmptyIsZeroAggFunction => createSum0AggFunction(argTypes)\n\n      case a: SqlMinMaxAggFunction if a.getKind == SqlKind.MIN =>\n        createMinAggFunction(argTypes, index)\n\n      case a: SqlMinMaxAggFunction if a.getKind == SqlKind.MAX =>\n        createMaxAggFunction(argTypes, index)\n\n      case _: SqlCountAggFunction if call.getArgList.size() > 1 =>\n        throw new TableException(\"We now only support the count of one field.\")\n\n      \/\/ TODO supports ApproximateCountDistinctAggFunction and CountDistinctAggFunction\n\n      case _: SqlCountAggFunction if call.getArgList.isEmpty => createCount1AggFunction(argTypes)\n\n      case _: SqlCountAggFunction => createCountAggFunction(argTypes)\n\n      case a: SqlRankFunction if a.getKind == SqlKind.ROW_NUMBER =>\n        createRowNumberAggFunction(argTypes)\n\n      case a: SqlRankFunction if a.getKind == SqlKind.RANK =>\n        createRankAggFunction(argTypes)\n\n      case a: SqlRankFunction if a.getKind == SqlKind.DENSE_RANK =>\n        createDenseRankAggFunction(argTypes)\n\n      case _: SqlLeadLagAggFunction =>\n        createLeadLagAggFunction(argTypes, index)\n\n      case _: SqlSingleValueAggFunction =>\n        createSingleValueAggFunction(argTypes)\n\n      case a: SqlFirstLastValueAggFunction if a.getKind == SqlKind.FIRST_VALUE =>\n        createFirstValueAggFunction(argTypes, index)\n\n      case a: SqlFirstLastValueAggFunction if a.getKind == SqlKind.LAST_VALUE =>\n        createLastValueAggFunction(argTypes, index)\n\n      case _: SqlListAggFunction if call.getArgList.size() == 1 =>\n        createListAggFunction(argTypes, index)\n\n      case _: SqlListAggFunction if call.getArgList.size() == 2 =>\n        createListAggWsFunction(argTypes, index)\n\n      \/\/ TODO supports SqlCardinalityCountAggFunction\n\n      case a: SqlAggFunction if a.getKind == SqlKind.COLLECT =>\n        createCollectAggFunction(argTypes)\n\n      case udagg: AggSqlFunction =>\n        \/\/ Can not touch the literals, Calcite make them in previous RelNode.\n        \/\/ In here, all inputs are input refs.\n        val constants = new util.ArrayList[AnyRef]()\n        argTypes.foreach(t => constants.add(null))\n        udagg.makeFunction(\n          constants.toArray,\n          argTypes)\n\n      case bsf: BridgingSqlAggFunction =>\n        bsf.getDefinition.asInstanceOf[UserDefinedFunction]\n\n      case unSupported: SqlAggFunction =>\n        throw new TableException(s\"Unsupported Function: '${unSupported.getName}'\")\n    }\n  }\n\n  private def createAvgAggFunction(argTypes: Array[LogicalType]): UserDefinedFunction = {\n    argTypes(0).getTypeRoot match {\n      case TINYINT =>\n        new AvgAggFunction.ByteAvgAggFunction\n      case SMALLINT =>\n        new AvgAggFunction.ShortAvgAggFunction\n      case INTEGER =>\n        new AvgAggFunction.IntAvgAggFunction\n      case BIGINT =>\n        new AvgAggFunction.LongAvgAggFunction\n      case FLOAT =>\n        new AvgAggFunction.FloatAvgAggFunction\n      case DOUBLE =>\n        new AvgAggFunction.DoubleAvgAggFunction\n      case DECIMAL =>\n        val d = argTypes(0).asInstanceOf[DecimalType]\n        new AvgAggFunction.DecimalAvgAggFunction(d)\n      case t =>\n        throw new TableException(s\"Avg aggregate function does not support type: ''$t''.\\n\" +\n          s\"Please re-check the data type.\")\n    }\n  }\n\n  private def createSumAggFunction(\n      argTypes: Array[LogicalType],\n      index: Int): UserDefinedFunction = {\n    if (needRetraction(index)) {\n      argTypes(0).getTypeRoot match {\n        case TINYINT =>\n          new ByteSumWithRetractAggFunction\n        case SMALLINT =>\n          new ShortSumWithRetractAggFunction\n        case INTEGER =>\n          new IntSumWithRetractAggFunction\n        case BIGINT =>\n          new LongSumWithRetractAggFunction\n        case FLOAT =>\n          new FloatSumWithRetractAggFunction\n        case DOUBLE =>\n          new DoubleSumWithRetractAggFunction\n        case DECIMAL =>\n          val d = argTypes(0).asInstanceOf[DecimalType]\n          new DecimalSumWithRetractAggFunction(d)\n        case t =>\n          throw new TableException(s\"Sum with retract aggregate function does not \" +\n            s\"support type: ''$t''.\\nPlease re-check the data type.\")\n      }\n    } else {\n      argTypes(0).getTypeRoot match {\n        case TINYINT =>\n          new SumAggFunction.ByteSumAggFunction\n        case SMALLINT =>\n          new SumAggFunction.ShortSumAggFunction\n        case INTEGER =>\n          new SumAggFunction.IntSumAggFunction\n        case BIGINT =>\n          new SumAggFunction.LongSumAggFunction\n        case FLOAT =>\n          new SumAggFunction.FloatSumAggFunction\n        case DOUBLE =>\n          new SumAggFunction.DoubleSumAggFunction\n        case DECIMAL =>\n          val d = argTypes(0).asInstanceOf[DecimalType]\n          new SumAggFunction.DecimalSumAggFunction(d)\n        case t =>\n          throw new TableException(s\"Sum aggregate function does not support type: ''$t''.\\n\" +\n            s\"Please re-check the data type.\")\n      }\n    }\n  }\n\n  private def createSum0AggFunction(argTypes: Array[LogicalType]): UserDefinedFunction = {\n    argTypes(0).getTypeRoot match {\n      case TINYINT =>\n        new Sum0AggFunction.ByteSum0AggFunction\n      case SMALLINT =>\n        new Sum0AggFunction.ShortSum0AggFunction\n      case INTEGER =>\n        new Sum0AggFunction.IntSum0AggFunction\n      case BIGINT =>\n        new Sum0AggFunction.LongSum0AggFunction\n      case FLOAT =>\n        new Sum0AggFunction.FloatSum0AggFunction\n      case DOUBLE =>\n        new Sum0AggFunction.DoubleSum0AggFunction\n      case DECIMAL =>\n        val d = argTypes(0).asInstanceOf[DecimalType]\n        new Sum0AggFunction.DecimalSum0AggFunction(d)\n      case t =>\n        throw new TableException(s\"Sum0 aggregate function does not support type: ''$t''.\\n\" +\n          s\"Please re-check the data type.\")\n    }\n  }\n\n  private def createIncrSumAggFunction(\n      argTypes: Array[LogicalType],\n      index: Int): UserDefinedFunction = {\n    if (needRetraction(index)) {\n      argTypes(0).getTypeRoot match {\n        case TINYINT =>\n          new ByteIncrSumWithRetractAggFunction\n        case SMALLINT =>\n          new ShortIncrSumWithRetractAggFunction\n        case INTEGER =>\n          new IntIncrSumWithRetractAggFunction\n        case BIGINT =>\n          new LongIncrSumWithRetractAggFunction\n        case FLOAT =>\n          new FloatIncrSumWithRetractAggFunction\n        case DOUBLE =>\n          new DoubleIncrSumWithRetractAggFunction\n        case DECIMAL =>\n          val d = argTypes(0).asInstanceOf[DecimalType]\n          new DecimalIncrSumWithRetractAggFunction(d)\n        case t =>\n          throw new TableException(s\"IncrSum with retract aggregate function does not \" +\n            s\"support type: ''$t''.\\nPlease re-check the data type.\")\n      }\n    } else {\n      argTypes(0).getTypeRoot match {\n        case TINYINT =>\n          new ByteIncrSumAggFunction\n        case SMALLINT =>\n          new ShortIncrSumAggFunction\n        case INTEGER =>\n          new IntIncrSumAggFunction\n        case BIGINT =>\n          new LongIncrSumAggFunction\n        case FLOAT =>\n          new FloatIncrSumAggFunction\n        case DOUBLE =>\n          new DoubleIncrSumAggFunction\n        case DECIMAL =>\n          val d = argTypes(0).asInstanceOf[DecimalType]\n          new DecimalIncrSumAggFunction(d)\n        case t =>\n          throw new TableException(s\"IncrSum aggregate function does not support type: ''$t''.\\n\" +\n            s\"Please re-check the data type.\")\n      }\n    }\n  }\n\n  private def createMinAggFunction(\n      argTypes: Array[LogicalType],\n      index: Int)\n    : UserDefinedFunction = {\n    val valueType = argTypes(0)\n    if (needRetraction(index)) {\n      valueType.getTypeRoot match {\n        case TINYINT | SMALLINT | INTEGER | BIGINT | FLOAT | DOUBLE | BOOLEAN | VARCHAR | DECIMAL |\n             TIME_WITHOUT_TIME_ZONE | DATE | TIMESTAMP_WITHOUT_TIME_ZONE =>\n          new MinWithRetractAggFunction(argTypes(0))\n        case t =>\n          throw new TableException(s\"Min with retract aggregate function does not \" +\n            s\"support type: ''$t''.\\nPlease re-check the data type.\")\n      }\n    } else {\n      argTypes(0).getTypeRoot match {\n        case TINYINT =>\n          new MinAggFunction.ByteMinAggFunction\n        case SMALLINT =>\n          new MinAggFunction.ShortMinAggFunction\n        case INTEGER =>\n          new MinAggFunction.IntMinAggFunction\n        case BIGINT =>\n          new MinAggFunction.LongMinAggFunction\n        case FLOAT =>\n          new MinAggFunction.FloatMinAggFunction\n        case DOUBLE =>\n          new MinAggFunction.DoubleMinAggFunction\n        case BOOLEAN =>\n          new MinAggFunction.BooleanMinAggFunction\n        case VARCHAR | CHAR =>\n          new MinAggFunction.StringMinAggFunction\n        case DATE =>\n          new MinAggFunction.DateMinAggFunction\n        case TIME_WITHOUT_TIME_ZONE =>\n          new MinAggFunction.TimeMinAggFunction\n        case TIMESTAMP_WITHOUT_TIME_ZONE =>\n          val d = argTypes(0).asInstanceOf[TimestampType]\n          new MinAggFunction.TimestampMinAggFunction(d)\n        case DECIMAL =>\n          val d = argTypes(0).asInstanceOf[DecimalType]\n          new MinAggFunction.DecimalMinAggFunction(d)\n        case t =>\n          throw new TableException(s\"Min aggregate function does not support type: ''$t''.\\n\" +\n            s\"Please re-check the data type.\")\n      }\n    }\n  }\n\n  private def createLeadLagAggFunction(\n      argTypes: Array[LogicalType], index: Int): UserDefinedFunction = {\n    argTypes(0).getTypeRoot match {\n      case TINYINT =>\n        new LeadLagAggFunction.ByteLeadLagAggFunction(argTypes.length)\n      case SMALLINT =>\n        new LeadLagAggFunction.ShortLeadLagAggFunction(argTypes.length)\n      case INTEGER =>\n        new LeadLagAggFunction.IntLeadLagAggFunction(argTypes.length)\n      case BIGINT =>\n        new LeadLagAggFunction.LongLeadLagAggFunction(argTypes.length)\n      case FLOAT =>\n        new LeadLagAggFunction.FloatLeadLagAggFunction(argTypes.length)\n      case DOUBLE =>\n        new LeadLagAggFunction.DoubleLeadLagAggFunction(argTypes.length)\n      case BOOLEAN =>\n        new LeadLagAggFunction.BooleanLeadLagAggFunction(argTypes.length)\n      case VARCHAR =>\n        new LeadLagAggFunction.StringLeadLagAggFunction(argTypes.length)\n      case DATE =>\n        new LeadLagAggFunction.DateLeadLagAggFunction(argTypes.length)\n      case TIME_WITHOUT_TIME_ZONE =>\n        new LeadLagAggFunction.TimeLeadLagAggFunction(argTypes.length)\n      case TIMESTAMP_WITHOUT_TIME_ZONE =>\n        val d = argTypes(0).asInstanceOf[TimestampType]\n        new LeadLagAggFunction.TimestampLeadLagAggFunction(argTypes.length, d)\n      case DECIMAL =>\n        val d = argTypes(0).asInstanceOf[DecimalType]\n        new LeadLagAggFunction.DecimalLeadLagAggFunction(argTypes.length, d)\n      case t =>\n        throw new TableException(s\"LeadLag aggregate function does not support type: ''$t''.\\n\" +\n            s\"Please re-check the data type.\")\n    }\n  }\n\n  private def createMaxAggFunction(\n        argTypes: Array[LogicalType],\n        index: Int)\n    : UserDefinedFunction = {\n    val valueType = argTypes(0)\n    if (needRetraction(index)) {\n      valueType.getTypeRoot match {\n        case TINYINT | SMALLINT | INTEGER | BIGINT | FLOAT | DOUBLE | BOOLEAN | VARCHAR | DECIMAL |\n             TIME_WITHOUT_TIME_ZONE | DATE | TIMESTAMP_WITHOUT_TIME_ZONE =>\n          new MaxWithRetractAggFunction(argTypes(0))\n        case t =>\n          throw new TableException(s\"Max with retract aggregate function does not \" +\n            s\"support type: ''$t''.\\nPlease re-check the data type.\")\n      }\n    } else {\n      valueType.getTypeRoot match {\n        case TINYINT =>\n          new MaxAggFunction.ByteMaxAggFunction\n        case SMALLINT =>\n          new MaxAggFunction.ShortMaxAggFunction\n        case INTEGER =>\n          new MaxAggFunction.IntMaxAggFunction\n        case BIGINT =>\n          new MaxAggFunction.LongMaxAggFunction\n        case FLOAT =>\n          new MaxAggFunction.FloatMaxAggFunction\n        case DOUBLE =>\n          new MaxAggFunction.DoubleMaxAggFunction\n        case BOOLEAN =>\n          new MaxAggFunction.BooleanMaxAggFunction\n        case VARCHAR =>\n          new MaxAggFunction.StringMaxAggFunction\n        case DATE =>\n          new MaxAggFunction.DateMaxAggFunction\n        case TIME_WITHOUT_TIME_ZONE =>\n          new MaxAggFunction.TimeMaxAggFunction\n        case TIMESTAMP_WITHOUT_TIME_ZONE =>\n          val d = argTypes(0).asInstanceOf[TimestampType]\n          new MaxAggFunction.TimestampMaxAggFunction(d)\n        case DECIMAL =>\n          val d = argTypes(0).asInstanceOf[DecimalType]\n          new MaxAggFunction.DecimalMaxAggFunction(d)\n        case t =>\n          throw new TableException(s\"Max aggregate function does not support type: ''$t''.\\n\" +\n            s\"Please re-check the data type.\")\n      }\n    }\n  }\n\n  private def createCount1AggFunction(argTypes: Array[LogicalType]): UserDefinedFunction = {\n    new Count1AggFunction\n  }\n\n  private def createCountAggFunction(argTypes: Array[LogicalType]): UserDefinedFunction = {\n    new CountAggFunction\n  }\n\n  private def createSingleValueAggFunction(argTypes: Array[LogicalType]): UserDefinedFunction = {\n    argTypes(0).getTypeRoot match {\n      case TINYINT =>\n        new ByteSingleValueAggFunction\n      case SMALLINT =>\n        new ShortSingleValueAggFunction\n      case INTEGER =>\n        new IntSingleValueAggFunction\n      case BIGINT =>\n        new LongSingleValueAggFunction\n      case FLOAT =>\n        new FloatSingleValueAggFunction\n      case DOUBLE =>\n        new DoubleSingleValueAggFunction\n      case BOOLEAN =>\n        new BooleanSingleValueAggFunction\n      case VARCHAR =>\n        new StringSingleValueAggFunction\n      case DATE =>\n        new DateSingleValueAggFunction\n      case TIME_WITHOUT_TIME_ZONE =>\n        new TimeSingleValueAggFunction\n      case TIMESTAMP_WITHOUT_TIME_ZONE =>\n        val d = argTypes(0).asInstanceOf[TimestampType]\n        new TimestampSingleValueAggFunction(d)\n      case DECIMAL =>\n        val d = argTypes(0).asInstanceOf[DecimalType]\n        new DecimalSingleValueAggFunction(d)\n      case t =>\n        throw new TableException(s\"SINGLE_VALUE aggregate function doesn't support type '$t'.\")\n    }\n  }\n\n  private def createRowNumberAggFunction(argTypes: Array[LogicalType]): UserDefinedFunction = {\n    new RowNumberAggFunction\n  }\n\n  private def createRankAggFunction(argTypes: Array[LogicalType]): UserDefinedFunction = {\n    val argTypes = orderKeyIdx\n      .map(inputType.getFieldList.get(_).getType)\n      .map(FlinkTypeFactory.toLogicalType)\n    new RankAggFunction(argTypes)\n  }\n\n  private def createDenseRankAggFunction(argTypes: Array[LogicalType]): UserDefinedFunction = {\n    val argTypes = orderKeyIdx\n      .map(inputType.getFieldList.get(_).getType)\n      .map(FlinkTypeFactory.toLogicalType)\n    new DenseRankAggFunction(argTypes)\n  }\n\n  private def createFirstValueAggFunction(\n      argTypes: Array[LogicalType],\n      index: Int)\n    : UserDefinedFunction = {\n    val valueType = argTypes(0)\n    if (needRetraction(index)) {\n      valueType.getTypeRoot match {\n        case TINYINT | SMALLINT | INTEGER | BIGINT | FLOAT | DOUBLE | BOOLEAN | VARCHAR | DECIMAL =>\n          new FirstValueWithRetractAggFunction(valueType)\n        case t =>\n          throw new TableException(s\"FIRST_VALUE with retract aggregate function does not \" +\n            s\"support type: ''$t''.\\nPlease re-check the data type.\")\n      }\n    } else {\n      valueType.getTypeRoot match {\n        case TINYINT | SMALLINT | INTEGER | BIGINT | FLOAT | DOUBLE | BOOLEAN | VARCHAR | DECIMAL =>\n          new FirstValueAggFunction(valueType)\n        case t =>\n          throw new TableException(s\"FIRST_VALUE aggregate function does not support \" +\n            s\"type: ''$t''.\\nPlease re-check the data type.\")\n      }\n    }\n  }\n\n  private def createLastValueAggFunction(\n      argTypes: Array[LogicalType],\n      index: Int)\n    : UserDefinedFunction = {\n    val valueType = argTypes(0)\n    if (needRetraction(index)) {\n      valueType.getTypeRoot match {\n        case TINYINT | SMALLINT | INTEGER | BIGINT | FLOAT | DOUBLE | BOOLEAN | VARCHAR | DECIMAL =>\n          new LastValueWithRetractAggFunction(valueType)\n        case t =>\n          throw new TableException(s\"LAST_VALUE with retract aggregate function does not \" +\n            s\"support type: ''$t''.\\nPlease re-check the data type.\")\n      }\n    } else {\n      valueType.getTypeRoot match {\n        case TINYINT | SMALLINT | INTEGER | BIGINT | FLOAT | DOUBLE | BOOLEAN | VARCHAR | DECIMAL =>\n          new LastValueAggFunction(valueType)\n        case t =>\n          throw new TableException(s\"LAST_VALUE aggregate function does not support \" +\n            s\"type: ''$t''.\\nPlease re-check the data type.\")\n      }\n    }\n  }\n\n  private def createListAggFunction(\n      argTypes: Array[LogicalType],\n      index: Int): UserDefinedFunction = {\n    if (needRetraction(index)) {\n      new ListAggWithRetractAggFunction\n    } else {\n      new ListAggFunction(1)\n    }\n  }\n\n  private def createListAggWsFunction(\n      argTypes: Array[LogicalType],\n      index: Int): UserDefinedFunction = {\n    if (needRetraction(index)) {\n      new ListAggWsWithRetractAggFunction\n    } else {\n      new ListAggFunction(2)\n    }\n  }\n\n  private def createCollectAggFunction(argTypes: Array[LogicalType]): UserDefinedFunction = {\n    new CollectAggFunction(argTypes(0))\n  }\n}\n","avg_line_length":38.2937956204,"max_line_length":102,"alphanum_fraction":0.68525137,"licenses":["Apache-2.0"],"repository_name":"821684824\/flink","path":"flink-table\/flink-table-planner-blink\/src\/main\/scala\/org\/apache\/flink\/table\/planner\/plan\/utils\/AggFunctionFactory.scala","size":20985,"lang":"Scala"}
{"content":"_VermilionGymText_5cb72::\n\ttext \"A little word of\"\n\tline \"advice, kid!\"\n\n\tpara \"Electricity is\"\n\tline \"sure powerful!\"\n\n\tpara \"But, it's useless\"\n\tline \"against ground-\"\n\tcont \"type #MON!\"\n\tdone\n\n_VermilionGymText_5cb77::\n\ttext \"The THUNDERBADGE\"\n\tline \"makes #MON up\"\n\tcont \"to \ud835\udddf40 obey you!\"\n\n\tpara \"It also lets your\"\n\tline \"#MON FLY any\"\n\tcont \"time, kid!\"\n\n\tpara \"You're special,\"\n\tline \"kid! Take this!\"\n\tdone\n\n_ReceivedTM24Text::\n\ttext $52, \" received \"\n\tline \"@\"\n\tTX_RAM wcf4b\n\ttext \"!@@\"\n\n_TM24ExplanationText::\n\tdb $0\n\tpara \"TM24 contains\"\n\tline \"THUNDERBOLT!\"\n\n\tpara \"Teach it to an\"\n\tline \"electric #MON!\"\n\tdone\n\n_TM24NoRoomText::\n\ttext \"Yo kid, make room\"\n\tline \"in your pack!\"\n\tdone\n\n_ReceivedThunderbadgeText::\n\ttext \"Whoa!\"\n\n\tpara \"You're the real\"\n\tline \"deal, kid!\"\n\n\tpara \"Fine then, take\"\n\tline \"the THUNDERBADGE!\"\n\tprompt\n\n_VermilionGymBattleText1::\n\ttext \"When I was in the\"\n\tline \"Army, LT.SURGE\"\n\tcont \"was my strict CO!\"\n\tdone\n\n_VermilionGymEndBattleText1::\n\ttext \"Stop!\"\n\tline \"You're very good!\"\n\tprompt\n\n_VermilionGymAfterBattleText1::\n\ttext \"The door won't\"\n\tline \"open?\"\n\n\tpara \"LT.SURGE always\"\n\tline \"was cautious!\"\n\tdone\n\n_VermilionGymBattleText2::\n\ttext \"I'm a lightweight,\"\n\tline \"but I'm good with\"\n\tcont \"electricity!\"\n\tdone\n\n_VermilionGymEndBattleText2::\n\ttext \"Fried!\"\n\tprompt\n\n_VermilionGymAfterBattleText2::\n\ttext \"OK, I'll talk!\"\n\n\tpara \"LT.SURGE said he\"\n\tline \"hid door switches\"\n\tcont \"inside something!\"\n\tdone\n\n_VermilionGymBattleText3::\n\ttext \"This is no place\"\n\tline \"for kids!\"\n\tdone\n\n_VermilionGymEndBattleText3::\n\ttext \"Wow!\"\n\tline \"Surprised me!\"\n\tprompt\n\n_VermilionGymAfterBattleText3::\n\ttext \"LT.SURGE set up\"\n\tline \"double locks!\"\n\tcont \"Here's a hint!\"\n\n\tpara \"When you open the\"\n\tline \"1st lock, the 2nd\"\n\tcont \"lock is right\"\n\tcont \"next to it!\"\n\tdone\n\n_VermilionGymText_5cbf4::\n\ttext \"Yo! Champ in\"\n\tline \"making!\"\n\n\tpara \"LT.SURGE has a\"\n\tline \"nickname. People\"\n\tcont \"refer to him as\"\n\tcont \"the Lightning\"\n\tcont \"American!\"\n\n\tpara \"He's an expert on\"\n\tline \"electric #MON!\"\n\n\tpara \"Birds and water\"\n\tline \"#MON are at\"\n\tcont \"risk! Beware of\"\n\tcont \"paralysis too!\"\n\n\tpara \"LT.SURGE is very\"\n\tline \"cautious!\"\n\n\tpara \"You'll have to\"\n\tline \"break a code to\"\n\tcont \"get to him!\"\n\tdone\n\n_VermilionGymText_5cbf9::\n\ttext \"Whew! That match\"\n\tline \"was electric!\"\n\tdone\n","avg_line_length":16.1597222222,"max_line_length":31,"alphanum_fraction":0.6957455952,"licenses":["MIT"],"repository_name":"ETDV-TheVoid\/pokemon-rgb-enhanced","path":"text\/maps\/vermilion_gym_2.asm","size":2330,"lang":"Assembly"}
{"content":"\n# labels as used on issues\n\nPlease do not use any other labels\n\n## priority based\n\n- `priority_critical`: means it needs to fixed\/implemented NOW, with a maximum of the day itself\n    - If for any reason the developer feels this is unachievable, they must immediately escalate.\n    - critical basically means, no-one goes home (sleeps), untill its fixed, only use this for things which are blocking to that point.\n- `prority_major`: means it is very urgent. should be fixed\/implemented with minimal time (usually up to 3 days, but should be 1-2 days normally max). \n    - If for any reason the developer feels this is unachievable, they must immediately escalate.\n- anythin with no labels is \n    - or in swimlane to start, means we don't work on it this week\n    - or in swimlane in progress, which means its finished this week\n    - or in swimlane blocked, means to be resolved in 1-2 days\n- `priority_minor`: put at back of sprint cycle\n\n\n## state\n\n- we no longer need the states because they are now part of the swimlanes on the team or release projects\n\n## type\n\n- `type_bug`\n- `type_feature`\n- `type_question`\n- `type_story`: used to distinguish storycards; usually an overview of a usecase we want to achieve\n\n","avg_line_length":39.2903225806,"max_line_length":151,"alphanum_fraction":0.7463054187,"licenses":["Apache-2.0"],"repository_name":"freeflowuniverse\/info_freeflow_pub","path":"wiki\/collaboration\/development\/issue_labels.md","size":1218,"lang":"Markdown"}
{"content":"#ifndef DEPTHINTEGRATORMULTICLASS_H\n#define DEPTHINTEGRATORMULTICLASS_H\n\n#include <Eigen\/Dense>\n\n#include <d3d_base\/depthMap.h>\n#include <d3d_base\/grid.h>\n\nnamespace D3D_CUDA\n{\nnamespace CudaDepthIntegratorMultiClassDeviceCode\n{\n    void initTile(int xRes, int yRes, int zRes, int numClasses, float** voxelsD);\n    void releaseDeviceMemory(void* addr);\n    void allocateAndUploadTransformation(float* transformationH, float** transformationD);\n    void allocateAndUploadProjection(float* projectionH, float** projectionD);\n    void allocateAndUploadClassScoresData(float* classScoresDataH, int rows, int cols, int numClasses, float** classScoresDataD);\n    void allocateAndUploadDepthData(float* depthDataH, int rows, int cols, float** depthDataD);\n    void integrateDepthMap(float* voxelD, const float* boxToGlobalD,\n                           int xRes, int yRes, int zRes,\n                           int numClasses, int freeSpaceClass,\n                           float xBegin, float yBegin, float zBegin,\n                           float deltaX, float deltaY, float deltaZ,\n                           const float* classScoresDataD, const float* depthDataD, int rows, int cols,\n                           float maxDepth, float minDepth,\n                           float epsilon, float eta, float uncertFact, float rho,\n                           const float* projD, float centerX, float centerY, float centerZ, float beta, float skyWeight);\n    void downloadTile(int xRes, int yRes, int zRes, float* voxelsD, float* voxelsH);\n\n}\n}\n\nnamespace D3D\n{\nclass CudaDepthIntegratorMultiClass\n{\npublic:\n    CudaDepthIntegratorMultiClass(int xRes, int yRes, int zRes,\n                    float xSize, float ySize, float zSize,\n                    int numClasses, int freeSpaceClass,\n                    float xMin, float yMin, float zMin,\n                    float minDepth, float maxDepth,\n                    float epsilon, float eta, float uncertFact,\n                    float rho, Eigen::Matrix4f boxToGlobal, int numTiles, float beta, float skyWeight);\n\n    ~CudaDepthIntegratorMultiClass();\n\n    void setTile(int i);\n\n    void addDepthMap(D3D::DepthMap<float, double>& depthMap, D3D::Grid<float>& classScores);\n\n    D3D::Grid<float> downloadTile();\n    float getTileX();\n    float getTileY();\n    float getTileZ();\n\nprivate:\n    int _xRes, _yRes, _zRes;\n    float _xSize, _ySize, _zSize;\n    float _xMin, _yMin, _zMin;\n\n    int _numClasses;\n    int _freeSpaceClass;\n\n    float _minDepth, _maxDepth;\n    float _epsilon;\n    float _eta;\n    float _uncertFact;\n    float _rho;\n    float _beta;\n    float _skyWeight;\n\n    Eigen::Matrix4f _boxToGlobal;\n    float* _boxToGlobalD;\n\n    int _numTiles; \/\/ tiling of the volume in case it does not fit in gpu memory at once\n\n    float deltaX;\n    float deltaY;\n    float deltaZ;\n\n    int tileXRes;\n\n    int currentTile;\n\n    float xBeginT, yBeginT, zBeginT; \/\/ first voxel center of current tile\n    int tileX, tileY, tileZ; \/\/ tile position\n    float xResT, yResT, zResT;\n\n    float* voxelsTD; \/\/ voxels on the device\n};\n\n}\n\n#endif\n","avg_line_length":31.9895833333,"max_line_length":129,"alphanum_fraction":0.6590687073,"licenses":["MIT"],"repository_name":"kunal71091\/Depth_Normal_Fusion","path":"vision-normal-fusion\/libs\/D3D\/src\/d3d_fusion\/cudaDepthIntegratorMultiClass.h","size":3071,"lang":"C"}
{"content":"import { AnimatedTilesManager } from '..\/..\/managers\/AnimatedTilesManager';\nimport { CutsceneManager } from '..\/..\/managers\/cutscene\/CutsceneManager';\nimport { Gamepad, GamepadStick } from '..\/..\/managers\/input\/inputs\/GamepadInput.ts';\nimport { MarkerController } from '..\/..\/managers\/MarkerController';\nimport { ParticleManager } from '..\/..\/managers\/ParticleManager';\nimport { GameplayEvent } from '..\/..\/sprites\/GameplayEvent';\nimport { Ladder } from '..\/..\/sprites\/Ladder';\nimport { Player } from '..\/..\/sprites\/Player';\nimport { TileSprite } from '..\/..\/sprites\/TileSprite';\nimport { CONST } from '..\/..\/util\/CONST';\nimport { TiledUtils } from '..\/..\/util\/TiledUtils';\nimport { SceneBase } from '.\/SceneBase';\n\nexport abstract class GameplaySceneBase extends SceneBase {\n  public map!: Phaser.Tilemaps.Tilemap;\n  public mapLayers: any = {};\n  public player!: Player;\n  protected tilesheet!: Phaser.Tilemaps.Tileset;\n  protected markerController!: MarkerController;\n  protected particleManager!: ParticleManager;\n  protected ladders: Ladder[] = [];\n  private animatedTilesManager!: AnimatedTilesManager;\n  private sceneData: {} = {};\n\n  constructor(config: Phaser.Types.Scenes.SettingsConfig) {\n    super(config);\n  }\n\n  public init(data: {}) {\n    this.sceneData = data;\n  }\n\n  public preload() {\n    this.animatedTilesManager = new AnimatedTilesManager(this);\n    this.markerController = new MarkerController(this);\n    this.particleManager = new ParticleManager(this);\n\n    if (CONST.DEBUG) {\n      this.setupDebug();\n    }\n  }\n\n  public create() {\n    super.create();\n\n    this.events.once('shutdown', () => {\n      this.ladders = [];\n      this.mapLayers = {};\n      this.sceneData = {};\n    });\n\n    \/\/ Make the player object.\n    this.player = new Player(this);\n    if (this.sceneData.playerX) {\n      const startX = (this.sceneData.playerDir === 'left') ? -64 : 64;\n      this.player.setPlayerPosition(this.sceneData.playerX, this.sceneData.playerY);\n      this.player.setPlayerDirection(this.sceneData.playerDir);\n      const cutscene = new CutsceneManager(this);\n      cutscene.addAction('playerRunTo', { player: this.player, xTarget: this.sceneData.playerX + startX });\n      cutscene.play();\n    }\n\n    \/\/ Falling stars.\n    this.particleManager.createParticleEmitter('falling_stars', [ 'falling_stars' ], 31);\n    this.particleManager.start('falling_stars');\n  }\n\n  public update() {\n\n  }\n\n  public setupTiles(map: string = 'map') {\n    this.map = this.make.tilemap({key: map});\n    this.tilesheet = this.map.addTilesetImage('Tiles', 'tilesheet', 16, 16, 0, 0);\n    for (let i = 0; i < this.map.layers.length; i++) {\n      const layer = this.map.layers[i];\n      this.mapLayers[layer.name] = this.map.createDynamicLayer(layer.name, this.tilesheet, CONST.ZERO, CONST.ZERO);\n      this.mapLayers[layer.name].setDepth(TiledUtils.getProperty(layer, 'depth')).setScale(CONST.SCALE);\n\n      if (TiledUtils.getProperty(layer, 'collide')) {\n        this.mapLayers[layer.name].setCollisionByExclusion([ -1, 0 ]);\n        this.matter.world.convertTilemapLayer(this.mapLayers[layer.name]);\n      }\n    }\n\n    \/\/ Set world bounds and start animated tiles.\n    this.matter.world.setBounds(CONST.ZERO, CONST.ZERO, this.map.widthInPixels * CONST.SCALE, this.map.heightInPixels * CONST.SCALE);\n    this.animatedTilesManager.init(this.map);\n\n    \/\/ Background.\n    this.add.rectangle(this.map.widthInPixels * 2, this.map.heightInPixels * 2, this.map.widthInPixels * CONST.SCALE, this.map.heightInPixels * CONST.SCALE, 0x292929, 1);\n  }\n\n  public setupImages() {\n    for (let i = 0; i < this.map.images.length; i++) {\n      const layer = this.map.images[i];\n\n      const tileSprite = new TileSprite(this, layer.x, layer.y, this.map.widthInPixels * CONST.SCALE, this.map.widthInPixels * CONST.SCALE, layer.name, undefined);\n      tileSprite.setDepth(TiledUtils.getProperty(layer, 'depth'))\n        .setScale(CONST.SCALE)\n        .setScrollFactor(TiledUtils.getProperty(layer, 'parallaxX'), TiledUtils.getProperty(layer, 'parallaxY'));\n\n      if (!TiledUtils.getProperty(layer, 'repeatY')) {\n        tileSprite.dontRepeatY();\n      }\n\n      if (!TiledUtils.getProperty(layer, 'repeatX')) {\n        tileSprite.dontRepeatX();\n      }\n\n      this.mapLayers[layer.name] = tileSprite;\n    }\n  }\n\n  public setupMarkers() {\n    const markers = this.map.getObjectLayer('markers').objects;\n    markers.forEach((marker: Phaser.Types.Tilemaps.TiledObject) => {\n      const message = TiledUtils.getProperty(marker, 'message');\n      const event = TiledUtils.getProperty(marker, 'event');\n      const disabled = TiledUtils.getProperty(marker, 'disabled');\n      const m = this.markerController.addMarkerWithTextPlate((marker.x * CONST.SCALE) + 32, (marker.y * CONST.SCALE) - 64, message, event);\n      m.setMarkerId(marker.id);\n      m.setEnabled(!disabled);\n    });\n  }\n\n  public setupTiledObjectLayer(layer: string, fn: (object: Phaser.Types.Tilemaps.TiledObject) => void) {\n    const objects = this.map.getObjectLayer('pump').objects;\n    objects.forEach(fn);\n  }\n\n  public setupEvents() {\n    this.time.delayedCall(600, () => {\n      const events = this.map.getObjectLayer('events').objects;\n      events.forEach((event: Phaser.Types.Tilemaps.TiledObject) => {\n        const w = event.width * CONST.SCALE;\n        const h = event.height * CONST.SCALE;\n        const x = (event.x * CONST.SCALE) + (w * CONST.HALF);\n        const y = (event.y * CONST.SCALE) - (h * CONST.HALF);\n        new GameplayEvent(this, x, y, w, h, TiledUtils.getProperty(event, 'event'));\n      });\n    });\n  }\n\n  public setupLadders() {\n    const ladders = this.map.getObjectLayer('ladders').objects;\n    ladders.forEach((ladder: Phaser.Types.Tilemaps.TiledObject) => {\n      const w = ladder.width * CONST.SCALE;\n      const h = ladder.height * CONST.SCALE;\n      const x = (ladder.x * CONST.SCALE) + (w * CONST.HALF);\n      const y = (ladder.y * CONST.SCALE) - (h * CONST.HALF);\n      const sprite = new Ladder(this, x, y, 'player', 'ladder');\n      sprite.setDepth(51);\n      sprite.setScale(CONST.SCALE);\n      this.ladders.push(sprite);\n    });\n  }\n\n  protected changeScene(scene: string, duration: number = 600, data: {} = {}) {\n    super.changeScene(scene, duration, data);\n  }\n}\n","avg_line_length":38.3312883436,"max_line_length":170,"alphanum_fraction":0.6659731114,"licenses":["MIT"],"repository_name":"BadMojoVeryBad\/its-time-to-go-home","path":"src\/scenes\/base\/GameplaySceneBase.ts","size":6248,"lang":"TypeScript"}
{"content":"\/*\n * atom-model.js\n *\/\n\nlet nextInstanceId = 1;\n\nclass Model {\n  static initClass() {\n    this.prototype.alive = true;\n  }\n  static resetNextInstanceId() { return nextInstanceId = 1; }\n\n  constructor(params) {\n    this.assignId(params != null ? params.id : undefined);\n  }\n\n  assignId(id) {\n    if (this.id == null) { this.id = id != null ? id : nextInstanceId++; }\n    if (id >= nextInstanceId) { return nextInstanceId = id + 1; }\n  }\n\n  destroy() {\n    if (!this.isAlive()) { return; }\n    this.alive = false;\n    return (typeof this.destroyed === 'function' ? this.destroyed() : undefined);\n  }\n\n  isAlive() { return this.alive; }\n\n  isDestroyed() { return !this.isAlive(); }\n}\n\nModel.initClass()\n\nmodule.exports = Model\n","avg_line_length":20.1388888889,"max_line_length":81,"alphanum_fraction":0.6151724138,"licenses":["MIT"],"repository_name":"romgrk\/xedel","path":"src\/editor\/model.js","size":725,"lang":"JavaScript"}
{"content":"\ufeffusing KSP.UI.Screens.Flight;\nusing LunaClient.Utilities;\nusing LunaClient.VesselIgnore;\nusing LunaClient.VesselUtilities;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Reflection;\n\nnamespace LunaClient.Systems.VesselProtoSys\n{\n    \/\/\/ <summary>\n    \/\/\/ Class that updates a vessel and it's protovessel based on a protovessel definition received from the server\n    \/\/\/ <\/summary>\n    public static class ProtoToVesselRefresh\n    {\n        private static FieldInfo StateField { get; } = typeof(Part).GetField(\"state\", BindingFlags.Instance | BindingFlags.NonPublic);\n        private static FieldInfo FsmField { get; } = typeof(ModuleProceduralFairing).GetField(\"fsm\", BindingFlags.Instance | BindingFlags.NonPublic);\n        private static FieldInfo PartModuleFields { get; } = typeof(PartModule).GetField(\"fields\", BindingFlags.Instance | BindingFlags.NonPublic);\n\n        private static readonly List<ProtoCrewMember> MembersToAdd = new List<ProtoCrewMember>();\n        private static readonly List<string> MembersToRemove = new List<string>();\n\n        \/\/\/ <summary>\n        \/\/\/ This method will take a vessel and update all it's parts and proto based on a protovessel we received\n        \/\/\/ Protovessel --------------> Vessel & ProtoVessel\n        \/\/\/ This way we avoid having to unload and reload a vessel with it's terrible performance\n        \/\/\/ <\/summary>\n        public static void UpdateVesselPartsFromProtoVessel(Vessel vessel, ProtoVessel protoVessel, IEnumerable<uint> vesselPartsId = null)\n        {\n            if (vessel == null || protoVessel == null || vessel.state == Vessel.State.DEAD) return;\n\n            if (vessel.id != protoVessel.vesselID)\n            {\n                LunaLog.LogError($\"Tried to update a vessel id {vessel.id} with a protovessel of vessel id {protoVessel.vesselID}\");\n                return;\n            }\n\n            var vesselProtoPartIds = vesselPartsId ?? protoVessel.protoPartSnapshots.Select(p => p.flightID);\n\n            \/\/If vessel is UNLOADED it won't have parts so we must take them from the proto...\n            var vesselPartsIds = vessel.loaded ? vessel.parts.Select(p => p.flightID) : vessel.protoVessel.protoPartSnapshots.Select(p=> p.flightID);\n\n            var hasMissingparts = vesselProtoPartIds.Except(vesselPartsIds).Any();\n            if (hasMissingparts || !VesselCommon.IsSpectating && (!vessel.Landed && protoVessel.landed || !vessel.Splashed && protoVessel.splashed))\n            {\n                \/\/Reload the whole vessel if vessel lands\/splashes as otherwise map view puts the vessel next to the other player.\n                \/\/Better to reload if has missing parts as creating them dinamically is a PIA\n                VesselLoader.ReloadVessel(protoVessel);\n                return;\n            }\n\n            var hasCrewChanges = false;\n\n            \/\/Never do vessel.protoVessel = protoVessel; not even if the vessel is not loaded as when it gets loaded the parts are created in the active vessel \n            \/\/and not on the target vessel\n\n            \/\/Run trough all the vessel parts and protoparts. \n            \/\/Vessel.parts will be empty if vessel is unloaded.\n            var protoPartsToRemove = new List<ProtoPartSnapshot>();\n            for (var i = 0; i < vessel.protoVessel.protoPartSnapshots.Count; i++)\n            {\n                var protoPartToUpdate = vessel.protoVessel.protoPartSnapshots[i];\n                var partSnapshot = VesselCommon.FindProtoPartInProtovessel(protoVessel, protoPartToUpdate.flightID);\n                if (partSnapshot == null) \/\/Part does not exist in the protovessel definition so kill it\n                {\n                    protoPartsToRemove.Add(protoPartToUpdate);\n                    continue;\n                }\n\n                AdjustCrewMembersInProtoPart(protoPartToUpdate, partSnapshot);\n                protoPartToUpdate.state = partSnapshot.state;\n                UpdatePartModulesInProtoPart(protoPartToUpdate, partSnapshot);\n                UpdateProtoVesselResources(protoPartToUpdate, partSnapshot);\n                \n                var part = protoPartToUpdate.partRef;\n                if (part != null) \/\/Part can be null if the vessel is unloaded!!\n                {\n                    \/\/Remove or add crew members in given part and detect if there have been any change\n                    hasCrewChanges |= AdjustCrewMembersInPart(part, partSnapshot);\n\n                    \/\/Set part \"state\" field... Important for fairings for example...\n                    StateField?.SetValue(part, partSnapshot.state);\n                    part.ResumeState = part.State;\n\n                    UpdatePartModules(partSnapshot, part);\n                    UpdateVesselResources(partSnapshot, part);\n                    UpdatePartFairings(partSnapshot, part);\n                }\n            }\n\n            \/\/Now kill both parts and protoparts that don't exist\n            for (var i = 0; i < protoPartsToRemove.Count; i++)\n            {\n                \/\/Part can be null if the vessel is unloaded.  In this case, no need to kill it as it's already gone from the game.\n                if (protoPartsToRemove[i].partRef != null)\n                {\n                    if (protoPartsToRemove[i].partRef.FindModuleImplementing<ModuleDecouple>() != null)\n                        protoPartsToRemove[i].partRef.decouple();\n                    else\n                        protoPartsToRemove[i].partRef.Die();\n                }\n\n                vessel.protoVessel.protoPartSnapshots.Remove(protoPartsToRemove[i]);\n            }\n\n            if (hasCrewChanges)\n            {\n                \/\/We must always refresh the crew in every part of the vessel, even if we don't spectate\n                vessel.RebuildCrewList();\n\n                \/\/IF we are spectating we must fix the portraits of the kerbals\n                if (FlightGlobals.ActiveVessel?.id == vessel.id)\n                {\n                    \/\/If you don't call spawn crew and you do a crew transfer the transfered crew won't appear in the portraits...\n                    Client.Singleton.StartCoroutine(CallbackUtil.DelayedCallback(0.25f, () => { FlightGlobals.ActiveVessel?.SpawnCrew(); }));\n                    \/\/If you don't call this the kerbal portraits appear in black...\n                    Client.Singleton.StartCoroutine(CallbackUtil.DelayedCallback(0.5f, () => { KerbalPortraitGallery.Instance?.SetActivePortraitsForVessel(FlightGlobals.ActiveVessel); }));\n                }\n            }\n        }\n\n        public static void CreateMissingPartsInCurrentProtoVessel(Vessel vessel, ProtoVessel protoVessel)\n        {\n            \/\/TODO: This is old code where we created parts dinamically but it's quite buggy. It create parts in the CURRENT vessel so it wont work for other vessels\n\n            \/\/We've run trough all the vessel parts and removed the ones that don't exist in the definition.\n            \/\/Now run trough the parts in the definition and add the parts that don't exist in the vessel.\n            var partsToInit = new List<ProtoPartSnapshot>();\n            foreach (var partSnapshot in protoVessel.protoPartSnapshots)\n            {\n                if (partSnapshot.FindModule(\"ModuleDockingNode\") != null)\n                {\n                    \/\/We are in a docking port part so remove it from our own vessel if we have it\n                    var vesselPart = VesselCommon.FindPartInVessel(vessel, partSnapshot.flightID);\n                    if (vesselPart != null)\n                    {\n                        vesselPart.Die();\n                    }\n                }\n\n                \/\/Skip parts that already exists\n                if (VesselCommon.FindPartInVessel(vessel, partSnapshot.flightID) != null)\n                    continue;\n\n                var newPart = partSnapshot.Load(vessel, false);\n                vessel.parts.Add(newPart);\n                partsToInit.Add(partSnapshot);\n            }\n\n            \/\/Init new parts. This must be done in another loop as otherwise new parts won't have their correct attachment parts.\n            foreach (var partSnapshot in partsToInit)\n                partSnapshot.Init(vessel);\n\n            vessel.RebuildCrewList();\n            Client.Singleton.StartCoroutine(CallbackUtil.DelayedCallback(0.25f, () => { FlightGlobals.ActiveVessel?.SpawnCrew(); }));\n            Client.Singleton.StartCoroutine(CallbackUtil.DelayedCallback(0.5f, () => { KerbalPortraitGallery.Instance?.SetActivePortraitsForVessel(FlightGlobals.ActiveVessel); }));\n        }\n\n        private static void UpdatePartModules(ProtoPartSnapshot partSnapshot, Part part)\n        {\n            \/\/Run trough all the part DEFINITION modules\n            foreach (var moduleSnapshot in partSnapshot.modules.Where(m => !VesselModulesToIgnore.ModulesToIgnore.Contains(m.moduleName)))\n            {\n                \/\/Get the corresponding module from the actual PART\n                var module = part.Modules.Cast<PartModule>().FirstOrDefault(pm => pm.moduleName == moduleSnapshot.moduleName);\n                if (module == null) continue;\n\n                var definitionPartModuleFieldVals = moduleSnapshot.moduleValues.values.Cast<ConfigNode.Value>()\n                    .Select(v => new { v.name, v.value }).ToArray();\n                var partModuleFieldVals = module.Fields.Cast<BaseField>()\n                    .Where(f => definitionPartModuleFieldVals.Any(mf => mf.name == f.name)).ToArray();\n\n                \/\/Run trough the current part Modules\n                foreach (var existingField in partModuleFieldVals)\n                {\n                    if (VesselModulesToIgnore.FieldsToIgnore.TryGetValue(module.moduleName, out var fieldsToIgnoreList) &&\n                        fieldsToIgnoreList.Contains(existingField.name))\n                        continue;\n\n                    \/\/Sometimes we get a proto part module value of 17.0001 and the part value is 17.0 so it's useless to reload\n                    \/\/a whole part module for such a small change! FormatModuleValue() strips the decimals if the value is a decimal\n                    var value = existingField.GetValue(existingField.host).ToString().FormatModuleValue();\n                    var newVal = definitionPartModuleFieldVals.First(mf => mf.name == existingField.name).value\n                        .FormatModuleValue();\n\n                    \/\/Field value between part module and part DEFINITION module are different!\n                    if (value != newVal)\n                    {\n                        PartModuleFields?.SetValue(module, new BaseFieldList(module));\n                        module.Fields.Load(moduleSnapshot.moduleValues);\n\n                        if (!VesselModulesToIgnore.ModulesToDontAwake.Contains(module.moduleName))\n                            module.OnAwake();\n                        if (!VesselModulesToIgnore.ModulesToDontLoad.Contains(module.moduleName))\n                            module.OnLoad(moduleSnapshot.moduleValues);\n                        if (!VesselModulesToIgnore.ModulesToDontStart.Contains(module.moduleName))\n                            module.OnStart(PartModule.StartState.Flying);\n                    }\n                }\n            }\n        }\n        \n        private static void UpdatePartFairings(ProtoPartSnapshot partSnapshot, Part part)\n        {\n            var fairingModule = part.FindModuleImplementing<ModuleProceduralFairing>();\n            if (fairingModule != null)\n            {\n                if (FsmField?.GetValue(fairingModule) is KerbalFSM fsmVal)\n                {\n                    var currentState = fsmVal.CurrentState;\n                    var protoFsmVal = partSnapshot.FindModule(\"ModuleProceduralFairing\")?.moduleValues?.GetValue(\"fsm\");\n\n                    if (protoFsmVal != null && currentState.ToString() != protoFsmVal)\n                    {\n                        fairingModule.DeployFairing();\n                    }\n                }\n            }\n        }\n\n        private static void UpdateVesselResources(ProtoPartSnapshot partSnapshot, Part part)\n        {\n            \/\/Run trough the poart DEFINITION resources\n            foreach (var resourceSnapshot in partSnapshot.resources)\n            {\n                \/\/Get the corresponding resource from the actual PART\n                var resource = part.Resources?.FirstOrDefault(pr => pr.resourceName == resourceSnapshot.resourceName);\n                if (resource == null) continue;\n\n                resource.amount = resourceSnapshot.amount;\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Add or remove crew from a part based on the part snapshot\n        \/\/\/ <\/summary>\n        private static bool AdjustCrewMembersInPart(Part part, ProtoPartSnapshot partSnapshot)\n        {\n            if (part.protoModuleCrew.Count != partSnapshot.protoModuleCrew.Count)\n            {\n                MembersToAdd.Clear();\n                MembersToRemove.Clear();\n                MembersToAdd.AddRange(partSnapshot.protoModuleCrew.Where(mp => part.protoModuleCrew.All(m => m.name != mp.name)));\n                MembersToRemove.AddRange(part.protoModuleCrew.Select(c => c.name).Except(partSnapshot.protoModuleCrew.Select(c => c.name)));\n\n                foreach (var memberToAdd in MembersToAdd)\n                {\n                    part.AddCrewmember(memberToAdd);\n                }\n\n                foreach (var memberToRemove in MembersToRemove)\n                {\n                    var member = part.protoModuleCrew.First(c => c.name == memberToRemove);\n                    part.RemoveCrewmember(member);\n                }\n\n                return true;\n            }\n\n            return false;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Add or remove crew from a protopart based on the part snapshot\n        \/\/\/ <\/summary>\n        private static void AdjustCrewMembersInProtoPart(ProtoPartSnapshot protoPartToUpdate, ProtoPartSnapshot partSnapshot)\n        {\n            if (protoPartToUpdate.protoModuleCrew.Count != partSnapshot.protoModuleCrew.Count)\n            {\n                MembersToAdd.Clear();\n                MembersToRemove.Clear();\n                MembersToAdd.AddRange(partSnapshot.protoModuleCrew.Where(mp => protoPartToUpdate.protoModuleCrew.All(m => m.name != mp.name)));\n                MembersToRemove.AddRange(protoPartToUpdate.protoModuleCrew.Select(c => c.name).Except(partSnapshot.protoModuleCrew.Select(c => c.name)));\n\n                foreach (var memberToAdd in MembersToAdd)\n                {\n                    protoPartToUpdate.protoModuleCrew.Add(memberToAdd);\n                }\n\n                foreach (var memberToRemove in MembersToRemove)\n                {\n                    var member = protoPartToUpdate.protoModuleCrew.First(c => c.name == memberToRemove);\n                    protoPartToUpdate.protoModuleCrew.Remove(member);\n                }\n            }\n        }\n        \n        private static void UpdatePartModulesInProtoPart(ProtoPartSnapshot protoPartToUpdate, ProtoPartSnapshot partSnapshot)\n        {\n            \/\/Run trough all the part DEFINITION modules\n            foreach (var moduleSnapshotDefinition in partSnapshot.modules.Where(m => !VesselModulesToIgnore.ModulesToIgnore.Contains(m.moduleName)))\n            {\n                \/\/Get the corresponding module from the actual vessel PROTOPART\n                var currentModule = protoPartToUpdate.FindModule(moduleSnapshotDefinition.moduleName);\n                if (currentModule != null)\n                {\n                    moduleSnapshotDefinition.moduleValues.CopyTo(currentModule.moduleValues);\n                }\n            }\n        }\n\n        private static void UpdateProtoVesselResources(ProtoPartSnapshot protoPartToUpdate, ProtoPartSnapshot partSnapshot)\n        {\n            \/\/Run trough the poart DEFINITION resources\n            foreach (var resourceSnapshot in partSnapshot.resources)\n            {\n                \/\/Get the corresponding resource from the actual PART\n                var resource = protoPartToUpdate.resources?.FirstOrDefault(pr => pr.resourceName == resourceSnapshot.resourceName);\n                if (resource == null) continue;\n\n                resource.amount = resourceSnapshot.amount;\n            }\n        }\n    }\n}\n","avg_line_length":51.4050632911,"max_line_length":188,"alphanum_fraction":0.6043462201,"licenses":["MIT"],"repository_name":"Badca52\/LunaMultiplayer","path":"Client\/Systems\/VesselProtoSys\/ProtoToVesselRefresh.cs","size":16246,"lang":"C#"}
{"content":"# This Makefile requires GNU Make.\n\nCXX = g++\nCXXFLAGS := $(shell gdal-config --cflags) -I. -Itut $(CPPFLAGS)\nCXXFLAGS += -Wall\nCXXFLAGS += -Wextra\n# CXXFLAGS += -Werror\n\nifdef HARDEN\nCXXFLAGS += -O2 -g\nCXXFLAGS += -D_FORTIFY_SOURCE=2\nCXXFLAGS += -fstack-protector-all\nCXXFLAGS += -Wformat -Werror=format-security\nCXXFLAGS += -ftrapv -fwrapv\n# Clashes with current build strategy.\n# CXXFLAGS += -fPIE -pie\nendif\n\nLDFLAGS = $(shell gdal-config --libs)\n\nPROGS = gdal_unit_test testperfcopywords testcopywords testclosedondestroydm testthreadcond test_virtualmem testblockcache testblockcachewrite testblockcachelimits testdestroy\n\nall: $(PROGS)\n\ntest:\n\tmake quick_test\n\t.\/testperfcopywords\n\nquick_test:\n\t.\/gdal_unit_test\n\t.\/testcopywords\n\t.\/testclosedondestroydm\n\t.\/testthreadcond\n\t.\/test_virtualmem\n\t.\/testblockcache -check -co TILED=YES --debug TEST,LOCK -loops 3 --config GDAL_RB_LOCK_DEBUG_CONTENTION YES\n\t.\/testblockcache -check -co TILED=YES --debug TEST,LOCK -loops 3 --config GDAL_RB_LOCK_DEBUG_CONTENTION YES --config GDAL_RB_LOCK_TYPE SPIN\n\t.\/testblockcache -check -co TILED=YES -migrate\n\t.\/testblockcache -check -memdriver\n\t.\/testblockcachewrite --debug ON\n\t.\/testblockcache --config GDAL_BAND_BLOCK_CACHE HASHSET -check -co TILED=YES --debug TEST,LOCK -loops 3 --config GDAL_RB_LOCK_DEBUG_CONTENTION YES\n\t.\/testblockcache --config GDAL_BAND_BLOCK_CACHE HASHSET -check -co TILED=YES --debug TEST,LOCK -loops 3 --config GDAL_RB_LOCK_DEBUG_CONTENTION YES --config GDAL_RB_LOCK_TYPE SPIN\n\t.\/testblockcachelimits --debug ON\n\t.\/testdestroy\n\nOBJ = \\\n    gdal_unit_test.o \\\n    test_alg.o \\\n    test_cpl.o \\\n    test_gdal.o \\\n    test_gdal_aaigrid.o \\\n    test_gdal_dted.o \\\n    test_gdal_gtiff.o \\\n    test_triangulation.o \\\n    test_ogr.o \\\n    test_ogr_geos.o \\\n    test_ogr_shape.o \\\n    test_osr.o \\\n    test_osr_ct.o \\\n    test_osr_pci.o \\\n    test_osr_proj4.o \\\n    tut\/tut_gdal.o\n\ngdal_unit_test: $(OBJ)\n\t$(CXX) $(CXXFLAGS) $^ $(LDFLAGS) -o $@\n\ntestperfcopywords: testperfcopywords.cpp\n\t$(CXX) -O2 $(CXXFLAGS) $< $(LDFLAGS) -o $@\n\ntestcopywords: testcopywords.cpp\n\t$(CXX) -O2 $(CXXFLAGS) $< $(LDFLAGS) -o $@\n\ntestclosedondestroydm: testclosedondestroydm.cpp\n\t$(CXX) -g $(CXXFLAGS) $< $(LDFLAGS) -o $@\n\ntestthreadcond: testthreadcond.cpp\n\t$(CXX) -g $(CXXFLAGS) $< $(LDFLAGS) -o $@\n\ntest_virtualmem: test_virtualmem.cpp\n\t$(CXX) -g $(CXXFLAGS) $< $(LDFLAGS) -o $@\n\ntestblockcache: testblockcache.cpp\n\t$(CXX) -g -O2 $(CXXFLAGS) $< $(LDFLAGS) -o $@\n\ntestblockcachewrite: testblockcachewrite.cpp\n\t$(CXX) -g -O2 $(CXXFLAGS) $< $(LDFLAGS) -o $@\n\ntestblockcachelimits: testblockcachelimits.cpp\n\t$(CXX) -g -O2 $(CXXFLAGS) $< $(LDFLAGS) -o $@\n\ntestdestroy: testdestroy.cpp\n\t$(CXX) -g -O2 $(CXXFLAGS) $< $(LDFLAGS) -o $@\n\nvsipreload.so: ..\/..\/gdal\/port\/vsipreload.cpp\n\t$(CXX) -fPIC -g $(CXXFLAGS) $< $(LDFLAGS) -shared -o $@\n\nclean:\n\t$(RM) $(PROGS)\n\t$(RM) $(OBJ)\n\t$(RM) *.a\n\t$(RM) *.out\n\t$(RM) *~\n\n","avg_line_length":28.1165048544,"max_line_length":179,"alphanum_fraction":0.7075276243,"licenses":["MIT"],"repository_name":"Symena\/gdal","path":"autotest\/cpp\/Makefile","size":2896,"lang":"Makefile"}
{"content":"\ufeff'''<summary>The SVGFEMorphologyElement interface corresponds to the &lt;feMorphology> element.<\/summary>\r\n<DynamicInterface(GetType(EcmaScriptObject))>\r\nPublic Interface [SVGFEMorphologyElement]\r\nInherits SVGElement, SVGFilterPrimitiveStandardAttributes\r\n\r\n  '''<summary>An SVGAnimatedEnumeration corresponding to the operator attribute of the given element. It takes one of the SVG_MORPHOLOGY_OPERATOR_* constants defined on this interface.<\/summary>\r\n  ReadOnly Property [operator] As Dynamic\r\nEnd Interface","avg_line_length":63.75,"max_line_length":195,"alphanum_fraction":0.8235294118,"licenses":["BSD-2-Clause"],"repository_name":"atkins126\/IslandRTL","path":"Source\/DOM\/SVGFEMorphologyElement.vb","size":512,"lang":"Visual Basic"}
{"content":"###############################################################################\n# Copyright 2019 Intel Corporation\n# All Rights Reserved.\n#\n# If this  software was obtained  under the  Intel Simplified  Software License,\n# the following terms apply:\n#\n# The source code,  information  and material  (\"Material\") contained  herein is\n# owned by Intel Corporation or its  suppliers or licensors,  and  title to such\n# Material remains with Intel  Corporation or its  suppliers or  licensors.  The\n# Material  contains  proprietary  information  of  Intel or  its suppliers  and\n# licensors.  The Material is protected by  worldwide copyright  laws and treaty\n# provisions.  No part  of  the  Material   may  be  used,  copied,  reproduced,\n# modified, published,  uploaded, posted, transmitted,  distributed or disclosed\n# in any way without Intel's prior express written permission.  No license under\n# any patent,  copyright or other  intellectual property rights  in the Material\n# is granted to  or  conferred  upon  you,  either   expressly,  by implication,\n# inducement,  estoppel  or  otherwise.  Any  license   under such  intellectual\n# property rights must be express and approved by Intel in writing.\n#\n# Unless otherwise agreed by Intel in writing,  you may not remove or alter this\n# notice or  any  other  notice   embedded  in  Materials  by  Intel  or Intel's\n# suppliers or licensors in any way.\n#\n#\n# If this  software  was obtained  under the  Apache License,  Version  2.0 (the\n# \"License\"), the following terms apply:\n#\n# You may  not use this  file except  in compliance  with  the License.  You may\n# obtain a copy of the License at http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n#\n#\n# Unless  required  by   applicable  law  or  agreed  to  in  writing,  software\n# distributed under the License  is distributed  on an  \"AS IS\"  BASIS,  WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#\n# See the   License  for the   specific  language   governing   permissions  and\n# limitations under the License.\n###############################################################################\n\n \n .section .note.GNU-stack,\"\",%progbits \n \n.text\n.p2align 6, 0x90\n \nLpoly:\n.quad   0xFFFFFFFFFFFFFFFF, 0xFFFFFFFF00000000, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFEFFFFFFFF \n \nLRR:\n.quad          0x200000003,        0x2ffffffff,        0x100000001,        0x400000002 \n \nLOne:\n.long  1,1,1,1,1,1,1,1 \n \nLTwo:\n.long  2,2,2,2,2,2,2,2 \n \nLThree:\n.long  3,3,3,3,3,3,3,3 \n.p2align 6, 0x90\n \n.globl sm2_mul_by_2\n.type sm2_mul_by_2, @function\n \nsm2_mul_by_2:\n \n    push         %r12\n \n    push         %r13\n \n    xor          %r13, %r13\n    movq         (%rsi), %r8\n    movq         (8)(%rsi), %r9\n    movq         (16)(%rsi), %r10\n    movq         (24)(%rsi), %r11\n    shld         $(1), %r11, %r13\n    shld         $(1), %r10, %r11\n    shld         $(1), %r9, %r10\n    shld         $(1), %r8, %r9\n    shl          $(1), %r8\n    mov          %r8, %rax\n    mov          %r9, %rdx\n    mov          %r10, %rcx\n    mov          %r11, %r12\n    subq         Lpoly+0(%rip), %rax\n    sbbq         Lpoly+8(%rip), %rdx\n    sbbq         Lpoly+16(%rip), %rcx\n    sbbq         Lpoly+24(%rip), %r12\n    sbb          $(0), %r13\n    cmove        %rax, %r8\n    cmove        %rdx, %r9\n    cmove        %rcx, %r10\n    cmove        %r12, %r11\n    movq         %r8, (%rdi)\n    movq         %r9, (8)(%rdi)\n    movq         %r10, (16)(%rdi)\n    movq         %r11, (24)(%rdi)\n \n    pop          %r13\n \n    pop          %r12\n \n    ret\n.Lfe1:\n.size sm2_mul_by_2, .Lfe1-(sm2_mul_by_2)\n.p2align 6, 0x90\n \n.globl sm2_div_by_2\n.type sm2_div_by_2, @function\n \nsm2_div_by_2:\n \n    push         %r12\n \n    push         %r13\n \n    push         %r14\n \n    movq         (%rsi), %r8\n    movq         (8)(%rsi), %r9\n    movq         (16)(%rsi), %r10\n    movq         (24)(%rsi), %r11\n    xor          %r13, %r13\n    xor          %r14, %r14\n    mov          %r8, %rax\n    mov          %r9, %rdx\n    mov          %r10, %rcx\n    mov          %r11, %r12\n    addq         Lpoly+0(%rip), %rax\n    adcq         Lpoly+8(%rip), %rdx\n    adcq         Lpoly+16(%rip), %rcx\n    adcq         Lpoly+24(%rip), %r12\n    adc          $(0), %r13\n    test         $(1), %r8\n    cmovne       %rax, %r8\n    cmovne       %rdx, %r9\n    cmovne       %rcx, %r10\n    cmovne       %r12, %r11\n    cmovne       %r13, %r14\n    shrd         $(1), %r9, %r8\n    shrd         $(1), %r10, %r9\n    shrd         $(1), %r11, %r10\n    shrd         $(1), %r14, %r11\n    movq         %r8, (%rdi)\n    movq         %r9, (8)(%rdi)\n    movq         %r10, (16)(%rdi)\n    movq         %r11, (24)(%rdi)\n \n    pop          %r14\n \n    pop          %r13\n \n    pop          %r12\n \n    ret\n.Lfe2:\n.size sm2_div_by_2, .Lfe2-(sm2_div_by_2)\n.p2align 6, 0x90\n \n.globl sm2_mul_by_3\n.type sm2_mul_by_3, @function\n \nsm2_mul_by_3:\n \n    push         %r12\n \n    push         %r13\n \n    xor          %r13, %r13\n    movq         (%rsi), %r8\n    movq         (8)(%rsi), %r9\n    movq         (16)(%rsi), %r10\n    movq         (24)(%rsi), %r11\n    shld         $(1), %r11, %r13\n    shld         $(1), %r10, %r11\n    shld         $(1), %r9, %r10\n    shld         $(1), %r8, %r9\n    shl          $(1), %r8\n    mov          %r8, %rax\n    mov          %r9, %rdx\n    mov          %r10, %rcx\n    mov          %r11, %r12\n    subq         Lpoly+0(%rip), %rax\n    sbbq         Lpoly+8(%rip), %rdx\n    sbbq         Lpoly+16(%rip), %rcx\n    sbbq         Lpoly+24(%rip), %r12\n    sbb          $(0), %r13\n    cmove        %rax, %r8\n    cmove        %rdx, %r9\n    cmove        %rcx, %r10\n    cmove        %r12, %r11\n    xor          %r13, %r13\n    addq         (%rsi), %r8\n    adcq         (8)(%rsi), %r9\n    adcq         (16)(%rsi), %r10\n    adcq         (24)(%rsi), %r11\n    adc          $(0), %r13\n    mov          %r8, %rax\n    mov          %r9, %rdx\n    mov          %r10, %rcx\n    mov          %r11, %r12\n    subq         Lpoly+0(%rip), %rax\n    sbbq         Lpoly+8(%rip), %rdx\n    sbbq         Lpoly+16(%rip), %rcx\n    sbbq         Lpoly+24(%rip), %r12\n    sbb          $(0), %r13\n    cmove        %rax, %r8\n    cmove        %rdx, %r9\n    cmove        %rcx, %r10\n    cmove        %r12, %r11\n    movq         %r8, (%rdi)\n    movq         %r9, (8)(%rdi)\n    movq         %r10, (16)(%rdi)\n    movq         %r11, (24)(%rdi)\n \n    pop          %r13\n \n    pop          %r12\n \n    ret\n.Lfe3:\n.size sm2_mul_by_3, .Lfe3-(sm2_mul_by_3)\n.p2align 6, 0x90\n \n.globl sm2_add\n.type sm2_add, @function\n \nsm2_add:\n \n    push         %r12\n \n    push         %r13\n \n    xor          %r13, %r13\n    movq         (%rsi), %r8\n    movq         (8)(%rsi), %r9\n    movq         (16)(%rsi), %r10\n    movq         (24)(%rsi), %r11\n    addq         (%rdx), %r8\n    adcq         (8)(%rdx), %r9\n    adcq         (16)(%rdx), %r10\n    adcq         (24)(%rdx), %r11\n    adc          $(0), %r13\n    mov          %r8, %rax\n    mov          %r9, %rdx\n    mov          %r10, %rcx\n    mov          %r11, %r12\n    subq         Lpoly+0(%rip), %rax\n    sbbq         Lpoly+8(%rip), %rdx\n    sbbq         Lpoly+16(%rip), %rcx\n    sbbq         Lpoly+24(%rip), %r12\n    sbb          $(0), %r13\n    cmove        %rax, %r8\n    cmove        %rdx, %r9\n    cmove        %rcx, %r10\n    cmove        %r12, %r11\n    movq         %r8, (%rdi)\n    movq         %r9, (8)(%rdi)\n    movq         %r10, (16)(%rdi)\n    movq         %r11, (24)(%rdi)\n \n    pop          %r13\n \n    pop          %r12\n \n    ret\n.Lfe4:\n.size sm2_add, .Lfe4-(sm2_add)\n.p2align 6, 0x90\n \n.globl sm2_sub\n.type sm2_sub, @function\n \nsm2_sub:\n \n    push         %r12\n \n    push         %r13\n \n    xor          %r13, %r13\n    movq         (%rsi), %r8\n    movq         (8)(%rsi), %r9\n    movq         (16)(%rsi), %r10\n    movq         (24)(%rsi), %r11\n    subq         (%rdx), %r8\n    sbbq         (8)(%rdx), %r9\n    sbbq         (16)(%rdx), %r10\n    sbbq         (24)(%rdx), %r11\n    sbb          $(0), %r13\n    mov          %r8, %rax\n    mov          %r9, %rdx\n    mov          %r10, %rcx\n    mov          %r11, %r12\n    addq         Lpoly+0(%rip), %rax\n    adcq         Lpoly+8(%rip), %rdx\n    adcq         Lpoly+16(%rip), %rcx\n    adcq         Lpoly+24(%rip), %r12\n    test         %r13, %r13\n    cmovne       %rax, %r8\n    cmovne       %rdx, %r9\n    cmovne       %rcx, %r10\n    cmovne       %r12, %r11\n    movq         %r8, (%rdi)\n    movq         %r9, (8)(%rdi)\n    movq         %r10, (16)(%rdi)\n    movq         %r11, (24)(%rdi)\n \n    pop          %r13\n \n    pop          %r12\n \n    ret\n.Lfe5:\n.size sm2_sub, .Lfe5-(sm2_sub)\n.p2align 6, 0x90\n \n.globl sm2_neg\n.type sm2_neg, @function\n \nsm2_neg:\n \n    push         %r12\n \n    push         %r13\n \n    xor          %r13, %r13\n    xor          %r8, %r8\n    xor          %r9, %r9\n    xor          %r10, %r10\n    xor          %r11, %r11\n    subq         (%rsi), %r8\n    sbbq         (8)(%rsi), %r9\n    sbbq         (16)(%rsi), %r10\n    sbbq         (24)(%rsi), %r11\n    sbb          $(0), %r13\n    mov          %r8, %rax\n    mov          %r9, %rdx\n    mov          %r10, %rcx\n    mov          %r11, %r12\n    addq         Lpoly+0(%rip), %rax\n    adcq         Lpoly+8(%rip), %rdx\n    adcq         Lpoly+16(%rip), %rcx\n    adcq         Lpoly+24(%rip), %r12\n    test         %r13, %r13\n    cmovne       %rax, %r8\n    cmovne       %rdx, %r9\n    cmovne       %rcx, %r10\n    cmovne       %r12, %r11\n    movq         %r8, (%rdi)\n    movq         %r9, (8)(%rdi)\n    movq         %r10, (16)(%rdi)\n    movq         %r11, (24)(%rdi)\n \n    pop          %r13\n \n    pop          %r12\n \n    ret\n.Lfe6:\n.size sm2_neg, .Lfe6-(sm2_neg)\n.p2align 6, 0x90\nsm2_mmull: \n    xor          %r13, %r13\n    movq         (%rbx), %rax\n    mulq         (%rsi)\n    mov          %rax, %r8\n    mov          %rdx, %r9\n    movq         (%rbx), %rax\n    mulq         (8)(%rsi)\n    add          %rax, %r9\n    adc          $(0), %rdx\n    mov          %rdx, %r10\n    movq         (%rbx), %rax\n    mulq         (16)(%rsi)\n    add          %rax, %r10\n    adc          $(0), %rdx\n    mov          %rdx, %r11\n    movq         (%rbx), %rax\n    mulq         (24)(%rsi)\n    add          %rax, %r11\n    adc          $(0), %rdx\n    mov          %rdx, %r12\n    mov          %r8, %r14\n    shl          $(32), %r14\n    mov          %r8, %r15\n    shr          $(32), %r15\n    mov          %r8, %rcx\n    mov          %r8, %rax\n    xor          %rbp, %rbp\n    xor          %rdx, %rdx\n    sub          %r14, %rcx\n    sbb          %r15, %rbp\n    sbb          %r14, %rdx\n    sbb          %r15, %rax\n    add          %rcx, %r9\n    adc          %rbp, %r10\n    adc          %rdx, %r11\n    adc          %rax, %r12\n    adc          $(0), %r13\n    xor          %r8, %r8\n    movq         (8)(%rbx), %rax\n    mulq         (%rsi)\n    add          %rax, %r9\n    adc          $(0), %rdx\n    mov          %rdx, %rcx\n    movq         (8)(%rbx), %rax\n    mulq         (8)(%rsi)\n    add          %rcx, %r10\n    adc          $(0), %rdx\n    add          %rax, %r10\n    adc          $(0), %rdx\n    mov          %rdx, %rcx\n    movq         (8)(%rbx), %rax\n    mulq         (16)(%rsi)\n    add          %rcx, %r11\n    adc          $(0), %rdx\n    add          %rax, %r11\n    adc          $(0), %rdx\n    mov          %rdx, %rcx\n    movq         (8)(%rbx), %rax\n    mulq         (24)(%rsi)\n    add          %rcx, %r12\n    adc          $(0), %rdx\n    add          %rax, %r12\n    adc          %rdx, %r13\n    adc          $(0), %r8\n    mov          %r9, %r14\n    shl          $(32), %r14\n    mov          %r9, %r15\n    shr          $(32), %r15\n    mov          %r9, %rcx\n    mov          %r9, %rax\n    xor          %rbp, %rbp\n    xor          %rdx, %rdx\n    sub          %r14, %rcx\n    sbb          %r15, %rbp\n    sbb          %r14, %rdx\n    sbb          %r15, %rax\n    add          %rcx, %r10\n    adc          %rbp, %r11\n    adc          %rdx, %r12\n    adc          %rax, %r13\n    adc          $(0), %r8\n    xor          %r9, %r9\n    movq         (16)(%rbx), %rax\n    mulq         (%rsi)\n    add          %rax, %r10\n    adc          $(0), %rdx\n    mov          %rdx, %rcx\n    movq         (16)(%rbx), %rax\n    mulq         (8)(%rsi)\n    add          %rcx, %r11\n    adc          $(0), %rdx\n    add          %rax, %r11\n    adc          $(0), %rdx\n    mov          %rdx, %rcx\n    movq         (16)(%rbx), %rax\n    mulq         (16)(%rsi)\n    add          %rcx, %r12\n    adc          $(0), %rdx\n    add          %rax, %r12\n    adc          $(0), %rdx\n    mov          %rdx, %rcx\n    movq         (16)(%rbx), %rax\n    mulq         (24)(%rsi)\n    add          %rcx, %r13\n    adc          $(0), %rdx\n    add          %rax, %r13\n    adc          %rdx, %r8\n    adc          $(0), %r9\n    mov          %r10, %r14\n    shl          $(32), %r14\n    mov          %r10, %r15\n    shr          $(32), %r15\n    mov          %r10, %rcx\n    mov          %r10, %rax\n    xor          %rbp, %rbp\n    xor          %rdx, %rdx\n    sub          %r14, %rcx\n    sbb          %r15, %rbp\n    sbb          %r14, %rdx\n    sbb          %r15, %rax\n    add          %rcx, %r11\n    adc          %rbp, %r12\n    adc          %rdx, %r13\n    adc          %rax, %r8\n    adc          $(0), %r9\n    xor          %r10, %r10\n    movq         (24)(%rbx), %rax\n    mulq         (%rsi)\n    add          %rax, %r11\n    adc          $(0), %rdx\n    mov          %rdx, %rcx\n    movq         (24)(%rbx), %rax\n    mulq         (8)(%rsi)\n    add          %rcx, %r12\n    adc          $(0), %rdx\n    add          %rax, %r12\n    adc          $(0), %rdx\n    mov          %rdx, %rcx\n    movq         (24)(%rbx), %rax\n    mulq         (16)(%rsi)\n    add          %rcx, %r13\n    adc          $(0), %rdx\n    add          %rax, %r13\n    adc          $(0), %rdx\n    mov          %rdx, %rcx\n    movq         (24)(%rbx), %rax\n    mulq         (24)(%rsi)\n    add          %rcx, %r8\n    adc          $(0), %rdx\n    add          %rax, %r8\n    adc          %rdx, %r9\n    adc          $(0), %r10\n    mov          %r11, %r14\n    shl          $(32), %r14\n    mov          %r11, %r15\n    shr          $(32), %r15\n    mov          %r11, %rcx\n    mov          %r11, %rax\n    xor          %rbp, %rbp\n    xor          %rdx, %rdx\n    sub          %r14, %rcx\n    sbb          %r15, %rbp\n    sbb          %r14, %rdx\n    sbb          %r15, %rax\n    add          %rcx, %r12\n    adc          %rbp, %r13\n    adc          %rdx, %r8\n    adc          %rax, %r9\n    adc          $(0), %r10\n    xor          %r11, %r11\n    movq         Lpoly+0(%rip), %rcx\n    movq         Lpoly+8(%rip), %rbp\n    movq         Lpoly+16(%rip), %rbx\n    movq         Lpoly+24(%rip), %rdx\n    mov          %r12, %rax\n    mov          %r13, %r11\n    mov          %r8, %r14\n    mov          %r9, %r15\n    sub          %rcx, %rax\n    sbb          %rbp, %r11\n    sbb          %rbx, %r14\n    sbb          %rdx, %r15\n    sbb          $(0), %r10\n    cmovnc       %rax, %r12\n    cmovnc       %r11, %r13\n    cmovnc       %r14, %r8\n    cmovnc       %r15, %r9\n    movq         %r12, (%rdi)\n    movq         %r13, (8)(%rdi)\n    movq         %r8, (16)(%rdi)\n    movq         %r9, (24)(%rdi)\n    ret\n.p2align 6, 0x90\n \n.globl sm2_mul_montl\n.type sm2_mul_montl, @function\n \nsm2_mul_montl:\n \n    push         %rbp\n \n    push         %rbx\n \n    push         %r12\n \n    push         %r13\n \n    push         %r14\n \n    push         %r15\n \n    mov          %rdx, %rbx\n    call         sm2_mmull\n \n    pop          %r15\n \n    pop          %r14\n \n    pop          %r13\n \n    pop          %r12\n \n    pop          %rbx\n \n    pop          %rbp\n \n    ret\n.Lfe7:\n.size sm2_mul_montl, .Lfe7-(sm2_mul_montl)\n.p2align 6, 0x90\n \n.globl sm2_to_mont\n.type sm2_to_mont, @function\n \nsm2_to_mont:\n \n    push         %rbp\n \n    push         %rbx\n \n    push         %r12\n \n    push         %r13\n \n    push         %r14\n \n    push         %r15\n \n    lea          LRR(%rip), %rbx\n    call         sm2_mmull\n \n    pop          %r15\n \n    pop          %r14\n \n    pop          %r13\n \n    pop          %r12\n \n    pop          %rbx\n \n    pop          %rbp\n \n    ret\n.Lfe8:\n.size sm2_to_mont, .Lfe8-(sm2_to_mont)\n.p2align 6, 0x90\nsm2_mmulx: \n    xor          %r13, %r13\n    xor          %rdx, %rdx\n    movq         (%rbx), %rdx\n    mulxq        (%rsi), %r8, %r9\n    mulxq        (8)(%rsi), %rcx, %r10\n    add          %rcx, %r9\n    mulxq        (16)(%rsi), %rcx, %r11\n    adc          %rcx, %r10\n    mulxq        (24)(%rsi), %rcx, %r12\n    adc          %rcx, %r11\n    adc          $(0), %r12\n    mov          %r8, %r14\n    shl          $(32), %r14\n    mov          %r8, %r15\n    shr          $(32), %r15\n    mov          %r8, %rax\n    mov          %r8, %rbp\n    xor          %rdx, %rdx\n    xor          %rcx, %rcx\n    sub          %r14, %rax\n    sbb          %r15, %rdx\n    sbb          %r14, %rcx\n    sbb          %r15, %rbp\n    add          %rax, %r9\n    adc          %rdx, %r10\n    adc          %rcx, %r11\n    adc          %rbp, %r12\n    adc          $(0), %r13\n    xor          %r8, %r8\n    movq         (8)(%rbx), %rdx\n    mulxq        (%rsi), %rcx, %rbp\n    adcx         %rcx, %r9\n    adox         %rbp, %r10\n    mulxq        (8)(%rsi), %rcx, %rbp\n    adcx         %rcx, %r10\n    adox         %rbp, %r11\n    mulxq        (16)(%rsi), %rcx, %rbp\n    adcx         %rcx, %r11\n    adox         %rbp, %r12\n    mulxq        (24)(%rsi), %rcx, %rbp\n    adcx         %rcx, %r12\n    adox         %rbp, %r13\n    adcx         %r8, %r13\n    adox         %r8, %r8\n    adc          $(0), %r8\n    mov          %r9, %r14\n    shl          $(32), %r14\n    mov          %r9, %r15\n    shr          $(32), %r15\n    mov          %r9, %rax\n    mov          %r9, %rbp\n    xor          %rdx, %rdx\n    xor          %rcx, %rcx\n    sub          %r14, %rax\n    sbb          %r15, %rdx\n    sbb          %r14, %rcx\n    sbb          %r15, %rbp\n    add          %rax, %r10\n    adc          %rdx, %r11\n    adc          %rcx, %r12\n    adc          %rbp, %r13\n    adc          $(0), %r8\n    xor          %r9, %r9\n    movq         (16)(%rbx), %rdx\n    mulxq        (%rsi), %rcx, %rbp\n    adcx         %rcx, %r10\n    adox         %rbp, %r11\n    mulxq        (8)(%rsi), %rcx, %rbp\n    adcx         %rcx, %r11\n    adox         %rbp, %r12\n    mulxq        (16)(%rsi), %rcx, %rbp\n    adcx         %rcx, %r12\n    adox         %rbp, %r13\n    mulxq        (24)(%rsi), %rcx, %rbp\n    adcx         %rcx, %r13\n    adox         %rbp, %r8\n    adcx         %r9, %r8\n    adox         %r9, %r9\n    adc          $(0), %r9\n    mov          %r10, %r14\n    shl          $(32), %r14\n    mov          %r10, %r15\n    shr          $(32), %r15\n    mov          %r10, %rax\n    mov          %r10, %rbp\n    xor          %rdx, %rdx\n    xor          %rcx, %rcx\n    sub          %r14, %rax\n    sbb          %r15, %rdx\n    sbb          %r14, %rcx\n    sbb          %r15, %rbp\n    add          %rax, %r11\n    adc          %rdx, %r12\n    adc          %rcx, %r13\n    adc          %rbp, %r8\n    adc          $(0), %r9\n    xor          %r10, %r10\n    movq         (24)(%rbx), %rdx\n    mulxq        (%rsi), %rcx, %rbp\n    adcx         %rcx, %r11\n    adox         %rbp, %r12\n    mulxq        (8)(%rsi), %rcx, %rbp\n    adcx         %rcx, %r12\n    adox         %rbp, %r13\n    mulxq        (16)(%rsi), %rcx, %rbp\n    adcx         %rcx, %r13\n    adox         %rbp, %r8\n    mulxq        (24)(%rsi), %rcx, %rbp\n    adcx         %rcx, %r8\n    adox         %rbp, %r9\n    adcx         %r10, %r9\n    adox         %r10, %r10\n    adc          $(0), %r10\n    mov          %r11, %r14\n    shl          $(32), %r14\n    mov          %r11, %r15\n    shr          $(32), %r15\n    mov          %r11, %rax\n    mov          %r11, %rbp\n    xor          %rdx, %rdx\n    xor          %rcx, %rcx\n    sub          %r14, %rax\n    sbb          %r15, %rdx\n    sbb          %r14, %rcx\n    sbb          %r15, %rbp\n    add          %rax, %r12\n    adc          %rdx, %r13\n    adc          %rcx, %r8\n    adc          %rbp, %r9\n    adc          $(0), %r10\n    xor          %r11, %r11\n    movq         Lpoly+0(%rip), %rax\n    movq         Lpoly+8(%rip), %rdx\n    movq         Lpoly+16(%rip), %rbx\n    movq         Lpoly+24(%rip), %rcx\n    mov          %r12, %rbp\n    mov          %r13, %r11\n    mov          %r8, %r14\n    mov          %r9, %r15\n    sub          %rax, %rbp\n    sbb          %rdx, %r11\n    sbb          %rbx, %r14\n    sbb          %rcx, %r15\n    sbb          $(0), %r10\n    cmovnc       %rbp, %r12\n    cmovnc       %r11, %r13\n    cmovnc       %r14, %r8\n    cmovnc       %r15, %r9\n    movq         %r12, (%rdi)\n    movq         %r13, (8)(%rdi)\n    movq         %r8, (16)(%rdi)\n    movq         %r9, (24)(%rdi)\n    ret\n.p2align 6, 0x90\n \n.globl sm2_mul_montx\n.type sm2_mul_montx, @function\n \nsm2_mul_montx:\n \n    push         %rbp\n \n    push         %rbx\n \n    push         %r12\n \n    push         %r13\n \n    push         %r14\n \n    push         %r15\n \n    mov          %rdx, %rbx\n    call         sm2_mmulx\n \n    pop          %r15\n \n    pop          %r14\n \n    pop          %r13\n \n    pop          %r12\n \n    pop          %rbx\n \n    pop          %rbp\n \n    ret\n.Lfe9:\n.size sm2_mul_montx, .Lfe9-(sm2_mul_montx)\n.p2align 6, 0x90\n \n.globl sm2_sqr_montl\n.type sm2_sqr_montl, @function\n \nsm2_sqr_montl:\n \n    push         %rbp\n \n    push         %rbx\n \n    push         %r12\n \n    push         %r13\n \n    push         %r14\n \n    push         %r15\n \n    movq         (%rsi), %rbx\n    movq         (8)(%rsi), %rax\n    mul          %rbx\n    mov          %rax, %r9\n    mov          %rdx, %r10\n    movq         (16)(%rsi), %rax\n    mul          %rbx\n    add          %rax, %r10\n    adc          $(0), %rdx\n    mov          %rdx, %r11\n    movq         (24)(%rsi), %rax\n    mul          %rbx\n    add          %rax, %r11\n    adc          $(0), %rdx\n    mov          %rdx, %r12\n    movq         (8)(%rsi), %rbx\n    movq         (16)(%rsi), %rax\n    mul          %rbx\n    add          %rax, %r11\n    adc          $(0), %rdx\n    mov          %rdx, %rbp\n    movq         (24)(%rsi), %rax\n    mul          %rbx\n    add          %rax, %r12\n    adc          $(0), %rdx\n    add          %rbp, %r12\n    adc          $(0), %rdx\n    mov          %rdx, %r13\n    movq         (16)(%rsi), %rbx\n    movq         (24)(%rsi), %rax\n    mul          %rbx\n    add          %rax, %r13\n    adc          $(0), %rdx\n    mov          %rdx, %r14\n    xor          %r15, %r15\n    shld         $(1), %r14, %r15\n    shld         $(1), %r13, %r14\n    shld         $(1), %r12, %r13\n    shld         $(1), %r11, %r12\n    shld         $(1), %r10, %r11\n    shld         $(1), %r9, %r10\n    shl          $(1), %r9\n    movq         (%rsi), %rax\n    mul          %rax\n    mov          %rax, %r8\n    add          %rdx, %r9\n    adc          $(0), %r10\n    movq         (8)(%rsi), %rax\n    mul          %rax\n    add          %rax, %r10\n    adc          %rdx, %r11\n    adc          $(0), %r12\n    movq         (16)(%rsi), %rax\n    mul          %rax\n    add          %rax, %r12\n    adc          %rdx, %r13\n    adc          $(0), %r14\n    movq         (24)(%rsi), %rax\n    mul          %rax\n    add          %rax, %r14\n    adc          %rdx, %r15\n    mov          %r8, %rax\n    mov          %r8, %rcx\n    mov          %r8, %rdx\n    xor          %rbp, %rbp\n    xor          %rbx, %rbx\n    shl          $(32), %r8\n    shr          $(32), %rax\n    sub          %r8, %rcx\n    sbb          %rax, %rbp\n    sbb          %r8, %rbx\n    sbb          %rax, %rdx\n    xor          %r8, %r8\n    add          %rcx, %r9\n    adc          %rbp, %r10\n    adc          %rbx, %r11\n    adc          %rdx, %r12\n    adc          $(0), %r8\n    mov          %r9, %rax\n    mov          %r9, %rcx\n    mov          %r9, %rdx\n    xor          %rbp, %rbp\n    xor          %rbx, %rbx\n    shl          $(32), %r9\n    shr          $(32), %rax\n    sub          %r9, %rcx\n    sbb          %rax, %rbp\n    sbb          %r9, %rbx\n    sbb          %rax, %rdx\n    xor          %r9, %r9\n    add          %rcx, %r10\n    adc          %rbp, %r11\n    adc          %rbx, %r12\n    adc          %rdx, %r13\n    adc          $(0), %r9\n    add          %r8, %r13\n    adc          $(0), %r9\n    mov          %r10, %rax\n    mov          %r10, %rcx\n    mov          %r10, %rdx\n    xor          %rbp, %rbp\n    xor          %rbx, %rbx\n    shl          $(32), %r10\n    shr          $(32), %rax\n    sub          %r10, %rcx\n    sbb          %rax, %rbp\n    sbb          %r10, %rbx\n    sbb          %rax, %rdx\n    xor          %r10, %r10\n    add          %rcx, %r11\n    adc          %rbp, %r12\n    adc          %rbx, %r13\n    adc          %rdx, %r14\n    adc          $(0), %r10\n    add          %r9, %r14\n    adc          $(0), %r10\n    mov          %r11, %rax\n    mov          %r11, %rcx\n    mov          %r11, %rdx\n    xor          %rbp, %rbp\n    xor          %rbx, %rbx\n    shl          $(32), %r11\n    shr          $(32), %rax\n    sub          %r11, %rcx\n    sbb          %rax, %rbp\n    sbb          %r11, %rbx\n    sbb          %rax, %rdx\n    xor          %r11, %r11\n    add          %rcx, %r12\n    adc          %rbp, %r13\n    adc          %rbx, %r14\n    adc          %rdx, %r15\n    adc          $(0), %r11\n    add          %r10, %r15\n    adc          $(0), %r11\n    movq         Lpoly+0(%rip), %rcx\n    movq         Lpoly+8(%rip), %rbp\n    movq         Lpoly+16(%rip), %rbx\n    movq         Lpoly+24(%rip), %rdx\n    mov          %r12, %rax\n    mov          %r13, %r8\n    mov          %r14, %r9\n    mov          %r15, %r10\n    sub          %rcx, %rax\n    sbb          %rbp, %r8\n    sbb          %rbx, %r9\n    sbb          %rdx, %r10\n    sbb          $(0), %r11\n    cmovnc       %rax, %r12\n    cmovnc       %r8, %r13\n    cmovnc       %r9, %r14\n    cmovnc       %r10, %r15\n    movq         %r12, (%rdi)\n    movq         %r13, (8)(%rdi)\n    movq         %r14, (16)(%rdi)\n    movq         %r15, (24)(%rdi)\n \n    pop          %r15\n \n    pop          %r14\n \n    pop          %r13\n \n    pop          %r12\n \n    pop          %rbx\n \n    pop          %rbp\n \n    ret\n.Lfe10:\n.size sm2_sqr_montl, .Lfe10-(sm2_sqr_montl)\n.p2align 6, 0x90\n \n.globl sm2_sqr_montx\n.type sm2_sqr_montx, @function\n \nsm2_sqr_montx:\n \n    push         %rbp\n \n    push         %rbx\n \n    push         %r12\n \n    push         %r13\n \n    push         %r14\n \n    push         %r15\n \n    movq         (%rsi), %rdx\n    mulxq        (8)(%rsi), %r9, %r10\n    mulxq        (16)(%rsi), %rcx, %r11\n    add          %rcx, %r10\n    mulxq        (24)(%rsi), %rcx, %r12\n    adc          %rcx, %r11\n    adc          $(0), %r12\n    movq         (8)(%rsi), %rdx\n    xor          %r13, %r13\n    mulxq        (16)(%rsi), %rcx, %rbp\n    adcx         %rcx, %r11\n    adox         %rbp, %r12\n    mulxq        (24)(%rsi), %rcx, %rbp\n    adcx         %rcx, %r12\n    adox         %rbp, %r13\n    adc          $(0), %r13\n    movq         (16)(%rsi), %rdx\n    mulxq        (24)(%rsi), %rcx, %r14\n    add          %rcx, %r13\n    adc          $(0), %r14\n    xor          %r15, %r15\n    shld         $(1), %r14, %r15\n    shld         $(1), %r13, %r14\n    shld         $(1), %r12, %r13\n    shld         $(1), %r11, %r12\n    shld         $(1), %r10, %r11\n    shld         $(1), %r9, %r10\n    shl          $(1), %r9\n    xor          %r8, %r8\n    movq         (%rsi), %rdx\n    mulx         %rdx, %r8, %rbp\n    adcx         %rbp, %r9\n    movq         (8)(%rsi), %rdx\n    mulx         %rdx, %rcx, %rbp\n    adcx         %rcx, %r10\n    adcx         %rbp, %r11\n    movq         (16)(%rsi), %rdx\n    mulx         %rdx, %rcx, %rbp\n    adcx         %rcx, %r12\n    adcx         %rbp, %r13\n    movq         (24)(%rsi), %rdx\n    mulx         %rdx, %rcx, %rbp\n    adcx         %rcx, %r14\n    adcx         %rbp, %r15\n    mov          %r8, %rax\n    mov          %r8, %rcx\n    mov          %r8, %rdx\n    xor          %rbp, %rbp\n    xor          %rbx, %rbx\n    shl          $(32), %r8\n    shr          $(32), %rax\n    sub          %r8, %rcx\n    sbb          %rax, %rbp\n    sbb          %r8, %rbx\n    sbb          %rax, %rdx\n    xor          %r8, %r8\n    add          %rcx, %r9\n    adc          %rbp, %r10\n    adc          %rbx, %r11\n    adc          %rdx, %r12\n    adc          $(0), %r8\n    mov          %r9, %rax\n    mov          %r9, %rcx\n    mov          %r9, %rdx\n    xor          %rbp, %rbp\n    xor          %rbx, %rbx\n    shl          $(32), %r9\n    shr          $(32), %rax\n    sub          %r9, %rcx\n    sbb          %rax, %rbp\n    sbb          %r9, %rbx\n    sbb          %rax, %rdx\n    xor          %r9, %r9\n    add          %rcx, %r10\n    adc          %rbp, %r11\n    adc          %rbx, %r12\n    adc          %rdx, %r13\n    adc          $(0), %r9\n    add          %r8, %r13\n    adc          $(0), %r9\n    mov          %r10, %rax\n    mov          %r10, %rcx\n    mov          %r10, %rdx\n    xor          %rbp, %rbp\n    xor          %rbx, %rbx\n    shl          $(32), %r10\n    shr          $(32), %rax\n    sub          %r10, %rcx\n    sbb          %rax, %rbp\n    sbb          %r10, %rbx\n    sbb          %rax, %rdx\n    xor          %r10, %r10\n    add          %rcx, %r11\n    adc          %rbp, %r12\n    adc          %rbx, %r13\n    adc          %rdx, %r14\n    adc          $(0), %r10\n    add          %r9, %r14\n    adc          $(0), %r10\n    mov          %r11, %rax\n    mov          %r11, %rcx\n    mov          %r11, %rdx\n    xor          %rbp, %rbp\n    xor          %rbx, %rbx\n    shl          $(32), %r11\n    shr          $(32), %rax\n    sub          %r11, %rcx\n    sbb          %rax, %rbp\n    sbb          %r11, %rbx\n    sbb          %rax, %rdx\n    xor          %r11, %r11\n    add          %rcx, %r12\n    adc          %rbp, %r13\n    adc          %rbx, %r14\n    adc          %rdx, %r15\n    adc          $(0), %r11\n    add          %r10, %r15\n    adc          $(0), %r11\n    movq         Lpoly+0(%rip), %rcx\n    movq         Lpoly+8(%rip), %rbp\n    movq         Lpoly+16(%rip), %rbx\n    movq         Lpoly+24(%rip), %rdx\n    mov          %r12, %rax\n    mov          %r13, %r8\n    mov          %r14, %r9\n    mov          %r15, %r10\n    sub          %rcx, %rax\n    sbb          %rbp, %r8\n    sbb          %rbx, %r9\n    sbb          %rdx, %r10\n    sbb          $(0), %r11\n    cmovnc       %rax, %r12\n    cmovnc       %r8, %r13\n    cmovnc       %r9, %r14\n    cmovnc       %r10, %r15\n    movq         %r12, (%rdi)\n    movq         %r13, (8)(%rdi)\n    movq         %r14, (16)(%rdi)\n    movq         %r15, (24)(%rdi)\n \n    pop          %r15\n \n    pop          %r14\n \n    pop          %r13\n \n    pop          %r12\n \n    pop          %rbx\n \n    pop          %rbp\n \n    ret\n.Lfe11:\n.size sm2_sqr_montx, .Lfe11-(sm2_sqr_montx)\n.p2align 6, 0x90\n \n.globl sm2_mont_back\n.type sm2_mont_back, @function\n \nsm2_mont_back:\n \n    push         %rbp\n \n    push         %rbx\n \n    push         %r12\n \n    push         %r13\n \n    push         %r14\n \n    push         %r15\n \n    movq         (%rsi), %r10\n    movq         (8)(%rsi), %r11\n    movq         (16)(%rsi), %r12\n    movq         (24)(%rsi), %r13\n    xor          %r8, %r8\n    xor          %r9, %r9\n    mov          %r10, %r14\n    shl          $(32), %r14\n    mov          %r10, %r15\n    shr          $(32), %r15\n    mov          %r10, %rcx\n    mov          %r10, %rax\n    xor          %rbp, %rbp\n    xor          %rdx, %rdx\n    sub          %r14, %rcx\n    sbb          %r15, %rbp\n    sbb          %r14, %rdx\n    sbb          %r15, %rax\n    add          %rcx, %r11\n    adc          %rbp, %r12\n    adc          %rdx, %r13\n    adc          %rax, %r8\n    adc          $(0), %r9\n    xor          %r10, %r10\n    mov          %r11, %r14\n    shl          $(32), %r14\n    mov          %r11, %r15\n    shr          $(32), %r15\n    mov          %r11, %rcx\n    mov          %r11, %rax\n    xor          %rbp, %rbp\n    xor          %rdx, %rdx\n    sub          %r14, %rcx\n    sbb          %r15, %rbp\n    sbb          %r14, %rdx\n    sbb          %r15, %rax\n    add          %rcx, %r12\n    adc          %rbp, %r13\n    adc          %rdx, %r8\n    adc          %rax, %r9\n    adc          $(0), %r10\n    xor          %r11, %r11\n    mov          %r12, %r14\n    shl          $(32), %r14\n    mov          %r12, %r15\n    shr          $(32), %r15\n    mov          %r12, %rcx\n    mov          %r12, %rax\n    xor          %rbp, %rbp\n    xor          %rdx, %rdx\n    sub          %r14, %rcx\n    sbb          %r15, %rbp\n    sbb          %r14, %rdx\n    sbb          %r15, %rax\n    add          %rcx, %r13\n    adc          %rbp, %r8\n    adc          %rdx, %r9\n    adc          %rax, %r10\n    adc          $(0), %r11\n    xor          %r12, %r12\n    mov          %r13, %r14\n    shl          $(32), %r14\n    mov          %r13, %r15\n    shr          $(32), %r15\n    mov          %r13, %rcx\n    mov          %r13, %rax\n    xor          %rbp, %rbp\n    xor          %rdx, %rdx\n    sub          %r14, %rcx\n    sbb          %r15, %rbp\n    sbb          %r14, %rdx\n    sbb          %r15, %rax\n    add          %rcx, %r8\n    adc          %rbp, %r9\n    adc          %rdx, %r10\n    adc          %rax, %r11\n    adc          $(0), %r12\n    xor          %r13, %r13\n    mov          %r8, %rcx\n    mov          %r9, %rbp\n    mov          %r10, %rbx\n    mov          %r11, %rdx\n    subq         Lpoly+0(%rip), %rcx\n    sbbq         Lpoly+8(%rip), %rbp\n    sbbq         Lpoly+16(%rip), %rbx\n    sbbq         Lpoly+24(%rip), %rdx\n    sbb          $(0), %r12\n    cmovnc       %rcx, %r8\n    cmovnc       %rbp, %r9\n    cmovnc       %rbx, %r10\n    cmovnc       %rdx, %r11\n    movq         %r8, (%rdi)\n    movq         %r9, (8)(%rdi)\n    movq         %r10, (16)(%rdi)\n    movq         %r11, (24)(%rdi)\n \n    pop          %r15\n \n    pop          %r14\n \n    pop          %r13\n \n    pop          %r12\n \n    pop          %rbx\n \n    pop          %rbp\n \n    ret\n.Lfe12:\n.size sm2_mont_back, .Lfe12-(sm2_mont_back)\n.p2align 6, 0x90\n \n.globl sm2_select_pp_w5\n.type sm2_select_pp_w5, @function\n \nsm2_select_pp_w5:\n \n    push         %r12\n \n    push         %r13\n \n    movdqa       LOne(%rip), %xmm0\n    movdqa       %xmm0, %xmm8\n    movd         %edx, %xmm1\n    pshufd       $(0), %xmm1, %xmm1\n    pxor         %xmm2, %xmm2\n    pxor         %xmm3, %xmm3\n    pxor         %xmm4, %xmm4\n    pxor         %xmm5, %xmm5\n    pxor         %xmm6, %xmm6\n    pxor         %xmm7, %xmm7\n    mov          $(16), %rcx\n.Lselect_loop_sse_w5gas_13: \n    movdqa       %xmm8, %xmm15\n    pcmpeqd      %xmm1, %xmm15\n    paddd        %xmm0, %xmm8\n    movdqa       (%rsi), %xmm9\n    movdqa       (16)(%rsi), %xmm10\n    movdqa       (32)(%rsi), %xmm11\n    movdqa       (48)(%rsi), %xmm12\n    movdqa       (64)(%rsi), %xmm13\n    movdqa       (80)(%rsi), %xmm14\n    add          $(96), %rsi\n    pand         %xmm15, %xmm9\n    pand         %xmm15, %xmm10\n    pand         %xmm15, %xmm11\n    pand         %xmm15, %xmm12\n    pand         %xmm15, %xmm13\n    pand         %xmm15, %xmm14\n    por          %xmm9, %xmm2\n    por          %xmm10, %xmm3\n    por          %xmm11, %xmm4\n    por          %xmm12, %xmm5\n    por          %xmm13, %xmm6\n    por          %xmm14, %xmm7\n    dec          %rcx\n    jnz          .Lselect_loop_sse_w5gas_13\n    movdqu       %xmm2, (%rdi)\n    movdqu       %xmm3, (16)(%rdi)\n    movdqu       %xmm4, (32)(%rdi)\n    movdqu       %xmm5, (48)(%rdi)\n    movdqu       %xmm6, (64)(%rdi)\n    movdqu       %xmm7, (80)(%rdi)\n \n    pop          %r13\n \n    pop          %r12\n \n    ret\n.Lfe13:\n.size sm2_select_pp_w5, .Lfe13-(sm2_select_pp_w5)\n \n","avg_line_length":25.538071066,"max_line_length":87,"alphanum_fraction":0.373427606,"licenses":["Apache-2.0"],"repository_name":"ymarkovitch\/ipp-crypto","path":"sources\/ippcp\/asm_intel64_gas_converted\/linux\/nonpic\/n0\/singlecpu\/pcpsm2pfuncs_montas.asm","size":35217,"lang":"Assembly"}
{"content":"---\nlayout: page\ntitle: \"Presentations\"\n---\n\n---\n\n### Invited talks\n\n2021.12 **Deep Ocean Circulation in the Subpolar North Atlantic Observed by Acoustically-tracked Floats** (virtual). Ocean Circulation and Climate Dynamics Colloquium. GEOMAR, Kiel, Germany.\n\n2021.09 **Density-compensated Overturning in the Labrador Sea** (virtual). School and Marine and Atmospheric Sciences. Stony Brook University. New York. U.S.\n\n2020.11 **Lagrangian observations of Deep Ocean Circulation in the Subpolar North Atlantic** (virtual). Atmosphere and Ocean Seminars. Johns Hopkins University, Baltimore, Maryland, U.S.\n\n2020.02 **Density-compensated Overturning in the Labrador Sea**. Paleoceanography and Climate Seminars. Woods Hole Oceanographic Institute, Woods Hole, Massachusetts, U.S.\n\n2018.02 **Observed and Modeled Pathways of the Iceland Scotland Overflow Water in the Eastern North Atlantic**. Nicholas School PhD Symposium. Duke University, Durham, North Carolina, U.S.\n\n2017.10 **Observed and Modeled Pathways of the Iceland Scotland Overflow Water in the Eastern North Atlantic**. Physical Oceanography Seminars. Woods Hole Oceanographic Institute, Woods Hole, Massachusetts, U.S.\n\n\n","avg_line_length":51.5217391304,"max_line_length":211,"alphanum_fraction":0.7873417722,"licenses":["Unlicense"],"repository_name":"sijiazou\/sijiazou.github.io","path":"Presentations.md","size":1185,"lang":"Markdown"}
{"content":"SUBDIRS = button \\\n          current \\\n          encoder \\\n          env \\\n          mc \\\n          proximity \\\n          relay \\\n          i2c \\\n          gpio \\\n          realtime\/user_mode\n  \n.PHONY: build clean\n\nbuild:\n\tfor d in $(SUBDIRS) ; do echo; PWD=$(PWD)\/$$d make -C $$d || exit 1; done\n\nclean:\n\tfor d in $(SUBDIRS) ; do echo; make -C $$d clean || exit 1; done\n\n","avg_line_length":18.65,"max_line_length":74,"alphanum_fraction":0.4691689008,"licenses":["MIT"],"repository_name":"sthaid\/proj_robot2","path":"body\/devel\/Makefile","size":373,"lang":"Makefile"}
{"content":"@php\n    $register = auth()->user()->register;\n    $banks = ['MANDIRI','BCA','BRI','Bank Syariah Indonesia', 'BTN', 'BJB', 'Lainya'];\n@endphp\n\n@extends('layouts.admin.master_admin')\n\n@section('content')\n<div class=\"container\">\n    <div class=\"clearfix\"><\/div>\n\t<div class=\"row\">\n\t\t<div class=\"col-md-12 col-sm-12 \">\n            @if ($errors->any())\n                <ul class=\"alert alert-danger pl-4 font-weight-bold\">\n                    @foreach ($errors->all() as $err)\n                        <li>{{ $err }}<\/li>\n                    @endforeach\n                <\/ul>\n            @endif\n\t\t\t<div class=\"x_panel\">\n\t\t\t\t<div class=\"x_header\">\n                    Pembayaran\n                <\/div>\n\t\t\t\t<div class=\"x_content\">\n                    <h2>TIPE PEMBAYARAN :<\/h2>\n                    <b><ul>\n                        <li>PEMBAYARAN BISA LANGSUNG DILAKUKAN DI KAMPUS SMK YPC TASIKMALAYA<\/li>\n                        <li>TRANSFER KE BANK MANDIRI SYARIAH : <br>\n                            NO. REKENING : 7093332223 <br>\n                            ATAS NAMA : SMK YPC TASIKMALAYA\n                        <\/li>\n                    <\/ul><\/b>\n                    <form action=\"{{ route('user.pembayaran', $register->id) }}\" method=\"post\" enctype=\"multipart\/form-data\">\n                        @csrf\n                        @method('put')\n                        <div class=\"row\">\n                            <div class=\"col-md-6 col-12\">\n                                <div class=\"form-group\">\n                                    <label for=\"via\">Tujuan Bank<\/label>\n                                    <select name=\"via\" id=\"via\" class=\"form-control\">\n                                        @foreach ($banks as $bank)\n                                            <option value=\"{{ $bank }}\" {{ $bank==old('via', $register->pembayaran->via??'')?'selected':'' }}>{{ $bank }}<\/option>\n                                        @endforeach\n                                    <\/select>\n                                <\/div>\n                                <div class=\"form-group\">\n                                    <label for=\"atas_nama\">Nama Pengirim<\/label>\n                                    <input type=\"text\" class=\"form-control\" name=\"atas_nama\" value=\"{{ old('atas_nama', $register->pembayaran->atas_nama??'') }}\" id=\"atas_nama\">\n                                <\/div>\n                                <div class=\"form-group\">\n                                    <label>Bukti Pembayaran<\/label>\n                                    <div class=\"custom-file\">\n                                        <input type=\"file\" id=\"bukti\" name=\"bukti\" class=\"custom-file-input\" accept=\"image\/*\">\n                                        <label for=\"bukti\" class=\"custom-file-label\">Silahkan Pilih Gambar Bukti Pembayaran<\/label>\n                                    <\/div>\n                                <\/div>`\n                                <div class=\"form-group mt-3\">\n                                    <button class=\"btn btn-success w-100\">Kirim<\/button>\n                                <\/div>\n                            <\/div>\n                            <div class=\"col-md-6 col-12\">\n                                @if ($register->pembayaran)\n                                    <img src=\"{{ asset('storage\/bukti\/'.$register->pembayaran->bukti) }}\" id=\"preview-img\" alt=\"\" class=\"img-thumbnail\">\n                                @else\n                                    <img src=\"{{ asset('img\/bodybg\/bg1.png') }}\" id=\"preview-img\" alt=\"\" class=\"img-thumbnail\">\n                                @endif\n                            <\/div>\n                        <\/div>\n                    <\/form>\n                    @if(!is_null($register->pembayaran))\n                    <table class=\"table table-bordered text-center mt-3\">\n                        <thead>\n                            <th>NISN<\/th>\n                            <th>NAMA CALON SISWA<\/th>\n                            <th>TIPE PEMBAYARAN<\/th>\n                            <th>STATUS<\/th>\n                        <\/thead>\n                        <tbody>\n                            <tr>\n                                <td>{{ $register->nisn }}<\/td>\n                                <td>{{ $register->nama }}<\/td>\n                                <td>{{ $register->pembayaran->jns_pembayaran }}<\/td>\n                                <td>{!! $register->pembayaran->verified !!}<\/td>\n                            <\/tr>\n                        <\/tbody>\n                    <\/table>\n                    @endif\n                <\/div>\n            <\/div>\n        <\/div>\n    <\/div>\n<\/div>\n@endsection\n\n@push('js')\n    <script>\n        $('#bukti').on('change', function(){\n            const [file] = $(this)[0].files;\n            if(file){\n                $('#preview-img').attr('src', URL.createObjectURL(file));\n            }\n        })\n    <\/script>\n@endpush\n","avg_line_length":46.8285714286,"max_line_length":177,"alphanum_fraction":0.3681106366,"licenses":["MIT"],"repository_name":"dwiharvinivika\/ppdb_ypc","path":"resources\/views\/user\/pembayaran.blade.php","size":4917,"lang":"PHP"}
{"content":"---\ntitle: Which OAuth 2.0 flow should I use?\ntoc: true\ndescription: Helps the user identify the proper OAuth 2.0 grant for each use case.\ntopics:\n  - api-authentication\n  - oidc\n  - application-grants\ncontentType: discussion\nuseCase:\n  - secure-api\n  - call-api\n---\n\n# Which OAuth 2.0 flow should I use?\n\n<%= include('..\/_includes\/_pipeline2') %>\n\nOAuth 2.0 supports several different **grants**. By grants we mean ways of retrieving an Access Token. Deciding which one is suited for your case depends mostly on your Application's type, but other parameters weigh in as well, like the level of trust for the Application, or the experience you want your users to have.\n\nFollow this flow to identify the grant that best matches your case.\n\n![Flowchart for OAuth 2.0 Grants](\/media\/articles\/api-auth\/oauth2-grants-flow.png)\n\n::: panel Quick refresher - OAuth 2.0 terminology\n- **Resource Owner**: the entity that can grant access to a protected resource. Typically this is the end-user.\n- **Application**: an application requesting access to a protected resource on behalf of the Resource Owner.\n- **Resource Server**: the server hosting the protected resources. This is the API you want to access.\n- **Authorization Server**: the server that authenticates the Resource Owner, and issues Access Tokens after getting proper authorization. In this case, Auth0.\n- **User Agent**: the agent used by the Resource Owner to interact with the Application, for example a browser or a native application.\n:::\n\n## Is the Application the Resource Owner?\n\nThe first decision point is about whether the party that requires access to resources is a machine. In this case of machine to machine authorization, the Application is also the Resource Owner. No end-user authorization is needed in this case. An example is a cron job that uses an API to import information to a database. In this example the cron job is the Application and the Resource Owner since it holds the Client ID and Client Secret and uses them to get an Access Token from the Authorization Server.\n\nIf this case matches your needs, then for more information on how this flow works and how to implement it refer to [Calling APIs from a service](\/api-auth\/grant\/client-credentials).\n\n## Is the Application a web app executing on the server?\n\nIf the Application is a regular web app executing on a server then the **Authorization Code Grant** is the flow you should use. Using this the Application can retrieve an Access Token and, optionally, a Refresh Token. It's considered the safest choice since the Access Token is passed directly to the web server hosting the Application, without going through the user's web browser and risk exposure.\n\nIf this case matches your needs, then for more information on how this flow works and how to implement it refer to [Calling APIs from server-side web apps](\/api-auth\/grant\/authorization-code).\n\n## Is the Application absolutely trusted with user credentials?\n\nThis decision point may result to suggesting the **Resource Owner Password Credentials Grant**. In this flow the end-user is asked to fill in credentials (username\/password) typically using an interactive form. This information is sent to the backend and from there to Auth0. It is therefore imperative that the Application is absolutely trusted with this information.\n\nThis grant should **only** be used when redirect-based flows (like the [Authorization Code Grant](\/api-auth\/grant\/authorization-code)) are not possible. If this is your case, then for more information on how this flow works and how to implement it refer to [Call APIs from Highly Trusted Applications](\/api-auth\/grant\/password).\n\n## Is the Application a native app or a SPA?\n\nIf the Application is a Single Page Application (meaning an application running in a browser using a scripting language such as Javascript) then the **Implicit Grant** should be used. In this case, instead of getting an authorization code that needs to be exchanged for an Access Token, the Application retrieves directly an Access Token. On the plus side, this is more efficient since it reduces the number of round trips required to get an Access Token. However, a security consideration is that the Access Token is exposed on the client side. Also, it should be noted that **Implicit Grant** does not return a Refresh Token because the browser cannot keep it private (read the __SPAs and Refresh Tokens__ panel for a workaround).\n\nFor more information on how this flow works and how to implement it, refer to [Call APIs from client-side web apps](\/api-auth\/grant\/implicit).\n\n::: panel SPAs and Refresh Tokens\nWhile SPAs cannot use [Refresh Tokens](\/tokens\/refresh-token), they can take advantage of other mechanics that provide the same function. A workaround to improve user experience is to use `prompt=none` when you invoke [the \/authorize endpoint](\/api\/authentication#implicit-grant). This will not display the login dialog or the consent dialog. For more information on this, refer to [Silent Authentication](\/api-auth\/tutorials\/silent-authentication). In addition to that if you call `\/authorize` from a hidden iframe and extract the new [Access Token](\/tokens\/overview-access-tokens) from the parent frame, then the user will not see the redirects happening.\n:::\n\nIf the Application is a native app then the **Authorization Code Grant using Proof Key for Code Exchange** should be used. This grant adds the concept of a `code_verifier` to the Authorization Code Grant. When at first the application asks for an **Authorization Code** it generates a `code_verifier` and its transformed value called `code_challenge`. The `code_challenge` is sent along with the request. A `code_challenge_method` is also sent. Afterwards, when the application wants to exchange the Authorization Code for an Access Token, it also sends along the `code_verifier`. The Authorization Server transforms this and if it matches the originally sent `code challenge` it returns an Access Token.\n\nFor more information on how this flow works and how to implement it, refer to [Calling APIs from Mobile Apps](\/api-auth\/grant\/authorization-code-pkce).\n","avg_line_length":95.8125,"max_line_length":732,"alphanum_fraction":0.7870189172,"licenses":["MIT"],"repository_name":"Ashiroq\/docs","path":"articles\/api-auth\/which-oauth-flow-to-use.md","size":6132,"lang":"Markdown"}
{"content":"package typingsSlinky.jssPluginTemplate\n\nimport org.scalablytyped.runtime.StObject\nimport scala.scalajs.js\nimport scala.scalajs.js.`|`\nimport scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}\n\n\/* This can be used to `require` the library as a side effect.\n  If it is a global library this will make scalajs-bundler include it *\/\n@JSImport(\"jss-plugin-template\", JSImport.Namespace)\n@js.native\nobject jssPluginTemplateRequire extends StObject\n","avg_line_length":37.0,"max_line_length":95,"alphanum_fraction":0.8087318087,"licenses":["MIT"],"repository_name":"ScalablyTyped\/SlinkyTyped","path":"j\/jss-plugin-template\/src\/main\/scala\/typingsSlinky\/jssPluginTemplate\/jssPluginTemplateRequire.scala","size":481,"lang":"Scala"}
{"content":"\n\/\/ https:\/\/open.kattis.com\/problems\/cd\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.util.HashSet;\n\npublic class cd {\n    public static void main(String[] args) throws IOException {\n        BufferedReader sc = new BufferedReader(new InputStreamReader(System.in));\n        OutputStream dc = new BufferedOutputStream(System.out);\n\n        while (true) {\n            String line = sc.readLine();\n            if (line.equals(\"0 0\"))\n                break;\n            int space = line.indexOf(' ');\n            int n = Integer.parseInt(line.substring(0, space));\n            int m = Integer.parseInt(line.substring(space + 1));\n            HashSet<String> cds = new HashSet<>(n);\n            for (int x = 0; x < n; x++)\n                cds.add(sc.readLine());\n            for (int x = 0; x < m; x++)\n                cds.add(sc.readLine());\n\n            dc.write(((n + m) - cds.size() + \"\\n\").getBytes());\n        }\n        sc.close();\n        dc.flush();\n    }\n}","avg_line_length":32.8484848485,"max_line_length":81,"alphanum_fraction":0.565498155,"licenses":["Unlicense"],"repository_name":"AllysonWindell\/Kattis","path":"Java\/cd.java","size":1084,"lang":"Java"}
{"content":"import Test.Hspec\nimport Matcha.Parser\nimport Data.List (isInfixOf)\n\nimport Matcha.AbstractTree\n\nmaptree :: (a -> b) -> AbstractTree a -> AbstractTree b\nmaptree f tree = case tree of\n  FDef a b -> FDef (map (maptree f) a) (map (maptree f) b)\n  FApp a -> FApp (map (maptree f) a)\n  Symbol a -> Symbol (f a)\n\nassert_parses input asserted = runner . run $ input where\n  -- this is broken\n  get_trees = map $ maptree fst\n  runner (Right as) = show (get_trees as) `shouldBe` asserted\n  runner as = as `shouldBe` Right []\n\nassert_fails input line column message = do\n  let output = show . run $ input\n  output `shouldSatisfy` isInfixOf message\n  output `shouldSatisfy` isInfixOf (\"line \" ++ show line)\n  output `shouldSatisfy` isInfixOf (\"column \" ++ show column)\n\nmain :: IO ()\nmain = hspec $ do\n\n  describe \"initial parser with\" $ do\n\n    it \"a single symbol\" $ do\n      assert_parses \"a\" \"[Symbol \\\"a\\\"]\"\n\n    describe \"function definition\" $ do\n\n      it \"parses most basic\" $ do\n        assert_parses \"{:}\" \"[FDef [] []]\"\n\n      it \"can take more than one argument\" $ do\n        assert_parses \"{a b c: (a b c)}\" \"[FDef [Symbol \\\"a\\\",Symbol \\\"b\\\",Symbol \\\"c\\\"] [FApp [FApp [Symbol \\\"a\\\",Symbol \\\"b\\\",Symbol \\\"c\\\"]]]]\"\n\n      it \"parses basic with newlines\" $ do\n        assert_parses \"{\\n:\\n\\n\\n}\\n\\n\" \"[FDef [] []]\"\n\n      it \"parses nested function definition\" $ do\n        assert_parses \"{: {x:}}\" \"[FDef [] [FApp [FDef [Symbol \\\"x\\\"] []]]]\"\n\n      it \"semicolons work fine\" $ do\n        assert_parses \"{: a; b}\" \"[FDef [] [FApp [Symbol \\\"a\\\"],FApp [Symbol \\\"b\\\"]]]\"\n\n      it \"does not parse mismatched brackets\" $ do\n        assert_fails \"{\" 1 2 \"end of input\"\n        assert_fails \"a\\n}\" 2 1 \"unexpected \\\"}\"\n\n      it \"fails on non-symbols for function arguments\" $ do\n        assert_fails \"{ () : }\" 1 3 \"unexpected \\\"(\"\n\n    describe \"function application\" $ do\n\n      it \"parses simple function application\" $ do\n        assert_parses \"(a b)\" \"[FApp [Symbol \\\"a\\\",Symbol \\\"b\\\"]]\"\n\n      it \"parses simple function application with newline\" $ do\n        assert_parses \"(\\n\\na \\nb)\\n\" \"[FApp [Symbol \\\"a\\\",Symbol \\\"b\\\"]]\"\n\n      it \"parses function application within function def\" $ do\n        assert_parses \"{a: a b}\" \"[FDef [Symbol \\\"a\\\"] [FApp [Symbol \\\"a\\\",Symbol \\\"b\\\"]]]\"\n\n      it \"does not parse mismatched parens\" $ do\n        assert_fails \"(\" 1 2 \"end of input\"\n        assert_fails \"a\\n)\" 2 1 \"unexpected \\\")\"\n","avg_line_length":34.1971830986,"max_line_length":145,"alphanum_fraction":0.6013179572,"licenses":["BSD-3-Clause"],"repository_name":"Charlesetc\/matcha","path":"test\/Spec.hs","size":2428,"lang":"Haskell"}
{"content":"<?php\n\nuse Illuminate\\Database\\Migrations\\Migration;\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Support\\Facades\\Schema;\n\nclass AddForeignKeysToArabicsTable extends Migration {\n\n\t\/**\n\t * Run the migrations.\n\t *\n\t * @return void\n\t *\/\n\tpublic function up()\n\t{\n\t\tSchema::table('arabics', function(Blueprint $table)\n\t\t{\n\t\t\t$table->foreign('datasurah_id', 'fksurah')->references('id')->on('datasurahs')->onUpdate('RESTRICT')->onDelete('RESTRICT');\n\t\t});\n\t}\n\n\n\t\/**\n\t * Reverse the migrations.\n\t *\n\t * @return void\n\t *\/\n\tpublic function down()\n\t{\n\t\tSchema::table('arabics', function(Blueprint $table)\n\t\t{\n\t\t\t$table->dropForeign('fksurah');\n\t\t});\n\t}\n\n}\n","avg_line_length":17.7837837838,"max_line_length":126,"alphanum_fraction":0.670212766,"licenses":["MIT"],"repository_name":"MidtorJya\/Quran.th","path":"database\/migrations\/2021_12_08_024124_add_foreign_keys_to_arabics_table.php","size":658,"lang":"PHP"}
{"content":"import magma as m\nfrom magma import *\n\n\ndef test_pair():\n    # types\n\n    A2 = Tuple[Bit, Bit]\n    print(A2)\n    assert isinstance(A2, TupleMeta)\n    print(str(A2))\n    assert A2 == A2\n\n    B2 = Tuple[In(Bit), In(Bit)]\n    assert isinstance(B2, TupleMeta)\n    assert B2 == B2\n\n    C2 = Tuple[Out(Bit), Out(Bit)]\n    assert isinstance(C2, TupleMeta)\n    #assert str(C2) == 'Tuple(x=Out(Bit),y=Out(Bit))'\n    assert C2 == C2\n\n    assert issubclass(m.In(m.Tuple[Bit, Bit]), m.In(m.Tuple[Bit, Bit]))\n    assert isinstance(m.In(m.Tuple[Bit, Bit])(), m.In(m.Tuple[Bit, Bit]))\n\n    assert issubclass(m.In(m.Tuple[Bit, Bit]), m.Tuple[Bit, Bit])\n    assert isinstance(m.In(m.Tuple[Bit, Bit])(), m.Tuple[Bit, Bit])\n\n    assert not issubclass(m.In(m.Tuple[Bit, Bit]), m.Out(m.Tuple[Bit, Bit]))\n    assert not isinstance(m.In(m.Tuple[Bit, Bit])(), m.Out(m.Tuple[Bit, Bit]))\n\n    assert issubclass(m.Out(m.Tuple[Bit, Bit]), m.Out(m.Tuple[Bit, Bit]))\n    assert isinstance(m.Out(m.Tuple[Bit, Bit])(), m.Out(m.Tuple[Bit, Bit]))\n\n    assert issubclass(m.Out(m.Tuple[Bit, Bit]), m.Tuple[Bit, Bit])\n    assert isinstance(m.Out(m.Tuple[Bit, Bit])(), m.Tuple[Bit, Bit])\n\n    assert not issubclass(m.Out(m.Tuple[Bit, Bit]), m.In(m.Tuple[Bit, Bit]))\n    assert not isinstance(m.Out(m.Tuple[Bit, Bit])(), m.In(m.Tuple[Bit, Bit]))\n\n\ndef test_dict():\n    # types\n    class A2(Product, cache=True):\n        x = Bit\n        y = Bit\n    print(A2)\n    assert isinstance(A2, ProductMeta)\n    print(str(A2))\n\n    assert issubclass(In(A2), A2)\n    assert issubclass(Out(A2), A2)\n    assert issubclass(Flip(A2), A2)\n    assert not issubclass(In(A2), Out(A2))\n    assert not issubclass(Out(A2), In(A2))\n\n    assert issubclass(Flip(In(A2)), Out(A2))\n    assert issubclass(Flip(Out(A2)), In(A2))\n\n    assert issubclass(Out(In(A2)), Out(A2))\n    assert issubclass(In(Out(A2)), In(A2))\n\n    assert not issubclass(Out(In(A2)), In(Out(A2)))\n    assert not issubclass(In(Out(A2)), Out(In(A2)))\n\n    assert not issubclass(Flip(In(A2)), Flip(Out(A2)))\n    assert not issubclass(Flip(Out(A2)), Flip(In(A2)))\n\n    assert isinstance(In(A2)(), A2)\n    assert isinstance(Out(A2)(), A2)\n    assert isinstance(Flip(A2)(), A2)\n    assert not isinstance(In(A2)(), Out(A2))\n    assert not isinstance(Out(A2)(), In(A2))\n\n    assert isinstance(Flip(In(A2))(), Out(A2))\n    assert isinstance(Flip(Out(A2))(), In(A2))\n\n    assert isinstance(Out(In(A2))(), Out(A2))\n    assert isinstance(In(Out(A2))(), In(A2))\n\n    assert not isinstance(Out(In(A2))(), In(Out(A2)))\n    assert not isinstance(In(Out(A2))(), Out(In(A2)))\n\n    assert not isinstance(Flip(In(A2))(), Flip(Out(A2)))\n    assert not isinstance(Flip(Out(A2))(), Flip(In(A2)))\n\n    #assert str(A2) == 'Tuple(x=Bit,y=Bit)'\n    assert A2 == A2\n\n    class B2(Product, cache=True):\n        x = In(Bit)\n        y = In(Bit)\n    assert isinstance(B2, ProductMeta)\n    #assert str(B2) == 'Tuple(x=In(Bit),y=In(Bit))'\n    assert B2 == B2\n\n    class C2(Product, cache=True):\n        x = Out(Bit)\n        y = Out(Bit)\n    assert isinstance(C2, ProductMeta)\n\n    #assert str(C2) == 'Tuple(x=Out(Bit),y=Out(Bit))'\n    assert C2 == C2\n\n    assert A2 == B2\n    assert A2 == C2\n    assert B2 == C2\n\n    assert A2 is not B2\n    assert A2 is not C2\n    assert B2 is not C2\n\n\ndef test_flip():\n    class Product2(Product):\n        x = In(Bit)\n        y = Out(Bit)\n    print(Product2)\n    print(Flip(Product2))\n\n    Tin = In(Product2)\n    Tout = Out(Product2)\n\n    print(Tin)\n    print(Tout)\n\n    assert Tin == Product2\n    assert Tout == Product2\n    assert Tin == Tout\n\n    assert Tin is not Product2\n    assert Tout is not Product2\n    assert Tin is not Tout\n\n    T = In(Tout)\n    assert T == Tin\n\n    #T = Flip(Tout)\n    #assert T == Tin\n    # print(T)\n\n    T = Out(Tin)\n    assert T == Tout\n\n    #T = Flip(Tin)\n    #assert T == Tout\n    # print(T)\n\n\ndef test_wire():\n    class Product2(Product):\n        x = Bit\n        y = Bit\n\n    t0 = Product2(name='t0')\n\n    t1 = Product2(name='t1')\n\n    wire(t0, t1)\n\n    assert t0.wired()\n    assert t1.wired()\n\n    assert t1.value() is t0\n    assert t0.value() is t1\n\n    assert t0.driving() == dict(x=[t1.x], y=[t1.y])\n\n    b0 = t0.x\n    b1 = t1.x\n\n    assert b0 is b1._wire.driver.bit\n    assert b1 is b0._wire.driving()[0]\n    assert b1.value() is b0\n\n\ndef test_val():\n    class A2(Product):\n        x = Bit\n        y = Bit\n\n    # constructor\n\n    a = A2(name='a')\n    print('created A2')\n    assert isinstance(a, Product)\n    assert str(a) == 'a'\n\n    # selectors\n\n    print('a[\"x\"]')\n    b = a['x']\n    assert isinstance(b, Bit)\n    assert str(b) == 'a.x'\n\n    print('a.x')\n    b = a.x\n    assert isinstance(b, Bit)\n    assert str(b) == 'a.x'\n\n\ndef test_nested():\n    # Test for https:\/\/github.com\/phanrahan\/magma\/issues\/445\n    def hierIO():\n        class dictIO(Product):\n            baseIO = make_baseIO()\n            ctr = m.In(m.Bit)\n        return dictIO\n\n    def DefineCtrModule():\n        class ctrModule(m.Circuit):\n            name = \"ctr_module\"\n            io = m.IO(ctr=m.In(m.Bit))\n        return ctrModule\n\n    def make_baseIO():\n        class dictIO(Product):\n            in0 = m.In(m.Bit),\n            out0 = m.Out(m.Bit)\n        return dictIO\n\n    def DefineBaseModule():\n        class baseModule(m.Circuit):\n            name = \"base_module\"\n            io = m.IO(baseIO=make_baseIO())\n        return baseModule\n\n    def DefineHier():\n        class HierModule(m.Circuit):\n            name = \"hier_module\"\n            io = m.IO(hier=hierIO())\n            baseM = DefineBaseModule()()\n            ctrM = DefineCtrModule()()\n            m.wire(baseM.baseIO, io.hier.baseIO)\n            m.wire(ctrM.ctr, io.hier.ctr)\n        return HierModule\n\n    baseMH = DefineHier()\n    m.compile(\"build\/baseMH\", baseMH, output=\"coreir-verilog\")\n\n\ndef test_tuple_nested_tuple_value():\n    def IFC0(params):\n        return m.Product.from_fields(\"IFC0\", {\n            \"port0\": m.In(m.Bits[params['param0']]),\n            \"port1\": m.In(m.Bits[params['param0']]),\n            \"port2\": m.In(m.Array[params['param0'], m.Bits[2]]),\n            \"port3\": m.In(m.Bits[params['param0']]),\n            \"port4\": m.In(m.Bit),\n            \"port5\": m.In(m.Bit),\n            \"port7\": m.In(m.Bit),\n            \"port8\": m.In(m.Bit),\n            \"port9\": m.In(m.Bit),\n            \"port10\": m.In(m.Bits[m.bitutils.clog2(params['param0'])]),\n        })\n\n    def IFC1(params):\n        dictOut = {\"port4\": m.Out(m.Bit)}\n        return m.Product.from_fields(\"IFC1\", dictOut)\n\n    def DefineMyCircuit(params):\n        class MyCircuit(m.Circuit):\n            io = m.IO(IFC0=IFC0(params).flip())\n        return MyCircuit\n\n    def DefineTop(params):\n        class Top(m.Circuit):\n            io = m.IO(IFC1=IFC1(params))\n            m.wire(io.IFC1.port4, DefineMyCircuit(params)().IFC0.port4)\n        return Top\n\n    m.compile(\"top\", DefineTop({'param0': 5}))\n\n\ndef test_flat_length():\n    a = m.Product.from_fields(\"anon\", dict(x=m.Bits[5], y=m.Bits[3], z=m.Bit))\n    assert a.flat_length() == 9\n\n\ndef test_anon_product():\n    product = m.Product.from_fields(\"anon\", dict(x=m.Bits[5], y=m.Bits[3], z=m.Bit))\n    assert isinstance(product, AnonymousProductMeta)\n    assert isinstance(product, ProductMeta)\n\n    anon_product = m.AnonProduct[dict(x=m.Bits[5], y=m.Bits[3], z=m.Bit)]\n    assert isinstance(anon_product, AnonymousProductMeta)\n    assert not isinstance(anon_product, ProductMeta)\n    assert anon_product.flat_length() == product.flat_length()\n    assert anon_product.x == product.x\n    assert anon_product.y == product.y\n    assert anon_product.z == product.z\n    assert anon_product == product\n    assert not anon_product is product\n","avg_line_length":26.0136054422,"max_line_length":84,"alphanum_fraction":0.5827667364,"licenses":["MIT"],"repository_name":"leonardt\/magma","path":"tests\/test_type\/test_tuple.py","size":7648,"lang":"Python"}
{"content":"ARG configuration\nARG NODE_IMAGE=node:8.11\n\nFROM microsoft\/dotnet:2.2-aspnetcore-runtime AS base\nWORKDIR \/app\nEXPOSE 80\n\nFROM microsoft\/dotnet:2.2-sdk as dotnet-build\nWORKDIR \/src\n\nFROM ${NODE_IMAGE} as node-build\nWORKDIR \/web\nCOPY src\/Web\/WebMVC .\nRUN npm install -g bower@1.8.4\nRUN bower install --allow-root\n\nFROM dotnet-build as build\nWORKDIR \/src\/src\/Web\/WebMVC\/wwwroot\nCOPY --from=node-build \/web\/wwwroot .\nWORKDIR \/src\nCOPY . .\nWORKDIR \/src\/src\/Web\/WebMVC\nRUN dotnet restore -nowarn:msb3202,nu1503\n\nFROM build AS publish\nARG configuration\nRUN dotnet publish --no-restore -c ${configuration} -o \/app\n\nFROM base AS final\nWORKDIR \/app\nCOPY --from=publish \/app .\nENTRYPOINT [\"dotnet\", \"WebMVC.dll\"]\n","avg_line_length":21.2727272727,"max_line_length":59,"alphanum_fraction":0.7635327635,"licenses":["MIT"],"repository_name":"balakrishnavalluri-gep\/eShopOnContainersAI","path":"src\/Web\/WebMVC\/Dockerfile","size":702,"lang":"Dockerfile"}
{"content":"# Reporting Security Issues\n\nPlease report any security issues you discovered to info@keplerjs.io\n\nIf you want to be sure of the communication you can use this [PGP public key](https:\/\/github.com\/stefanocudini\/stefanocudini\/blob\/master\/stefano-cudini.asc)\n\nWe will assess the risk, plus make a fix available before we create a GitHub issue.\n\nThank you for your contribution.\n","avg_line_length":37.5,"max_line_length":156,"alphanum_fraction":0.8,"licenses":["BSD-2-Clause"],"repository_name":"Keplerjs\/Kepler","path":"SECURITY.md","size":375,"lang":"Markdown"}
{"content":"\ufeffusing System;\nusing System.Collections;\nusing System.Globalization;\nusing System.IO;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nusing Shadowsocks.Encryption;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;\nusing System.Threading.Tasks;\nusing System.Security.Cryptography;\n\nnamespace Shadowsocks.Controller\n{\n    public class PACServer : Listener.Service\n    {\n        public const string PAC_FILE = \"pac.txt\";\n        public const string USER_RULE_FILE = \"user-rule.txt\";\n        public const string USER_ABP_FILE = \"abp.txt\";\n\n        private string PacSecret { get; set; } = \"\";\n\n        public string PacUrl { get; private set; } = \"\";\n\n        FileSystemWatcher PACFileWatcher;\n        FileSystemWatcher UserRuleFileWatcher;\n        private Configuration _config;\n\n        public event EventHandler PACFileChanged;\n        public event EventHandler UserRuleFileChanged;\n\n        public PACServer()\n        {\n            this.WatchPacFile();\n            this.WatchUserRuleFile();\n        }\n\n        public void UpdateConfiguration(Configuration config)\n        {\n            this._config = config;\n\n            if (config.secureLocalPac)\n            {\n                var rd = new byte[32];\n                RNG.GetBytes(rd);\n                PacSecret = $\"&secret={Convert.ToBase64String(rd)}\";\n            }\n            else\n            {\n                PacSecret = \"\";\n            }\n\n            PacUrl = $\"http:\/\/{config.localHost}:{config.localPort}\/pac?t={GetTimestamp(DateTime.Now)}{PacSecret}\";\n        }\n\n\n        private static string GetTimestamp(DateTime value)\n        {\n            return value.ToString(\"yyyyMMddHHmmssfff\");\n        }\n\n        public override bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            if (socket.ProtocolType != ProtocolType.Tcp)\n            {\n                return false;\n            }\n            try\n            {\n                string request = Encoding.UTF8.GetString(firstPacket, 0, length);\n                string[] lines = request.Split('\\r', '\\n');\n                bool hostMatch = false, pathMatch = false, useSocks = false;\n                bool secretMatch = PacSecret.IsNullOrEmpty();\n                foreach (string line in lines)\n                {\n                    string[] kv = line.Split(new char[] { ':' }, 2);\n                    if (kv.Length == 2)\n                    {\n                        if (kv[0] == \"Host\")\n                        {\n                            if (kv[1].Trim() == ((IPEndPoint)socket.LocalEndPoint).ToString())\n                            {\n                                hostMatch = true;\n                            }\n                        }\n                        \/\/else if (kv[0] == \"User-Agent\")\n                        \/\/{\n                        \/\/    \/\/ we need to drop connections when changing servers\n                        \/\/    if (kv[1].IndexOf(\"Chrome\") >= 0)\n                        \/\/    {\n                        \/\/        useSocks = true;\n                        \/\/    }\n                        \/\/}\n                    }\n                    else if (kv.Length == 1)\n                    {\n                        if (line.IndexOf(\"pac\", StringComparison.Ordinal) >= 0)\n                        {\n                            pathMatch = true;\n                        }\n                        if (!secretMatch)\n                        {\n                            if (line.IndexOf(PacSecret, StringComparison.Ordinal) >= 0)\n                            {\n                                secretMatch = true;\n                            }\n                        }\n                    }\n                }\n                if (hostMatch && pathMatch)\n                {\n                    if (!secretMatch)\n                    {\n                        socket.Close(); \/\/ Close immediately\n                    }\n                    else\n                    {\n                        SendResponse(socket, useSocks);\n                    }\n                    return true;\n                }\n                return false;\n            }\n            catch (ArgumentException)\n            {\n                return false;\n            }\n        }\n\n        public string TouchPACFile()\n        {\n            if (File.Exists(PAC_FILE))\n            {\n                return PAC_FILE;\n            }\n            else\n            {\n                FileManager.UncompressFile(PAC_FILE, Resources.proxy_pac_txt);\n                return PAC_FILE;\n            }\n        }\n\n        internal string TouchUserRuleFile()\n        {\n            if (File.Exists(USER_RULE_FILE))\n            {\n                return USER_RULE_FILE;\n            }\n            else\n            {\n                File.WriteAllText(USER_RULE_FILE, Resources.user_rule);\n                return USER_RULE_FILE;\n            }\n        }\n        protected string ToHexString(byte[] bytes)\n        {\n            string hexString = string.Empty;\n            if (bytes != null)\n            {\n                StringBuilder str = new StringBuilder();\n\n                for (int i = 0; i < bytes.Length; i++)\n                {\n                    str.Append(bytes[i].ToString(\"X2\"));\n                }\n                hexString = str.ToString();\n            }\n            return hexString;\n        }\n\n        private string GetPACContent()\n        {\n            \/\/PAC_FILE\n            if (File.Exists(PAC_FILE))\n            {\n                return File.ReadAllText(PAC_FILE, Encoding.UTF8); \n            }\n            else\n            {\n                return Utils.UnGzip(Resources.proxy_pac_txt);\n            }\n        }\n\n        public void SendResponse(Socket socket, bool useSocks)\n        {\n            try\n            {\n                IPEndPoint localEndPoint = (IPEndPoint)socket.LocalEndPoint;\n\n                string proxy = GetPACAddress(localEndPoint, useSocks);\n\n                string pacContent = GetPACContent().Replace(\"__PROXY__\", proxy);\n\n                string responseHead = String.Format(@\"HTTP\/1.1 200 OK\nServer: Shadowsocks\nContent-Type: application\/x-ns-proxy-autoconfig\nContent-Length: {0}\nConnection: Close\n\n\", Encoding.UTF8.GetBytes(pacContent).Length);\n                byte[] response = Encoding.UTF8.GetBytes(responseHead + pacContent);\n                socket.BeginSend(response, 0, response.Length, 0, new AsyncCallback(SendCallback), socket);\n                Utils.ReleaseMemory(true);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                socket.Close();\n            }\n        }\n\n        private void SendCallback(IAsyncResult ar)\n        {\n            Socket conn = (Socket)ar.AsyncState;\n            try\n            {\n                conn.Shutdown(SocketShutdown.Send);\n            }\n            catch\n            { }\n        }\n\n        private void WatchPacFile()\n        {\n            PACFileWatcher?.Dispose();\n            PACFileWatcher = new FileSystemWatcher(Directory.GetCurrentDirectory());\n            PACFileWatcher.NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.FileName | NotifyFilters.DirectoryName;\n            PACFileWatcher.Filter = PAC_FILE;\n            PACFileWatcher.Changed += PACFileWatcher_Changed;\n            PACFileWatcher.Created += PACFileWatcher_Changed;\n            PACFileWatcher.Deleted += PACFileWatcher_Changed;\n            PACFileWatcher.Renamed += PACFileWatcher_Changed;\n            PACFileWatcher.EnableRaisingEvents = true;\n        }\n\n        private void WatchUserRuleFile()\n        {\n            UserRuleFileWatcher?.Dispose();\n            UserRuleFileWatcher = new FileSystemWatcher(Directory.GetCurrentDirectory());\n            UserRuleFileWatcher.NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.FileName | NotifyFilters.DirectoryName;\n            UserRuleFileWatcher.Filter = USER_RULE_FILE;\n            UserRuleFileWatcher.Changed += UserRuleFileWatcher_Changed;\n            UserRuleFileWatcher.Created += UserRuleFileWatcher_Changed;\n            UserRuleFileWatcher.Deleted += UserRuleFileWatcher_Changed;\n            UserRuleFileWatcher.Renamed += UserRuleFileWatcher_Changed;\n            UserRuleFileWatcher.EnableRaisingEvents = true;\n        }\n\n        #region FileSystemWatcher.OnChanged()\n        \/\/ FileSystemWatcher Changed event is raised twice\n        \/\/ http:\/\/stackoverflow.com\/questions\/1764809\/filesystemwatcher-changed-event-is-raised-twice\n        \/\/ Add a short delay to avoid raise event twice in a short period\n        private void PACFileWatcher_Changed(object sender, FileSystemEventArgs e)\n        {\n            if (PACFileChanged != null)\n            {\n                Logging.Info($\"Detected: PAC file '{e.Name}' was {e.ChangeType.ToString().ToLower()}.\");\n                Task.Factory.StartNew(() =>\n                {\n                    ((FileSystemWatcher)sender).EnableRaisingEvents = false;\n                    System.Threading.Thread.Sleep(10);\n                    PACFileChanged(this, new EventArgs());\n                    ((FileSystemWatcher)sender).EnableRaisingEvents = true;\n                });\n            }\n        }\n\n        private void UserRuleFileWatcher_Changed(object sender, FileSystemEventArgs e)\n        {\n            if (UserRuleFileChanged != null)\n            {\n                Logging.Info($\"Detected: User Rule file '{e.Name}' was {e.ChangeType.ToString().ToLower()}.\");\n                Task.Factory.StartNew(() =>\n                {\n                    ((FileSystemWatcher)sender).EnableRaisingEvents = false;\n                    System.Threading.Thread.Sleep(10);\n                    UserRuleFileChanged(this, new EventArgs());\n                    ((FileSystemWatcher)sender).EnableRaisingEvents = true;\n                });\n            }\n        }\n        #endregion\n\n        private string GetPACAddress(IPEndPoint localEndPoint, bool useSocks)\n        {\n            return localEndPoint.AddressFamily == AddressFamily.InterNetworkV6\n                ? $\"{(useSocks ? \"SOCKS5\" : \"PROXY\")} [{localEndPoint.Address}]:{_config.localPort};\"\n                : $\"{(useSocks ? \"SOCKS5\" : \"PROXY\")} {localEndPoint.Address}:{_config.localPort};\";\n        }\n    }\n}\n","avg_line_length":34.7653061224,"max_line_length":126,"alphanum_fraction":0.5029840524,"licenses":["Apache-2.0"],"repository_name":"GinaCSF\/CSFSecurity","path":"shadowsocks-csharp\/Controller\/Service\/PACServer.cs","size":10223,"lang":"C#"}
{"content":"; A093039: Sequence resulting from a sum of three repeated binomial(n+3,4) sequences.\n; 1,2,7,11,25,35,65,85,140,175,266,322,462,546,750,870,1155,1320,1705,1925,2431,2717,3367,3731,4550,5005,6020,6580,7820,8500,9996,10812,12597,13566,15675,16815,19285,20615,23485,25025,28336,30107,33902\n\nmov $1,$0\nadd $1,$0\nadd $0,$1\ndiv $0,2\nseq $0,189374 ; Expansion of 1\/((1-x)^5*(x^2+x+1)^3).\n","avg_line_length":42.4444444444,"max_line_length":201,"alphanum_fraction":0.7172774869,"licenses":["Apache-2.0"],"repository_name":"ckrause\/cm","path":"programs\/oeis\/093\/A093039.asm","size":382,"lang":"Assembly"}
{"content":"#Sets the Escrow Passphrase for an Edge Appliance. Beginning with 9.3, escrow passphrases are required for customers that escrow encyrption keys with Nasuni.\n\n#populate NMC hostname and credentials\n$hostname = \"insertNMChostnameHere\"\n \n#Path to the NMC API authentication token input file\n$tokenFile = \"c:\\nasuni\\token.txt\"\n \n#specify Edge Appliance serial number\n$filer_serial_number = \"insertSerial\"\n\n#specify the Escrow Passphrase\n$EscrowPassphrase = 'insertPassphrase'\n\n#end variables\n\n#function for error\n#Error Handling function - must appear in the script before it is referenced\nfunction Failure {\n    if ( $PSVersionTable.PSVersion.Major -lt 6) { #PowerShell 5 and earlier\n    $global:result = $_.Exception.Response.GetResponseStream()\n    $global:reader = New-Object System.IO.StreamReader($global:result)\n    $global:responseBody = $global:reader.ReadToEnd();\n    Write-Host -BackgroundColor:Black -ForegroundColor:Red \"Status: A system exception was caught.\"\n    Write-Host -BackgroundColor:Black -ForegroundColor:Red $global:responsebody\n    Write-Host -BackgroundColor:Black -ForegroundColor:Red \"The request body has been saved to `$global:helpme\"($result)\n    } else { #PowerShell 6 or higher lack support for GetResponseStream\n$Message =  $_.ErrorDetails.Message;\nWrite-Host (\"Message: \"+ $Message)\n}\n}\n\n#Request token and build connection headers\n# Allow untrusted SSL certs\nif ($PSVersionTable.PSEdition -eq 'Core') #PowerShell Core\n{\n\tif ($PSDefaultParameterValues.Contains('Invoke-RestMethod:SkipCertificateCheck')) {}\n\telse {\n\t\t$PSDefaultParameterValues.Add('Invoke-RestMethod:SkipCertificateCheck', $true)\n\t}\n}\nelse #other versions of PowerShell\n{if (\"TrustAllCertsPolicy\" -as [type]) {} else {\t\t\n\t\nAdd-Type -TypeDefinition @\"\nusing System.Net;\nusing System.Security.Cryptography.X509Certificates;\npublic class TrustAllCertsPolicy : ICertificatePolicy {\n\tpublic bool CheckValidationResult(\n\t\tServicePoint srvPoint, X509Certificate certificate,\n\t\tWebRequest request, int certificateProblem) {\n\t\treturn true;\n\t}\n}\n\"@\n[System.Net.ServicePointManager]::CertificatePolicy = New-Object -TypeName TrustAllCertsPolicy\n\n#set the correct TLS Type\n[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\n } }\n \n#build JSON headers\n$headers = New-Object \"System.Collections.Generic.Dictionary[[String],[String]]\"\n$headers.Add(\"Accept\", 'application\/json')\n$headers.Add(\"Content-Type\", 'application\/json')\n  \n#Read the token from a file and add it to the headers for the request\n$token = Get-Content $tokenFile\n$headers.Add(\"Authorization\",\"Token \" + $token)\n \n#Set the URL for the escrow passphrase\n$SetEscrowURL=\"https:\/\/\"+$hostname+\"\/api\/v1.1\/filers\/\"+$filer_serial_number+\"\/\"\n \n#body for setting the escrow passphrase\n$body = @\"\n{\n    \"settings\": {\n        \"escrow_passphrase\": \"$EscrowPassphrase\"\n    }\n}\n\"@\n\n#set the escrow passphrase\ntry { $response=Invoke-RestMethod -Uri $SetEscrowUrl -Method Patch -Headers $headers -Body $body} catch {Failure}\nwrite-output $response | ConvertTo-Json\n","avg_line_length":35.2209302326,"max_line_length":157,"alphanum_fraction":0.7616375041,"licenses":["MIT"],"repository_name":"nasuni-labs\/nasuni-nmcapi-powershell-utilities","path":"Operations\/SetEscrowPassphrase.ps1","size":3029,"lang":"PowerShell"}
{"content":"=head1 LICENSE\n\nCopyright [1999-2015] Wellcome Trust Sanger Institute and the EMBL-European Bioinformatics Institute \nCopyright [2016-2022] EMBL-European Bioinformatics Institute\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n=cut\n\npackage EnsEMBL::REST::Model::ga4gh::variants;\n\nuse Moose;\nextends 'Catalyst::Model';\nuse Scalar::Util qw\/weaken\/;\nuse Catalyst::Exception;\n\nuse Bio::EnsEMBL::IO::Parser::VCF4Tabix;\nuse Bio::EnsEMBL::Variation::DBSQL::VCFCollectionAdaptor;\nuse Bio::EnsEMBL::Variation::VariationFeature;\nuse Bio::EnsEMBL::Variation::DBSQL::VariationFeatureAdaptor;\nuse EnsEMBL::REST::Model::ga4gh::ga4gh_utils;\n\n\nwith 'Catalyst::Component::InstancePerContext';\n\nhas 'context' => (is => 'ro', weak_ref => 1);\n\n\n\n=head2\n\nNow mapping ensembl source        => GA4GH dataset\n                    VCFcollection => variationSet\n\n=cut\n\nsub build_per_context_instance {\n  my ($self, $c, @args) = @_;\n  weaken($c);\n  return $self->new({ context => $c, %$self, @args });\n}\n\nsub fetch_gavariant {\n\n  my ($self, $data ) = @_; \n\n  return ({ \"variants\"      => [],\n            \"nextPageToken\" => $data->{pageToken}\n          }) if $data->{pageSize} < 1;\n\n  ## get the VCF collection object for the required set\n  $data->{vcf_collection} =  $self->context->model('ga4gh::ga4gh_utils')->fetch_VCFcollection_by_id($data->{variantSetId});\n  Catalyst::Exception->throw( \" Failed to find the specified variantSetId\")\n    unless defined $data->{vcf_collection}; \n\n  ## format sample names if filtering by sample required\n  $data->{req_samples} = $self->check_sample_info($data->{callSetIds}) if defined $data->{callSetIds}->[0] ;\n\n  ## get genotype data - pull out set by region & filter on variant name if supplied\n  return $self->fetch_by_region($data);\n\n}\n\n## format sample names if filtering by sample required\n## callSetIds = VariantSetID:samplename\nsub check_sample_info{\n\n  my ($self, $callSetIds ) = @_;\n\n  my %req_samples; \n\n  foreach my $callsetId ( @{$callSetIds} ){\n    my $sample = (split\/\\:\/,$callsetId)[1];\n    $req_samples{$sample} = 1;\n  }\n\n  return \\%req_samples;\n}\n\n\nsub fetch_by_region{\n\n  my $self = shift;\n  my $data = shift;\n\n  ## if this is a new request set first token to start of region \n  $data->{pageToken} = $data->{start} unless exists  $data->{pageToken} && $data->{pageToken} =~\/\\d+\/;\n\n\n  ## get the next range of variation data for the token - should return slightly more than required\n  my ($var_info, $next_token)  = $self->get_next_by_token($data);\n\n\n  return ({ \"variants\"      => $var_info,\n            \"nextPageToken\" => $next_token\n          });\n  \n}\n\n=head2 sort_genotypes\n\n  extract genotypes & apply filtering \n\n  input:  array of strings - format : 'NA10000:0|1:44:23'\n  output: array of individual genotype hashes\n=cut\nsub sort_genotypes {\n  my ($self, $parser, $data, $is_remapped) = @_;\n\n\n  my $geno_strings  = $parser->get_samples_info();\n\n  my @genotypes;\n\n  foreach my $sample(keys %{$geno_strings}){\n\n    ## filter by individual if required\n    next if defined $data->{callSetIds}->[0] && \n      !defined $data->{req_samples}->{$sample};\n\n    my $gen_hash;\n    $gen_hash->{callSetId}    =  $data->{variantSetId} .\":\". $sample;\n    $gen_hash->{callSetName}  = $sample;\n\n    my @g = split\/\\||\\\/\/, $geno_strings->{$sample}->{GT};\n    foreach my $g(@g){\n      ## force genotype to be numeric\n      push @{$gen_hash->{genotype}}, numeric($g);\n    } \n\n    ## place holders\n    $gen_hash->{phaseset}           = '';\n    $gen_hash->{genotypeLikelihood} = [];\n    $gen_hash->{info}               = {};\n    \n    unless( $is_remapped ){\n      ## meta data may not be relevant if variant remapped rather than recalled\n      foreach my $inf (keys %{$geno_strings->{$sample}} ){\n        next if $inf eq 'GT';\n        if( $inf eq 'GL'){\n          my @gl = split\/\\,\/, $geno_strings->{$sample}->{GL};\n          foreach my $gl (@gl){\n            push @{$gen_hash->{genotypeLikelihood}}, numeric($gl);\n          }\n        }\n        else{\n          if( $geno_strings->{$sample}->{$inf} =~\/\\,\/){\n            @{$gen_hash->{info}->{$inf}} = split\/\\,\/, $geno_strings->{$sample}->{$inf};\n          }\n          else{ \n            $gen_hash->{info}->{$inf} = [$geno_strings->{$sample}->{$inf}];\n          }\n        }\n      }\n    }\n\n    push @genotypes, $gen_hash;\n\n  }\n  return \\@genotypes;\n}\n\n\n## extract a batch of results for request and hold new start pos in token string\nsub get_next_by_token{\n\n  my ($self, $data) = @_;\n\n\n  ## look up filename from vcf collection object\n  my $file  =  $data->{vcf_collection}->filename_template();\n\n  $file =~ s\/\\#\\#\\#CHR\\#\\#\\#\/$data->{referenceName}\/;\n\n  # return these ordered by position for simple pagination\n  my @var;\n  my $nextToken;\n\n  ## exits here if unsupported chromosome requested\n  return (\\@var, $nextToken) unless -e $file;\n\n  my $parser = Bio::EnsEMBL::IO::Parser::VCF4Tabix->open( $file ) || die \"Failed to get parser : $!\\n\";\n  $parser->seek($data->{referenceName}, $data->{pageToken}, $data->{end});\n\n  my $n = 0;\n\n  while($n < ($data->{pageSize} + 1)){\n\n    my $got_something = $parser->next();\n    last if $got_something ==0;\n\n    my $name = $parser->get_IDs->[0];\n    ## create placeholder name if not supplied\n    $name = $parser->get_seqname .\"_\". $parser->get_raw_start if $name eq \".\" ;\n\n    if ($n == $data->{pageSize} ){\n      ## batch complete \n      ## save next position for new page token\n      $nextToken = $parser->get_raw_start -1;\n      last;\n    }\n\n\n    ## add filter for variant name if required\n    next if defined $data->{variantName} && $data->{variantName} =~\/\\w+\/ &&  $data->{variantName} ne $name;\n\n    next if $name=~ \/esv\/; ##skip these for now\n\n    ## format array of genotypes\n    my $genotype_calls = [];\n    $genotype_calls = $self->sort_genotypes($parser, $data, $data->{vcf_collection}->{is_remapped})\n      unless $data->{variantSetId} =~\/11|12\/;  ## hack for compliance suite\n\n    $n++;\n    my $variation_hash;\n\n    $variation_hash->{variantSetId}    = $data->{variantSetId};\n    $variation_hash->{calls}           = $genotype_calls;\n\n    $variation_hash->{names}           = [ $name ];\n    $variation_hash->{id}              = $data->{variantSetId} .\":\".$name;\n    $variation_hash->{referenceBases}  = $parser->get_reference;\n    $variation_hash->{alternateBases}  = \\@{$parser->get_alternatives};\n    $variation_hash->{referenceName}   = $parser->get_seqname ;\n\n    ## position is zero-based + closed start of interval \n    $variation_hash->{start}           = numeric($parser->get_raw_start - 1);\n    ## open end of interval\n    $variation_hash->{end}             = numeric($parser->get_raw_end);\n\n    $variation_hash->{created}         = $data->{vcf_collection}->created || undef;\n    $variation_hash->{updated}         = $data->{vcf_collection}->updated || undef; \n\n\n    ## What can be trusted if variants re-mapped but not re-called? Start with: AC, AF, AN\n    my $var_info = $parser->get_info();\n    if( $data->{vcf_collection}->{is_remapped} || $data->{variantSetId} =~ \/11|12\/){ ## hack for compliance suite ){\n      $variation_hash->{info} = { AC => [$var_info->{AC}],\n                                  AN => [$var_info->{AN}],\n                                  AF => [$var_info->{AF}]\n                                };\n    }\n    else{\n      foreach my $k (keys %{$var_info}){\n        $variation_hash->{info}->{$k}  =  [$var_info->{$k}];\n      }\n    }\n\n     push @var, $variation_hash;\n\n   \n    ## exit if single required variant already found\n    last if defined $data->{variantName} && $data->{variantName} =~\/\\w+\/;\n  }\n\n\n  $parser->close();\n\n  return (\\@var, $nextToken) ;\n\n}\n\n\n=head2 getVariant\n\n  Gets a Variant by ID.\n  GET \/variants\/{id} will return a JSON version of Variant.\n  id is currently variantset_id:variantname\n=cut\n\nsub getVariant{\n\n  my ($self, $id ) = @_; \n\n  my $c = $self->context();\n  my $species = \"homo_sapiens\"; \n  my $varfeat;\n\n  my $va  = $c->model('Registry')->get_adaptor($species, 'Variation', 'Variation');\n  my $vfa = $c->model('Registry')->get_adaptor($species, 'Variation', 'VariationFeature');\n\n  $vfa->db->include_failed_variations(0); ## don't extract multi-mapping variants\n \n  my ($variantSetId, $variantId) = split\/\\:\/, $id;\n\n  ## nameless compliance variants\n  if( $variantSetId =~\/11|12\/){\n    return $self->get_compliance_variant( $variantSetId, $variantId); \n  }\n  ## look up position in ensembl db \n  my $var = $va->fetch_by_name($variantId);\n  my $vf  = $vfa->fetch_all_by_Variation($var) if defined $var;  \n\n  if (defined $vf->[0]) {\n    $varfeat = $vf->[0];\n\n    ## return genotype data \n    my $var_info = $self->getSingleCallSets($vf->[0], $variantSetId, $variantId);\n \n    return ( $var_info->[0] ) if exists $var_info->[0]->{id} ;   \n  }\n  elsif($id =~\/\\w+\\:c\\.\\w+|\\w+\\:g\\.\\w+|\\w+\\:p\\.\\w+\/ ){\n    ## try to look up as HGVS\n    eval { $varfeat = $vfa->fetch_by_hgvs_notation( $id ) };\n  }\n  \n  ## Send 404 for non-existant ids\n  return unless defined $varfeat;  \n\n  ## return basic location info if available\n\n  my $variation_hash;\n\n  my @als = split\/\\\/\/, $varfeat->allele_string();\n  shift @als; ## remove reference allele\n  $variation_hash->{name}            = $varfeat->variation_name();\n  $variation_hash->{id}              = $id;\n  $variation_hash->{referenceBases}  = $varfeat->ref_allele_string();\n  $variation_hash->{alternateBases}  = \\@als;\n  $variation_hash->{referenceName}   = $varfeat->seq_region_name();\n\n  ## position is zero-based + closed start of interval \n  $variation_hash->{start}           = $varfeat->seq_region_start() -1;\n  ## open end of interval\n  $variation_hash->{end}             = $varfeat->seq_region_end();\n\n  $variation_hash->{created}         = '';\n  $variation_hash->{updated}         = '';\n\n  return $variation_hash;\n}\n\n=head2 getSingleCallSets\n\nlook up a default set of genotypes if queried by id\n\n=cut\nsub getSingleCallSets{\n\n my ($self, $varfeat, $variantSetId, $varname ) = @_;\n\n  my $data;\n  $data->{referenceName} = $varfeat->seq_region_name();\n  $data->{start}         = $varfeat->seq_region_start() -2;\n  $data->{end}           = $varfeat->seq_region_end();\n  $data->{variantSetId}  = $variantSetId;\n  $data->{variantName}   = $varname; ## check for supplied name not current database mane\n\n\n  ## hack for compliance data - create as fake ALT??\n  if($variantSetId ==10){\n    $data->{start} = $data->{start} - 41196312;\n    $data->{end }  = $data->{end} - 41196312;\n    $data->{referenceName} = \"ref_brca1\";\n  }\n\n  ## load VCFcollections object for variantSet \n  $data->{vcf_collection} = $self->context->model('ga4gh::ga4gh_utils')->fetch_VCFcollection_by_id($data->{variantSetId});\n\n  return unless defined $data->{vcf_collection}; \n\n  ## create fake token -what should really be returned for get??\n  $data->{pageSize} = 1;\n  $data->{pageToken} = $data->{start};\n\n  my ($var_info, $next_ds) = $self->get_next_by_token($data);\n\n  ## exit if none found\n  Catalyst::Exception->throw(\" No variants are available for this region\"  )\n     unless defined $var_info ;\n\n  return $var_info;\n\n}\n\n## nameless (fake?) variants not in the database\n## id is based on chrom and location\n## create private GA4GH database?\nsub get_compliance_variant{\n\n  my ($self, $variantSetId, $varname ) = @_;\n\n  return unless $variantSetId ==11 || $variantSetId ==12;\n\n  ## create post style input structure\n  my $data;\n  my ($chr, $pos) = split\/\\_\/, $varname ;\n\n  $data->{start}         = $pos - 1;\n  $data->{end }          = $pos;\n  $data->{referenceName} = $chr;\n  $data->{variantSetId}  = $variantSetId; \n\n  ## load VCFcollections object for variantSet \n  $data->{vcf_collection} = $self->context->model('ga4gh::ga4gh_utils')->fetch_VCFcollection_by_id($data->{variantSetId});\n  Catalyst::Exception->throw( \" Failed to find the specified variantSetId\")\n    unless defined $data->{vcf_collection};  \n \n\n  ## create fake token\n  $data->{pageSize} = 1;\n  $data->{pageToken} = $data->{start};\n\n  my ($var_info, $next_ds) = $self->get_next_by_token($data);\n\n  ## exit if none found\n  Catalyst::Exception->throw(\" No variant $varname available \" )\n     unless defined $var_info ;\n\n  return $var_info->[0];\n}\n\nsub numeric{\n  my $string = shift;\n  return $string * 1;\n}\n\n\nwith 'EnsEMBL::REST::Role::Content';\n\n__PACKAGE__->meta->make_immutable;\n\n1;\n","avg_line_length":29.301843318,"max_line_length":123,"alphanum_fraction":0.6249901706,"licenses":["Apache-2.0"],"repository_name":"nuno-agostinho\/ensembl-rest","path":"lib\/EnsEMBL\/REST\/Model\/ga4gh\/variants.pm","size":12717,"lang":"Perl"}
{"content":"\/\/ Copyright (c) 2011-2015 The Bitcoin Core developers\n\/\/ Distributed under the MIT software license, see the accompanying\n\/\/ file COPYING or http:\/\/www.opensource.org\/licenses\/mit-license.php.\n\n#include \"transactionview.h\"\n\n#include \"addresstablemodel.h\"\n#include \"kazusilverunits.h\"\n#include \"csvmodelwriter.h\"\n#include \"editaddressdialog.h\"\n#include \"guiutil.h\"\n#include \"optionsmodel.h\"\n#include \"platformstyle.h\"\n#include \"transactiondescdialog.h\"\n#include \"transactionfilterproxy.h\"\n#include \"transactionrecord.h\"\n#include \"transactiontablemodel.h\"\n#include \"walletmodel.h\"\n\n#include \"ui_interface.h\"\n\n#include <QComboBox>\n#include <QDateTimeEdit>\n#include <QDesktopServices>\n#include <QDoubleValidator>\n#include <QHBoxLayout>\n#include <QHeaderView>\n#include <QLabel>\n#include <QLineEdit>\n#include <QMenu>\n#include <QPoint>\n#include <QScrollBar>\n#include <QSignalMapper>\n#include <QTableView>\n#include <QUrl>\n#include <QVBoxLayout>\n\nTransactionView::TransactionView(const PlatformStyle *platformStyle, QWidget *parent) :\n    QWidget(parent), model(0), transactionProxyModel(0),\n    transactionView(0), abandonAction(0)\n{\n    \/\/ Build filter row\n    setContentsMargins(0,0,0,0);\n\n    QHBoxLayout *hlayout = new QHBoxLayout();\n    hlayout->setContentsMargins(0,0,0,6);\n\n    if (platformStyle->getUseExtraSpacing()) {\n        hlayout->setSpacing(10);\n        hlayout->addSpacing(26);\n    } else {\n        hlayout->setSpacing(5);\n        hlayout->addSpacing(23);\n    }\n\n    watchOnlyWidget = new QComboBox(this);\n    watchOnlyWidget->setFixedWidth(24);\n    watchOnlyWidget->addItem(\"\", TransactionFilterProxy::WatchOnlyFilter_All);\n    watchOnlyWidget->addItem(platformStyle->SingleColorIcon(\":\/icons\/eye_plus\"), \"\", TransactionFilterProxy::WatchOnlyFilter_Yes);\n    watchOnlyWidget->addItem(platformStyle->SingleColorIcon(\":\/icons\/eye_minus\"), \"\", TransactionFilterProxy::WatchOnlyFilter_No);\n    hlayout->addWidget(watchOnlyWidget);\n\n    dateWidget = new QComboBox(this);\n    if (platformStyle->getUseExtraSpacing()) {\n        dateWidget->setFixedWidth(121);\n    } else {\n        dateWidget->setFixedWidth(120);\n    }\n    dateWidget->addItem(tr(\"All\"), All);\n    dateWidget->addItem(tr(\"Today\"), Today);\n    dateWidget->addItem(tr(\"This week\"), ThisWeek);\n    dateWidget->addItem(tr(\"This month\"), ThisMonth);\n    dateWidget->addItem(tr(\"Last month\"), LastMonth);\n    dateWidget->addItem(tr(\"This year\"), ThisYear);\n    dateWidget->addItem(tr(\"Range...\"), Range);\n    hlayout->addWidget(dateWidget);\n\n    typeWidget = new QComboBox(this);\n    if (platformStyle->getUseExtraSpacing()) {\n        typeWidget->setFixedWidth(121);\n    } else {\n        typeWidget->setFixedWidth(120);\n    }\n\n    typeWidget->addItem(tr(\"All\"), TransactionFilterProxy::ALL_TYPES);\n    typeWidget->addItem(tr(\"Received with\"), TransactionFilterProxy::TYPE(TransactionRecord::RecvWithAddress) |\n                                        TransactionFilterProxy::TYPE(TransactionRecord::RecvFromOther) |\n                                        TransactionFilterProxy::TYPE(TransactionRecord::CFundPayment));\n    typeWidget->addItem(tr(\"Sent to\"), TransactionFilterProxy::TYPE(TransactionRecord::SendToAddress) |\n                                  TransactionFilterProxy::TYPE(TransactionRecord::SendToOther) |\n                                  TransactionFilterProxy::TYPE(TransactionRecord::CFund));\n    typeWidget->addItem(tr(\"To yourself\"), TransactionFilterProxy::TYPE(TransactionRecord::SendToSelf));\n    typeWidget->addItem(tr(\"Staked\/generated\"), (TransactionFilterProxy::TYPE(TransactionRecord::Generated) |\n                        TransactionFilterProxy::TYPE(TransactionRecord::Staked)));\n    typeWidget->addItem(tr(\"Community Fund\"), TransactionFilterProxy::TYPE(TransactionRecord::CFund) |\n                        TransactionFilterProxy::TYPE(TransactionRecord::CFundPayment));\n    typeWidget->addItem(tr(\"Other\"), TransactionFilterProxy::TYPE(TransactionRecord::Other));\n\n    hlayout->addWidget(typeWidget);\n\n    addressWidget = new QLineEdit(this);\n#if QT_VERSION >= 0x040700\n    addressWidget->setPlaceholderText(tr(\"Enter address or label to search\"));\n#endif\n    hlayout->addWidget(addressWidget);\n\n    amountWidget = new QLineEdit(this);\n#if QT_VERSION >= 0x040700\n    amountWidget->setPlaceholderText(tr(\"Min amount\"));\n#endif\n    if (platformStyle->getUseExtraSpacing()) {\n        amountWidget->setFixedWidth(115);\n    } else {\n        amountWidget->setFixedWidth(120);\n    }\n    amountWidget->setValidator(new QDoubleValidator(0, 1e20, 8, this));\n    hlayout->addWidget(amountWidget);\n\n    QVBoxLayout *vlayout = new QVBoxLayout(this);\n    vlayout->setContentsMargins(0,0,0,0);\n    vlayout->setSpacing(0);\n\n    QTableView *view = new QTableView(this);\n    vlayout->addLayout(hlayout);\n    vlayout->addWidget(createDateRangeWidget());\n    vlayout->addWidget(view);\n    vlayout->setSpacing(0);\n    int width = view->verticalScrollBar()->sizeHint().width();\n    \/\/ Cover scroll bar width with spacing\n    if (platformStyle->getUseExtraSpacing()) {\n        hlayout->addSpacing(width+2);\n    } else {\n        hlayout->addSpacing(width);\n    }\n    \/\/ Always show scroll bar\n    view->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOn);\n    view->setTabKeyNavigation(false);\n    view->setContextMenuPolicy(Qt::CustomContextMenu);\n\n    view->installEventFilter(this);\n\n    transactionView = view;\n\n    \/\/ Actions\n    abandonAction = new QAction(tr(\"Abandon transaction\"), this);\n    QAction *copyAddressAction = new QAction(tr(\"Copy address\"), this);\n    QAction *copyLabelAction = new QAction(tr(\"Copy label\"), this);\n    QAction *copyAmountAction = new QAction(tr(\"Copy amount\"), this);\n    QAction *copyTxIDAction = new QAction(tr(\"Copy transaction ID\"), this);\n    QAction *copyTxHexAction = new QAction(tr(\"Copy raw transaction\"), this);\n    QAction *copyTxPlainText = new QAction(tr(\"Copy full transaction details\"), this);\n    QAction *editLabelAction = new QAction(tr(\"Edit label\"), this);\n    QAction *showDetailsAction = new QAction(tr(\"Show transaction details\"), this);\n\n    contextMenu = new QMenu();\n    contextMenu->addAction(copyAddressAction);\n    contextMenu->addAction(copyLabelAction);\n    contextMenu->addAction(copyAmountAction);\n    contextMenu->addAction(copyTxIDAction);\n    contextMenu->addAction(copyTxHexAction);\n    contextMenu->addAction(copyTxPlainText);\n    contextMenu->addAction(showDetailsAction);\n    contextMenu->addSeparator();\n    contextMenu->addAction(abandonAction);\n    contextMenu->addAction(editLabelAction);\n\n    mapperThirdPartyTxUrls = new QSignalMapper(this);\n\n    \/\/ Connect actions\n    connect(mapperThirdPartyTxUrls, SIGNAL(mapped(QString)), this, SLOT(openThirdPartyTxUrl(QString)));\n\n    connect(dateWidget, SIGNAL(activated(int)), this, SLOT(chooseDate(int)));\n    connect(typeWidget, SIGNAL(activated(int)), this, SLOT(chooseType(int)));\n    connect(watchOnlyWidget, SIGNAL(activated(int)), this, SLOT(chooseWatchonly(int)));\n    connect(addressWidget, SIGNAL(textChanged(QString)), this, SLOT(changedPrefix(QString)));\n    connect(amountWidget, SIGNAL(textChanged(QString)), this, SLOT(changedAmount(QString)));\n\n    connect(view, SIGNAL(doubleClicked(QModelIndex)), this, SIGNAL(doubleClicked(QModelIndex)));\n    connect(view, SIGNAL(customContextMenuRequested(QPoint)), this, SLOT(contextualMenu(QPoint)));\n\n    connect(abandonAction, SIGNAL(triggered()), this, SLOT(abandonTx()));\n    connect(copyAddressAction, SIGNAL(triggered()), this, SLOT(copyAddress()));\n    connect(copyLabelAction, SIGNAL(triggered()), this, SLOT(copyLabel()));\n    connect(copyAmountAction, SIGNAL(triggered()), this, SLOT(copyAmount()));\n    connect(copyTxIDAction, SIGNAL(triggered()), this, SLOT(copyTxID()));\n    connect(copyTxHexAction, SIGNAL(triggered()), this, SLOT(copyTxHex()));\n    connect(copyTxPlainText, SIGNAL(triggered()), this, SLOT(copyTxPlainText()));\n    connect(editLabelAction, SIGNAL(triggered()), this, SLOT(editLabel()));\n    connect(showDetailsAction, SIGNAL(triggered()), this, SLOT(showDetails()));\n}\n\nvoid TransactionView::setModel(WalletModel *model)\n{\n    this->model = model;\n    if(model)\n    {\n        transactionProxyModel = new TransactionFilterProxy(this);\n        transactionProxyModel->setSourceModel(model->getTransactionTableModel());\n        transactionProxyModel->setDynamicSortFilter(true);\n        transactionProxyModel->setSortCaseSensitivity(Qt::CaseInsensitive);\n        transactionProxyModel->setFilterCaseSensitivity(Qt::CaseInsensitive);\n\n        transactionProxyModel->setSortRole(Qt::EditRole);\n\n        transactionView->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);\n        transactionView->setModel(transactionProxyModel);\n        transactionView->setAlternatingRowColors(true);\n        transactionView->setSelectionBehavior(QAbstractItemView::SelectRows);\n        transactionView->setSelectionMode(QAbstractItemView::ExtendedSelection);\n        transactionView->setSortingEnabled(true);\n        transactionView->sortByColumn(TransactionTableModel::Date, Qt::DescendingOrder);\n        transactionView->verticalHeader()->hide();\n\n        transactionView->setColumnWidth(TransactionTableModel::Status, STATUS_COLUMN_WIDTH);\n        transactionView->setColumnWidth(TransactionTableModel::Watchonly, WATCHONLY_COLUMN_WIDTH);\n        transactionView->setColumnWidth(TransactionTableModel::Date, DATE_COLUMN_WIDTH);\n        transactionView->setColumnWidth(TransactionTableModel::Type, TYPE_COLUMN_WIDTH);\n        transactionView->setColumnWidth(TransactionTableModel::Amount, AMOUNT_MINIMUM_COLUMN_WIDTH);\n\n        columnResizingFixer = new GUIUtil::TableViewLastColumnResizingFixer(transactionView, AMOUNT_MINIMUM_COLUMN_WIDTH, MINIMUM_COLUMN_WIDTH, this);\n\n        if (model->getOptionsModel())\n        {\n            \/\/ Add third party transaction URLs to context menu\n            QStringList listUrls = model->getOptionsModel()->getThirdPartyTxUrls().split(\"|\", QString::SkipEmptyParts);\n            for (int i = 0; i < listUrls.size(); ++i)\n            {\n                QString host = QUrl(listUrls[i].trimmed(), QUrl::StrictMode).host();\n                if (!host.isEmpty())\n                {\n                    QAction *thirdPartyTxUrlAction = new QAction(host, this); \/\/ use host as menu item label\n                    if (i == 0)\n                        contextMenu->addSeparator();\n                    contextMenu->addAction(thirdPartyTxUrlAction);\n                    connect(thirdPartyTxUrlAction, SIGNAL(triggered()), mapperThirdPartyTxUrls, SLOT(map()));\n                    mapperThirdPartyTxUrls->setMapping(thirdPartyTxUrlAction, listUrls[i].trimmed());\n                }\n            }\n        }\n\n        \/\/ show\/hide column Watch-only\n        updateWatchOnlyColumn(model->haveWatchOnly());\n\n        \/\/ Watch-only signal\n        connect(model, SIGNAL(notifyWatchonlyChanged(bool)), this, SLOT(updateWatchOnlyColumn(bool)));\n    }\n}\n\nvoid TransactionView::chooseDate(int idx)\n{\n    if(!transactionProxyModel)\n        return;\n    QDate current = QDate::currentDate();\n    dateRangeWidget->setVisible(false);\n    switch(dateWidget->itemData(idx).toInt())\n    {\n    case All:\n        transactionProxyModel->setDateRange(\n                TransactionFilterProxy::MIN_DATE,\n                TransactionFilterProxy::MAX_DATE);\n        break;\n    case Today:\n        transactionProxyModel->setDateRange(\n                QDateTime(current),\n                TransactionFilterProxy::MAX_DATE);\n        break;\n    case ThisWeek: {\n        \/\/ Find last Monday\n        QDate startOfWeek = current.addDays(-(current.dayOfWeek()-1));\n        transactionProxyModel->setDateRange(\n                QDateTime(startOfWeek),\n                TransactionFilterProxy::MAX_DATE);\n\n        } break;\n    case ThisMonth:\n        transactionProxyModel->setDateRange(\n                QDateTime(QDate(current.year(), current.month(), 1)),\n                TransactionFilterProxy::MAX_DATE);\n        break;\n    case LastMonth:\n        transactionProxyModel->setDateRange(\n                QDateTime(QDate(current.year(), current.month(), 1).addMonths(-1)),\n                QDateTime(QDate(current.year(), current.month(), 1)));\n        break;\n    case ThisYear:\n        transactionProxyModel->setDateRange(\n                QDateTime(QDate(current.year(), 1, 1)),\n                TransactionFilterProxy::MAX_DATE);\n        break;\n    case Range:\n        dateRangeWidget->setVisible(true);\n        dateRangeChanged();\n        break;\n    }\n}\n\nvoid TransactionView::chooseType(int idx)\n{\n    if(!transactionProxyModel)\n        return;\n    transactionProxyModel->setTypeFilter(\n        typeWidget->itemData(idx).toInt());\n}\n\nvoid TransactionView::chooseWatchonly(int idx)\n{\n    if(!transactionProxyModel)\n        return;\n    transactionProxyModel->setWatchOnlyFilter(\n        (TransactionFilterProxy::WatchOnlyFilter)watchOnlyWidget->itemData(idx).toInt());\n}\n\nvoid TransactionView::changedPrefix(const QString &prefix)\n{\n    if(!transactionProxyModel)\n        return;\n    transactionProxyModel->setAddressPrefix(prefix);\n}\n\nvoid TransactionView::changedAmount(const QString &amount)\n{\n    if(!transactionProxyModel)\n        return;\n    CAmount amount_parsed = 0;\n    if(KazuSilverUnits::parse(model->getOptionsModel()->getDisplayUnit(), amount, &amount_parsed))\n    {\n        transactionProxyModel->setMinAmount(amount_parsed);\n    }\n    else\n    {\n        transactionProxyModel->setMinAmount(0);\n    }\n}\n\nvoid TransactionView::exportClicked()\n{\n    \/\/ CSV is currently the only supported format\n    QString filename = GUIUtil::getSaveFileName(this,\n        tr(\"Export Transaction History\"), QString(),\n        tr(\"Comma separated file (*.csv)\"), NULL);\n\n    if (filename.isNull())\n        return;\n\n    CSVModelWriter writer(filename);\n\n    \/\/ name, column, role\n    writer.setModel(transactionProxyModel);\n    writer.addColumn(tr(\"Confirmed\"), 0, TransactionTableModel::ConfirmedRole);\n    if (model && model->haveWatchOnly())\n        writer.addColumn(tr(\"Watch-only\"), TransactionTableModel::Watchonly);\n    writer.addColumn(tr(\"Date\"), 0, TransactionTableModel::DateRole);\n    writer.addColumn(tr(\"Type\"), TransactionTableModel::Type, Qt::EditRole);\n    writer.addColumn(tr(\"Label\"), 0, TransactionTableModel::LabelRole);\n    writer.addColumn(tr(\"Address\"), 0, TransactionTableModel::AddressRole);\n    writer.addColumn(KazuSilverUnits::getAmountColumnTitle(model->getOptionsModel()->getDisplayUnit()), 0, TransactionTableModel::FormattedAmountRole);\n    writer.addColumn(tr(\"ID\"), 0, TransactionTableModel::TxIDRole);\n\n    if(!writer.write()) {\n        Q_EMIT message(tr(\"Exporting Failed\"), tr(\"There was an error trying to save the transaction history to %1.\").arg(filename),\n            CClientUIInterface::MSG_ERROR);\n    }\n    else {\n        Q_EMIT message(tr(\"Exporting Successful\"), tr(\"The transaction history was successfully saved to %1.\").arg(filename),\n            CClientUIInterface::MSG_INFORMATION);\n    }\n}\n\nvoid TransactionView::contextualMenu(const QPoint &point)\n{\n    QModelIndex index = transactionView->indexAt(point);\n    QModelIndexList selection = transactionView->selectionModel()->selectedRows(0);\n    if (selection.empty())\n        return;\n\n    \/\/ check if transaction can be abandoned, disable context menu action in case it doesn't\n    uint256 hash;\n    hash.SetHex(selection.at(0).data(TransactionTableModel::TxHashRole).toString().toStdString());\n    abandonAction->setEnabled(model->transactionCanBeAbandoned(hash));\n\n    if(index.isValid())\n    {\n        contextMenu->exec(QCursor::pos());\n    }\n}\n\nvoid TransactionView::abandonTx()\n{\n    if(!transactionView || !transactionView->selectionModel())\n        return;\n    QModelIndexList selection = transactionView->selectionModel()->selectedRows(0);\n\n    \/\/ get the hash from the TxHashRole (QVariant \/ QString)\n    uint256 hash;\n    QString hashQStr = selection.at(0).data(TransactionTableModel::TxHashRole).toString();\n    hash.SetHex(hashQStr.toStdString());\n\n    \/\/ Abandon the wallet transaction over the walletModel\n    model->abandonTransaction(hash);\n\n    \/\/ Update the table\n    model->getTransactionTableModel()->updateTransaction(hashQStr, CT_UPDATED, false);\n}\n\nvoid TransactionView::copyAddress()\n{\n    GUIUtil::copyEntryData(transactionView, 0, TransactionTableModel::AddressRole);\n}\n\nvoid TransactionView::copyLabel()\n{\n    GUIUtil::copyEntryData(transactionView, 0, TransactionTableModel::LabelRole);\n}\n\nvoid TransactionView::copyAmount()\n{\n    GUIUtil::copyEntryData(transactionView, 0, TransactionTableModel::FormattedAmountRole);\n}\n\nvoid TransactionView::copyTxID()\n{\n    GUIUtil::copyEntryData(transactionView, 0, TransactionTableModel::TxIDRole);\n}\n\nvoid TransactionView::copyTxHex()\n{\n    GUIUtil::copyEntryData(transactionView, 0, TransactionTableModel::TxHexRole);\n}\n\nvoid TransactionView::copyTxPlainText()\n{\n    GUIUtil::copyEntryData(transactionView, 0, TransactionTableModel::TxPlainTextRole);\n}\n\nvoid TransactionView::editLabel()\n{\n    if(!transactionView->selectionModel() ||!model)\n        return;\n    QModelIndexList selection = transactionView->selectionModel()->selectedRows();\n    if(!selection.isEmpty())\n    {\n        AddressTableModel *addressBook = model->getAddressTableModel();\n        if(!addressBook)\n            return;\n        QString address = selection.at(0).data(TransactionTableModel::AddressRole).toString();\n        if(address.isEmpty())\n        {\n            \/\/ If this transaction has no associated address, exit\n            return;\n        }\n        \/\/ Is address in address book? Address book can miss address when a transaction is\n        \/\/ sent from outside the UI.\n        int idx = addressBook->lookupAddress(address);\n        if(idx != -1)\n        {\n            \/\/ Edit sending \/ receiving address\n            QModelIndex modelIdx = addressBook->index(idx, 0, QModelIndex());\n            \/\/ Determine type of address, launch appropriate editor dialog type\n            QString type = modelIdx.data(AddressTableModel::TypeRole).toString();\n\n            EditAddressDialog dlg(\n                type == AddressTableModel::Receive\n                ? EditAddressDialog::EditReceivingAddress\n                : EditAddressDialog::EditSendingAddress, this);\n            dlg.setModel(addressBook);\n            dlg.loadRow(idx);\n            dlg.exec();\n        }\n        else\n        {\n            \/\/ Add sending address\n            EditAddressDialog dlg(EditAddressDialog::NewSendingAddress,\n                this);\n            dlg.setModel(addressBook);\n            dlg.setAddress(address);\n            dlg.exec();\n        }\n    }\n}\n\nvoid TransactionView::showDetails()\n{\n    if(!transactionView->selectionModel())\n        return;\n    QModelIndexList selection = transactionView->selectionModel()->selectedRows();\n    if(!selection.isEmpty())\n    {\n        TransactionDescDialog *dlg = new TransactionDescDialog(selection.at(0));\n        dlg->setAttribute(Qt::WA_DeleteOnClose);\n        dlg->show();\n    }\n}\n\nvoid TransactionView::openThirdPartyTxUrl(QString url)\n{\n    if(!transactionView || !transactionView->selectionModel())\n        return;\n    QModelIndexList selection = transactionView->selectionModel()->selectedRows(0);\n    if(!selection.isEmpty())\n         QDesktopServices::openUrl(QUrl::fromUserInput(url.replace(\"%s\", selection.at(0).data(TransactionTableModel::TxHashRole).toString())));\n}\n\nQWidget *TransactionView::createDateRangeWidget()\n{\n    dateRangeWidget = new QFrame();\n    dateRangeWidget->setFrameStyle(QFrame::Panel | QFrame::Raised);\n    dateRangeWidget->setContentsMargins(1,1,1,1);\n    QHBoxLayout *layout = new QHBoxLayout(dateRangeWidget);\n    layout->setContentsMargins(0,0,0,0);\n    layout->addSpacing(23);\n    layout->addWidget(new QLabel(tr(\"Range:\")));\n\n    dateFrom = new QDateTimeEdit(this);\n    dateFrom->setDisplayFormat(\"dd\/MM\/yy\");\n    dateFrom->setCalendarPopup(true);\n    dateFrom->setMinimumWidth(100);\n    dateFrom->setDate(QDate::currentDate().addDays(-7));\n    layout->addWidget(dateFrom);\n    layout->addWidget(new QLabel(tr(\"to\")));\n\n    dateTo = new QDateTimeEdit(this);\n    dateTo->setDisplayFormat(\"dd\/MM\/yy\");\n    dateTo->setCalendarPopup(true);\n    dateTo->setMinimumWidth(100);\n    dateTo->setDate(QDate::currentDate());\n    layout->addWidget(dateTo);\n    layout->addStretch();\n\n    \/\/ Hide by default\n    dateRangeWidget->setVisible(false);\n\n    \/\/ Notify on change\n    connect(dateFrom, SIGNAL(dateChanged(QDate)), this, SLOT(dateRangeChanged()));\n    connect(dateTo, SIGNAL(dateChanged(QDate)), this, SLOT(dateRangeChanged()));\n\n    return dateRangeWidget;\n}\n\nvoid TransactionView::dateRangeChanged()\n{\n    if(!transactionProxyModel)\n        return;\n    transactionProxyModel->setDateRange(\n            QDateTime(dateFrom->date()),\n            QDateTime(dateTo->date()).addDays(1));\n}\n\nvoid TransactionView::focusTransaction(const QModelIndex &idx)\n{\n    if(!transactionProxyModel)\n        return;\n    QModelIndex targetIdx = transactionProxyModel->mapFromSource(idx);\n    transactionView->scrollTo(targetIdx);\n    transactionView->setCurrentIndex(targetIdx);\n    transactionView->setFocus();\n}\n\n\/\/ We override the virtual resizeEvent of the QWidget to adjust tables column\n\/\/ sizes as the tables width is proportional to the dialogs width.\nvoid TransactionView::resizeEvent(QResizeEvent* event)\n{\n    QWidget::resizeEvent(event);\n    columnResizingFixer->stretchColumnWidth(TransactionTableModel::ToAddress);\n}\n\n\/\/ Need to override default Ctrl+C action for amount as default behaviour is just to copy DisplayRole text\nbool TransactionView::eventFilter(QObject *obj, QEvent *event)\n{\n    if (event->type() == QEvent::KeyPress)\n    {\n        QKeyEvent *ke = static_cast<QKeyEvent *>(event);\n        if (ke->key() == Qt::Key_C && ke->modifiers().testFlag(Qt::ControlModifier))\n        {\n             GUIUtil::copyEntryData(transactionView, 0, TransactionTableModel::TxPlainTextRole);\n             return true;\n        }\n    }\n    return QWidget::eventFilter(obj, event);\n}\n\n\/\/ show\/hide column Watch-only\nvoid TransactionView::updateWatchOnlyColumn(bool fHaveWatchOnly)\n{\n    watchOnlyWidget->setVisible(fHaveWatchOnly);\n    transactionView->setColumnHidden(TransactionTableModel::Watchonly, !fHaveWatchOnly);\n}\n","avg_line_length":37.9199318569,"max_line_length":151,"alphanum_fraction":0.6918999057,"licenses":["MIT"],"repository_name":"kazucoin\/kazusilver","path":"src\/qt\/transactionview.cpp","size":22259,"lang":"C++"}
{"content":"#-----------------------------------------------------------------------------\n# MITK Data\n#-----------------------------------------------------------------------------\n\n# Sanity checks\nif(DEFINED MITK_DATA_DIR AND NOT EXISTS ${MITK_DATA_DIR})\n  message(FATAL_ERROR \"MITK_DATA_DIR variable is defined but corresponds to non-existing directory\")\nendif()\n\nset(proj MITK-Data)\nset(proj_DEPENDENCIES)\nset(MITK-Data_DEPENDS ${proj})\n\nif(BUILD_TESTING)\n  set(revision_tag e2d97a94) # first 8 characters of hash-tag\n#                  ^^^^^^^^  these are just to check correct length of hash part\n\n  ExternalProject_Add(${proj}\n    SOURCE_DIR ${proj}\n    URL ${MITK_THIRDPARTY_DOWNLOAD_PREFIX_URL}\/MITK-Data_${revision_tag}.tar.gz\n    UPDATE_COMMAND \"\"\n    CONFIGURE_COMMAND \"\"\n    BUILD_COMMAND \"\"\n    INSTALL_COMMAND \"\"\n    DEPENDS ${proj_DEPENDENCIES}\n  )\n\n  set(MITK_DATA_DIR ${CMAKE_CURRENT_BINARY_DIR}\/${proj})\n\nelse()\n\n  mitkMacroEmptyExternalProject(${proj} \"${proj_DEPENDENCIES}\")\n\nendif(BUILD_TESTING)\n\n\n","avg_line_length":27.2432432432,"max_line_length":100,"alphanum_fraction":0.6140873016,"licenses":["BSD-3-Clause"],"repository_name":"kometa-dev\/MITK","path":"CMakeExternals\/MITKData.cmake","size":1008,"lang":"CMake"}
{"content":"What are the 10 newest invoices?","avg_line_length":32.0,"max_line_length":32,"alphanum_fraction":0.8125,"licenses":["MIT"],"repository_name":"Neural-Program-Synthesis\/sqlectron-gui","path":".sql","size":32,"lang":"SQL"}
{"content":"CREATE TABLE \"MLB_50\"(\n\"AB\" smallint NOT NULL,\n\"AVG\" decimal(4, 3),\n\"BABIP\" decimal(4, 3),\n\"BB.\" decimal(4, 1),\n\"BB\" smallint NOT NULL,\n\"BIP.\" decimal(4, 1),\n\"BIP\" smallint NOT NULL,\n\"Ba.\" decimal(4, 1),\n\"Balls\" smallint,\n\"Ca.\" decimal(4, 1),\n\"Calculation_496521908228587527\" decimal(4, 3),\n\"Called\" smallint,\n\"F.\" decimal(4, 1),\n\"FB.\" decimal(4, 1) NOT NULL,\n\"FB\" smallint NOT NULL,\n\"Foul\" smallint,\n\"GB.\" decimal(4, 1) NOT NULL,\n\"GB\" smallint NOT NULL,\n\"GIDP\" smallint NOT NULL,\n\"HBP\" smallint NOT NULL,\n\"HR\" smallint NOT NULL,\n\"H\" smallint NOT NULL,\n\"ISO\" decimal(4, 3),\n\"K.\" decimal(4, 1),\n\"LD.\" decimal(4, 1) NOT NULL,\n\"LD\" smallint NOT NULL,\n\"Number of Records\" smallint NOT NULL,\n\"OBP\" decimal(4, 3),\n\"PA\" smallint NOT NULL,\n\"PU.\" decimal(4, 1) NOT NULL,\n\"PU\" smallint NOT NULL,\n\"Pitches\" smallint,\n\"SF\" smallint NOT NULL,\n\"SH\" smallint NOT NULL,\n\"SLG\" decimal(4, 3),\n\"SOL\" smallint NOT NULL,\n\"SOS\" smallint NOT NULL,\n\"SO\" smallint NOT NULL,\n\"Str.\" decimal(4, 1),\n\"Strikes\" smallint,\n\"SwStr.\" decimal(4, 1),\n\"Swinging\" smallint,\n\"TB\" smallint NOT NULL,\n\"Wh.Sw\" decimal(4, 1),\n\"X1B\" smallint NOT NULL,\n\"X2B\" smallint NOT NULL,\n\"X3B\" smallint NOT NULL,\n\"batter_name\" varchar(26) NOT NULL,\n\"iBB\" smallint NOT NULL,\n\"league\" varchar(4) NOT NULL,\n\"p_throws\" varchar(1),\n\"parentteam\" varchar(3) NOT NULL,\n\"pwRC.\" smallint,\n\"stand\" varchar(1) NOT NULL,\n\"teamname\" varchar(27) NOT NULL,\n\"wOBA\" decimal(4, 3) NOT NULL,\n\"wRAA\" decimal(3, 1) NOT NULL,\n\"wRC.\" smallint,\n\"wRC\" decimal(3, 1) NOT NULL,\n\"year\" smallint NOT NULL,\n\"Calculation_40532458108489732\" decimal(17, 14),\n\"Calculation_40532458114363409\" decimal(18, 15)\n);\n","avg_line_length":24.9384615385,"max_line_length":48,"alphanum_fraction":0.6822948797,"licenses":["MIT"],"repository_name":"bogdanghita\/public_bi_benchmark-master_project","path":"benchmark\/MLB\/tables-vectorwise\/MLB_50.table.sql","size":1621,"lang":"SQL"}
{"content":"require('constants')\r\nrequire('cosmos_common')\r\nrequire('fn')\r\nrequire('map_events')\r\n\r\nlocal cosmos_map_id = args[MAP_ID]\r\n\r\n-- Add random creatures to the map.  The random creatures are taken from\r\n-- the deities' anger summons in the game data.\r\nfunction add_divine_creatures(map_id, rows, cols, num_creatures)\r\n  local divine_creatures = {\"archangel\", \"titan\", \"air_elemental\",\r\n                            \"skyborn\", \"fire_elemental\", \"planewalker\",\r\n                            \"voidling\", \"star_beast\", \"astral_horror\"}\r\n  local y, x = 0, 0\r\n  local creature_id = divine_creatures[1]\r\n\r\n  for i = 1, num_creatures do\r\n    y = RNG_range(0, rows-1)\r\n    x = RNG_range(0, cols-1)\r\n    creature_id = divine_creatures[RNG_range(1, #divine_creatures)]\r\n\r\n    if tile_has_creature(y, x, map_id) == false then\r\n      add_creature_to_map(creature_id, y, x, map_id, true)\r\n    end\r\n  end\r\nend\r\n\r\nfunction create_rift(map_id, rift_y, rift_x)\r\n  -- Generate the rift and the exclusionary area around the center\r\n  -- of the map.  Only divine creatures may enter\/move within the rift.  \r\n  for ry = rift_y - 1, rift_y + 1 do\r\n    for rx = rift_x - 1, rift_x + 1 do\r\n      add_basic_feature_to_map(\"_rift\", ry, rx, map_id)\r\n      map_set_tile_property(map_id, ry, rx, \"TILE_PROPERTY_ALLOWED_RACES\", \"_divine\")\r\n    end\r\n  end\r\nend\r\n\r\n-- Initializing the cosmos is done by picking a deity, and spawning it\r\n-- along with a number of its followers.  These are given action speeds\r\n-- greater than the player's to ensure that the player always gets to act\r\n-- first.\r\n-- \r\n-- Sceadugenga is excluded from the initial spawn.  He is always the last \r\n-- to generate.\r\nfunction init_cosmos(map_id)\r\n  local r, c = map_get_dimensions(map_id)\r\n  local rift_y, rift_x = cosmos_common.get_rift_yx(r, c)\r\n\r\n  -- Create the rift, add the race restrictions, and then add one of The\r\n  -- Nine with associated followers.\r\n  create_rift(map_id, rift_y, rift_x)\r\n  cosmos_common.populate_rift(map_id, rift_y, rift_x)\r\n\r\n  -- Generate lesser divine beings throughout the level.  The number of\r\n  -- creatures should be half the number of columns.\r\n  add_divine_creatures(map_id, r, c, c\/2)\r\nend\r\n\r\nmap_events.set_map_fn(cosmos_map_id, init_cosmos)\r\n\r\n","avg_line_length":35.9193548387,"max_line_length":86,"alphanum_fraction":0.6910642119,"licenses":["MIT"],"repository_name":"sidav\/shadow-of-the-wyrm","path":"scripts\/areas\/events\/cosmos.lua","size":2227,"lang":"Lua"}
{"content":"\/*\n * Copyright (c) 2004-2022, University of Oslo\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * Redistributions of source code must retain the above copyright notice, this\n * list of conditions and the following disclaimer.\n *\n * Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and\/or other materials provided with the distribution.\n * Neither the name of the HISP project nor the names of its contributors may\n * be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\/\npackage org.hisp.dhis.webapi.controller;\n\nimport org.hisp.dhis.sms.outbound.OutboundSms;\nimport org.hisp.dhis.sms.outbound.OutboundSmsService;\nimport org.hisp.dhis.web.HttpStatus;\nimport org.hisp.dhis.webapi.DhisControllerConvenienceTest;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\n\n\/**\n * Tests the {@link org.hisp.dhis.webapi.controller.sms.SmsOutboundController}\n * using (mocked) REST requests.\n *\n * @author Jan Bernitt\n *\/\nclass SmsOutboundControllerTest extends DhisControllerConvenienceTest\n{\n\n    @Autowired\n    private OutboundSmsService outboundSmsService;\n\n    @Test\n    void testSendSMSMessage()\n    {\n        assertWebMessage( \"Internal Server Error\", 500, \"ERROR\", \"No default gateway configured\",\n            POST( \"\/sms\/outbound?recipient=\" + getSuperuserUid() + \"&message=text\" )\n                .content( HttpStatus.INTERNAL_SERVER_ERROR ) );\n    }\n\n    @Test\n    void testSendSMSMessage_NoRecipient()\n    {\n        assertWebMessage( \"Conflict\", 409, \"ERROR\", \"Recipient must be specified\",\n            POST( \"\/sms\/outbound?recipient=&message=text\" ).content( HttpStatus.CONFLICT ) );\n    }\n\n    @Test\n    void testSendSMSMessage_NoMessage()\n    {\n        assertWebMessage( \"Conflict\", 409, \"ERROR\", \"Message must be specified\",\n            POST( \"\/sms\/outbound?recipient=xyz&message=\" ).content( HttpStatus.CONFLICT ) );\n    }\n\n    @Test\n    void testSendSMSMessageWithBody()\n    {\n        assertWebMessage( \"Internal Server Error\", 500, \"ERROR\", \"No default gateway configured\",\n            POST( \"\/sms\/outbound\",\n                \"{\" + \"'recipients':[{'id':'\" + getSuperuserUid() + \"'}],\" + \"'message':'text'\" + \"}\" )\n                    .content( HttpStatus.INTERNAL_SERVER_ERROR ) );\n    }\n\n    @Test\n    void testDeleteOutboundMessage()\n    {\n        OutboundSms sms = new OutboundSms();\n        outboundSmsService.save( sms );\n        assertWebMessage( \"OK\", 200, \"OK\", \"OutboundSms with \" + sms.getUid() + \" deleted\",\n            DELETE( \"\/sms\/outbound\/\" + sms.getUid() ).content( HttpStatus.OK ) );\n    }\n\n    @Test\n    void testDeleteOutboundMessage_NoSuchObject()\n    {\n        assertWebMessage( \"Not Found\", 404, \"ERROR\", \"No OutboundSms with id 'xyz' was found.\",\n            DELETE( \"\/sms\/outbound\/xyz\" ).content( HttpStatus.NOT_FOUND ) );\n    }\n\n    @Test\n    void testDeleteOutboundMessages()\n    {\n        OutboundSms sms = new OutboundSms();\n        outboundSmsService.save( sms );\n        assertWebMessage( \"OK\", 200, \"OK\", \"Objects deleted\",\n            DELETE( \"\/sms\/outbound\/?ids=\" + sms.getUid() ).content( HttpStatus.OK ) );\n    }\n}\n","avg_line_length":39.8761904762,"max_line_length":103,"alphanum_fraction":0.6945306902,"licenses":["BSD-3-Clause"],"repository_name":"dhis2\/dhis2","path":"dhis-2\/dhis-web-api-test\/src\/test\/java\/org\/hisp\/dhis\/webapi\/controller\/SmsOutboundControllerTest.java","size":4187,"lang":"Java"}
{"content":"html {\n  font-family: sans-serif;\n  -ms-text-size-adjust: 100%;\n  -webkit-text-size-adjust: 100%;\n}\nbody {\n  margin: 0;\n}\narticle,\naside,\ndetails,\nfigcaption,\nfigure,\nfooter,\nheader,\nmain,\nmenu,\nnav,\nsection,\nsummary {\n  display: block;\n}\naudio,\ncanvas,\nprogress,\nvideo {\n  display: inline-block;\n}\naudio:not([controls]) {\n  display: none;\n  height: 0;\n}\nprogress {\n  vertical-align: baseline;\n}\n[hidden],\ntemplate {\n  display: none;\n}\na {\n  background-color: transparent;\n  -webkit-text-decoration-skip: objects;\n}\na:active,\na:hover {\n  outline-width: 0;\n}\nabbr[title] {\n  border-bottom: none;\n  text-decoration: underline;\n  text-decoration: underline dotted;\n}\nb,\nstrong {\n  font-weight: inherit;\n  font-weight: bolder;\n}\ndfn {\n  font-style: italic;\n}\nh1 {\n  font-size: 2em;\n  margin: 0.67em 0;\n}\nmark {\n  background-color: #ff0;\n  color: #000;\n}\nsmall {\n  font-size: 80%;\n}\nsub,\nsup {\n  font-size: 75%;\n  line-height: 0;\n  position: relative;\n  vertical-align: baseline;\n}\nsub {\n  bottom: -0.25em;\n}\nsup {\n  top: -0.5em;\n}\nimg {\n  border-style: none;\n}\nsvg:not(:root) {\n  overflow: hidden;\n}\ncode,\nkbd,\npre,\nsamp {\n  font-family: monospace, monospace;\n  font-size: 1em;\n}\nfigure {\n  margin: 1em 40px;\n}\nhr {\n  box-sizing: content-box;\n  height: 0;\n  overflow: visible;\n}\nbutton,\ninput,\noptgroup,\nselect,\ntextarea {\n  font: inherit;\n  margin: 0;\n}\noptgroup {\n  font-weight: 700;\n}\nbutton,\ninput {\n  overflow: visible;\n}\nbutton,\nselect {\n  text-transform: none;\n}\n[type='reset'],\n[type='submit'],\nbutton,\nhtml [type='button'] {\n  -webkit-appearance: button;\n}\n[type='button']::-moz-focus-inner,\n[type='reset']::-moz-focus-inner,\n[type='submit']::-moz-focus-inner,\nbutton::-moz-focus-inner {\n  border-style: none;\n  padding: 0;\n}\n[type='button']:-moz-focusring,\n[type='reset']:-moz-focusring,\n[type='submit']:-moz-focusring,\nbutton:-moz-focusring {\n  outline: 1px dotted ButtonText;\n}\nfieldset {\n  border: 1px solid silver;\n  margin: 0 2px;\n  padding: 0.35em 0.625em 0.75em;\n}\nlegend {\n  box-sizing: border-box;\n  color: inherit;\n  display: table;\n  max-width: 100%;\n  padding: 0;\n  white-space: normal;\n}\ntextarea {\n  overflow: auto;\n}\n[type='checkbox'],\n[type='radio'] {\n  box-sizing: border-box;\n  padding: 0;\n}\n[type='number']::-webkit-inner-spin-button,\n[type='number']::-webkit-outer-spin-button {\n  height: auto;\n}\n[type='search'] {\n  -webkit-appearance: textfield;\n  outline-offset: -2px;\n}\n[type='search']::-webkit-search-cancel-button,\n[type='search']::-webkit-search-decoration {\n  -webkit-appearance: none;\n}\n::-webkit-input-placeholder {\n  color: inherit;\n  opacity: 0.54;\n}\n::-webkit-file-upload-button {\n  -webkit-appearance: button;\n  font: inherit;\n}\nhtml {\n  font: 112.5%\/1.45em georgia, serif;\n  box-sizing: border-box;\n  overflow-y: scroll;\n  background-color: #f1f1f1;\n}\n* {\n  box-sizing: inherit;\n}\n*:before {\n  box-sizing: inherit;\n}\n*:after {\n  box-sizing: inherit;\n}\nbody {\n  color: hsla(0, 0%, 0%, 0.8);\n  \/* font-family: georgia, serif; *\/\n  font-weight: normal;\n  word-wrap: break-word;\n  font-kerning: normal;\n  -moz-font-feature-settings: 'kern', 'liga', 'clig', 'calt';\n  -ms-font-feature-settings: 'kern', 'liga', 'clig', 'calt';\n  -webkit-font-feature-settings: 'kern', 'liga', 'clig', 'calt';\n  font-feature-settings: 'kern', 'liga', 'clig', 'calt';\n}\nimg {\n  max-width: 100%;\n  margin-left: 0;\n  margin-right: 0;\n  margin-top: 0;\n  padding-bottom: 0;\n  padding-left: 0;\n  padding-right: 0;\n  padding-top: 0;\n  margin-bottom: 0rem;\n}\nh1 {\n  margin-left: 0;\n  margin-right: 0;\n  margin-top: 0;\n  padding-bottom: 0;\n  padding-left: 0;\n  padding-right: 0;\n  padding-top: 0;\n  margin-bottom: 0rem;\n  color: inherit;\n  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen,\n    Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;\n  font-weight: bold;\n  text-rendering: optimizeLegibility;\n  font-size: 2.25rem;\n  line-height: 1.1;\n}\nh2 {\n  margin-left: 0;\n  margin-right: 0;\n  margin-top: 0;\n  padding-bottom: 0;\n  padding-left: 0;\n  padding-right: 0;\n  padding-top: 0;\n  margin-bottom: 0rem;\n  color: inherit;\n  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen,\n    Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;\n  font-weight: bold;\n  text-rendering: optimizeLegibility;\n  font-size: 1.62671rem;\n  line-height: 1.1;\n}\nh3 {\n  margin-left: 0;\n  margin-right: 0;\n  margin-top: 0;\n  padding-bottom: 0;\n  padding-left: 0;\n  padding-right: 0;\n  padding-top: 0;\n  margin-bottom: 0rem;\n  color: inherit;\n  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen,\n    Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;\n  font-weight: bold;\n  text-rendering: optimizeLegibility;\n  font-size: 1.38316rem;\n  line-height: 1.1;\n}\nh4 {\n  margin-left: 0;\n  margin-right: 0;\n  margin-top: 0;\n  padding-bottom: 0;\n  padding-left: 0;\n  padding-right: 0;\n  padding-top: 0;\n  margin-bottom: 0rem;\n  color: inherit;\n  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen,\n    Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;\n  font-weight: bold;\n  text-rendering: optimizeLegibility;\n  font-size: 1rem;\n  line-height: 1.1;\n}\nh5 {\n  margin-left: 0;\n  margin-right: 0;\n  margin-top: 0;\n  padding-bottom: 0;\n  padding-left: 0;\n  padding-right: 0;\n  padding-top: 0;\n  margin-bottom: 0rem;\n  color: inherit;\n  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen,\n    Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;\n  font-weight: bold;\n  text-rendering: optimizeLegibility;\n  font-size: 0.85028rem;\n  line-height: 1.1;\n}\nh6 {\n  margin-left: 0;\n  margin-right: 0;\n  margin-top: 0;\n  padding-bottom: 0;\n  padding-left: 0;\n  padding-right: 0;\n  padding-top: 0;\n  margin-bottom: 0rem;\n  color: inherit;\n  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen,\n    Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;\n  font-weight: bold;\n  text-rendering: optimizeLegibility;\n  font-size: 0.78405rem;\n  line-height: 1.1;\n}\nhgroup {\n  margin-left: 0;\n  margin-right: 0;\n  margin-top: 0;\n  padding-bottom: 0;\n  padding-left: 0;\n  padding-right: 0;\n  padding-top: 0;\n  margin-bottom: 0rem;\n}\nul {\n  margin-left: 1.45rem;\n  margin-right: 0;\n  margin-top: 0;\n  padding-bottom: 0;\n  padding-left: 0;\n  padding-right: 0;\n  padding-top: 0;\n  margin-bottom: 0rem;\n  list-style-position: outside;\n  list-style-image: none;\n}\nol {\n  margin-left: 1.45rem;\n  margin-right: 0;\n  margin-top: 0;\n  padding-bottom: 0;\n  padding-left: 0;\n  padding-right: 0;\n  padding-top: 0;\n  margin-bottom: 0rem;\n  list-style-position: outside;\n  list-style-image: none;\n}\ndl {\n  margin-left: 0;\n  margin-right: 0;\n  margin-top: 0;\n  padding-bottom: 0;\n  padding-left: 0;\n  padding-right: 0;\n  padding-top: 0;\n  margin-bottom: 0rem;\n}\ndd {\n  margin-left: 0;\n  margin-right: 0;\n  margin-top: 0;\n  padding-bottom: 0;\n  padding-left: 0;\n  padding-right: 0;\n  padding-top: 0;\n  margin-bottom: 0rem;\n}\np {\n  margin-bottom: 0;\n  margin-left: 0;\n  margin-right: 0;\n  margin-top: 0;\n  padding-bottom: 0;\n  padding-left: 0;\n  padding-right: 0;\n  padding-top: 0;\n}\nfigure {\n  margin-left: 0;\n  margin-right: 0;\n  margin-top: 0;\n  padding-bottom: 0;\n  padding-left: 0;\n  padding-right: 0;\n  padding-top: 0;\n  margin-bottom: 0rem;\n}\npre {\n  margin-left: 0;\n  margin-right: 0;\n  margin-top: 0;\n  padding-bottom: 0;\n  padding-left: 0;\n  padding-right: 0;\n  padding-top: 0;\n  margin-bottom: 0rem;\n  font-size: 0.85rem;\n  line-height: 1.42;\n  background: hsla(0, 0%, 0%, 0.04);\n  border-radius: 3px;\n  overflow: auto;\n  word-wrap: normal;\n  padding: 1.45rem;\n}\ntable {\n  margin-left: 0;\n  margin-right: 0;\n  margin-top: 0;\n  padding-bottom: 0;\n  padding-left: 0;\n  padding-right: 0;\n  padding-top: 0;\n  margin-bottom: 0rem;\n  font-size: 1rem;\n  line-height: 1.45rem;\n  border-collapse: collapse;\n  width: 100%;\n}\nfieldset {\n  margin-left: 0;\n  margin-right: 0;\n  margin-top: 0;\n  padding-bottom: 0;\n  padding-left: 0;\n  padding-right: 0;\n  padding-top: 0;\n  margin-bottom: 0rem;\n}\nblockquote {\n  margin-left: 1.45rem;\n  margin-right: 1.45rem;\n  margin-top: 0;\n  padding-bottom: 0;\n  padding-left: 0;\n  padding-right: 0;\n  padding-top: 0;\n  margin-bottom: 0rem;\n}\nform {\n  margin-left: 0;\n  margin-right: 0;\n  margin-top: 0;\n  padding-bottom: 0;\n  padding-left: 0;\n  padding-right: 0;\n  padding-top: 0;\n  margin-bottom: 0rem;\n}\nnoscript {\n  margin-left: 0;\n  margin-right: 0;\n  margin-top: 0;\n  padding-bottom: 0;\n  padding-left: 0;\n  padding-right: 0;\n  padding-top: 0;\n  margin-bottom: 0rem;\n}\niframe {\n  margin-left: 0;\n  margin-right: 0;\n  margin-top: 0;\n  padding-bottom: 0;\n  padding-left: 0;\n  padding-right: 0;\n  padding-top: 0;\n  margin-bottom: 0rem;\n}\nhr {\n  margin-left: 0;\n  margin-right: 0;\n  margin-top: 0;\n  padding-bottom: 0;\n  padding-left: 0;\n  padding-right: 0;\n  padding-top: 0;\n  margin-bottom: calc(1.45rem - 1px);\n  background: hsla(0, 0%, 0%, 0.2);\n  border: none;\n  height: 1px;\n}\naddress {\n  margin-left: 0;\n  margin-right: 0;\n  margin-top: 0;\n  padding-bottom: 0;\n  padding-left: 0;\n  padding-right: 0;\n  padding-top: 0;\n  margin-bottom: 0rem;\n}\nb {\n  font-weight: bold;\n}\nstrong {\n  font-weight: bold;\n}\ndt {\n  font-weight: bold;\n}\nth {\n  font-weight: bold;\n}\nli {\n  margin-bottom: calc(1.45rem \/ 2);\n}\nol li {\n  padding-left: 0;\n}\nul li {\n  padding-left: 0;\n}\nli > ol {\n  margin-left: 1.45rem;\n  margin-bottom: calc(1.45rem \/ 2);\n  margin-top: calc(1.45rem \/ 2);\n}\nli > ul {\n  margin-left: 1.45rem;\n  margin-bottom: calc(1.45rem \/ 2);\n  margin-top: calc(1.45rem \/ 2);\n}\nblockquote *:last-child {\n  margin-bottom: 0;\n}\nli > p {\n  margin-bottom: calc(1.45rem \/ 2);\n}\ncode {\n  font-size: 0.85rem;\n  line-height: 1.45rem;\n}\nkbd {\n  font-size: 0.85rem;\n  line-height: 1.45rem;\n}\nsamp {\n  font-size: 0.85rem;\n  line-height: 1.45rem;\n}\nabbr {\n  border-bottom: 1px dotted hsla(0, 0%, 0%, 0.5);\n  cursor: help;\n}\nacronym {\n  border-bottom: 1px dotted hsla(0, 0%, 0%, 0.5);\n  cursor: help;\n}\nabbr[title] {\n  border-bottom: 1px dotted hsla(0, 0%, 0%, 0.5);\n  cursor: help;\n  text-decoration: none;\n}\nthead {\n  text-align: left;\n}\ntd,\nth {\n  text-align: left;\n  border-bottom: 1px solid hsla(0, 0%, 0%, 0.12);\n  font-feature-settings: 'tnum';\n  -moz-font-feature-settings: 'tnum';\n  -ms-font-feature-settings: 'tnum';\n  -webkit-font-feature-settings: 'tnum';\n  padding-left: 0.96667rem;\n  padding-right: 0.96667rem;\n  padding-top: 0.725rem;\n  padding-bottom: calc(0.725rem - 1px);\n}\nth:first-child,\ntd:first-child {\n  padding-left: 0;\n}\nth:last-child,\ntd:last-child {\n  padding-right: 0;\n}\ntt,\ncode {\n  background-color: hsla(0, 0%, 0%, 0.04);\n  border-radius: 3px;\n  font-family: 'SFMono-Regular', Consolas, 'Roboto Mono', 'Droid Sans Mono',\n    'Liberation Mono', Menlo, Courier, monospace;\n  padding: 0;\n  padding-top: 0.2em;\n  padding-bottom: 0.2em;\n}\npre code {\n  background: none;\n  line-height: 1.42;\n}\ncode:before,\ncode:after,\ntt:before,\ntt:after {\n  letter-spacing: -0.2em;\n  content: ' ';\n}\npre code:before,\npre code:after,\npre tt:before,\npre tt:after {\n  content: '';\n}\n@media only screen and (max-width: 480px) {\n  html {\n    font-size: 100%;\n  }\n}\n\n.galleryOuterImages {\n  display: inline-block;\n}\n\n.gold-background {\n  background-color: #bfa26e;\n  border-radius: 0.5rem;\n}\n\n.error-background {\n  background-color: #9d5050;\n  border-radius: 0.5rem;\n}\n\n.gold-background:first-child {\n  margin-top: 3rem;\n}\n\n.scale-in-ver-top {\n  -webkit-animation: scale-in-ver-top 0.5s ease-in-out both;\n  animation: scale-in-ver-top 0.5s ease-in-out both;\n}\n\n.scale-out-ver-top {\n  -webkit-animation: scale-out-ver-top 0.5s ease-in-out both;\n  animation: scale-out-ver-top 0.5s ease-in-out both;\n}\n\/* ----------------------------------------------\n * Generated by Animista on 2018-9-2 15:10:15\n * w: http:\/\/animista.net, t: @cssanimista\n * ---------------------------------------------- *\/\n\n\/**\n * ----------------------------------------\n * animation scale-in-ver-top\n * ----------------------------------------\n *\/\n@-webkit-keyframes scale-in-ver-top {\n  0% {\n    -webkit-transform: scaleY(0);\n    transform: scaleY(0);\n    -webkit-transform-origin: 100% 0%;\n    transform-origin: 100% 0%;\n    opacity: 1;\n  }\n  100% {\n    -webkit-transform: scaleY(1);\n    transform: scaleY(1);\n    -webkit-transform-origin: 100% 0%;\n    transform-origin: 100% 0%;\n    opacity: 1;\n  }\n}\n@keyframes scale-in-ver-top {\n  0% {\n    -webkit-transform: scaleY(0);\n    transform: scaleY(0);\n    -webkit-transform-origin: 100% 0%;\n    transform-origin: 100% 0%;\n    opacity: 1;\n  }\n  100% {\n    -webkit-transform: scaleY(1);\n    transform: scaleY(1);\n    -webkit-transform-origin: 100% 0%;\n    transform-origin: 100% 0%;\n    opacity: 1;\n  }\n}\n\n\/* ----------------------------------------------\n * Generated by Animista on 2018-9-2 15:12:49\n * w: http:\/\/animista.net, t: @cssanimista\n * ---------------------------------------------- *\/\n\n\/**\n * ----------------------------------------\n * animation scale-out-ver-top\n * ----------------------------------------\n *\/\n@-webkit-keyframes scale-out-ver-top {\n  0% {\n    -webkit-transform: scaleY(1);\n    transform: scaleY(1);\n    -webkit-transform-origin: 100% 0%;\n    transform-origin: 100% 0%;\n    opacity: 1;\n  }\n  100% {\n    -webkit-transform: scaleY(0);\n    transform: scaleY(0);\n    -webkit-transform-origin: 100% 0%;\n    transform-origin: 100% 0%;\n    opacity: 1;\n  }\n}\n@keyframes scale-out-ver-top {\n  0% {\n    -webkit-transform: scaleY(1);\n    transform: scaleY(1);\n    -webkit-transform-origin: 100% 0%;\n    transform-origin: 100% 0%;\n    opacity: 1;\n  }\n  100% {\n    -webkit-transform: scaleY(0);\n    transform: scaleY(0);\n    -webkit-transform-origin: 100% 0%;\n    transform-origin: 100% 0%;\n    opacity: 1;\n  }\n}\n","avg_line_length":18.7639836289,"max_line_length":76,"alphanum_fraction":0.6273811255,"licenses":["MIT"],"repository_name":"evgeni-tsn\/MashmoClothing","path":"src\/layouts\/index.css","size":13754,"lang":"CSS"}
{"content":"\/\/ Code generated by smithy-go-codegen DO NOT EDIT.\n\npackage endpoints\n\nimport (\n\t\"github.com\/aws\/aws-sdk-go-v2\/aws\"\n\tendpoints \"github.com\/aws\/aws-sdk-go-v2\/internal\/endpoints\/v2\"\n\t\"github.com\/aws\/smithy-go\/logging\"\n\t\"regexp\"\n)\n\n\/\/ Options is the endpoint resolver configuration options\ntype Options struct {\n\t\/\/ Logger is a logging implementation that log events should be sent to.\n\tLogger logging.Logger\n\n\t\/\/ LogDeprecated indicates that deprecated endpoints should be logged to the\n\t\/\/ provided logger.\n\tLogDeprecated bool\n\n\t\/\/ ResolvedRegion is used to override the region to be resolved, rather then the\n\t\/\/ using the value passed to the ResolveEndpoint method. This value is used by the\n\t\/\/ SDK to translate regions like fips-us-east-1 or us-east-1-fips to an alternative\n\t\/\/ name. You must not set this value directly in your application.\n\tResolvedRegion string\n\n\t\/\/ DisableHTTPS informs the resolver to return an endpoint that does not use the\n\t\/\/ HTTPS scheme.\n\tDisableHTTPS bool\n\n\t\/\/ UseDualStackEndpoint specifies the resolver must resolve a dual-stack endpoint.\n\tUseDualStackEndpoint aws.DualStackEndpointState\n\n\t\/\/ UseFIPSEndpoint specifies the resolver must resolve a FIPS endpoint.\n\tUseFIPSEndpoint aws.FIPSEndpointState\n}\n\nfunc (o Options) GetResolvedRegion() string {\n\treturn o.ResolvedRegion\n}\n\nfunc (o Options) GetDisableHTTPS() bool {\n\treturn o.DisableHTTPS\n}\n\nfunc (o Options) GetUseDualStackEndpoint() aws.DualStackEndpointState {\n\treturn o.UseDualStackEndpoint\n}\n\nfunc (o Options) GetUseFIPSEndpoint() aws.FIPSEndpointState {\n\treturn o.UseFIPSEndpoint\n}\n\nfunc transformToSharedOptions(options Options) endpoints.Options {\n\treturn endpoints.Options{\n\t\tLogger:               options.Logger,\n\t\tLogDeprecated:        options.LogDeprecated,\n\t\tResolvedRegion:       options.ResolvedRegion,\n\t\tDisableHTTPS:         options.DisableHTTPS,\n\t\tUseDualStackEndpoint: options.UseDualStackEndpoint,\n\t\tUseFIPSEndpoint:      options.UseFIPSEndpoint,\n\t}\n}\n\n\/\/ Resolver AppIntegrations endpoint resolver\ntype Resolver struct {\n\tpartitions endpoints.Partitions\n}\n\n\/\/ ResolveEndpoint resolves the service endpoint for the given region and options\nfunc (r *Resolver) ResolveEndpoint(region string, options Options) (endpoint aws.Endpoint, err error) {\n\tif len(region) == 0 {\n\t\treturn endpoint, &aws.MissingRegionError{}\n\t}\n\n\topt := transformToSharedOptions(options)\n\treturn r.partitions.ResolveEndpoint(region, opt)\n}\n\n\/\/ New returns a new Resolver\nfunc New() *Resolver {\n\treturn &Resolver{\n\t\tpartitions: defaultPartitions,\n\t}\n}\n\nvar partitionRegexp = struct {\n\tAws      *regexp.Regexp\n\tAwsCn    *regexp.Regexp\n\tAwsIso   *regexp.Regexp\n\tAwsIsoB  *regexp.Regexp\n\tAwsUsGov *regexp.Regexp\n}{\n\n\tAws:      regexp.MustCompile(\"^(us|eu|ap|sa|ca|me|af)\\\\-\\\\w+\\\\-\\\\d+$\"),\n\tAwsCn:    regexp.MustCompile(\"^cn\\\\-\\\\w+\\\\-\\\\d+$\"),\n\tAwsIso:   regexp.MustCompile(\"^us\\\\-iso\\\\-\\\\w+\\\\-\\\\d+$\"),\n\tAwsIsoB:  regexp.MustCompile(\"^us\\\\-isob\\\\-\\\\w+\\\\-\\\\d+$\"),\n\tAwsUsGov: regexp.MustCompile(\"^us\\\\-gov\\\\-\\\\w+\\\\-\\\\d+$\"),\n}\n\nvar defaultPartitions = endpoints.Partitions{\n\t{\n\t\tID: \"aws\",\n\t\tDefaults: map[endpoints.DefaultKey]endpoints.Endpoint{\n\t\t\t{\n\t\t\t\tVariant: endpoints.DualStackVariant,\n\t\t\t}: {\n\t\t\t\tHostname:          \"app-integrations.{region}.api.aws\",\n\t\t\t\tProtocols:         []string{\"https\"},\n\t\t\t\tSignatureVersions: []string{\"v4\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tVariant: endpoints.FIPSVariant,\n\t\t\t}: {\n\t\t\t\tHostname:          \"app-integrations-fips.{region}.amazonaws.com\",\n\t\t\t\tProtocols:         []string{\"https\"},\n\t\t\t\tSignatureVersions: []string{\"v4\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tVariant: endpoints.FIPSVariant | endpoints.DualStackVariant,\n\t\t\t}: {\n\t\t\t\tHostname:          \"app-integrations-fips.{region}.api.aws\",\n\t\t\t\tProtocols:         []string{\"https\"},\n\t\t\t\tSignatureVersions: []string{\"v4\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tVariant: 0,\n\t\t\t}: {\n\t\t\t\tHostname:          \"app-integrations.{region}.amazonaws.com\",\n\t\t\t\tProtocols:         []string{\"https\"},\n\t\t\t\tSignatureVersions: []string{\"v4\"},\n\t\t\t},\n\t\t},\n\t\tRegionRegex:    partitionRegexp.Aws,\n\t\tIsRegionalized: true,\n\t\tEndpoints: endpoints.Endpoints{\n\t\t\tendpoints.EndpointKey{\n\t\t\t\tRegion: \"af-south-1\",\n\t\t\t}: endpoints.Endpoint{},\n\t\t\tendpoints.EndpointKey{\n\t\t\t\tRegion: \"ap-northeast-1\",\n\t\t\t}: endpoints.Endpoint{},\n\t\t\tendpoints.EndpointKey{\n\t\t\t\tRegion: \"ap-northeast-2\",\n\t\t\t}: endpoints.Endpoint{},\n\t\t\tendpoints.EndpointKey{\n\t\t\t\tRegion: \"ap-southeast-1\",\n\t\t\t}: endpoints.Endpoint{},\n\t\t\tendpoints.EndpointKey{\n\t\t\t\tRegion: \"ap-southeast-2\",\n\t\t\t}: endpoints.Endpoint{},\n\t\t\tendpoints.EndpointKey{\n\t\t\t\tRegion: \"ca-central-1\",\n\t\t\t}: endpoints.Endpoint{},\n\t\t\tendpoints.EndpointKey{\n\t\t\t\tRegion: \"eu-central-1\",\n\t\t\t}: endpoints.Endpoint{},\n\t\t\tendpoints.EndpointKey{\n\t\t\t\tRegion: \"eu-west-2\",\n\t\t\t}: endpoints.Endpoint{},\n\t\t\tendpoints.EndpointKey{\n\t\t\t\tRegion: \"us-east-1\",\n\t\t\t}: endpoints.Endpoint{},\n\t\t\tendpoints.EndpointKey{\n\t\t\t\tRegion: \"us-west-2\",\n\t\t\t}: endpoints.Endpoint{},\n\t\t},\n\t},\n\t{\n\t\tID: \"aws-cn\",\n\t\tDefaults: map[endpoints.DefaultKey]endpoints.Endpoint{\n\t\t\t{\n\t\t\t\tVariant: endpoints.DualStackVariant,\n\t\t\t}: {\n\t\t\t\tHostname:          \"app-integrations.{region}.api.amazonwebservices.com.cn\",\n\t\t\t\tProtocols:         []string{\"https\"},\n\t\t\t\tSignatureVersions: []string{\"v4\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tVariant: endpoints.FIPSVariant,\n\t\t\t}: {\n\t\t\t\tHostname:          \"app-integrations-fips.{region}.amazonaws.com.cn\",\n\t\t\t\tProtocols:         []string{\"https\"},\n\t\t\t\tSignatureVersions: []string{\"v4\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tVariant: endpoints.FIPSVariant | endpoints.DualStackVariant,\n\t\t\t}: {\n\t\t\t\tHostname:          \"app-integrations-fips.{region}.api.amazonwebservices.com.cn\",\n\t\t\t\tProtocols:         []string{\"https\"},\n\t\t\t\tSignatureVersions: []string{\"v4\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tVariant: 0,\n\t\t\t}: {\n\t\t\t\tHostname:          \"app-integrations.{region}.amazonaws.com.cn\",\n\t\t\t\tProtocols:         []string{\"https\"},\n\t\t\t\tSignatureVersions: []string{\"v4\"},\n\t\t\t},\n\t\t},\n\t\tRegionRegex:    partitionRegexp.AwsCn,\n\t\tIsRegionalized: true,\n\t},\n\t{\n\t\tID: \"aws-iso\",\n\t\tDefaults: map[endpoints.DefaultKey]endpoints.Endpoint{\n\t\t\t{\n\t\t\t\tVariant: endpoints.FIPSVariant,\n\t\t\t}: {\n\t\t\t\tHostname:          \"app-integrations-fips.{region}.c2s.ic.gov\",\n\t\t\t\tProtocols:         []string{\"https\"},\n\t\t\t\tSignatureVersions: []string{\"v4\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tVariant: 0,\n\t\t\t}: {\n\t\t\t\tHostname:          \"app-integrations.{region}.c2s.ic.gov\",\n\t\t\t\tProtocols:         []string{\"https\"},\n\t\t\t\tSignatureVersions: []string{\"v4\"},\n\t\t\t},\n\t\t},\n\t\tRegionRegex:    partitionRegexp.AwsIso,\n\t\tIsRegionalized: true,\n\t},\n\t{\n\t\tID: \"aws-iso-b\",\n\t\tDefaults: map[endpoints.DefaultKey]endpoints.Endpoint{\n\t\t\t{\n\t\t\t\tVariant: endpoints.FIPSVariant,\n\t\t\t}: {\n\t\t\t\tHostname:          \"app-integrations-fips.{region}.sc2s.sgov.gov\",\n\t\t\t\tProtocols:         []string{\"https\"},\n\t\t\t\tSignatureVersions: []string{\"v4\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tVariant: 0,\n\t\t\t}: {\n\t\t\t\tHostname:          \"app-integrations.{region}.sc2s.sgov.gov\",\n\t\t\t\tProtocols:         []string{\"https\"},\n\t\t\t\tSignatureVersions: []string{\"v4\"},\n\t\t\t},\n\t\t},\n\t\tRegionRegex:    partitionRegexp.AwsIsoB,\n\t\tIsRegionalized: true,\n\t},\n\t{\n\t\tID: \"aws-us-gov\",\n\t\tDefaults: map[endpoints.DefaultKey]endpoints.Endpoint{\n\t\t\t{\n\t\t\t\tVariant: endpoints.DualStackVariant,\n\t\t\t}: {\n\t\t\t\tHostname:          \"app-integrations.{region}.api.aws\",\n\t\t\t\tProtocols:         []string{\"https\"},\n\t\t\t\tSignatureVersions: []string{\"v4\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tVariant: endpoints.FIPSVariant,\n\t\t\t}: {\n\t\t\t\tHostname:          \"app-integrations-fips.{region}.amazonaws.com\",\n\t\t\t\tProtocols:         []string{\"https\"},\n\t\t\t\tSignatureVersions: []string{\"v4\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tVariant: endpoints.FIPSVariant | endpoints.DualStackVariant,\n\t\t\t}: {\n\t\t\t\tHostname:          \"app-integrations-fips.{region}.api.aws\",\n\t\t\t\tProtocols:         []string{\"https\"},\n\t\t\t\tSignatureVersions: []string{\"v4\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tVariant: 0,\n\t\t\t}: {\n\t\t\t\tHostname:          \"app-integrations.{region}.amazonaws.com\",\n\t\t\t\tProtocols:         []string{\"https\"},\n\t\t\t\tSignatureVersions: []string{\"v4\"},\n\t\t\t},\n\t\t},\n\t\tRegionRegex:    partitionRegexp.AwsUsGov,\n\t\tIsRegionalized: true,\n\t},\n}\n","avg_line_length":28.0636042403,"max_line_length":103,"alphanum_fraction":0.6505917905,"licenses":["Apache-2.0"],"repository_name":"Nexuscompute\/aws-sdk-go-v2","path":"service\/appintegrations\/internal\/endpoints\/endpoints.go","size":7942,"lang":"GO"}
{"content":"\/\/ Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.\nuse crate::swc_common::Spanned;\nuse crate::swc_ecma_ast;\n\nuse super::parser::DocParser;\nuse super::DocNode;\nuse super::DocNodeKind;\n\npub fn get_doc_node_for_export_decl(\n  doc_parser: &DocParser,\n  export_decl: &swc_ecma_ast::ExportDecl,\n) -> DocNode {\n  let export_span = export_decl.span();\n  use crate::swc_ecma_ast::Decl;\n\n  let js_doc = doc_parser.js_doc_for_span(export_span);\n  let location = doc_parser.ast_parser.get_span_location(export_span).into();\n\n  match &export_decl.decl {\n    Decl::Class(class_decl) => {\n      let (name, class_def) =\n        super::class::get_doc_for_class_decl(doc_parser, class_decl);\n      DocNode {\n        kind: DocNodeKind::Class,\n        name,\n        location,\n        js_doc,\n        class_def: Some(class_def),\n        function_def: None,\n        variable_def: None,\n        enum_def: None,\n        type_alias_def: None,\n        namespace_def: None,\n        interface_def: None,\n      }\n    }\n    Decl::Fn(fn_decl) => {\n      let (name, function_def) =\n        super::function::get_doc_for_fn_decl(doc_parser, fn_decl);\n      DocNode {\n        kind: DocNodeKind::Function,\n        name,\n        location,\n        js_doc,\n        function_def: Some(function_def),\n        class_def: None,\n        variable_def: None,\n        enum_def: None,\n        type_alias_def: None,\n        namespace_def: None,\n        interface_def: None,\n      }\n    }\n    Decl::Var(var_decl) => {\n      let (name, var_def) = super::variable::get_doc_for_var_decl(var_decl);\n      DocNode {\n        kind: DocNodeKind::Variable,\n        name,\n        location,\n        js_doc,\n        variable_def: Some(var_def),\n        function_def: None,\n        class_def: None,\n        enum_def: None,\n        type_alias_def: None,\n        namespace_def: None,\n        interface_def: None,\n      }\n    }\n    Decl::TsInterface(ts_interface_decl) => {\n      let (name, interface_def) =\n        super::interface::get_doc_for_ts_interface_decl(\n          doc_parser,\n          ts_interface_decl,\n        );\n      DocNode {\n        kind: DocNodeKind::Interface,\n        name,\n        location,\n        js_doc,\n        interface_def: Some(interface_def),\n        variable_def: None,\n        function_def: None,\n        class_def: None,\n        enum_def: None,\n        type_alias_def: None,\n        namespace_def: None,\n      }\n    }\n    Decl::TsTypeAlias(ts_type_alias) => {\n      let (name, type_alias_def) =\n        super::type_alias::get_doc_for_ts_type_alias_decl(\n          doc_parser,\n          ts_type_alias,\n        );\n      DocNode {\n        kind: DocNodeKind::TypeAlias,\n        name,\n        location,\n        js_doc,\n        type_alias_def: Some(type_alias_def),\n        interface_def: None,\n        variable_def: None,\n        function_def: None,\n        class_def: None,\n        enum_def: None,\n        namespace_def: None,\n      }\n    }\n    Decl::TsEnum(ts_enum) => {\n      let (name, enum_def) =\n        super::r#enum::get_doc_for_ts_enum_decl(doc_parser, ts_enum);\n      DocNode {\n        kind: DocNodeKind::Enum,\n        name,\n        location,\n        js_doc,\n        enum_def: Some(enum_def),\n        type_alias_def: None,\n        interface_def: None,\n        variable_def: None,\n        function_def: None,\n        class_def: None,\n        namespace_def: None,\n      }\n    }\n    Decl::TsModule(ts_module) => {\n      let (name, namespace_def) =\n        super::namespace::get_doc_for_ts_module(doc_parser, ts_module);\n      DocNode {\n        kind: DocNodeKind::Namespace,\n        name,\n        location,\n        js_doc,\n        namespace_def: Some(namespace_def),\n        enum_def: None,\n        type_alias_def: None,\n        interface_def: None,\n        variable_def: None,\n        function_def: None,\n        class_def: None,\n      }\n    }\n  }\n}\n","avg_line_length":26.3219178082,"max_line_length":77,"alphanum_fraction":0.5878220141,"licenses":["MIT"],"repository_name":"JAicewizard\/deno","path":"cli\/doc\/module.rs","size":3843,"lang":"Rust"}
{"content":"# Install script for directory: \/Users\/silence\/Documents\/Github\/Me\/iOS-Reverse\/llvm\/Source\/llvm\/unittests\/AsmParser\n\n# Set the install prefix\nif(NOT DEFINED CMAKE_INSTALL_PREFIX)\n  set(CMAKE_INSTALL_PREFIX \"\/usr\/local\")\nendif()\nstring(REGEX REPLACE \"\/$\" \"\" CMAKE_INSTALL_PREFIX \"${CMAKE_INSTALL_PREFIX}\")\n\n# Set the install configuration name.\nif(NOT DEFINED CMAKE_INSTALL_CONFIG_NAME)\n  if(BUILD_TYPE)\n    string(REGEX REPLACE \"^[^A-Za-z0-9_]+\" \"\"\n           CMAKE_INSTALL_CONFIG_NAME \"${BUILD_TYPE}\")\n  else()\n    set(CMAKE_INSTALL_CONFIG_NAME \"Release\")\n  endif()\n  message(STATUS \"Install configuration: \\\"${CMAKE_INSTALL_CONFIG_NAME}\\\"\")\nendif()\n\n# Set the component getting installed.\nif(NOT CMAKE_INSTALL_COMPONENT)\n  if(COMPONENT)\n    message(STATUS \"Install component: \\\"${COMPONENT}\\\"\")\n    set(CMAKE_INSTALL_COMPONENT \"${COMPONENT}\")\n  else()\n    set(CMAKE_INSTALL_COMPONENT)\n  endif()\nendif()\n\n# Is this installation the result of a crosscompile?\nif(NOT DEFINED CMAKE_CROSSCOMPILING)\n  set(CMAKE_CROSSCOMPILING \"FALSE\")\nendif()\n\n","avg_line_length":29.7428571429,"max_line_length":115,"alphanum_fraction":0.7463976945,"licenses":["MIT"],"repository_name":"silence0201\/iOS-Reverse","path":"llvm\/Source\/llvm_xcode\/unittests\/AsmParser\/cmake_install.cmake","size":1041,"lang":"CMake"}
{"content":"@{\r\n\r\n# Script module or binary module file associated with this manifest.\r\nModuleToProcess = 'posh-git.psm1'\r\n\r\n# Version number of this module.\r\nModuleVersion = '0.6.1.20160330'\r\n\r\n# ID used to uniquely identify this module\r\nGUID = '74c9fd30-734b-4c89-a8ae-7727ad21d1d5'\r\n\r\n# Author of this module\r\nAuthor = 'Keith Dahlby and contributors'\r\n\r\n# Copyright statement for this module\r\nCopyright = '(c) 2010-2016 Keith Dahlby and contributors'\r\n\r\n# Description of the functionality provided by this module\r\nDescription = 'A PowerShell environment for Git'\r\n\r\n# Minimum version of the Windows PowerShell engine required by this module\r\nPowerShellVersion = '2.0'\r\n\r\n# Functions to export from this module\r\nFunctionsToExport = @('Invoke-NullCoalescing',\r\n        'Write-GitStatus',\r\n        'Write-Prompt',\r\n        'Get-GitStatus',\r\n        'Enable-GitColors',\r\n        'Get-GitDirectory',\r\n        'TabExpansion',\r\n        'Get-AliasPattern',\r\n        'Get-SshAgent',\r\n        'Start-SshAgent',\r\n        'Stop-SshAgent',\r\n        'Add-SshKey',\r\n        'Get-SshPath',\r\n        'Update-AllBranches',\r\n        'tgit')\r\n\r\n# Cmdlets to export from this module\r\nCmdletsToExport = @()\r\n\r\n# Variables to export from this module\r\nVariablesToExport = @()\r\n\r\n# Aliases to export from this module\r\nAliasesToExport = @('??')\r\n\r\n# Private data to pass to the module specified in RootModule\/ModuleToProcess. This may also contain a PSData hashtable with additional module metadata used by PowerShell.\r\nPrivateData = @{\r\n\r\n    PSData = @{\r\n\r\n        # Tags applied to this module. These help with module discovery in online galleries.\r\n        Tags = @('git')\r\n\r\n        # A URL to the license for this module.\r\n        LicenseUri = 'https:\/\/github.com\/dahlbyk\/posh-git\/blob\/master\/LICENSE.txt'\r\n\r\n        # A URL to the main website for this project.\r\n        ProjectUri = 'https:\/\/github.com\/dahlbyk\/posh-git'\r\n\r\n        # A URL to an icon representing this module.\r\n        # IconUri = ''\r\n\r\n        # ReleaseNotes of this module\r\n        # ReleaseNotes = ''\r\n\r\n    } # End of PSData hashtable\r\n\r\n} # End of PrivateData hashtable\r\n\r\n}\r\n\r\n","avg_line_length":27.9342105263,"max_line_length":171,"alphanum_fraction":0.6519076778,"licenses":["MIT"],"repository_name":"HaroldAlmon\/posh-git","path":"posh-git.psd1","size":2123,"lang":"PowerShell"}
{"content":"\/**\n * Auto-generated action file for \"Spinitron v2\" API.\n *\n * Generated at: 2019-05-07T14:44:09.560Z\n * Mass generator version: 1.1.0\n *\n * flowground :- Telekom iPaaS \/ spinitron-com-connector\n * Copyright \u00a9 2019, Deutsche Telekom AG\n * contact: flowground@telekom.de\n *\n * All files of this connector are licensed under the Apache 2.0 License. For details\n * see the file LICENSE on the toplevel directory.\n *\n *\n * Operation: undefined\n * Endpoint Path: '\/shows'\n * Method: 'get'\n *\n *\/\n\nconst Swagger = require('swagger-client');\nconst processWrapper = require('..\/services\/process-wrapper');\nconst spec = require('..\/spec.json');\n\n\/\/ this wrapers offers a simplified emitData(data) function\nmodule.exports.process = processWrapper(processAction);\n\n\/\/ parameter names for this call\nconst PARAMETERS = [\n    \"start\",\n    \"end\",\n    \"count\",\n    \"page\",\n    \"fields\",\n    \"expand\"\n];\n\n\/\/ mappings from connector field names to API field names\nconst FIELD_MAP = {\n    \"start\": \"start\",\n    \"end\": \"end\",\n    \"count\": \"count\",\n    \"page\": \"page\",\n    \"fields\": \"fields\",\n    \"expand\": \"expand\"\n};\n\nfunction processAction(msg, cfg) {\n    var isVerbose = process.env.debug || cfg.verbose;\n\n    if (isVerbose) {\n        console.log(`---MSG: ${JSON.stringify(msg)}`);\n        console.log(`---CFG: ${JSON.stringify(cfg)}`);\n        console.log(`---ENV: ${JSON.stringify(process.env)}`);\n    }\n\n    const contentType = undefined;\n\n    const body = msg.body;\n    mapFieldNames(body);\n\n    let parameters = {};\n    for(let param of PARAMETERS) {\n        parameters[param] = body[param];\n    }\n\n    \/\/ credentials for this operation\n    let securities = {};\n    securities['Bearer'] = cfg['Bearer'];\n\n    let callParams = {\n        spec: spec,\n        operationId: undefined,\n        pathName: '\/shows',\n        method: 'get',\n        parameters: parameters,\n        requestContentType: contentType,\n        requestBody: body.requestBody,\n        securities: {authorized: securities},\n        server: spec.servers[cfg.server] || cfg.otherServer,\n    };\n\n    if (isVerbose) {\n        let out = Object.assign({}, callParams);\n        out.spec = '[omitted]';\n        console.log(`--SWAGGER CALL: ${JSON.stringify(out)}`);\n    }\n\n    \/\/ Call operation via Swagger client\n    return Swagger.execute(callParams).then(data => {\n        \/\/ emit a single message with data\n        this.emitData(data);\n\n        \/\/ if the response contains an array of entities, you can emit them one by one:\n\n        \/\/ data.obj.someItems.forEach((item) => {\n        \/\/     this.emitData(item);\n        \/\/ }\n    });\n}\n\nfunction mapFieldNames(obj) {\n    if(Array.isArray(obj)) {\n        obj.forEach(mapFieldNames);\n    }\n    else if(typeof obj === 'object' && obj) {\n        Object.keys(obj).forEach(key => {\n            mapFieldNames(obj[key]);\n\n            let goodKey = FIELD_MAP[key];\n            if(goodKey && goodKey !== key) {\n                obj[goodKey] = obj[key];\n                delete obj[key];\n            }\n        });\n    }\n}","avg_line_length":25.7008547009,"max_line_length":87,"alphanum_fraction":0.594945128,"licenses":["Apache-2.0"],"repository_name":"flowground\/spinitron-com-connector","path":"lib\/actions\/get_shows.js","size":3008,"lang":"JavaScript"}
{"content":"\/\/ Copyright (c) Xenko contributors (https:\/\/xenko.com) and Silicon Studio Corp. (https:\/\/www.siliconstudio.co.jp)\n\/\/ Distributed under the MIT license. See the LICENSE.md file in the project root for more information.\nusing System;\nusing System.IO;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Xenko.Core.Serialization;\nusing Xenko.Engine.Network;\nusing Xenko.Shaders.Compiler.Internals;\n\nnamespace Xenko.Shaders.Compiler\n{\n    \/\/\/ <summary>\n    \/\/\/ Used internally by <see cref=\"RemoteEffectCompiler\"\/> to compile shaders remotely,\n    \/\/\/ and <see cref=\"Rendering.EffectSystem.CreateEffectCompiler\"\/> to record effect requested.\n    \/\/\/ <\/summary>\n    class RemoteEffectCompilerClient : IDisposable\n    {\n        private readonly object lockObject = new object();\n        private readonly Guid? packageId;\n        private Task<SocketMessageLayer> socketMessageLayerTask;\n        private CancellationTokenSource cancellationTokenSource = new CancellationTokenSource();\n\n        public RemoteEffectCompilerClient(Guid? packageId)\n        {\n            this.packageId = packageId;\n        }\n\n        public void Dispose()\n        {\n            \/\/ Notify cancellation\n            cancellationTokenSource.Cancel();\n            if (socketMessageLayerTask != null && socketMessageLayerTask.Status == TaskStatus.RanToCompletion)\n            {\n                socketMessageLayerTask.Result.Context.Dispose();\n                socketMessageLayerTask = null;\n            }\n        }\n\n        public void NotifyEffectUsed(EffectCompileRequest effectCompileRequest, CompilerResults result)\n        {\n            if (result.HasErrors)\n                return;\n\n            Task.Run(async () =>\n            {\n                \/\/ Silently fails if connection already failed previously\n                var socketMessageLayerTask = GetOrCreateConnection(cancellationTokenSource.Token);\n                if (socketMessageLayerTask.IsFaulted)\n                    return;\n\n                var bytecode = await result.Bytecode.AwaitResult();\n                if (bytecode.CompilationLog.HasErrors)\n                    return;\n\n                \/\/ Ignore everything that has been compiled by the startup cache\n                if (bytecode.LoadSource == EffectBytecodeCacheLoadSource.StartupCache)\n                    return;\n\n                \/\/ Send any effect request remotely (should fail if not connected)\n                var socketMessageLayer = await socketMessageLayerTask;\n\n                var memoryStream = new MemoryStream();\n                var binaryWriter = new BinarySerializationWriter(memoryStream);\n                binaryWriter.Context.SerializerSelector = SerializerSelector.AssetWithReuse;\n                binaryWriter.SerializeExtended(effectCompileRequest, ArchiveMode.Serialize, null);\n\n                await socketMessageLayer.Send(new RemoteEffectCompilerEffectRequested { Request = memoryStream.ToArray() });\n            });\n        }\n\n        public async Task<SocketMessageLayer> Connect(Guid? packageId, CancellationToken cancellationToken)\n        {\n            var url = string.Format(\"\/service\/{0}\/Xenko.EffectCompilerServer.exe\", XenkoVersion.NuGetVersion);\n            if (packageId.HasValue)\n                url += string.Format(\"?packageid={0}\", packageId.Value);\n\n            var socketContext = await RouterClient.RequestServer(url, cancellationToken);\n\n            var socketMessageLayer = new SocketMessageLayer(socketContext, false);\n\n            \/\/ Register network VFS\n            NetworkVirtualFileProvider.RegisterServer(socketMessageLayer);\n\n            Task.Run(() => socketMessageLayer.MessageLoop());\n\n            return socketMessageLayer;\n        }\n\n        public async Task<EffectBytecodeCompilerResult> Compile(ShaderMixinSource mixinTree, EffectCompilerParameters effectParameters)\n        {\n            \/\/ Make sure we are connected\n            \/\/ TODO: Handle reconnections, etc...\n            var socketMessageLayer = await GetOrCreateConnection(cancellationTokenSource.Token);\n\n            var shaderCompilerAnswer = (RemoteEffectCompilerEffectAnswer)await socketMessageLayer.SendReceiveAsync(new RemoteEffectCompilerEffectRequest\n            {\n                MixinTree = mixinTree,\n                EffectParameters = effectParameters,\n            });\n\n            var result = new EffectBytecodeCompilerResult(shaderCompilerAnswer.EffectBytecode, EffectBytecodeCacheLoadSource.JustCompiled);\n\n            foreach (var message in shaderCompilerAnswer.LogMessages)\n                result.CompilationLog.Messages.Add(message);\n\n            result.CompilationLog.HasErrors = shaderCompilerAnswer.LogHasErrors;\n\n            return result;\n        }\n\n        private async Task<SocketMessageLayer> GetOrCreateConnection(CancellationToken cancellationToken)\n        {\n            \/\/ Lazily connect\n            lock (lockObject)\n            {\n                if (socketMessageLayerTask == null)\n                    socketMessageLayerTask = Task.Run(() => Connect(packageId, cancellationToken));\n            }\n\n            return await socketMessageLayerTask;\n        }\n    }\n}\n","avg_line_length":40.944,"max_line_length":152,"alphanum_fraction":0.6531848378,"licenses":["MIT"],"repository_name":"Aminator\/xenko","path":"sources\/engine\/Xenko.Engine\/Shaders.Compiler\/RemoteEffectCompilerClient.cs","size":5118,"lang":"C#"}
{"content":"<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    <title>mini-compiler: Not compatible<\/title>\n    <link rel=\"shortcut icon\" type=\"image\/png\" href=\"..\/..\/..\/..\/..\/favicon.png\" \/>\n    <link href=\"..\/..\/..\/..\/..\/bootstrap.min.css\" rel=\"stylesheet\">\n    <link href=\"..\/..\/..\/..\/..\/bootstrap-custom.css\" rel=\"stylesheet\">\n    <link href=\"\/\/maxcdn.bootstrapcdn.com\/font-awesome\/4.2.0\/css\/font-awesome.min.css\" rel=\"stylesheet\">\n    <script src=\"..\/..\/..\/..\/..\/moment.min.js\"><\/script>\n    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->\n    <!-- WARNING: Respond.js doesn't work if you view the page via file:\/\/ -->\n    <!--[if lt IE 9]>\n      <script src=\"https:\/\/oss.maxcdn.com\/html5shiv\/3.7.2\/html5shiv.min.js\"><\/script>\n      <script src=\"https:\/\/oss.maxcdn.com\/respond\/1.4.2\/respond.min.js\"><\/script>\n    <![endif]-->\n  <\/head>\n  <body>\n    <div class=\"container\">\n      <div class=\"navbar navbar-default\" role=\"navigation\">\n        <div class=\"container-fluid\">\n          <div class=\"navbar-header\">\n            <a class=\"navbar-brand\" href=\"..\/..\/..\/..\/..\"><i class=\"fa fa-lg fa-flag-checkered\"><\/i> Coq bench<\/a>\n          <\/div>\n          <div id=\"navbar\" class=\"collapse navbar-collapse\">\n            <ul class=\"nav navbar-nav\">\n              <li><a href=\"..\/..\">clean \/ released<\/a><\/li>\n              <li class=\"active\"><a href=\"\">8.5.0 \/ mini-compiler - 8.7.0<\/a><\/li>\n            <\/ul>\n          <\/div>\n        <\/div>\n      <\/div>\n      <div class=\"article\">\n        <div class=\"row\">\n          <div class=\"col-md-12\">\n            <a href=\"..\/..\">\u00ab Up<\/a>\n            <h1>\n              mini-compiler\n              <small>\n                8.7.0\n                <span class=\"label label-info\">Not compatible<\/span>\n              <\/small>\n            <\/h1>\n            <p><em><script>document.write(moment(\"2021-08-18 10:24:42 +0000\", \"YYYY-MM-DD HH:mm:ss Z\").fromNow());<\/script> (2021-08-18 10:24:42 UTC)<\/em><p>\n            <h2>Context<\/h2>\n            <pre># Packages matching: installed\n# Name              # Installed # Synopsis\nbase-bigarray       base\nbase-num            base        Num library distributed with the OCaml compiler\nbase-ocamlbuild     base        OCamlbuild binary and libraries distributed with the OCaml compiler\nbase-threads        base\nbase-unix           base\ncamlp5              7.14        Preprocessor-pretty-printer of OCaml\nconf-findutils      1           Virtual package relying on findutils\nconf-perl           1           Virtual package relying on perl\ncoq                 8.5.0       Formal proof management system\nnum                 0           The Num library for arbitrary-precision integer and rational arithmetic\nocaml               4.02.3      The OCaml compiler (virtual package)\nocaml-base-compiler 4.02.3      Official 4.02.3 release\nocaml-config        1           OCaml Switch Configuration\n# opam file:\nopam-version: &quot;2.0&quot;\nmaintainer: &quot;Hugo.Herbelin@inria.fr&quot;\nhomepage: &quot;https:\/\/github.com\/coq-contribs\/mini-compiler&quot;\nlicense: &quot;LGPL 2.1&quot;\nbuild: [make &quot;-j%{jobs}%&quot;]\ninstall: [make &quot;install&quot;]\nremove: [&quot;rm&quot; &quot;-R&quot; &quot;%{lib}%\/coq\/user-contrib\/MiniCompiler&quot;]\ndepends: [\n  &quot;ocaml&quot;\n  &quot;coq&quot; {&gt;= &quot;8.7&quot; &amp; &lt; &quot;8.8~&quot;}\n]\ntags: [ &quot;keyword: compilation&quot; &quot;keyword: correctness&quot; &quot;keyword: arithmetic&quot; &quot;category: Computer Science\/Semantics and Compilation\/Compilation&quot; &quot;date: 2003&quot; ]\nauthors: [ &quot;Jean-Christophe Filli\u00e2tre&quot; ]\nbug-reports: &quot;https:\/\/github.com\/coq-contribs\/mini-compiler\/issues&quot;\ndev-repo: &quot;git+https:\/\/github.com\/coq-contribs\/mini-compiler.git&quot;\nsynopsis: &quot;Correctness of a tiny compiler for arithmetic expressions&quot;\ndescription: &quot;&quot;&quot;\nTutorial correctness proof of a tiny compiler from\nsimple arithmetic expressions (constants, variables and additions) to\nsimple assembly-like code (one accumulator, infinitly many registers and\naddition)&quot;&quot;&quot;\nflags: light-uninstall\nurl {\n  src: &quot;https:\/\/github.com\/coq-contribs\/mini-compiler\/archive\/v8.7.0.tar.gz&quot;\n  checksum: &quot;md5=dd4f40c8ef66e6bdb212edec29102e53&quot;\n}\n<\/pre>\n            <h2>Lint<\/h2>\n            <dl class=\"dl-horizontal\">\n              <dt>Command<\/dt>\n              <dd><code>true<\/code><\/dd>\n              <dt>Return code<\/dt>\n              <dd>0<\/dd>\n            <\/dl>\n            <h2>Dry install<\/h2>\n            <p>Dry install with the current Coq version:<\/p>\n            <dl class=\"dl-horizontal\">\n              <dt>Command<\/dt>\n              <dd><code>opam install -y --show-action coq-mini-compiler.8.7.0 coq.8.5.0<\/code><\/dd>\n              <dt>Return code<\/dt>\n              <dd>5120<\/dd>\n              <dt>Output<\/dt>\n              <dd><pre>[NOTE] Package coq is already installed (current version is 8.5.0).\nThe following dependencies couldn&#39;t be met:\n  - coq-mini-compiler -&gt; coq &gt;= 8.7 -&gt; ocaml &gt;= 4.05.0\n      base of this switch (use `--unlock-base&#39; to force)\nYour request can&#39;t be satisfied:\n  - No available version of coq satisfies the constraints\nNo solution found, exiting\n<\/pre><\/dd>\n            <\/dl>\n            <p>Dry install without Coq\/switch base, to test if the problem was incompatibility with the current Coq\/OCaml version:<\/p>\n            <dl class=\"dl-horizontal\">\n              <dt>Command<\/dt>\n              <dd><code>opam remove -y coq; opam install -y --show-action --unlock-base coq-mini-compiler.8.7.0<\/code><\/dd>\n              <dt>Return code<\/dt>\n              <dd>0<\/dd>\n            <\/dl>\n            <h2>Install dependencies<\/h2>\n            <dl class=\"dl-horizontal\">\n              <dt>Command<\/dt>\n              <dd><code>true<\/code><\/dd>\n              <dt>Return code<\/dt>\n              <dd>0<\/dd>\n              <dt>Duration<\/dt>\n              <dd>0 s<\/dd>\n            <\/dl>\n            <h2>Install<\/h2>\n            <dl class=\"dl-horizontal\">\n              <dt>Command<\/dt>\n              <dd><code>true<\/code><\/dd>\n              <dt>Return code<\/dt>\n              <dd>0<\/dd>\n              <dt>Duration<\/dt>\n              <dd>0 s<\/dd>\n            <\/dl>\n            <h2>Installation size<\/h2>\n            <p>No files were installed.<\/p>\n            <h2>Uninstall<\/h2>\n            <dl class=\"dl-horizontal\">\n              <dt>Command<\/dt>\n              <dd><code>true<\/code><\/dd>\n              <dt>Return code<\/dt>\n              <dd>0<\/dd>\n              <dt>Missing removes<\/dt>\n              <dd>\n                none\n              <\/dd>\n              <dt>Wrong removes<\/dt>\n              <dd>\n                none\n              <\/dd>\n            <\/dl>\n          <\/div>\n        <\/div>\n      <\/div>\n      <hr\/>\n      <div class=\"footer\">\n        <p class=\"text-center\">\n          <small>Sources are on <a href=\"https:\/\/github.com\/coq-bench\">GitHub<\/a>. \u00a9 Guillaume Claret.<\/small>\n        <\/p>\n      <\/div>\n    <\/div>\n    <script src=\"https:\/\/ajax.googleapis.com\/ajax\/libs\/jquery\/1.11.1\/jquery.min.js\"><\/script>\n    <script src=\"..\/..\/..\/..\/..\/bootstrap.min.js\"><\/script>\n  <\/body>\n<\/html>\n","avg_line_length":42.7529411765,"max_line_length":207,"alphanum_fraction":0.5559988993,"licenses":["MIT"],"repository_name":"coq-bench\/coq-bench.github.io","path":"clean\/Linux-x86_64-4.02.3-2.0.6\/released\/8.5.0\/mini-compiler\/8.7.0.html","size":7271,"lang":"HTML"}
{"content":"<?php\n\/\/ 1. [Required] Point to the composer or dompdf autoloader\nrequire_once \"vendor\/autoload.php\";\n\n\/\/ 2. [Optional] Set the path to your font directory\n\/\/    By default dopmdf loads fonts to dompdf\/lib\/fonts\n\/\/    If you have modified your font directory set this\n\/\/    variable appropriately.\n\/\/$fontDir = \"lib\/fonts\";\n\n\n\/\/ *** DO NOT MODIFY BELOW THIS POINT ***\n\nuse Dompdf\\Dompdf;\nuse Dompdf\\CanvasFactory;\nuse Dompdf\\Exception;\nuse Dompdf\\FontMetrics;\nuse Dompdf\\Options;\n\nuse FontLib\\Font;\n\/\/$fontDir = \"storage\/fonts\";\n\/**\n * Display command line usage\n *\/\nfunction usage() {\n  echo <<<EOD\n\nUsage: {$_SERVER[\"argv\"][0]} font_family [n_file [b_file] [i_file] [bi_file]]\n\nfont_family:      the name of the font, e.g. Verdana, 'Times New Roman',\n                  monospace, sans-serif. If it equals to \"system_fonts\",\n                  all the system fonts will be installed.\n\nn_file:           the .ttf or .otf file for the normal, non-bold, non-italic\n                  face of the font.\n\n{b|i|bi}_file:    the files for each of the respective (bold, italic,\n                  bold-italic) faces.\n\nIf the optional b|i|bi files are not specified, load_font.php will search\nthe directory containing normal font file (n_file) for additional files that\nit thinks might be the correct ones (e.g. that end in _Bold or b or B).  If\nit finds the files they will also be processed.  All files will be\nautomatically copied to the DOMPDF font directory, and afm files will be\ngenerated using php-font-lib (https:\/\/github.com\/PhenX\/php-font-lib).\n\nExamples:\n\n.\/load_font.php silkscreen \/usr\/share\/fonts\/truetype\/slkscr.ttf\n.\/load_font.php 'Times New Roman' \/mnt\/c_drive\/WINDOWS\/Fonts\/times.ttf\n\nEOD;\nexit;\n}\n\nif ( $_SERVER[\"argc\"] < 3 && @$_SERVER[\"argv\"][1] != \"system_fonts\" ) {\n  usage();\n}\n\n$dompdf = new Dompdf();\nif (isset($fontDir) && realpath($fontDir) !== false) {\n  $dompdf->getOptions()->set('fontDir', $fontDir);\n}\n\n\/**\n * Installs a new font family\n * This function maps a font-family name to a font.  It tries to locate the\n * bold, italic, and bold italic versions of the font as well.  Once the\n * files are located, ttf versions of the font are copied to the fonts\n * directory.  Changes to the font lookup table are saved to the cache.\n *\n * @param Dompdf $dompdf      dompdf main object\n * @param string $fontname    the font-family name\n * @param string $normal      the filename of the normal face font subtype\n * @param string $bold        the filename of the bold face font subtype\n * @param string $italic      the filename of the italic face font subtype\n * @param string $bold_italic the filename of the bold italic face font subtype\n *\n * @throws Exception\n *\/\nfunction install_font_family($dompdf, $fontname, $normal, $bold = null, $italic = null, $bold_italic = null) {\n  $fontMetrics = $dompdf->getFontMetrics();\n\n  \/\/ Check if the base filename is readable\n  if ( !is_readable($normal) )\n    throw new Exception(\"Unable to read '$normal'.\");\n\n  $dir = dirname($normal);\n  $basename = basename($normal);\n  $last_dot = strrpos($basename, '.');\n  if ($last_dot !== false) {\n    $file = substr($basename, 0, $last_dot);\n    $ext = strtolower(substr($basename, $last_dot));\n  } else {\n    $file = $basename;\n    $ext = '';\n  }\n\n  if ( !in_array($ext, array(\".ttf\", \".otf\")) ) {\n    throw new Exception(\"Unable to process fonts of type '$ext'.\");\n  }\n\n  \/\/ Try $file_Bold.$ext etc.\n  $path = \"$dir\/$file\";\n\n  $patterns = array(\n    \"bold\"        => array(\"_Bold\", \"b\", \"B\", \"bd\", \"BD\"),\n    \"italic\"      => array(\"_Italic\", \"i\", \"I\"),\n    \"bold_italic\" => array(\"_Bold_Italic\", \"bi\", \"BI\", \"ib\", \"IB\"),\n  );\n\n  foreach ($patterns as $type => $_patterns) {\n    if ( !isset($$type) || !is_readable($$type) ) {\n      foreach($_patterns as $_pattern) {\n        if ( is_readable(\"$path$_pattern$ext\") ) {\n          $$type = \"$path$_pattern$ext\";\n          break;\n        }\n      }\n\n      if ( is_null($$type) )\n        echo (\"Unable to find $type face file.\\n\");\n    }\n  }\n\n  $fonts = compact(\"normal\", \"bold\", \"italic\", \"bold_italic\");\n  $entry = array();\n\n  \/\/ Copy the files to the font directory.\n  foreach ($fonts as $var => $src) {\n    if ( is_null($src) ) {\n      $entry[$var] = $dompdf->getOptions()->get('fontDir') . '\/' . mb_substr(basename($normal), 0, -4);\n      continue;\n    }\n\n    \/\/ Verify that the fonts exist and are readable\n    if ( !is_readable($src) )\n      throw new Exception(\"Requested font '$src' is not readable\");\n\n    $dest = $dompdf->getOptions()->get('fontDir') . '\/' . basename($src);\n\n    if ( !is_writeable(dirname($dest)) )\n      throw new Exception(\"Unable to write to destination '$dest'.\");\n\n    echo \"Copying $src to $dest...\\n\";\n\n    if ( !copy($src, $dest) )\n      throw new Exception(\"Unable to copy '$src' to '$dest'\");\n\n    $entry_name = mb_substr($dest, 0, -4);\n\n    echo \"Generating Adobe Font Metrics for $entry_name...\\n\";\n\n    $font_obj = Font::load($dest);\n    $font_obj->saveAdobeFontMetrics(\"$entry_name.ufm\");\n    $font_obj->close();\n\n    $entry[$var] = $entry_name;\n  }\n\n  \/\/ Store the fonts in the lookup table\n  $fontMetrics->setFontFamily($fontname, $entry);\n\n  \/\/ Save the changes\n  $fontMetrics->saveFontFamilies();\n}\n\n\/\/ If installing system fonts (may take a long time)\nif ( $_SERVER[\"argv\"][1] === \"system_fonts\" ) {\n  $fontMetrics = $dompdf->getFontMetrics();\n  $files = glob(\"\/usr\/share\/fonts\/truetype\/*.ttf\") +\n    glob(\"\/usr\/share\/fonts\/truetype\/*\/*.ttf\") +\n    glob(\"\/usr\/share\/fonts\/truetype\/*\/*\/*.ttf\") +\n    glob(\"C:\\\\Windows\\\\fonts\\\\*.ttf\") +\n    glob(\"C:\\\\WinNT\\\\fonts\\\\*.ttf\") +\n    glob(\"\/mnt\/c_drive\/WINDOWS\/Fonts\/\");\n  $fonts = array();\n  foreach ($files as $file) {\n      $font = Font::load($file);\n      $records = $font->getData(\"name\", \"records\");\n      $type = $fontMetrics->getType($records[2]);\n      $fonts[mb_strtolower($records[1])][$type] = $file;\n      $font->close();\n  }\n\n  foreach ( $fonts as $family => $files ) {\n    echo \" >> Installing '$family'... \\n\";\n\n    if ( !isset($files[\"normal\"]) ) {\n      echo \"No 'normal' style font file\\n\";\n    }\n    else {\n      install_font_family($dompdf, $family, @$files[\"normal\"], @$files[\"bold\"], @$files[\"italic\"], @$files[\"bold_italic\"]);\n      echo \"Done !\\n\";\n    }\n\n    echo \"\\n\";\n  }\n}\nelse {\n  call_user_func_array(\"install_font_family\", array_merge( array($dompdf), array_slice($_SERVER[\"argv\"], 1) ));\n}\n","avg_line_length":31.3497536946,"max_line_length":123,"alphanum_fraction":0.6247642992,"licenses":["MIT"],"repository_name":"chchluko\/jcarpermore","path":"load_font.php","size":6364,"lang":"PHP"}
{"content":"package options\n\nimport (\n\t\"github.com\/akhripko\/dummy\/kafka\/consumer\"\n\t\"github.com\/akhripko\/dummy\/kafka\/producer\"\n\t\"github.com\/akhripko\/dummy\/providers\/grpc\/hellosrv\"\n\t\"github.com\/akhripko\/dummy\/storage\/postgres\"\n\t\"github.com\/spf13\/viper\"\n)\n\nfunc ReadEnv() *Config {\n\tviper.AutomaticEnv()\n\n\tviper.SetEnvPrefix(\"APP\")\n\n\tviper.SetDefault(\"LOG_LEVEL\", \"DEBUG\")\n\n\tviper.SetDefault(\"HTTP_PORT\", 8080)\n\tviper.SetDefault(\"GRAPHQL_PORT\", 8081)\n\tviper.SetDefault(\"GRPC_PORT\", 8090)\n\n\tviper.SetDefault(\"HEALTH_CHECK_PORT\", 8888)\n\tviper.SetDefault(\"PROMETHEUS_PORT\", 9100)\n\n\tviper.SetDefault(\"HELLO_SRV_TARGET\", \"localhost:8090\")\n\n\tviper.SetDefault(\"SQLDB_HOST\", \"localhost\")\n\tviper.SetDefault(\"SQLDB_PORT\", 5432)\n\tviper.SetDefault(\"SQLDB_USER\", \"postgres\")\n\tviper.SetDefault(\"SQLDB_PASS\", \"\")\n\tviper.SetDefault(\"SQLDB_DB_NAME\", \"db\")\n\tviper.SetDefault(\"SQLDB_MAX_OPEN_CONNS\", 10)\n\n\tviper.SetDefault(\"CACHE_ADDR\", \":6379\")\n\n\tviper.SetDefault(\"KAFKA_BOOTSTRAP_SERVERS\", \"localhost:9092\")\n\tviper.SetDefault(\"KAFKA_SSL_ENABLED\", false)\n\tviper.SetDefault(\"KAFKA_SSL_CA_LOCATION\", \"\")\n\tviper.SetDefault(\"KAFKA_SSL_CERTIFICATE_LOCATION\", \"\")\n\tviper.SetDefault(\"KAFKA_SSL_KEY_LOCATION\", \"\")\n\tviper.SetDefault(\"KAFKA_PRODUCER_IDEMPOTENCE\", false)\n\tviper.SetDefault(\"KAFKA_PRODUCER_READ_EVENTS\", true)\n\tviper.SetDefault(\"KAFKA_PRODUCER_FLUSH_TIMEOUT_MS\", 15000)\n\n\tviper.SetDefault(\"KAFKA_TOPIC_TEST\", \"hello-topic\")\n\n\tviper.SetDefault(\"KAFKA_CONSUMER_POLL_TIMEOUT_MS\", 300)\n\tviper.SetDefault(\"KAFKA_CONSUMER_NAME\", \"hello\")\n\tviper.SetDefault(\"KAFKA_CONSUMER_GROUP_ID\", \"dummy\")\n\tviper.SetDefault(\"KAFKA_CONSUMER_SESSION_TIMEOUT_MS\", 6000)\n\tviper.SetDefault(\"KAFKA_CONSUMER_AUTO_OFFSET_RESET\", \"earliest\")\n\n\treturn &Config{\n\t\tLogLevel:        viper.GetString(\"LOG_LEVEL\"),\n\t\tHTTPPort:        viper.GetInt(\"HTTP_PORT\"),\n\t\tGRPCPort:        viper.GetInt(\"GRPC_PORT\"),\n\t\tGraphqlPort:     viper.GetInt(\"GRAPHQL_PORT\"),\n\t\tHealthCheckPort: viper.GetInt(\"HEALTH_CHECK_PORT\"),\n\t\tPrometheusPort:  viper.GetInt(\"PROMETHEUS_PORT\"),\n\t\tSQLDB: postgres.Config{\n\t\t\tHost:         viper.GetString(\"SQLDB_HOST\"),\n\t\t\tPort:         viper.GetInt(\"SQLDB_PORT\"),\n\t\t\tUser:         viper.GetString(\"SQLDB_USER\"),\n\t\t\tPass:         viper.GetString(\"SQLDB_PASS\"),\n\t\t\tDBName:       viper.GetString(\"SQLDB_DB_NAME\"),\n\t\t\tMaxOpenConns: viper.GetInt(\"SQLDB_MAX_OPEN_CONNS\"),\n\t\t},\n\t\tCacheAddr:    viper.GetString(\"CACHE_ADDR\"),\n\t\tHelloSrvConf: hellosrv.Config{Target: viper.GetString(\"HELLO_SRV_TARGET\")},\n\t\tKafkaTopic:   KafkaTopic{Hello: viper.GetString(\"KAFKA_TOPIC_TEST\")},\n\t\tKafkaProducer: producer.Config{\n\t\t\tIdempotence:      viper.GetBool(\"KAFKA_PRODUCER_IDEMPOTENCE\"),\n\t\t\tReadEvents:       viper.GetBool(\"KAFKA_PRODUCER_READ_EVENTS\"),\n\t\t\tFlushTimeoutMs:   viper.GetInt(\"KAFKA_PRODUCER_FLUSH_TIMEOUT_MS\"),\n\t\t\tBootstrapServers: viper.GetString(\"KAFKA_BOOTSTRAP_SERVERS\"),\n\t\t\tSSL: producer.SSLConfig{\n\t\t\t\tEnabled:             viper.GetBool(\"KAFKA_SSL_ENABLED\"),\n\t\t\t\tKeyLocation:         viper.GetString(\"KAFKA_SSL_KEY_LOCATION\"),\n\t\t\t\tCertificateLocation: viper.GetString(\"KAFKA_SSL_CERTIFICATE_LOCATION\"),\n\t\t\t\tCALocation:          viper.GetString(\"KAFKA_SSL_CA_LOCATION\"),\n\t\t\t},\n\t\t},\n\t\tKafkaConsumer: consumer.Config{\n\t\t\tBootstrapServers: viper.GetString(\"KAFKA_BOOTSTRAP_SERVERS\"),\n\t\t\tPollTimeoutMs:    viper.GetInt(\"KAFKA_CONSUMER_POLL_TIMEOUT_MS\"),\n\t\t\tName:             viper.GetString(\"KAFKA_CONSUMER_NAME\"),\n\t\t\tGroupID:          viper.GetString(\"KAFKA_CONSUMER_GROUP_ID\"),\n\t\t\tSessionTimeoutMs: viper.GetString(\"KAFKA_CONSUMER_SESSION_TIMEOUT_MS\"),\n\t\t\tAutoOffsetReset:  viper.GetString(\"KAFKA_CONSUMER_AUTO_OFFSET_RESET\"),\n\t\t\tSSL: consumer.SSLConfig{\n\t\t\t\tEnabled:             viper.GetBool(\"KAFKA_SSL_ENABLED\"),\n\t\t\t\tKeyLocation:         viper.GetString(\"KAFKA_SSL_KEY_LOCATION\"),\n\t\t\t\tCertificateLocation: viper.GetString(\"KAFKA_SSL_CERTIFICATE_LOCATION\"),\n\t\t\t\tCALocation:          viper.GetString(\"KAFKA_SSL_CA_LOCATION\"),\n\t\t\t},\n\t\t},\n\t}\n}\n","avg_line_length":39.3232323232,"max_line_length":77,"alphanum_fraction":0.7397893655,"licenses":["MIT"],"repository_name":"IvanProdaiko94\/dummy","path":"options\/env.go","size":3893,"lang":"GO"}
{"content":"export default class Cancel {\n    message?: string\n    constructor(message?: string) {\n        this.message = message\n    }\n}\n\nexport function isCancel(value: any) {\n    return value instanceof Cancel\n}\n","avg_line_length":18.4545454545,"max_line_length":38,"alphanum_fraction":0.6699507389,"licenses":["MIT"],"repository_name":"izhaoqing\/ts-axios","path":"src\/cancel\/Cancel.ts","size":203,"lang":"TypeScript"}
{"content":"package edu.cdl.iot.integrations.application\n\nimport edu.cdl.iot.common.factories.ConfigFactory\nimport edu.cdl.iot.integrations.application.dependencies.IntegrationsDependencies\nimport org.apache.camel.component.kafka.{KafkaComponent, KafkaConfiguration}\nimport org.apache.camel.component.netty.http.NettyHttpComponent\nimport org.apache.camel.impl.DefaultCamelContext\n\nobject CamelMain {\n  def main(args: Array[String]) {\n    val configFactory = new ConfigFactory()\n    val config = configFactory.getConfig\n\n    val context = new DefaultCamelContext\n\n    val dependencies = new IntegrationsDependencies(config, context)\n\n    val kafkaComponent = new KafkaComponent()\n    val kafkaConfig = new KafkaConfiguration\n\n\n    kafkaConfig.setSerializerClass(\"org.apache.kafka.common.serialization.ByteArraySerializer\")\n    kafkaConfig.setKeySerializerClass(\"org.apache.kafka.common.serialization.ByteArraySerializer\")\n    kafkaConfig.setValueDeserializer(\"org.apache.kafka.common.serialization.ByteArrayDeserializer\")\n    kafkaConfig.setKeyDeserializer(\"org.apache.kafka.common.serialization.ByteArrayDeserializer\")\n    kafkaComponent.setConfiguration(kafkaConfig)\n\n    context.addComponent(\"netty-http\", new NettyHttpComponent)\n    context.addComponent(\"kafka\", kafkaComponent)\n    context.addRoutes(dependencies.grafanaRoutes)\n    context.addRoutes(dependencies.predictionRoutes)\n    context.addRoutes(dependencies.notebookQueryRoutes)\n    context.addRoutes(dependencies.notebookImportRoutes)\n    context.addRoutes(dependencies.notebookModelRoutes)\n    context.addRoutes(dependencies.notebookProjectRoutes)\n    context.addRoutes(dependencies.schedulerDependencies.timedRoutesBuilder)\n\n    context.start()\n\n  }\n}\n","avg_line_length":40.5952380952,"max_line_length":99,"alphanum_fraction":0.8170087977,"licenses":["Apache-2.0"],"repository_name":"Amisha1489\/refit","path":"applications\/integrations-application\/src\/main\/scala\/edu\/cdl\/iot\/integrations\/application\/CamelMain.scala","size":1705,"lang":"Scala"}
{"content":"import {\n  SET_SCREAMS,\n  LIKE_SCREAM,\n  UNLIKE_SCREAM,\n  LOADING_DATA,\n  DELETE_SCREAM,\n  POST_SCREAM,\n  SET_SCREAM,\n  SUBMIT_COMMENT\n} from \"..\/type\";\n\nconst initialState = {\n  screams: [],\n  scream: {},\n  loading: false\n};\n\nexport default function(state = initialState, action) {\n  switch (action.type) {\n    case LOADING_DATA:\n      return {\n        ...state,\n        loading: true\n      };\n    case SET_SCREAMS:\n      return {\n        ...state,\n        screams: action.payload,\n        loading: false\n      };\n    case LIKE_SCREAM:\n    case UNLIKE_SCREAM:\n      let index = -1;\n      state.screams.forEach(scream => {\n        index++;\n        if (scream.id === action.payload.screamId) return false;\n      });\n      state.screams[index].likeCount = action.payload.likeCount;\n      if (state.scream.id === action.payload.screamId) {\n        state.scream.likeCount = action.payload.likeCount;\n      }\n      return {\n        ...state\n      };\n    case DELETE_SCREAM:\n      let index1 = -1;\n      state.screams.forEach(scream => {\n        index1++;\n        if (scream.id === action.payload) return false;\n      });\n      console.log(index1);\n      state.screams.splice(index1, 1);\n      return {\n        ...state\n      };\n    case SET_SCREAM:\n      return {\n        ...state,\n        scream: action.payload\n      };\n    case POST_SCREAM:\n      return {\n        ...state,\n        screams: [action.payload, ...state.screams]\n      };\n    case SUBMIT_COMMENT:\n      return{\n        ...state,\n        comments:[action.payload, ...state.scream.comments]\n      }\n    default:\n      return state;\n  }\n}\n","avg_line_length":21.2933333333,"max_line_length":64,"alphanum_fraction":0.557294928,"licenses":["MIT"],"repository_name":"Riptide-Trident\/devengers-client","path":"src\/redux\/reducers\/dataReducer.js","size":1597,"lang":"JavaScript"}
{"content":"<?php\n\ndeclare(strict_types=1);\n\n\/*\n * This file is part of the box project.\n *\n * (c) Kevin Herrera <kevin@herrera.io>\n *     Th\u00e9o Fidry <theo.fidry@gmail.com>\n *\n * This source file is subject to the MIT license that is bundled\n * with this source code in the file LICENSE.\n *\/\n\nnamespace KevinGH\\Box;\n\nuse Generator;\nuse Humbug\\PhpScoper\\Whitelist;\nuse KevinGH\\Box\\Compactor\\FakeCompactor;\nuse KevinGH\\Box\\Compactor\\PhpScoper;\nuse KevinGH\\Box\\PhpScoper\\Scoper;\nuse PHPUnit\\Framework\\TestCase;\nuse Prophecy\\Argument;\nuse Prophecy\\Prophecy\\ObjectProphecy;\n\n\/**\n * @covers \\KevinGH\\Box\\Compactors\n *\/\nclass CompactorsTest extends TestCase\n{\n    \/** @var Compactor|ObjectProphecy *\/\n    private $compactor1Prophecy;\n\n    \/** @var Compactor *\/\n    private $compactor1;\n\n    \/** @var Compactor|ObjectProphecy *\/\n    private $compactor2Prophecy;\n\n    \/** @var Compactor *\/\n    private $compactor2;\n\n    \/** @var Compactors *\/\n    private $compactors;\n\n    \/**\n     * {@inheritdoc}\n     *\/\n    public function setUp(): void\n    {\n        $this->compactor1Prophecy = $this->prophesize(Compactor::class);\n        $this->compactor1 = $this->compactor1Prophecy->reveal();\n\n        $this->compactor2Prophecy = $this->prophesize(Compactor::class);\n        $this->compactor2 = $this->compactor2Prophecy->reveal();\n\n        $this->compactors = new Compactors($this->compactor1, $this->compactor2);\n    }\n\n    public function test_it_applies_all_compactors_in_order(): void\n    {\n        $file = 'foo';\n        $contents = 'original contents';\n\n        $this->compactor1Prophecy\n            ->compact($file, $contents)\n            ->willReturn($contentsAfterCompactor1 = 'contents after compactor1')\n        ;\n        $this->compactor2Prophecy\n            ->compact($file, $contentsAfterCompactor1)\n            ->willReturn($contentsAfterCompactor2 = 'contents after compactor2')\n        ;\n\n        $expected = $contentsAfterCompactor2;\n\n        $actual = $this->compactors->compactContents($file, $contents);\n\n        $this->assertSame($expected, $actual);\n\n        $this->compactor1Prophecy->compact(Argument::cetera())->shouldHaveBeenCalledTimes(1);\n        $this->compactor2Prophecy->compact(Argument::cetera())->shouldHaveBeenCalledTimes(1);\n    }\n\n    public function test_it_can_be_converted_into_an_array(): void\n    {\n        $this->assertSame(\n            [\n                $this->compactor1,\n                $this->compactor2,\n            ],\n            $this->compactors->toArray()\n        );\n    }\n\n    \/**\n     * @dataProvider provideCompactorsForFirstWhitelistCheck\n     *\n     * @param Compactor[] $compactors\n     *\/\n    public function test_it_provides_the_first_scoper_compactor_whitelist_when_there_is_one(array $compactors, ?Whitelist $expected): void\n    {\n        $actual = (new Compactors(...$compactors))->getScoperWhitelist();\n\n        $this->assertSame($expected, $actual);\n    }\n\n    \/**\n     * @dataProvider provideCompactorsForFirstWhitelistChange\n     *\n     * @param Compactor[] $compactors\n     *\/\n    public function test_it_can_change_the_first_scoper_compactor_whitelist(array $compactors, ?Whitelist $newWhitelist): void\n    {\n        $compactorsAggregate = new Compactors(...$compactors);\n\n        if (null !== $newWhitelist) {\n            $compactorsAggregate->registerWhitelist($newWhitelist);\n        }\n\n        $actual = $compactorsAggregate->getScoperWhitelist();\n\n        $this->assertSame($newWhitelist, $actual);\n    }\n\n    public function provideCompactorsForFirstWhitelistCheck(): Generator\n    {\n        yield [\n            [],\n            null,\n        ];\n\n        yield [\n            [new FakeCompactor()],\n            null,\n        ];\n\n        yield (function (): array {\n            $whitelist = Whitelist::create(true, true, true);\n\n            return [\n                [\n                    new FakeCompactor(),\n                    $this->createScoperCompactor($whitelist),\n                ],\n                $whitelist,\n            ];\n        })();\n\n        yield (function (): array {\n            $firstWhitelist = Whitelist::create(true, true, true);\n            $secondWhitelist = Whitelist::create(false, false, false);\n\n            return [\n                [\n                    new FakeCompactor(),\n                    $this->createScoperCompactor($firstWhitelist),\n                    $this->createScoperCompactor($secondWhitelist),\n                ],\n                $firstWhitelist,\n            ];\n        })();\n    }\n\n    public function provideCompactorsForFirstWhitelistChange(): Generator\n    {\n        yield [\n            [],\n            null,\n        ];\n\n        yield [\n            [new FakeCompactor()],\n            null,\n        ];\n\n        yield (function (): array {\n            $whitelist = Whitelist::create(true, true, true);\n\n            return [\n                [\n                    new FakeCompactor(),\n                    $this->createScoperCompactorWithChangeWhitelist($whitelist),\n                ],\n                $whitelist,\n            ];\n        })();\n\n        yield (function (): array {\n            $firstWhitelist = Whitelist::create(true, true, true);\n            $secondWhitelist = Whitelist::create(false, false, false);\n\n            return [\n                [\n                    new FakeCompactor(),\n                    $this->createScoperCompactorWithChangeWhitelist($firstWhitelist),\n                    $this->createScoperCompactorWithChangeWhitelist($secondWhitelist),\n                ],\n                $firstWhitelist,\n            ];\n        })();\n    }\n\n    private function createScoperCompactor(Whitelist $whitelist): PhpScoper\n    {\n        \/** @var ObjectProphecy|Scoper $scoperProphecy *\/\n        $scoperProphecy = $this->prophesize(Scoper::class);\n        $scoperProphecy->getWhitelist()->willReturn($whitelist);\n\n        \/** @var Scoper $scoper *\/\n        $scoper = $scoperProphecy->reveal();\n\n        return new PhpScoper($scoper);\n    }\n\n    private function createScoperCompactorWithChangeWhitelist(Whitelist $whitelist): PhpScoper\n    {\n        \/** @var ObjectProphecy|Scoper $scoperProphecy *\/\n        $scoperProphecy = $this->prophesize(Scoper::class);\n        $scoperProphecy->changeWhitelist($whitelist)->shouldBeCalled();\n        $scoperProphecy->getWhitelist()->willReturn($whitelist);\n\n        \/** @var Scoper $scoper *\/\n        $scoper = $scoperProphecy->reveal();\n\n        return new PhpScoper($scoper);\n    }\n}\n","avg_line_length":28.1754385965,"max_line_length":138,"alphanum_fraction":0.5817247821,"licenses":["MIT"],"repository_name":"theofidry\/box","path":"tests\/CompactorsTest.php","size":6425,"lang":"PHP"}
{"content":"#!\/bin\/bash\n\nif [ \"$1\" == \"--local\" ]; then\n  # If the local flag is passed, we run a version of the web project set up for development.\n  # Run an install to make sure new Node dependencies since last Docker image build are installed.\n  npm install\n  .\/node_modules\/@angular\/cli\/bin\/ng serve --port 80 --host 0.0.0.0 --disable-host-check -c local\n  exit\nfi\n\nenv_js_path=\/env.js\n\nif [ -e $env_js_path ]; then\n  cp $env_js_path \/usr\/share\/nginx\/www\/assets\/env.js\nfi\n\nexec nginx -g 'daemon off;' \"$@\"\n","avg_line_length":27.7222222222,"max_line_length":98,"alphanum_fraction":0.6913827655,"licenses":["MIT"],"repository_name":"UoA-eResearch\/research-hub","path":"docker-entrypoint.sh","size":499,"lang":"Shell"}
{"content":"import Link from '.\/Link'\nimport formatDate from '@\/lib\/utils\/formatDate'\nimport { PostFrontMatter } from 'types\/PostFrontMatter'\n\ninterface NoteProps {\n  note: PostFrontMatter\n}\n\nexport default function Note({ note }: NoteProps) {\n  const { slug, date, title, tags } = note\n  return (\n    <article className=\"mb-4\">\n      <div className=\"block sm:flex items-center justify-between\">\n        <h3 className=\"text-xl sm:text-2xl font-bold leading-8 tracking-tight\">\n          <Link href={`\/til\/${slug}`} className=\"text-gray-900 dark:text-gray-100\">\n            {title}\n          <\/Link>\n        <\/h3>\n        <div className=\"text-sm\">\n          <time dateTime={date}>{formatDate(date)}<\/time>\n        <\/div>\n      <\/div>\n      <div className=\"flex flex-wrap space-x-2 mt-4\">\n        {tags.map((tag) => (\n          <div\n            key={tag}\n            className=\"py-1 px-3 bg-white rounded-full bg-gray-900 dark:bg-primary-500\"\n          >\n            <div className=\"text-xs font-medium leading-none text-white\">{tag}<\/div>\n          <\/div>\n        ))}\n      <\/div>\n    <\/article>\n  )\n}\n","avg_line_length":30.2222222222,"max_line_length":87,"alphanum_fraction":0.5762867647,"licenses":["MIT"],"repository_name":"trankhacvy\/vy.tk","path":"components\/Note.tsx","size":1088,"lang":"TypeScript"}
{"content":"package com.sun.mobileshop.activity;\n\nimport android.content.Intent;\nimport android.support.v7.app.AppCompatActivity;\nimport android.os.Bundle;\nimport android.view.animation.Animation;\nimport android.view.animation.AnimationUtils;\nimport android.widget.ImageView;\n\nimport com.sun.mobileshop.R;\n\npublic class SplashActivity extends AppCompatActivity {\n    private static final String TAG=\"SplashActivity\";\n    private ImageView mSplash_load_it;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_splash);\n        initView();\n    }\n\n    private void initView(){\n        \/\/\u52a8\u753b\u6548\u679c\n        mSplash_load_it=(ImageView)findViewById(R.id.splash_loading_item);\n        \/\/\u52a0\u8f7d\u52a8\u753b\n        Animation translate= AnimationUtils.loadAnimation(this,R.anim.splash_loading);\n        translate.setAnimationListener(new Animation.AnimationListener() {\n            @Override\n            public void onAnimationStart(Animation animation) {\n\n            }\n\n            @Override\n            public void onAnimationEnd(Animation animation) {\n                \/\/\u7ed3\u675f\u65f6\u8df3\u8f6c\n                Intent intent=new Intent(SplashActivity.this,AdActivity.class);\n                startActivity(intent);\n                overridePendingTransition(R.anim.push_left_in,R.anim.push_left_out);\n                finish();\n\n            }\n\n            @Override\n            public void onAnimationRepeat(Animation animation) {\n\n            }\n        });\n        \/\/\u6267\u884c\u52a8\u753b\n        mSplash_load_it.setAnimation(translate);\n    }\n}\n","avg_line_length":29.7169811321,"max_line_length":86,"alphanum_fraction":0.6634920635,"licenses":["Apache-2.0"],"repository_name":"sun11225\/ModileShop","path":"app\/src\/main\/java\/com\/sun\/mobileshop\/activity\/SplashActivity.java","size":1609,"lang":"Java"}
{"content":"# Assume clonedd to ~\/dotfiles.\n\n# soft-link\nln -sf $PWD\/emacs\/emacs ~\/.emacs\nln -sf $PWD\/git\/gitignore_global ~\/.gitignore_global\nln -sf $PWD\/zsh\/bash_profile ~\/.bash_profile\nln -sf $PWD\/zsh\/bash_python ~\/.bash_python\nln -sf $PWD\/zsh\/bash_shopify ~\/.bash_shopify\n\n# assume .zshrc exists\ntouch ~\/.zshrc\necho \"source $PWD\/zsh\/zshrc\" >> ~\/.zshrc\n\n# files that need editing \/ not needed on `spin``\nif [ ! $SPIN ]; then\n  mkdir ~\/.gnupg\n  ln -sf $PWD\/gnupg\/gpg-agent.conf ~\/.gnupg\/gpg-agent.conf\n  cp $PWD\/gnupg\/gpg.conf ~\/.gnupg\/gpg.conf\n  cat $PWD\/git\/gitconfig >> ~\/.gitconfig\n  mkdir -p ~\/.config\/karabiner\n  ln -sf $PWD\/karabiner\/karabiner.json ~\/.config\/karabiner\/.\n  mkdir ~\/.iterm2\n  ln -sf $PWD\/iterm2\/com.googlecode.iterm2.plist ~\/.iterm2\/.\nfi\n","avg_line_length":30.0,"max_line_length":60,"alphanum_fraction":0.6946666667,"licenses":["Unlicense"],"repository_name":"jimgraham\/dot-files","path":"install.sh","size":750,"lang":"Shell"}
{"content":"FROM grafana\/grafana:4.6.3\n\nCOPY config-n-run.sh config-n-run.sh\n\nCOPY grafana.ini \/etc\/grafana\/grafana.ini\n\nCOPY dashboards \/var\/lib\/grafana\/dashboards\n\nEXPOSE 3000\n\nENTRYPOINT [\"\/config-n-run.sh\"]\n","avg_line_length":16.5833333333,"max_line_length":43,"alphanum_fraction":0.7638190955,"licenses":["Apache-2.0"],"repository_name":"dvilaverde\/secure-agent-monitor","path":"images\/grafana\/Dockerfile","size":199,"lang":"Dockerfile"}
{"content":"\n-->8\n-- scumm-8 core engine\n\n-- ############################\n--    you should not need to \n--  modify anything below here\n-- ############################\n\nfunction shake(bc)\nbd,be=bc,bc and 1 or be\nend\nfunction bf(bg)\nlocal bh=\"lookat\"\nif has_flag(bg.classes,\"class_talkable\") then\nbh=\"talkto\"\nelseif has_flag(bg.classes,\"class_openable\") then\nif bg.state==\"state_closed\"then\nbh=\"open\"\nelse\nbh=\"close\"\nend\nend\nfor bi in all(verbs) do\nbj=get_verb(bi)\nif bj[2]==bh then bh=bi break end\nend\nreturn bh\nend\nfunction bk(bl,bm,bn)\nlocal bo=has_flag(bm.classes,\"class_actor\")\nif bl==\"walkto\"then\nreturn\nelseif bl==\"pickup\"then\nsay_line(bo and\"i don't need them\"or\"i don't need that\")\nelseif bl==\"use\"then\nsay_line(bo and\"i can't just *use* someone\"or\n((bn and has_flag(bn.classes,class_actor)) and\"i can't use that on someone!\"or\"that doesn't work\"))\nelseif bl==\"give\"then\nsay_line(bo and\"i don't think i should be giving this away\"or\"i can't do that\")\nelseif bl==\"lookat\"then\nsay_line(bo and\"i think it's alive\"or\"looks pretty ordinary\")\nelseif bl==\"open\"or bl==\"close\"then\nsay_line((bo and\"they don't\"or\"it doesn't\")..\" seem to \"..bl)\nelseif bl==\"push\"or bl==\"pull\"then\nsay_line(bo and\"moving them would accomplish nothing\"or\"it won't budge!\")\nelseif bl==\"talkto\"then\nsay_line(bo and\"erm ...  i don't think they want to talk\"or\"i am not talking to that!\")\nelse\nsay_line\"hmm. no.\"\nend\nend\nfunction camera_at(bp)\ncam_x,bq,br=bs(bp)\nend\nfunction camera_follow(bt)\nstop_script(bu)\nbr,bq=bt\nbu=function()\nwhile br do\nif(br.in_room==room_curr) cam_x=bs(br)\nyield()\nend\nend\nstart_script(bu,true)\nif(br.in_room!=room_curr) change_room(br.in_room,1)\nend\nfunction camera_pan_to(bp)\nbq,br=bs(bp)\nbu=function()\nwhile cam_x~=bq do\ncam_x+=sgn(bq-cam_x)\/2\nyield()\nend\nbq=nil\nend\nstart_script(bu,true)\nend\nfunction wait_for_camera()\nwhile script_running(bu) do\nyield()\nend\nend\nfunction cutscene(type,bv,bw)\nbx={\nby=type,\nbz=cocreate(bv),\nca=bw,\ncb=br\n}\nadd(cc,bx)\ncd=bx\nbreak_time()\nend\nfunction dialog_set(ce)\nfor msg in all(ce) do\ndialog_add(msg)\nend\nend\nfunction dialog_add(msg)\ncf=cf or{cg={}}\nch=ci(msg,32)\ncj=ck(ch)\ncl={\nnum=#cf.cg+1,\nmsg=msg,\nch=ch,\ncm=cj\n}\nadd(cf.cg,cl)\nend\nfunction dialog_start(col,cn)\ncf.col=col\ncf.cn=cn\ncf.co=true\nselected_sentence=nil\nend\nfunction dialog_hide()\ncf.co=false\nend\nfunction dialog_clear()\ncf.cg={}\nselected_sentence=nil\nend\nfunction dialog_end()\ncf=nil\nend\nfunction get_use_pos(bg)\nlocal cp,y,x=bg.use_pos or\"pos_infront\",bg.y,bg.x\nif cq(cp) then\nx,y=cp[1],cp[2]\nelse\nlocal cr={\npos_left={-2,bg.h*8-2},\npos_right={bg.w*8,bg.h*8-2},\npos_above={bg.w*4-4,-2},\npos_center={bg.w*4,bg.h*4-4},\npos_infront={bg.w*4-4,bg.h*8+2}\n}\nif cp==\"pos_left\"and bg.cs then\nx-=(bg.w*8+4)\ny+=1\nelse\nx+=cr[cp][1]\ny+=cr[cp][2]\nend\nend\nreturn{x=x,y=y}\nend\nfunction do_anim(ct,cu,cv)\nif cu==\"face_towards\"then\nif cq(cv) then\ncw=atan2(ct.x-cv.x,cv.y-ct.y)\ncx=93*(3.1415\/180)\ncw=cx-cw\ncy=(cw*360)%360\ncv=4-flr(cy\/90)\ncv=cz[cv]\nend\nface_dir=cz[ct.face_dir]\ncv=cz[cv]\nwhile face_dir!=cv do\nif face_dir<cv then\nface_dir+=1\nelse\nface_dir-=1\nend\nct.face_dir=cz[face_dir]\nct.flip=(ct.face_dir==\"face_left\")\nbreak_time(10)\nend\nelse\nct.curr_anim=cu\nct.da=1\nct.db=1\nend\nend\nfunction open_door(dc,dd)\nif dc.state==\"state_open\"then\nsay_line\"it's already open\"\nelse\ndc.state=\"state_open\"\nif(dd) dd.state=\"state_open\"\nend\nend\nfunction close_door(dc,dd)\nif dc.state==\"state_closed\"then\nsay_line\"it's already closed\"\nelse\ndc.state=\"state_closed\"\nif(dd) dd.state=\"state_closed\"\nend\nend\nfunction come_out_door(de,df,dg)\nif(df==nil) dh(\"target door does not exist\") return\nif(de.state~=\"state_open\") say_line(\"the door is closed\") return\ndi=df.in_room\nif(di!=room_curr) change_room(di,dg)\nlocal dj=get_use_pos(df)\nput_at(selected_actor,dj.x,dj.y,di)\nif df.use_dir then\ndk=cz[(cz[df.use_dir]+1)%4+1]\nelse\ndk=\"face_front\"\nend\nselected_actor.face_dir=dk\nselected_actor.flip=(selected_actor.face_dir==\"face_left\")\nend\ndl={\nopen=open_door,\nclose=close_door,\nwalkto=come_out_door\n}\nfunction fades(dm,dir)\nlocal dn=25-25*dir\nwhile true do\ndn+=dir*2\nif dn>50\nor dn<0 then\nreturn\nend\nif(dm==1) dp=min(dn,32)\nyield()\nend\nend\nfunction change_room(di,dm)\nif(not di) dh(\"room does not exist\") return\nstop_script(dq)\nif dm and room_curr then\nfades(dm,1)\nend\nif(room_curr and room_curr.exit) room_curr.exit(room_curr)\ndr={}\nds()\nroom_curr=di\nif(not br or br.in_room!=room_curr) cam_x=0\nstop_talking()\nif dm then\ndq=function()\nfades(dm,-1)\nend\nstart_script(dq,true)\nelse\ndp=0\nend\nif room_curr.enter then\nroom_curr.enter(room_curr)\nend\nend\nfunction valid_verb(bl,dt)\nif(not dt or not dt.verbs) return false\nif cq(bl) then\nif(dt.verbs[bl[1]]) return true\nelse\nif(dt.verbs[bl]) return true\nend\nend\nfunction pickup_obj(bg,bt)\nbt=bt or selected_actor\nadd(bt.du,bg)\nbg.owner=bt\ndel(bg.in_room.objects,bg)\nend\nfunction start_script(dv,dw,dx,q)\nlocal bz=cocreate(dv)\nadd(dw and dy or dr,{dv,bz,dx,q})\nend\nfunction script_running(dv)\nfor dz in all({dr,dy}) do\nfor ea,eb in pairs(dz) do\nif eb[1]==dv then\nreturn eb\nend\nend\nend\nend\nfunction stop_script(dv)\neb=script_running(dv)\ndel(dr,eb)\ndel(dy,eb)\nend\nfunction break_time(ec)\nfor x=1,ec or 1 do\nyield()\nend\nend\nfunction wait_for_message()\nwhile ed do\nyield()\nend\nend\nfunction say_line(bt,msg,ee,ef)\nif type(bt)==\"string\"then\nmsg,bt=bt,selected_actor\nend\neg=bt\nprint_line(msg,bt.x,bt.y-bt.h*8+4,bt.col,1,ee,ef)\nend\nfunction stop_talking()\ned,eg=nil\nend\nfunction print_line(msg,x,y,col,eh,ee,ef,ei)\ncol=col or 7\neh=eh or 0\nlocal ej=127-(x-cam_x)\nif(eh==1) ej=min(x-cam_x,ej)\nlocal ek=max(flr(ej\/2),16)\nlocal el=\"\"\nfor em=1,#msg do\nlocal en=sub(msg,em,em)\nif en==\":\"then\nel=sub(msg,em+1)\nmsg=sub(msg,1,em-1)\nbreak\nend\nend\nlocal ch=ci(msg,ek)\nlocal cj=ck(ch)\neo=x-cam_x\nif(eh==1) eo-=cj*(ei and 4 or 2)\nlocal eo,ep=max(2,eo),max(18,y)\neo=min(eo,127-(cj*4)-1)\ned={\neq=ch,\nx=eo,\ny=ep,\ncol=col,\neh=eh,\ner=ef or#msg*8,\ncm=cj,\nee=ee,\nei=ei\n}\nif#el>0 then\nes=eg\nwait_for_message()\neg=es\nprint_line(el,x,y,col,eh,ee,nil,ei)\nend\nwait_for_message()\nend\nfunction put_at(bg,x,y,et)\nif et then\nif not has_flag(bg.classes,\"class_actor\") then\nif(bg.in_room) del(bg.in_room.objects,bg)\nadd(et.objects,bg)\nbg.owner=nil\nend\nbg.in_room=et\nend\nbg.x,bg.y=x,y\nend\nfunction stop_actor(bt)\nbt.eu,bt.curr_anim=0\nds()\nend\nfunction walk_to(bt,x,y)\nlocal ev=ew(bt)\nlocal ex,ey=flr(x\/8)+room_curr.map[1],flr(y\/8)+room_curr.map[2]\nlocal ez={ex,ey}\nlocal fa=fb(ev,ez,{x,y})\nbt.eu=1\nfor fc=1,#fa do\nlocal fd=fa[fc]\nlocal fe=bt.walk_speed*(bt.scale or bt.ff)\nlocal fg,fh=(fd[1]-room_curr.map[1])*8+4,(fd[2]-room_curr.map[2])*8+4\nif(fc==#fa and x>=fg-4 and x<=fg+4 and y>=fh-4 and y<=fh+4) fg,fh=x,y\nlocal fi=sqrt((fg-bt.x)^2+(fh-bt.y)^2)\nlocal fj=fe*(fg-bt.x)\/fi\nlocal fk=fe*(fh-bt.y)\/fi\nif fi>0 then\nfor em=0,fi\/fe-1 do\nif bt.eu==0 then\nreturn\nend\nbt.flip=fj<0\nif abs(fj)<fe\/2 then\nbt.curr_anim=fk>0 and bt.walk_anim_front or bt.walk_anim_back\nbt.face_dir=fk>0 and\"face_front\"or\"face_back\"\nelse\nbt.curr_anim=bt.walk_anim_side\nbt.face_dir=bt.flip and\"face_left\"or\"face_right\"\nend\nbt.x+=fj\nbt.y+=fk\nyield()\nend\nend\nend\nbt.eu,bt.curr_anim=2\nend\nfunction wait_for_actor(bt)\nbt=bt or selected_actor\nwhile bt.eu!=2 do\nyield()\nend\nend\nfunction proximity(bm,bn)\nreturn bm.in_room==bn.in_room and sqrt((bm.x-bn.x)^2+(bm.y-bn.y)^2) or 1000\nend\nstage_top=16\ncam_x,be=0,0\nfl,fm,fn,fo=63.5,63.5,0,1\nfp={\n{spr=ui_uparrowspr,x=75,y=stage_top+60},\n{spr=ui_dnarrowspr,x=75,y=stage_top+72}\n}\ncz={\n\"face_front\",\n\"face_left\",\n\"face_back\",\n\"face_right\",\nface_front=1,\nface_left=2,\nface_back=3,\nface_right=4\n}\nfunction fq(bg)\nlocal fr={}\nfor ea,bi in pairs(bg) do\nadd(fr,ea)\nend\nreturn fr\nend\nfunction get_verb(bg)\nlocal bl,fr={},fq(bg[1])\nadd(bl,fr[1])\nadd(bl,bg[1][fr[1]])\nadd(bl,bg.text)\nreturn bl\nend\nfunction ds()\nfs,ft,fu,fv,fw,j=get_verb(verb_default),false,\"\"\nend\nds()\ncd=nil\ndy={}\ndr={}\ncc={}\nfx={}\ndp,dp=0,0\nfy=0\nfunction _init()\npoke(0x5f2d,1)\nfz()\nstart_script(startup_script,true)\nend\nfunction _update60()\nif selected_actor and selected_actor.bz\nand not coresume(selected_actor.bz) then\nselected_actor.bz=nil\nend\nga(dy)\nif cd then\nif cd.bz\nand not coresume(cd.bz) then\nif cd.by!=3\nand cd.cb\nthen\ncamera_follow(cd.cb)\nselected_actor=cd.cb\nend\ndel(cc,cd)\nif#cc>0 then\ncd=cc[#cc]\nelse\nif(cd.by!=2) fy=3\ncd=nil\nend\nend\nelse\nga(dr)\nend\ngb()\ngc()\ngd,ge=1.5-rnd(3),1.5-rnd(3)\ngd=flr(gd*be)\nge=flr(ge*be)\nif(not bd) be=be>0.05 and be*0.90 or 0\nend\nfunction _draw()\ncls()\ncamera(cam_x+gd,0+ge)\nclip(\n0+dp-gd,\nstage_top+dp-ge,\n128-dp*2-gd,\n64-dp*2)\ngf()\ncamera(0,0)\nclip()\nif show_debuginfo then\nprint(\"cpu: \"..flr(100*stat(1))..\"%\",0,stage_top-16,8)\nprint(\"mem: \"..flr(stat(0)\/1024*100)..\"%\",0,stage_top-8,8)\nprint(\"x: \"..flr(fl+cam_x)..\" y:\"..fm-stage_top,80,stage_top-8,8)\nend\ngg()\nif cf\nand cf.co then\ngh()\ngi()\nreturn\nend\nif(fy>0) fy-=1 return\nif(not cd) gj()\nif(not cd\nor cd.by==2)\nand fy==0 then\ngk()\nend\nif(not cd) gi()\nend\nfunction gl()\ngm=stat(34)>0\nend\nfunction gb()\nif ed and not gm and(btnp(4) or stat(34)==1) then\ned.er,gm=0,true\nreturn\nend\nif cd then\nif(btnp(5) or stat(34)==2) and cd.ca then\ncd.bz=cocreate(cd.ca)\ncd.ca=nil\nreturn\nend\ngl()\nreturn\nend\nif btn(0) then fl-=1 end\nif btn(1) then fl+=1 end\nif btn(2) then fm-=1 end\nif btn(3) then fm+=1 end\nif btnp(4) then gn(1) end\nif btnp(5) then gn(2) end\ngo,gp=stat(32)-1,stat(33)-1\nif go!=gq then fl=go end\nif gp!=gr then fm=gp end\nif stat(34)>0 and not gm then\ngn(stat(34))\nend\ngq,gr=go,gp\ngl()\nend\nfl,fm=mid(0,fl,127),mid(0,fm,127)\nfunction gn(gs)\nif(not selected_actor) return\nif cf and cf.co then\nif(gt) selected_sentence=gt\nreturn\nend\nif(ft) ds()\nif gu then\nfs,fv,fw=get_verb(gu)\nelseif gv then\nif gs==1 then\nif fv and not ft then\nfw=gv\nelse\nfv=gv\nend\nif(fs[2]==get_verb(verb_default)[2]\nand gv.owner) then\nfs=get_verb(verbs[verb_default_inventory_index])\nend\nelseif gw then\nfs,fv=get_verb(gw),gv\ngj()\nend\nelseif gx then\nif gx==fp[1] then\nif(selected_actor.gy>0) selected_actor.gy-=1\nelse\nif selected_actor.gy+2<flr(#selected_actor.du\/4) then\nselected_actor.gy+=1\nend\nend\nreturn\nend\nlocal gz=fs[2]\nif fv then\nif gz==\"use\"or gz==\"give\"then\nif fw then\nelseif fv.use_with and fv.owner==selected_actor then\nreturn\nend\nend\nft=true\nselected_actor.bz=cocreate(function()\nif(not fv.owner\nand(not has_flag(fv.classes,\"class_actor\")\nor gz!=\"use\"))\nor fw\nthen\nha=fw or fv\nhb=get_use_pos(ha)\nwalk_to(selected_actor,hb.x,hb.y)\nif selected_actor.eu!=2 then return end\nuse_dir=ha\nif ha.use_dir then use_dir=ha.use_dir end\ndo_anim(selected_actor,\"face_towards\",use_dir)\nend\nif valid_verb(fs,fv) then\nstart_script(fv.verbs[fs[1]],false,fv,fw)\nelse\nif has_flag(fv.classes,\"class_door\") then\nlocal dv=dl[gz]\nif(dv) dv(fv,fv.target_door)\nelse\nbk(gz,fv,fw)\nend\nend\nds()\nend)\ncoresume(selected_actor.bz)\nelseif fm>stage_top and fm<stage_top+64 then\nft=true\nselected_actor.bz=cocreate(function()\nwalk_to(selected_actor,fl+cam_x,fm-stage_top)\nds()\nend)\ncoresume(selected_actor.bz)\nend\nend\nfunction gc()\nif(not room_curr) return\ngu,gw,gv,gt,gx=nil\nif cf and cf.co then\nfor dz in all(cf.cg) do\nif(hc(dz)) gt=dz\nend\nreturn\nend\nhd()\nfor bg in all(room_curr.objects) do\nif(not bg.classes\nor(bg.classes and not has_flag(bg.classes,\"class_untouchable\")))\nand(not bg.dependent_on\nor bg.dependent_on.state==bg.dependent_on_state)\nthen\nhe(bg,bg.w*8,bg.h*8,cam_x,hf)\nelse\nbg.hg=nil\nend\nif hc(bg) then\nif not gv\nor max(bg.z,gv.z)==bg.z\nthen\ngv=bg\nend\nend\nhh(bg)\nend\nfor ea,bt in pairs(actors) do\nif bt.in_room==room_curr then\nhe(bt,bt.w*8,bt.h*8,cam_x,hf)\nhh(bt)\nif(hc(bt) and bt!=selected_actor) gv=bt\nend\nend\nif selected_actor then\nfor bi in all(verbs) do\nif(hc(bi)) gu=bi\nend\nfor hi in all(fp) do\nif(hc(hi)) gx=hi\nend\nfor ea,bg in pairs(selected_actor.du) do\nif hc(bg) then\ngv=bg\nif(fs[2]==\"pickup\"and gv.owner) fs=nil\nend\nif(bg.owner!=selected_actor) del(selected_actor.du,bg)\nend\nfs=fs or get_verb(verb_default)\ngw=gv and bf(gv) or gw\nend\nend\nfunction hd()\nfor x=-64,64 do\nfx[x]={}\nend\nend\nfunction hh(bg)\nadd(fx[bg.z and bg.z or flr(bg.y+(bg.hj and 0 or bg.h*8))],bg)\nend\nfunction gf()\nif not room_curr then\nprint(\"-error-  no current room set\",5+cam_x,5+stage_top,8,0)\nreturn\nend\nrectfill(0,stage_top,127,stage_top+64,room_curr.hk or 0)\nfor z=-64,64 do\nif z==0 then\nhl(room_curr)\nif room_curr.trans_col then\npalt(0,false)\npalt(room_curr.trans_col,true)\nend\nmap(room_curr.map[1],room_curr.map[2],0,stage_top,room_curr.hm,room_curr.hn)\npal()\nelse\nho=fx[z]\nfor bg in all(ho) do\nif not has_flag(bg.classes,\"class_actor\") then\nif bg.states\nor(bg.state\nand bg[bg.state]\nand bg[bg.state]>0)\nand(not bg.dependent_on\nor bg.dependent_on.state==bg.dependent_on_state)\nand not bg.owner\nor bg.draw\nor bg.curr_anim\nthen\nhp(bg)\nend\nelse\nif(bg.in_room==room_curr) hq(bg)\nend\nend\nend\nend\nend\nfunction hl(bg)\nif bg.col_replace then\nfc=bg.col_replace\npal(fc[1],fc[2])\nend\nif bg.lighting then\nhr(bg.lighting)\nelseif bg.in_room and bg.in_room.lighting then\nhr(bg.in_room.lighting)\nend\nend\nfunction hp(bg)\nlocal hs=0\nhl(bg)\nif bg.draw then\nbg.draw(bg)\nelse\nif bg.curr_anim then\nht(bg)\nhs=bg.curr_anim[bg.da]\nend\nfor h=0,bg.repeat_x and bg.repeat_x-1 or 0 do\nif bg.states then\nhs=bg.states[bg.state]\nelseif hs==0 then\nhs=bg[bg.state]\nend\nhu(hs,bg.x+(h*(bg.w*8)),bg.y,bg.w,bg.h,bg.trans_col,bg.flip_x,bg.scale)\nend\nend\npal()\nend\nfunction hq(bt)\nlocal hv,hs=cz[bt.face_dir]\nif bt.curr_anim\nand(bt.eu==1 or cq(bt.curr_anim))\nthen\nht(bt)\nhs=bt.curr_anim[bt.da]\nelse\nhs=bt.idle[hv]\nend\nhl(bt)\nlocal hw=(bt.y-room_curr.autodepth_pos[1])\/(room_curr.autodepth_pos[2]-room_curr.autodepth_pos[1])\nhw=room_curr.autodepth_scale[1]+(room_curr.autodepth_scale[2]-room_curr.autodepth_scale[1])*hw\nbt.ff=mid(room_curr.autodepth_scale[1],hw,room_curr.autodepth_scale[2])\nlocal scale=bt.scale or bt.ff\nlocal hx,hy=(8*bt.h),(8*bt.w)\nlocal hz=hx-(hx*scale)\nlocal ia=hy-(hy*scale)\nlocal ib=bt.cs+flr(ia\/2)\nlocal ic=bt.hj+hz\nhu(hs,\nib,\nic,\nbt.w,\nbt.h,\nbt.trans_col,\nbt.flip,\nfalse,\nscale)\nif eg\nand eg==bt\nand eg.talk\nthen\nif bt.id<7 then\nhu(bt.talk[hv],\nib+(bt.talk[5] or 0),\nic+flr((bt.talk[6] or 8)*scale),\n(bt.talk[7] or 1),\n(bt.talk[8] or 1),\nbt.trans_col,\nbt.flip,\nfalse,\nscale)\nend\nbt.id=bt.id%14+1\nend\npal()\nend\nfunction gj()\nlocal ie,ig,ih=verb_maincol,fs[2],fs and fs[3] or\"\"\nif fv then\nih=ih..\" \"..fv.name\nif ig==\"use\"and(not ft or fw) then\nih=ih..\" with\"\nelseif ig==\"give\"then\nih=ih..\" to\"\nend\nend\nif fw then\nih=ih..\" \"..fw.name\nelseif gv\nand gv.name!=\"\"\nand(not fv or(fv!=gv))\nand not ft\nthen\nif gv.owner\nand ig==get_verb(verb_default)[2] then\nih=\"look-at\"\nend\nih=ih..\" \"..gv.name\nend\nfu=ih\nif ft then\nih=fu\nie=verb_hovcol\nend\nprint(ii(ih),63.5-flr(#ih*2),stage_top+66,ie)\nend\nfunction gg()\nif ed then\nlocal ij=0\nfor ik in all(ed.eq) do\nlocal il=0\nif ed.eh==1 then\nil=((ed.cm*4)-(#ik*4))\/2\nend\noutline_text(\nik,\ned.x+il,\ned.y+ij,\ned.col,\n0,\ned.ee,\ned.ei)\nij+=ed.ei and 12 or 6\nend\ned.er-=1\nif(ed.er<=0) stop_talking()\nend\nend\nfunction gk()\nlocal eo,ep,im=0,75,0\nfor bi in all(verbs) do\nlocal io=bi==gu and verb_hovcol or\n(gw and bi==gw and verb_defcol or\nverb_maincol)\nlocal bj=get_verb(bi)\nprint(bj[3],eo,ep+stage_top+1,verb_shadcol)\nprint(bj[3],eo,ep+stage_top,io)\nbi.x=eo\nbi.y=ep\nhe(bi,#bj[3]*4,5,0,0)\nif(#bj[3]>im) im=#bj[3]\nep+=8\nif ep>=95 then\nep=75\neo+=(im+1.0)*4\nim=0\nend\nend\nif selected_actor then\neo,ep=86,76\nlocal ip=selected_actor.gy*4\nlocal iq=min(ip+8,#selected_actor.du)\nfor ir=1,8 do\nrectfill(eo-1,stage_top+ep-1,eo+8,stage_top+ep+8,verb_shadcol)\nbg=selected_actor.du[ip+ir]\nif bg then\nbg.x,bg.y=eo,ep\nhp(bg)\nhe(bg,bg.w*8,bg.h*8,0,0)\nend\neo+=11\nif eo>=125 then\nep+=12\neo=86\nend\nir+=1\nend\nfor em=1,2 do\nis=fp[em]\npal(7,gx==is and verb_hovcol or verb_maincol)\npal(5,verb_shadcol)\nhu(is.spr,is.x,is.y,1,1,0)\nhe(is,8,7,0,0)\npal()\nend\nend\nend\nfunction gh()\nlocal eo,ep=0,70\nfor dz in all(cf.cg) do\nif dz.cm>0 then\ndz.x,dz.y=eo,ep\nhe(dz,dz.cm*4,#dz.ch*5,0,0)\nlocal io=dz==gt and cf.cn or cf.col\nfor ik in all(dz.ch) do\nprint(ii(ik),eo,ep+stage_top,io)\nep+=5\nend\nep+=2\nend\nend\nend\nfunction gi()\ncol=ui_cursor_cols[fo]\npal(7,col)\nspr(ui_cursorspr,fl-4,fm-3,1,1,0)\npal()\nfn+=1\nif fn>7 then\nfn=1\nfo=fo%#ui_cursor_cols+1\nend\nend\nfunction hu(it,x,y,w,h,iu,flip_x,iv,scale)\nset_trans_col(iu)\nit=it or 0\nlocal iw,ix=8*(it%16),8*flr(it\/16)\nlocal iy,iz=8*w,8*h\nlocal ja=scale or 1\nlocal jb,jc=iy*ja,iz*ja\nsspr(iw,ix,iy,iz,x,stage_top+y,jb,jc,flip_x,iv)\nend\nfunction set_trans_col(iu)\npalt(0,false)\npalt(iu,true)\nend\nfunction fz()\nfor et in all(rooms) do\njd(et)\net.hm=#et.map>2 and et.map[3]-et.map[1]+1 or 16\net.hn=#et.map>2 and et.map[4]-et.map[2]+1 or 8\net.autodepth_pos=et.autodepth_pos or{9,50}\net.autodepth_scale=et.autodepth_scale or{0.25,1}\nfor bg in all(et.objects) do\njd(bg)\nbg.in_room,bg.h=et,bg.h or 0\nif(bg.init) bg.init(bg)\nend\nend\nfor je,bt in pairs(actors) do\njd(bt)\nbt.eu=2\nbt.db=1\nbt.id=1\nbt.da=1\nbt.du={\n}\nbt.gy=0\nend\nend\nfunction ga(scripts)\nfor eb in all(scripts) do\nif eb[2] and not coresume(eb[2],eb[3],eb[4]) then\ndel(scripts,eb)\nend\nend\nend\nfunction hr(jf)\nif(jf) jf=1-jf\nlocal fd=flr(mid(0,jf,1)*100)\nlocal jg={0,1,1,2,1,13,6,\n4,4,9,3,13,1,13,14}\nfor jh=1,15 do\ncol=jh\nji=(fd+(jh*1.46))\/22\nfor ea=1,ji do\ncol=jg[col]\nend\npal(jh,col)\nend\nend\nfunction cq(t)\nreturn type(t)==\"table\"\nend\nfunction bs(bp)\nreturn mid(0,(cq(bp) and bp.x or bp)-64,(room_curr.hm*8)-128)\nend\nfunction ew(bg)\nreturn{flr(bg.x\/8)+room_curr.map[1],flr(bg.y\/8)+room_curr.map[2]}\nend\nfunction jj(ex,ey)\nreturn fget(mget(ex,ey),0)\nend\nfunction ci(msg,ek)\nlocal ch,jk,jl,en={},\"\",\"\",\"\"\nlocal function jm(jn)\nif#jl+#jk>jn then\nadd(ch,jk)\njk=\"\"\nend\njk=jk..jl\njl=\"\"\nend\nfor em=1,#msg do\nen=sub(msg,em,em)\njl=jl..en\nif en==\" \"or#jl>ek-1 then\njm(ek)\nelseif#jl>ek-1 then\njl=jl..\"-\"\njm(ek)\nelseif en==\";\"then\njk=jk..sub(jl,1,#jl-1)\njl=\"\"\njm(0)\nend\nend\njm(ek)\nif(jk!=\"\") add(ch,jk)\nreturn ch\nend\nfunction ck(ch)\nlocal cj=0\nfor ik in all(ch) do\nif(#ik>cj) cj=#ik\nend\nreturn cj\nend\nfunction has_flag(bg,jo)\nfor jp in all(bg) do\nif(jp==jo) return true\nend\nend\nfunction he(bg,w,h,jq,jr)\nlocal x,y=bg.x,bg.y\nif has_flag(bg.classes,\"class_actor\") then\nbg.cs=x-(bg.w*8)\/2\nbg.hj=y-(bg.h*8)+1\nx=bg.cs\ny=bg.hj\nend\nbg.hg={\nx=x,\ny=y+stage_top,\njs=x+w-1,\njt=y+h+stage_top-1,\njq=jq,\njr=jr\n}\nend\nfunction fb(ju,jv)\nlocal jw,jx,jy,jz,ka,kb={},{},{}\nkc(jw,ju,0)\njy[kd(ju)]=0\nwhile#jw>0 and#jw<1000 do\nkb=jw[#jw][1]\ndel(jw,jw[#jw])\nif(kd(kb)==kd(jv)) break\nlocal ke={}\nfor x=-1,1 do\nfor y=-1,1,x==0 and 2 or 1 do\nlocal kf,kg=kb[1]+x,kb[2]+y\nif kf>=room_curr.map[1] and kf<=room_curr.map[1]+room_curr.hm\nand kg>=room_curr.map[2] and kg<=room_curr.map[2]+room_curr.hn\nand jj(kf,kg)\nand((abs(x)!=abs(y))\nor jj(kf,kb[2])\nor jj(kf-x,kg)\nor enable_diag_squeeze)\nthen\nlocal kh={kf,kg}\nlocal ki=kd(kh)\nlocal kj=jy[kd(kb)]+(x*y==0 and 1 or 1.414)\nif not jy[ki] or kj<jy[ki] then\njy[ki]=kj\nlocal h=max(abs(jv[1]-kf),abs(jv[2]-kg))+min(abs(jv[1]-kf),abs(jv[2]-kg))*.414\nkc(jw,kh,kj+h)\njx[ki]=kb\nif not jz or h<jz then\njz=h\nka=ki\nkk=kh\nend\nend\nend\nend\nend\nend\nlocal fa={}\nkb=jx[kd(jv)]\nif kb then\nadd(fa,jv)\nelseif ka then\nkb=jx[ka]\nadd(fa,kk)\nend\nif kb then\nlocal kl,km=kd(kb),kd(ju)\nwhile kl!=km do\nadd(fa,kb)\nkb=jx[kl]\nkl=kd(kb)\nend\nfor em=1,#fa\/2 do\nlocal kn=fa[em]\nlocal ko=#fa-(em-1)\nfa[em]=fa[ko]\nfa[ko]=kn\nend\nend\nreturn fa\nend\nfunction kc(t,bp,fd)\nlocal kp={bp,fd}\nif#t>=1 then\nfor em=#t+1,2,-1 do\nlocal kh=t[em-1]\nif fd<kh[2] then\nt[em]=kp\nreturn\nelse\nt[em]=kh\nend\nend\nend\nt[1]=kp\nend\nfunction kd(kq)\nreturn((kq[1]+1)*16)+kq[2]\nend\nfunction ht(bg)\nbg.db+=1\nif bg.db>bg.frame_delay then\nbg.db=1\nbg.da=bg.da%#bg.curr_anim+1\nend\nend\nfunction dh(msg)\nprint_line(\"-error-;\"..msg,5+cam_x,5,8,0)\nend\nfunction jd(bg)\nfor ik in all(split(bg.data,\"\\n\")) do\nlocal pairs=split(ik,\"=\")\nif#pairs==2 then\nbg[pairs[1]]=kr(pairs[2])\nelse\nprinth(\" > invalid data: [\"..pairs[1]..\"]\")\nend\nend\nend\nfunction split(dz,ks)\nlocal kt,ip,ku={},0,0\nfor em=1,#dz do\nlocal kv=sub(dz,em,em)\nif kv==ks then\nadd(kt,sub(dz,ip,ku))\nip,ku=0,0\nelseif kv!=\" \"\nand kv!=\"\\t\"then\nku,ip=em,ip==0 and em or ip\nend\nend\nif ip+ku>0 then\nadd(kt,sub(dz,ip,ku))\nend\nreturn kt\nend\nfunction kr(kw)\nlocal kx=sub(kw,1,1)\nif kw==\"true\"then\nreturn true\nelseif kw==\"false\"then\nreturn false\nelseif tonum(kw) then\nreturn tonum(kw)\nelseif kx==\"{\"then\nlocal kn=sub(kw,2,#kw-1)\nky={}\nfor bp in all(split(kn,\",\")) do\nadd(ky,kr(bp))\nend\nreturn ky\nelse\nreturn kw\nend\nend\nfunction outline_text(kz,x,y,la,lb,ee,ei)\nif(not ee) kz=ii(kz)\nif(ei) kz=\"\\^w\\^t\"..kz\nfor lc=-1,1 do\nfor ld=-1,1,lc==0 and 2 or 1 do\nprint(kz,x+lc,y+ld,lb)\nend\nend\nprint(kz,x,y,la)\nend\nfunction hc(bg)\nif(not bg.hg or cd) return false\nlocal hg=bg.hg\nreturn not((fl+hg.jq>hg.js or fl+hg.jq<hg.x)\nor(fm>hg.jt or fm<hg.y))\nend\nfunction ii(dz)\nlocal t=\"\"\nfor em=1,#dz do\nlocal fc=ord(dz,em)\nt..=chr(fc>96 and fc<123 and fc-32 or fc)\nend\nreturn t\nend\n","avg_line_length":16.7949138638,"max_line_length":99,"alphanum_fraction":0.7056611146,"licenses":["MIT"],"repository_name":"Liquidream\/SCUMM-8","path":"dist\/scumm-8.min.lua","size":20473,"lang":"Lua"}
{"content":"package com.wix.pay.creditguard\r\n\r\nimport org.json4s.DefaultFormats\r\nimport org.json4s.native.Serialization\r\n\r\nclass JsonCreditguardAuthorizationParser() extends CreditguardAuthorizationParser {\r\n  private implicit val formats = DefaultFormats\r\n\r\n  override def parse(authorizationKey: String): CreditguardAuthorization = {\r\n    Serialization.read[CreditguardAuthorization](authorizationKey)\r\n  }\r\n\r\n  override def stringify(authorization: CreditguardAuthorization): String = {\r\n    Serialization.write(authorization)\r\n  }\r\n}\r\n","avg_line_length":31.0,"max_line_length":84,"alphanum_fraction":0.7931688805,"licenses":["Apache-2.0"],"repository_name":"wix-playground\/libpay-creditguard","path":"libpay-creditguard\/src\/main\/scala\/com\/wix\/pay\/creditguard\/JsonCreditguardAuthorizationParser.scala","size":527,"lang":"Scala"}
{"content":"\"\"\"\n    Raibert hopper policy for Hopper2D\n\"\"\"\n\n@with_kw mutable struct RaibertOptions\n    live_plotting::Bool=false # Use the live plotting tool to debug\nend\n\nmutable struct Raibert3D <: Policy\n\tkr_c::Real\n\tkr_p::Real\n\tkr_v_stance::Real\n\tkr_v_flight::Real\n\tk\u03b8_c::Real\n\tk\u03b8_p::Real\n\tk\u03b8_v::Real\n\tu::AbstractVector\n\tcontact::Bool\n\tv0::Vector{Real}\n\tTstance::Real\n\tTflight::Real\n\tq0::AbstractVector\n\tq1::AbstractVector\n\topts::RaibertOptions\nend\n\nfunction raibert_policy(model::Hopper3D;\n\t\tv0=[0.0; 0.0], Tstance=0.13, Tflight=0.62, h = 0.1,\n\t\tkr_c =  8e1,\n\t\tkr_p = -1e3,\n\t\tkr_v_stance = -1e-2,\n\t\tkr_v_flight = -1e1,\n\t\tk\u03b8_c =  0.0,\n\t\tk\u03b8_p = -6e1,\n\t\tk\u03b8_v = -1e1,\n\t\tmpc_opts = RaibertOptions(),\n\t\t)\n\n\t@assert v0[1] == 0.0 || v0[2] == 0.0\n\n\tu  = zeros(model.dim.u)\n\tq0 = zeros(model.dim.q)\n\tq1 = zeros(model.dim.q)\n\tcontact = false\n\n\tRaibert3D(kr_c, kr_p, kr_v_stance, kr_v_flight, k\u03b8_c, k\u03b8_p, k\u03b8_v,\n\t\tu, contact, v0, Tstance, Tflight, copy(q0), copy(q1), mpc_opts)\nend\n\nfunction policy(p::Raibert3D, x, traj, t)\n\t# Initialization\n\th = traj.h\n\tp.q0 = copy(traj.q[t])\n\tp.q1 = copy(x)\n\n\t# get Euler angles\n\trot0 = RotXYZ(MRP(p.q0[4:6]...))\n\teul0 = [rot0.theta1; rot0.theta2; rot0.theta3]\n\n\trot1 = RotXYZ(MRP(p.q1[4:6]...))\n\teul1 = [rot1.theta1; rot1.theta2; rot1.theta3]\n\n\t# Detect contact\n\tif any(traj.\u03b3[max(1,t-1)] .> 1.5e-2)\n\t\tp.contact = true\n\telse\n\t\tp.contact = false\n\tend\n\n\n\t# Velocities\n\tqv = (p.q1 - p.q0)\/h\n\t\u03b8v = (eul1 - eul0)\/h\n\trv = qv[7]\n\n\t# References\n\t\u03b81 = eul1\n\tr1 = p.q1[7]\n\trref = 0.5\n\n\t# td = touchdown\n\t\u03b8td  = [asin(p.v0[1]*Tstance\/(2*rref))\/2; asin(p.v0[2]*Tstance\/(2*rref))\/2]\n\n\t# Gains\n\tkr_c = p.kr_c\n\tkr_p = p.kr_p\n\tkr_v_stance = p.kr_v_stance\n\tkr_v_flight = p.kr_v_flight\n\n\tk\u03b8_c = p.k\u03b8_c\n\tk\u03b8_p = p.k\u03b8_p\n\tk\u03b8_v = p.k\u03b8_v\n\n\tdir = qv[1:2] .\/ norm(qv[1:2]) # TODO: change to binary switch\n\n\tif p.contact\n\t\t# regulate around \u03b8td using same gain k\u03b8_p but taking into account\n\t\t# that stance time is much lower than flight time\n\t\tp.u[1] = (dir[2] * k\u03b8_c + k\u03b8_p*(\u03b81[1] + dir[2] * \u03b8td[1]) * p.Tflight\/p.Tstance)\n\t\tp.u[2] = (dir[1] * k\u03b8_c + k\u03b8_p*(\u03b81[2] + dir[1] * \u03b8td[2]) * p.Tflight\/p.Tstance)\n\t\tp.u[3] = kr_c + kr_p*(r1 - rref) + kr_v_stance*rv\n\telse\n\t\t# regulate around \u03b8td\n\t\tp.u[1] = (k\u03b8_p*(\u03b81[1] - dir[2] * \u03b8td[1]))  + k\u03b8_v*\u03b8v[1]\n\t\tp.u[2] = (k\u03b8_p*(\u03b81[2] - dir[1] * \u03b8td[2]))  + k\u03b8_v*\u03b8v[2]\n\t\tp.u[3] = kr_p*(r1 - rref) + kr_v_flight*rv\n\tend\n\n\tp.u .*= h\n\n    return p.u\nend\n","avg_line_length":21.0353982301,"max_line_length":81,"alphanum_fraction":0.626419857,"licenses":["MIT"],"repository_name":"rejuvyesh\/ContactImplicitMPC.jl","path":"src\/controller\/raibert_3D_policy.jl","size":2417,"lang":"Julia"}
{"content":"\/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\npackage org.apache.dubbo.remoting.exchange.codec;\n\nimport org.apache.dubbo.common.Version;\nimport org.apache.dubbo.common.io.Bytes;\nimport org.apache.dubbo.common.io.StreamUtils;\nimport org.apache.dubbo.common.logger.Logger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.serialize.Cleanable;\nimport org.apache.dubbo.common.serialize.ObjectInput;\nimport org.apache.dubbo.common.serialize.ObjectOutput;\nimport org.apache.dubbo.common.serialize.Serialization;\nimport org.apache.dubbo.common.utils.StringUtils;\nimport org.apache.dubbo.remoting.Channel;\nimport org.apache.dubbo.remoting.RemotingException;\nimport org.apache.dubbo.remoting.buffer.ChannelBuffer;\nimport org.apache.dubbo.remoting.buffer.ChannelBufferInputStream;\nimport org.apache.dubbo.remoting.buffer.ChannelBufferOutputStream;\nimport org.apache.dubbo.remoting.exchange.Request;\nimport org.apache.dubbo.remoting.exchange.Response;\nimport org.apache.dubbo.remoting.exchange.support.DefaultFuture;\nimport org.apache.dubbo.remoting.telnet.codec.TelnetCodec;\nimport org.apache.dubbo.remoting.transport.CodecSupport;\nimport org.apache.dubbo.remoting.transport.ExceedPayloadLimitException;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\n\/**\n * ExchangeCodec.\n *\/\npublic class ExchangeCodec extends TelnetCodec {\n\n    \/\/ header length.\n    protected static final int HEADER_LENGTH = 16;\n    \/\/ magic header.\n    protected static final short MAGIC = (short) 0xdabb;\n    protected static final byte MAGIC_HIGH = Bytes.short2bytes(MAGIC)[0];\n    protected static final byte MAGIC_LOW = Bytes.short2bytes(MAGIC)[1];\n    \/\/ message flag.\n    protected static final byte FLAG_REQUEST = (byte) 0x80;\n    protected static final byte FLAG_TWOWAY = (byte) 0x40;\n    protected static final byte FLAG_EVENT = (byte) 0x20;\n    protected static final int SERIALIZATION_MASK = 0x1f;\n    private static final Logger logger = LoggerFactory.getLogger(ExchangeCodec.class);\n\n    public Short getMagicCode() {\n        return MAGIC;\n    }\n\n    @Override\n    public void encode(Channel channel, ChannelBuffer buffer, Object msg) throws IOException {\n        if (msg instanceof Request) {\n            encodeRequest(channel, buffer, (Request) msg);\n        } else if (msg instanceof Response) {\n            encodeResponse(channel, buffer, (Response) msg);\n        } else {\n            super.encode(channel, buffer, msg);\n        }\n    }\n\n    @Override\n    public Object decode(Channel channel, ChannelBuffer buffer) throws IOException {\n        int readable = buffer.readableBytes();\n        byte[] header = new byte[Math.min(readable, HEADER_LENGTH)];\n        buffer.readBytes(header);\n        return decode(channel, buffer, readable, header);\n    }\n\n    @Override\n    protected Object decode(Channel channel, ChannelBuffer buffer, int readable, byte[] header) throws IOException {\n        \/\/ check magic number.\n        if (readable > 0 && header[0] != MAGIC_HIGH\n                || readable > 1 && header[1] != MAGIC_LOW) {\n            int length = header.length;\n            if (header.length < readable) {\n                header = Bytes.copyOf(header, readable);\n                buffer.readBytes(header, length, readable - length);\n            }\n            for (int i = 1; i < header.length - 1; i++) {\n                if (header[i] == MAGIC_HIGH && header[i + 1] == MAGIC_LOW) {\n                    buffer.readerIndex(buffer.readerIndex() - header.length + i);\n                    header = Bytes.copyOf(header, i);\n                    break;\n                }\n            }\n            return super.decode(channel, buffer, readable, header);\n        }\n        \/\/ check length.\n        if (readable < HEADER_LENGTH) {\n            return DecodeResult.NEED_MORE_INPUT;\n        }\n\n        \/\/ get data length.\n        int len = Bytes.bytes2int(header, 12);\n        checkPayload(channel, len);\n\n        int tt = len + HEADER_LENGTH;\n        if (readable < tt) {\n            return DecodeResult.NEED_MORE_INPUT;\n        }\n\n        \/\/ limit input stream.\n        ChannelBufferInputStream is = new ChannelBufferInputStream(buffer, len);\n\n        try {\n            return decodeBody(channel, is, header);\n        } finally {\n            if (is.available() > 0) {\n                try {\n                    if (logger.isWarnEnabled()) {\n                        logger.warn(\"Skip input stream \" + is.available());\n                    }\n                    StreamUtils.skipUnusedStream(is);\n                } catch (IOException e) {\n                    logger.warn(e.getMessage(), e);\n                }\n            }\n        }\n    }\n\n    protected Object decodeBody(Channel channel, InputStream is, byte[] header) throws IOException {\n        byte flag = header[2], proto = (byte) (flag & SERIALIZATION_MASK);\n        \/\/ get request id.\n        long id = Bytes.bytes2long(header, 4);\n        if ((flag & FLAG_REQUEST) == 0) {\n            \/\/ decode response.\n            Response res = new Response(id);\n            if ((flag & FLAG_EVENT) != 0) {\n                res.setEvent(Response.HEARTBEAT_EVENT);\n            }\n            \/\/ get status.\n            byte status = header[3];\n            res.setStatus(status);\n            try {\n                ObjectInput in = CodecSupport.deserialize(channel.getUrl(), is, proto);\n                if (status == Response.OK) {\n                    Object data;\n                    if (res.isHeartbeat()) {\n                        data = decodeHeartbeatData(channel, in);\n                    } else if (res.isEvent()) {\n                        data = decodeEventData(channel, in);\n                    } else {\n                        data = decodeResponseData(channel, in, getRequestData(id));\n                    }\n                    res.setResult(data);\n                } else {\n                    res.setErrorMessage(in.readUTF());\n                }\n            } catch (Throwable t) {\n                res.setStatus(Response.CLIENT_ERROR);\n                res.setErrorMessage(StringUtils.toString(t));\n            }\n            return res;\n        } else {\n            \/\/ decode request.\n            Request req = new Request(id);\n            req.setVersion(Version.getProtocolVersion());\n            req.setTwoWay((flag & FLAG_TWOWAY) != 0);\n            if ((flag & FLAG_EVENT) != 0) {\n                req.setEvent(true);\n            }\n            try {\n                ObjectInput in = CodecSupport.deserialize(channel.getUrl(), is, proto);\n                Object data;\n                if (req.isHeartbeat()) {\n                    data = decodeHeartbeatData(channel, in);\n                } else if (req.isEvent()) {\n                    data = decodeEventData(channel, in);\n                } else {\n                    data = decodeRequestData(channel, in);\n                }\n                req.setData(data);\n            } catch (Throwable t) {\n                \/\/ bad request\n                req.setBroken(true);\n                req.setData(t);\n            }\n            return req;\n        }\n    }\n\n    protected Object getRequestData(long id) {\n        DefaultFuture future = DefaultFuture.getFuture(id);\n        if (future == null) {\n            return null;\n        }\n        Request req = future.getRequest();\n        if (req == null) {\n            return null;\n        }\n        return req.getData();\n    }\n\n    protected void encodeRequest(Channel channel, ChannelBuffer buffer, Request req) throws IOException {\n        Serialization serialization = getSerialization(channel);\n        \/\/ header.\n        byte[] header = new byte[HEADER_LENGTH];\n        \/\/ set magic number.\n        Bytes.short2bytes(MAGIC, header);\n\n        \/\/ set request and serialization flag.\n        header[2] = (byte) (FLAG_REQUEST | serialization.getContentTypeId());\n\n        if (req.isTwoWay()) {\n            header[2] |= FLAG_TWOWAY;\n        }\n        if (req.isEvent()) {\n            header[2] |= FLAG_EVENT;\n        }\n\n        \/\/ set request id.\n        Bytes.long2bytes(req.getId(), header, 4);\n\n        \/\/ encode request data.\n        int savedWriteIndex = buffer.writerIndex();\n        buffer.writerIndex(savedWriteIndex + HEADER_LENGTH);\n        ChannelBufferOutputStream bos = new ChannelBufferOutputStream(buffer);\n        ObjectOutput out = serialization.serialize(channel.getUrl(), bos);\n        if (req.isEvent()) {\n            encodeEventData(channel, out, req.getData());\n        } else {\n            encodeRequestData(channel, out, req.getData(), req.getVersion());\n        }\n        out.flushBuffer();\n        if (out instanceof Cleanable) {\n            ((Cleanable) out).cleanup();\n        }\n        bos.flush();\n        bos.close();\n        int len = bos.writtenBytes();\n        checkPayload(channel, len);\n        Bytes.int2bytes(len, header, 12);\n\n        \/\/ write\n        buffer.writerIndex(savedWriteIndex);\n        buffer.writeBytes(header); \/\/ write header.\n        buffer.writerIndex(savedWriteIndex + HEADER_LENGTH + len);\n    }\n\n    protected void encodeResponse(Channel channel, ChannelBuffer buffer, Response res) throws IOException {\n        int savedWriteIndex = buffer.writerIndex();\n        try {\n            Serialization serialization = getSerialization(channel);\n            \/\/ header.\n            byte[] header = new byte[HEADER_LENGTH];\n            \/\/ set magic number.\n            Bytes.short2bytes(MAGIC, header);\n            \/\/ set request and serialization flag.\n            header[2] = serialization.getContentTypeId();\n            if (res.isHeartbeat()) {\n                header[2] |= FLAG_EVENT;\n            }\n            \/\/ set response status.\n            byte status = res.getStatus();\n            header[3] = status;\n            \/\/ set request id.\n            Bytes.long2bytes(res.getId(), header, 4);\n\n            buffer.writerIndex(savedWriteIndex + HEADER_LENGTH);\n            ChannelBufferOutputStream bos = new ChannelBufferOutputStream(buffer);\n            ObjectOutput out = serialization.serialize(channel.getUrl(), bos);\n            \/\/ encode response data or error message.\n            if (status == Response.OK) {\n                if (res.isHeartbeat()) {\n                    encodeHeartbeatData(channel, out, res.getResult());\n                } else {\n                    encodeResponseData(channel, out, res.getResult(), res.getVersion());\n                }\n            } else {\n                out.writeUTF(res.getErrorMessage());\n            }\n            out.flushBuffer();\n            if (out instanceof Cleanable) {\n                ((Cleanable) out).cleanup();\n            }\n            bos.flush();\n            bos.close();\n\n            int len = bos.writtenBytes();\n            checkPayload(channel, len);\n            Bytes.int2bytes(len, header, 12);\n            \/\/ write\n            buffer.writerIndex(savedWriteIndex);\n            buffer.writeBytes(header); \/\/ write header.\n            buffer.writerIndex(savedWriteIndex + HEADER_LENGTH + len);\n        } catch (Throwable t) {\n            \/\/ clear buffer\n            buffer.writerIndex(savedWriteIndex);\n            \/\/ send error message to Consumer, otherwise, Consumer will wait till timeout.\n            if (!res.isEvent() && res.getStatus() != Response.BAD_RESPONSE) {\n                Response r = new Response(res.getId(), res.getVersion());\n                r.setStatus(Response.BAD_RESPONSE);\n\n                if (t instanceof ExceedPayloadLimitException) {\n                    logger.warn(t.getMessage(), t);\n                    try {\n                        r.setErrorMessage(t.getMessage());\n                        channel.send(r);\n                        return;\n                    } catch (RemotingException e) {\n                        logger.warn(\"Failed to send bad_response info back: \" + t.getMessage() + \", cause: \" + e.getMessage(), e);\n                    }\n                } else {\n                    \/\/ FIXME log error message in Codec and handle in caught() of IoHanndler?\n                    logger.warn(\"Fail to encode response: \" + res + \", send bad_response info instead, cause: \" + t.getMessage(), t);\n                    try {\n                        r.setErrorMessage(\"Failed to send response: \" + res + \", cause: \" + StringUtils.toString(t));\n                        channel.send(r);\n                        return;\n                    } catch (RemotingException e) {\n                        logger.warn(\"Failed to send bad_response info back: \" + res + \", cause: \" + e.getMessage(), e);\n                    }\n                }\n            }\n\n            \/\/ Rethrow exception\n            if (t instanceof IOException) {\n                throw (IOException) t;\n            } else if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            } else if (t instanceof Error) {\n                throw (Error) t;\n            } else {\n                throw new RuntimeException(t.getMessage(), t);\n            }\n        }\n    }\n\n    @Override\n    protected Object decodeData(ObjectInput in) throws IOException {\n        return decodeRequestData(in);\n    }\n\n    @Deprecated\n    protected Object decodeHeartbeatData(ObjectInput in) throws IOException {\n        try {\n            return in.readObject();\n        } catch (ClassNotFoundException e) {\n            throw new IOException(StringUtils.toString(\"Read object failed.\", e));\n        }\n    }\n\n    protected Object decodeRequestData(ObjectInput in) throws IOException {\n        try {\n            return in.readObject();\n        } catch (ClassNotFoundException e) {\n            throw new IOException(StringUtils.toString(\"Read object failed.\", e));\n        }\n    }\n\n    protected Object decodeResponseData(ObjectInput in) throws IOException {\n        try {\n            return in.readObject();\n        } catch (ClassNotFoundException e) {\n            throw new IOException(StringUtils.toString(\"Read object failed.\", e));\n        }\n    }\n\n    @Override\n    protected void encodeData(ObjectOutput out, Object data) throws IOException {\n        encodeRequestData(out, data);\n    }\n\n    private void encodeEventData(ObjectOutput out, Object data) throws IOException {\n        out.writeObject(data);\n    }\n\n    @Deprecated\n    protected void encodeHeartbeatData(ObjectOutput out, Object data) throws IOException {\n        encodeEventData(out, data);\n    }\n\n    protected void encodeRequestData(ObjectOutput out, Object data) throws IOException {\n        out.writeObject(data);\n    }\n\n    protected void encodeResponseData(ObjectOutput out, Object data) throws IOException {\n        out.writeObject(data);\n    }\n\n    @Override\n    protected Object decodeData(Channel channel, ObjectInput in) throws IOException {\n        return decodeRequestData(channel, in);\n    }\n\n    protected Object decodeEventData(Channel channel, ObjectInput in) throws IOException {\n        try {\n            return in.readObject();\n        } catch (ClassNotFoundException e) {\n            throw new IOException(StringUtils.toString(\"Read object failed.\", e));\n        }\n    }\n\n    @Deprecated\n    protected Object decodeHeartbeatData(Channel channel, ObjectInput in) throws IOException {\n        try {\n            return in.readObject();\n        } catch (ClassNotFoundException e) {\n            throw new IOException(StringUtils.toString(\"Read object failed.\", e));\n        }\n    }\n\n    protected Object decodeRequestData(Channel channel, ObjectInput in) throws IOException {\n        return decodeRequestData(in);\n    }\n\n    protected Object decodeResponseData(Channel channel, ObjectInput in) throws IOException {\n        return decodeResponseData(in);\n    }\n\n    protected Object decodeResponseData(Channel channel, ObjectInput in, Object requestData) throws IOException {\n        return decodeResponseData(channel, in);\n    }\n\n    @Override\n    protected void encodeData(Channel channel, ObjectOutput out, Object data) throws IOException {\n        encodeRequestData(channel, out, data);\n    }\n\n    private void encodeEventData(Channel channel, ObjectOutput out, Object data) throws IOException {\n        encodeEventData(out, data);\n    }\n\n    @Deprecated\n    protected void encodeHeartbeatData(Channel channel, ObjectOutput out, Object data) throws IOException {\n        encodeHeartbeatData(out, data);\n    }\n\n    protected void encodeRequestData(Channel channel, ObjectOutput out, Object data) throws IOException {\n        encodeRequestData(out, data);\n    }\n\n    protected void encodeResponseData(Channel channel, ObjectOutput out, Object data) throws IOException {\n        encodeResponseData(out, data);\n    }\n\n    protected void encodeRequestData(Channel channel, ObjectOutput out, Object data, String version) throws IOException {\n        encodeRequestData(out, data);\n    }\n\n    protected void encodeResponseData(Channel channel, ObjectOutput out, Object data, String version) throws IOException {\n        encodeResponseData(out, data);\n    }\n\n\n}\n","avg_line_length":38.1403887689,"max_line_length":133,"alphanum_fraction":0.5943145138,"licenses":["Apache-2.0"],"repository_name":"AnyYANG\/dubbo-x","path":"dubbo-remoting\/dubbo-remoting-api\/src\/main\/java\/org\/apache\/dubbo\/remoting\/exchange\/codec\/ExchangeCodec.java","size":17659,"lang":"Java"}
{"content":"#!\/usr\/bin\/perl -w\n\nuse strict;\nuse warnings;\n\n# This is done to execute the test wrapper.\nrequire GimpTest::Run;\n\n# This function will be modified from script to script.\nsub gen_image\n{\n    my $img = load_input_file(\"tiger_sitting.png\");\n\n    gimp_rect_select($img, 20, 30, 150, 100, CHANNEL_OP_REPLACE(), 0, 0);\n\n    plug_in_emboss(1, $img, get_layer($img), 30, 100, 40, 1);\n\n    return { 'image_id' => $img };\n}\n\n","avg_line_length":19.8095238095,"max_line_length":73,"alphanum_fraction":0.6682692308,"licenses":["MIT"],"repository_name":"shlomif\/gimp-test-suite","path":"gimp-tests\/valid-output\/gen-scripts\/emboss.pl","size":416,"lang":"Perl"}
{"content":"\/*\nCopyright 2019 The HAProxy Ingress Controller Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*\/\n\npackage haproxy\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"sort\"\n\n\t\"github.com\/jcmoraisjr\/haproxy-ingress\/pkg\/haproxy\/template\"\n\thatypes \"github.com\/jcmoraisjr\/haproxy-ingress\/pkg\/haproxy\/types\"\n)\n\n\/\/ Config ...\ntype Config interface {\n\tAcquireHost(hostname string) *hatypes.Host\n\tFindHost(hostname string) *hatypes.Host\n\tAcquireBackend(namespace, name, port string) *hatypes.Backend\n\tFindBackend(namespace, name, port string) *hatypes.Backend\n\tConfigDefaultBackend(defaultBackend *hatypes.Backend)\n\tConfigDefaultX509Cert(filename string)\n\tAddUserlist(name string, users []hatypes.User) *hatypes.Userlist\n\tFindUserlist(name string) *hatypes.Userlist\n\tFrontendGroup() *hatypes.FrontendGroup\n\tBuildFrontendGroup() error\n\tDefaultHost() *hatypes.Host\n\tDefaultBackend() *hatypes.Backend\n\tGlobal() *hatypes.Global\n\tHosts() []*hatypes.Host\n\tBackends() []*hatypes.Backend\n\tUserlists() []*hatypes.Userlist\n\tEquals(other Config) bool\n}\n\ntype config struct {\n\tfgroup          *hatypes.FrontendGroup\n\tbindUtils       hatypes.BindUtils\n\tmapsTemplate    *template.Config\n\tmapsDir         string\n\tglobal          *hatypes.Global\n\thosts           []*hatypes.Host\n\tbackends        []*hatypes.Backend\n\tuserlists       []*hatypes.Userlist\n\tdefaultHost     *hatypes.Host\n\tdefaultBackend  *hatypes.Backend\n\tdefaultX509Cert string\n}\n\ntype options struct {\n\tmapsTemplate *template.Config\n\tmapsDir      string\n}\n\nfunc createConfig(bindUtils hatypes.BindUtils, options options) *config {\n\tmapsTemplate := options.mapsTemplate\n\tif mapsTemplate == nil {\n\t\tmapsTemplate = template.CreateConfig()\n\t}\n\treturn &config{\n\t\tbindUtils:    bindUtils,\n\t\tglobal:       &hatypes.Global{},\n\t\tmapsTemplate: mapsTemplate,\n\t\tmapsDir:      options.mapsDir,\n\t}\n}\n\nfunc (c *config) AcquireHost(hostname string) *hatypes.Host {\n\tif host := c.FindHost(hostname); host != nil {\n\t\treturn host\n\t}\n\thost := createHost(hostname)\n\tif host.Hostname != \"*\" {\n\t\tc.hosts = append(c.hosts, host)\n\t\tsort.Slice(c.hosts, func(i, j int) bool {\n\t\t\treturn c.hosts[i].Hostname < c.hosts[j].Hostname\n\t\t})\n\t} else {\n\t\tc.defaultHost = host\n\t}\n\treturn host\n}\n\nfunc (c *config) FindHost(hostname string) *hatypes.Host {\n\tif hostname == \"*\" && c.defaultHost != nil {\n\t\treturn c.defaultHost\n\t}\n\tfor _, f := range c.hosts {\n\t\tif f.Hostname == hostname {\n\t\t\treturn f\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc createHost(hostname string) *hatypes.Host {\n\treturn &hatypes.Host{\n\t\tHostname: hostname,\n\t}\n}\n\nfunc (c *config) sortBackends() {\n\tsort.Slice(c.backends, func(i, j int) bool {\n\t\tif c.backends[i] == c.defaultBackend {\n\t\t\treturn false\n\t\t}\n\t\tif c.backends[j] == c.defaultBackend {\n\t\t\treturn true\n\t\t}\n\t\treturn c.backends[i].ID < c.backends[j].ID\n\t})\n}\n\nfunc (c *config) AcquireBackend(namespace, name, port string) *hatypes.Backend {\n\tif backend := c.FindBackend(namespace, name, port); backend != nil {\n\t\treturn backend\n\t}\n\tbackend := createBackend(namespace, name, port)\n\tc.backends = append(c.backends, backend)\n\tc.sortBackends()\n\treturn backend\n}\n\nfunc (c *config) FindBackend(namespace, name, port string) *hatypes.Backend {\n\tfor _, b := range c.backends {\n\t\tif b.Namespace == namespace && b.Name == name && b.Port == port {\n\t\t\treturn b\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc createBackend(namespace, name, port string) *hatypes.Backend {\n\treturn &hatypes.Backend{\n\t\tID:        buildID(namespace, name, port),\n\t\tNamespace: namespace,\n\t\tName:      name,\n\t\tPort:      port,\n\t\tEndpoints: []*hatypes.Endpoint{},\n\t}\n}\n\nfunc buildID(namespace, name, port string) string {\n\treturn fmt.Sprintf(\"%s_%s_%s\", namespace, name, port)\n}\n\nfunc (c *config) ConfigDefaultBackend(defaultBackend *hatypes.Backend) {\n\tif c.defaultBackend != nil {\n\t\tdef := c.defaultBackend\n\t\tdef.ID = buildID(def.Namespace, def.Name, def.Port)\n\t}\n\tc.defaultBackend = defaultBackend\n\tif c.defaultBackend != nil {\n\t\tc.defaultBackend.ID = \"_default_backend\"\n\t}\n\tc.sortBackends()\n}\n\nfunc (c *config) ConfigDefaultX509Cert(filename string) {\n\tc.defaultX509Cert = filename\n}\n\nfunc (c *config) AddUserlist(name string, users []hatypes.User) *hatypes.Userlist {\n\tuserlist := &hatypes.Userlist{\n\t\tName:  name,\n\t\tUsers: users,\n\t}\n\tc.userlists = append(c.userlists, userlist)\n\tsort.Slice(c.userlists, func(i, j int) bool {\n\t\treturn c.userlists[i].Name < c.userlists[j].Name\n\t})\n\treturn userlist\n}\n\nfunc (c *config) FindUserlist(name string) *hatypes.Userlist {\n\treturn nil\n}\n\nfunc (c *config) FrontendGroup() *hatypes.FrontendGroup {\n\treturn c.fgroup\n}\n\nfunc (c *config) BuildFrontendGroup() error {\n\t\/\/ tested thanks to instance_test templating tests\n\t\/\/ ideas to make a nice test or a nice refactor are welcome\n\tif len(c.hosts) == 0 {\n\t\treturn fmt.Errorf(\"cannot create frontends without hosts\")\n\t}\n\tfrontends, sslpassthrough := hatypes.BuildRawFrontends(c.hosts)\n\tfgroupMaps := hatypes.CreateMaps()\n\tfgroup := &hatypes.FrontendGroup{\n\t\tFrontends:         frontends,\n\t\tHasSSLPassthrough: len(sslpassthrough) > 0,\n\t\tMaps:              fgroupMaps,\n\t\tHTTPFrontsMap:     fgroupMaps.AddMap(c.mapsDir + \"\/_global_http_front.map\"),\n\t\tHTTPRootRedirMap:  fgroupMaps.AddMap(c.mapsDir + \"\/_global_http_root_redir.map\"),\n\t\tHTTPSRedirMap:     fgroupMaps.AddMap(c.mapsDir + \"\/_global_https_redir.map\"),\n\t\tSSLPassthroughMap: fgroupMaps.AddMap(c.mapsDir + \"\/_global_sslpassthrough.map\"),\n\t}\n\tif fgroup.HasTCPProxy() {\n\t\t\/\/ More than one HAProxy's frontend or bind, or using ssl-passthrough config,\n\t\t\/\/ so need a `mode tcp` frontend with `inspect-delay` and `req.ssl_sni`\n\t\tvar i int\n\t\tfor _, frontend := range frontends {\n\t\t\tfor _, bind := range frontend.Binds {\n\t\t\t\ti++\n\t\t\t\tbindName := fmt.Sprintf(\"_socket%03d\", i)\n\t\t\t\tif len(bind.Hosts) == 1 {\n\t\t\t\t\tbind.TLS.TLSCert = c.defaultX509Cert\n\t\t\t\t\tbind.TLS.TLSCertDir = bind.Hosts[0].TLS.TLSFilename\n\t\t\t\t} else {\n\t\t\t\t\tx509dir, err := c.createCertsDir(bindName, bind.Hosts)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tbind.TLS.TLSCert = c.defaultX509Cert\n\t\t\t\t\tbind.TLS.TLSCertDir = x509dir\n\t\t\t\t}\n\t\t\t\tbind.Name = bindName\n\t\t\t\tbind.Socket = fmt.Sprintf(\"unix@\/var\/run\/%s.sock\", bindName)\n\t\t\t\tbind.AcceptProxy = true\n\t\t\t}\n\t\t}\n\t} else {\n\t\t\/\/ One single HAProxy's frontend and bind\n\t\tbind := frontends[0].Binds[0]\n\t\tbind.Name = \"_public\"\n\t\tbind.Socket = \":443\"\n\t\tif len(bind.Hosts) == 1 {\n\t\t\tbind.TLS.TLSCert = c.defaultX509Cert\n\t\t\tbind.TLS.TLSCertDir = bind.Hosts[0].TLS.TLSFilename\n\t\t} else {\n\t\t\tx509dir, err := c.createCertsDir(bind.Name, bind.Hosts)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tfrontends[0].Binds[0].TLS.TLSCert = c.defaultX509Cert\n\t\t\tfrontends[0].Binds[0].TLS.TLSCertDir = x509dir\n\t\t}\n\t}\n\tfor _, frontend := range frontends {\n\t\tmapsPrefix := c.mapsDir + \"\/\" + frontend.Name\n\t\tfrontend.Maps = hatypes.CreateMaps()\n\t\tfrontend.HostBackendsMap = frontend.Maps.AddMap(mapsPrefix + \"_host.map\")\n\t\tfrontend.RootRedirMap = frontend.Maps.AddMap(mapsPrefix + \"_root_redir.map\")\n\t\tfrontend.SNIBackendsMap = frontend.Maps.AddMap(mapsPrefix + \"_sni.map\")\n\t\tfrontend.TLSInvalidCrtErrorList = frontend.Maps.AddMap(mapsPrefix + \"_inv_crt.list\")\n\t\tfrontend.TLSInvalidCrtErrorPagesMap = frontend.Maps.AddMap(mapsPrefix + \"_inv_crt_redir.map\")\n\t\tfrontend.TLSNoCrtErrorList = frontend.Maps.AddMap(mapsPrefix + \"_no_crt.list\")\n\t\tfrontend.TLSNoCrtErrorPagesMap = frontend.Maps.AddMap(mapsPrefix + \"_no_crt_redir.map\")\n\t\tfrontend.VarNamespaceMap = frontend.Maps.AddMap(mapsPrefix + \"_k8s_ns.map\")\n\t\tfor _, bind := range frontend.Binds {\n\t\t\tbind.Maps = hatypes.CreateMaps()\n\t\t\tbind.UseServerList = bind.Maps.AddMap(c.mapsDir + \"\/\" + bind.Name + \".list\")\n\t\t}\n\t}\n\t\/\/ Some maps use yes\/no answers instead of a list with found\/missing keys\n\t\/\/ This approach avoid overlap:\n\t\/\/  1. match with path_beg\/map_beg, \/path has a feature and a declared \/path\/sub doesn't have\n\t\/\/  2. *.host.domain wildcard\/alias\/alias-regex has a feature and a declared sub.host.domain doesn't have\n\tyesno := map[bool]string{true: \"yes\", false: \"no\"}\n\tfor _, sslpassHost := range sslpassthrough {\n\t\trootPath := sslpassHost.FindPath(\"\/\")\n\t\tif rootPath == nil {\n\t\t\treturn fmt.Errorf(\"missing root path on host %s\", sslpassHost.Hostname)\n\t\t}\n\t\tfgroup.SSLPassthroughMap.AppendHostname(sslpassHost.Hostname, rootPath.BackendID)\n\t\tfgroup.HTTPSRedirMap.AppendHostname(sslpassHost.Hostname+\"\/\", yesno[sslpassHost.HTTPPassthroughBackend == nil])\n\t\tif sslpassHost.HTTPPassthroughBackend != nil {\n\t\t\tfgroup.HTTPFrontsMap.AppendHostname(sslpassHost.Hostname+\"\/\", sslpassHost.HTTPPassthroughBackend.ID)\n\t\t}\n\t}\n\tfor _, f := range frontends {\n\t\tfor _, host := range f.Hosts {\n\t\t\tfor _, path := range host.Paths {\n\t\t\t\t\/\/ TODO use only root path if all uri has the same conf\n\t\t\t\tfgroup.HTTPSRedirMap.AppendHostname(host.Hostname+path.Path, yesno[path.Backend.SSLRedirect])\n\t\t\t\tbase := host.Hostname + path.Path\n\t\t\t\tvar aliasName, aliasRegex string\n\t\t\t\t\/\/ TODO warn in logs about ignoring alias name due to hostname colision\n\t\t\t\tif host.Alias.AliasName != \"\" && c.FindHost(host.Alias.AliasName) == nil {\n\t\t\t\t\taliasName = host.Alias.AliasName + path.Path\n\t\t\t\t}\n\t\t\t\tif host.Alias.AliasRegex != \"\" {\n\t\t\t\t\taliasRegex = host.Alias.AliasRegex + path.Path\n\t\t\t\t}\n\t\t\t\tback := path.BackendID\n\t\t\t\tif host.HasTLSAuth() {\n\t\t\t\t\tf.SNIBackendsMap.AppendHostname(base, back)\n\t\t\t\t\tf.SNIBackendsMap.AppendAliasName(aliasName, back)\n\t\t\t\t\tf.SNIBackendsMap.AppendAliasRegex(aliasRegex, back)\n\t\t\t\t\tpath.Backend.SSL.HasTLSAuth = true\n\t\t\t\t} else {\n\t\t\t\t\tf.HostBackendsMap.AppendHostname(base, back)\n\t\t\t\t\tf.HostBackendsMap.AppendAliasName(aliasName, back)\n\t\t\t\t\tf.HostBackendsMap.AppendAliasRegex(aliasRegex, back)\n\t\t\t\t}\n\t\t\t\tif !path.Backend.SSLRedirect {\n\t\t\t\t\tfgroup.HTTPFrontsMap.AppendHostname(base, back)\n\t\t\t\t}\n\t\t\t\tvar ns string\n\t\t\t\tif host.VarNamespace {\n\t\t\t\t\tns = path.Backend.Namespace\n\t\t\t\t} else {\n\t\t\t\t\tns = \"-\"\n\t\t\t\t}\n\t\t\t\tf.VarNamespaceMap.AppendHostname(base, ns)\n\t\t\t}\n\t\t\tif host.HasTLSAuth() {\n\t\t\t\tf.TLSInvalidCrtErrorList.AppendHostname(host.Hostname, \"\")\n\t\t\t\tif !host.TLS.CAVerifyOptional {\n\t\t\t\t\tf.TLSNoCrtErrorList.AppendHostname(host.Hostname, \"\")\n\t\t\t\t}\n\t\t\t\tpage := host.TLS.CAErrorPage\n\t\t\t\tif page != \"\" {\n\t\t\t\t\tf.TLSInvalidCrtErrorPagesMap.AppendHostname(host.Hostname, page)\n\t\t\t\t\tif !host.TLS.CAVerifyOptional {\n\t\t\t\t\t\tf.TLSNoCrtErrorPagesMap.AppendHostname(host.Hostname, page)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/ TODO wildcard\/alias\/alias-regex hostname can overlap\n\t\t\t\/\/ a configured domain which doesn't have rootRedirect\n\t\t\tif host.RootRedirect != \"\" {\n\t\t\t\tfgroup.HTTPRootRedirMap.AppendHostname(host.Hostname, host.RootRedirect)\n\t\t\t\tf.RootRedirMap.AppendHostname(host.Hostname, host.RootRedirect)\n\t\t\t}\n\t\t}\n\t\tfor _, bind := range f.Binds {\n\t\t\tfor _, host := range bind.Hosts {\n\t\t\t\tbind.UseServerList.AppendHostname(host.Hostname, \"\")\n\t\t\t}\n\t\t}\n\t}\n\tif err := writeMaps(fgroup.Maps, c.mapsTemplate); err != nil {\n\t\treturn err\n\t}\n\tfor _, f := range frontends {\n\t\tif err := writeMaps(f.Maps, c.mapsTemplate); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor _, bind := range f.Binds {\n\t\t\tif err := writeMaps(bind.Maps, c.mapsTemplate); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\tc.fgroup = fgroup\n\treturn nil\n}\n\nfunc writeMaps(maps *hatypes.HostsMaps, template *template.Config) error {\n\tfor _, hmap := range maps.Items {\n\t\tif err := template.WriteOutput(hmap.Match, hmap.MatchFile); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif len(hmap.Regex) > 0 {\n\t\t\tif err := template.WriteOutput(hmap.Regex, hmap.RegexFile); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (c *config) createCertsDir(bindName string, hosts []*hatypes.Host) (string, error) {\n\tcerts := make([]string, 0, len(hosts))\n\tadded := map[string]bool{}\n\tfor _, host := range hosts {\n\t\tfilename := host.TLS.TLSFilename\n\t\tif filename != \"\" && !added[filename] && filename != c.defaultX509Cert {\n\t\t\tcerts = append(certs, host.TLS.TLSFilename)\n\t\t\tadded[filename] = true\n\t\t}\n\t}\n\tif len(certs) == 0 {\n\t\treturn \"\", nil\n\t}\n\treturn c.bindUtils.CreateX509CertsDir(bindName, certs)\n}\n\nfunc (c *config) DefaultHost() *hatypes.Host {\n\treturn c.defaultHost\n}\n\nfunc (c *config) DefaultBackend() *hatypes.Backend {\n\treturn c.defaultBackend\n}\n\nfunc (c *config) Global() *hatypes.Global {\n\treturn c.global\n}\n\nfunc (c *config) Hosts() []*hatypes.Host {\n\treturn c.hosts\n}\n\nfunc (c *config) Backends() []*hatypes.Backend {\n\treturn c.backends\n}\n\nfunc (c *config) Userlists() []*hatypes.Userlist {\n\treturn c.userlists\n}\n\nfunc (c *config) Equals(other Config) bool {\n\tc2, ok := other.(*config)\n\tif !ok {\n\t\treturn false\n\t}\n\treturn reflect.DeepEqual(c, c2)\n}\n","avg_line_length":30.220657277,"max_line_length":113,"alphanum_fraction":0.6998601833,"licenses":["Apache-2.0"],"repository_name":"gavinbunney\/haproxy-ingress","path":"pkg\/haproxy\/config.go","size":12874,"lang":"GO"}
{"content":"# Install script for directory: \/Users\/admin\/cef\/tests\/gtest\n\n# Set the install prefix\nif(NOT DEFINED CMAKE_INSTALL_PREFIX)\n  set(CMAKE_INSTALL_PREFIX \"\/usr\/local\")\nendif()\nstring(REGEX REPLACE \"\/$\" \"\" CMAKE_INSTALL_PREFIX \"${CMAKE_INSTALL_PREFIX}\")\n\n# Set the install configuration name.\nif(NOT DEFINED CMAKE_INSTALL_CONFIG_NAME)\n  if(BUILD_TYPE)\n    string(REGEX REPLACE \"^[^A-Za-z0-9_]+\" \"\"\n           CMAKE_INSTALL_CONFIG_NAME \"${BUILD_TYPE}\")\n  else()\n    set(CMAKE_INSTALL_CONFIG_NAME \"Release\")\n  endif()\n  message(STATUS \"Install configuration: \\\"${CMAKE_INSTALL_CONFIG_NAME}\\\"\")\nendif()\n\n# Set the component getting installed.\nif(NOT CMAKE_INSTALL_COMPONENT)\n  if(COMPONENT)\n    message(STATUS \"Install component: \\\"${COMPONENT}\\\"\")\n    set(CMAKE_INSTALL_COMPONENT \"${COMPONENT}\")\n  else()\n    set(CMAKE_INSTALL_COMPONENT)\n  endif()\nendif()\n\n# Is this installation the result of a crosscompile?\nif(NOT DEFINED CMAKE_CROSSCOMPILING)\n  set(CMAKE_CROSSCOMPILING \"FALSE\")\nendif()\n\n","avg_line_length":28.1714285714,"max_line_length":76,"alphanum_fraction":0.7393509128,"licenses":["BSD-3-Clause"],"repository_name":"glenchiu1\/JanisonReplayMacOS-Version","path":"tests\/gtest\/cmake_install.cmake","size":986,"lang":"CMake"}
{"content":"module GraphQL\n  module SchemaComparator\n    module Diff\n      class Argument\n        def initialize(type, field, old_arg, new_arg)\n          @type = type\n          @field = field\n\n          @old_arg = old_arg\n          @new_arg = new_arg\n        end\n\n        def diff\n          changes = []\n\n          if old_arg.description != new_arg.description\n            changes << Changes::FieldArgumentDescriptionChanged.new(type, field, old_arg, new_arg)\n          end\n\n          if old_arg.default_value != new_arg.default_value\n            changes << Changes::FieldArgumentDefaultChanged.new(type, field, old_arg, new_arg)\n          end\n\n          if old_arg.type != new_arg.type\n            changes << Changes::FieldArgumentTypeChanged.new(type, field, old_arg, new_arg)\n          end\n\n          # TODO directives\n\n          changes\n        end\n\n        private\n\n        attr_reader(\n          :type,\n          :field,\n          :new_arg,\n          :old_arg\n        )\n      end\n    end\n  end\nend\n","avg_line_length":22.0444444444,"max_line_length":98,"alphanum_fraction":0.5534274194,"licenses":["MIT"],"repository_name":"StanBoyet\/graphql-schema_comparator","path":"lib\/graphql\/schema_comparator\/diff\/argument.rb","size":992,"lang":"Ruby"}
{"content":"function Get-AbrOntapNetworkFailoverGroup {\n    <#\n    .SYNOPSIS\n    Used by As Built Report to retrieve NetApp ONTAP Failover Group information from the Cluster Management Network\n    .DESCRIPTION\n\n    .NOTES\n        Version:        0.6.2\n        Author:         Jonathan Colon\n        Twitter:        @jcolonfzenpr\n        Github:         rebelinux\n    .EXAMPLE\n\n    .LINK\n\n    #>\n    [CmdletBinding()]\n    param (\n    )\n\n    begin {\n        Write-PscriboMessage \"Collecting ONTAP Failover Group information.\"\n    }\n\n    process {\n        $FG = Get-NcNetFailoverGroup -Controller $Array\n        $FGObj = @()\n        if ($FG) {\n            foreach ($Item in $FG) {\n                $inObj = [ordered] @{\n                    'Name' = $Item.FailoverGroup\n                    'Vserver' = $Item.Vserver\n                    'Target' = $Item.Target\n                }\n                $FGObj += [pscustomobject]$inobj\n            }\n\n            $TableParams = @{\n                Name = \"Network Failover Group - $($ClusterInfo.ClusterName)\"\n                List = $false\n                ColumnWidths = 30, 30, 40\n            }\n            if ($Report.ShowTableCaptions) {\n                $TableParams['Caption'] = \"- $($TableParams.Name)\"\n            }\n            $FGObj | Table @TableParams\n        }\n    }\n\n    end {}\n\n}","avg_line_length":25.2884615385,"max_line_length":115,"alphanum_fraction":0.4859315589,"licenses":["MIT"],"repository_name":"AsBuiltReport\/AsBuiltReport.NetApp.ONTAP","path":"Src\/Private\/Get-AbrOntapNetworkFailoverGroup.ps1","size":1315,"lang":"PowerShell"}
{"content":"\n#-----------------------------------------------------------------------------\n# Options\n#-----------------------------------------------------------------------------\nif(WIN32)\n  if(NOT DEFINED VRPN_USE_OpenHaptics)\n    set(VRPN_USE_OpenHaptics ${iMSTK_USE_OpenHaptics})\n  endif()\nelse()\n  set(VRPN_USE_OpenHaptics OFF)\nendif()\n\n#-----------------------------------------------------------------------------\n# Dependencies\n#-----------------------------------------------------------------------------\nset(VRPN_DEPENDENCIES \"LibNiFalcon\")\nif(WIN32)\n  list(APPEND VRPN_DEPENDENCIES \"Libusb\")\n  list(APPEND VRPN_DEPENDENCIES \"FTD2XX\")\nendif(WIN32)\nif(VRPN_USE_OpenHaptics)\n  list(APPEND VRPN_DEPENDENCIES \"OpenHaptics\")\nendif()\n\n#-----------------------------------------------------------------------------\n# Add External Project\n#-----------------------------------------------------------------------------\n\n# Download options\nif(NOT DEFINED iMSTK_VRPN_GIT_SHA)\n  set(iMSTK_VRPN_GIT_SHA \"7a2845e4b1be2707ccb67dd1d388fb22a766e8f7\") # vrpn-imstk-additions\nendif()\nif(NOT DEFINED iMSTK_VRPN_GIT_REPOSITORY)\n  set(iMSTK_VRPN_GIT_REPOSITORY \"https:\/\/gitlab.kitware.com\/iMSTK\/vrpn.git\")\nendif()\n\ninclude(imstkAddExternalProject)\nimstk_add_external_project( VRPN\n  GIT_REPOSITORY ${iMSTK_VRPN_GIT_REPOSITORY}\n  GIT_TAG ${iMSTK_VRPN_GIT_SHA}\n  # Cannot get a zip as vrpn uses submodules which are not pulled into the zip\n  CMAKE_CACHE_ARGS\n    -DBUILD_TESTING:BOOL=OFF\n    -DVRPN_SUBPROJECT_BUILD:BOOL=ON\n    -DVRPN_BUILD_CLIENTS:BOOL=OFF\n    -DVRPN_BUILD_CLIENT_LIBRARY:BOOL=ON\n    -DVRPN_BUILD_SERVER_LIBRARY:BOOL=ON\n    -DVRPN_INSTALL:BOOL=ON\n    -DVRPN_BUILD_PYTHON:BOOL=OFF\n    -DVRPN_USE_GPM_MOUSE:BOOL=OFF\n    -DVRPN_USE_LIBUSB_1_0:BOOL=ON\n    -DVRPN_USE_HID:BOOL=ON\n    -DVRPN_USE_LIBNIFALCON:BOOL=OFF\n    -DVRPN_BUILD_SERVERS:BOOL=ON\n    -DVRPN_USE_PHANTOM_SERVER:BOOL=${VRPN_USE_OPENHAPTICS}\n    -DVRPN_USE_HDAPI:BOOL=${VRPN_USE_OPENHAPTICS}\n    -DOPENHAPTICS_ROOT_DIR:PATH=${OPENHAPTICS_ROOT_DIR}\n  DEPENDENCIES ${VRPN_DEPENDENCIES}\n  RELATIVE_INCLUDE_PATH \"\"\n  #VERBOSE\n)\n\nExternalProject_Message(\"VRPN\" \"VRPN: Phantom Omni support [${VRPN_USE_OpenHaptics}]\")\n","avg_line_length":33.859375,"max_line_length":91,"alphanum_fraction":0.6165205353,"licenses":["Apache-2.0"],"repository_name":"liangxijie\/iMSTK","path":"CMake\/External\/External_VRPN.cmake","size":2167,"lang":"CMake"}
{"content":"package org.sailcbi.APIServer.Entities.JsFacades.Stripe\n\nimport play.api.libs.json.{JsValue, Json}\n\ncase class ChargeMetadata(\n\tcloseId: Option[String],\n\torderId: Option[String],\n\ttoken: Option[String],\n\tcbiInstance: Option[String],\n\trefunds: Option[String]\n)\n\nobject ChargeMetadata {\n\timplicit val chargeJSONFormat = Json.format[ChargeMetadata]\n\n\tdef apply(v: JsValue): ChargeMetadata = v.as[ChargeMetadata]\n}\n","avg_line_length":22.8333333333,"max_line_length":61,"alphanum_fraction":0.7761557178,"licenses":["MIT"],"repository_name":"community-boating\/cbidb-api","path":"app\/org\/sailcbi\/APIServer\/Entities\/JsFacades\/Stripe\/ChargeMetadata.scala","size":411,"lang":"Scala"}
{"content":"# AUTOGENERATED FILE\nFROM balenalib\/intel-nuc-alpine:3.14-build\n\n# remove several traces of python\nRUN apk del python*\n\n# http:\/\/bugs.python.org\/issue19846\n# > At the moment, setting \"LANG=C\" on a Linux system *fundamentally breaks Python 3*, and that's not OK.\nENV LANG C.UTF-8\n\n# key 63C7CC90: public key \"Simon McVittie <smcv@pseudorandom.co.uk>\" imported\n# key 3372DCFA: public key \"Donald Stufft (dstufft) <donald@stufft.io>\" imported\nRUN gpg --keyserver keyring.debian.org --recv-keys 4DE8FF2A63C7CC90 \\\n\t&& gpg --keyserver keyserver.ubuntu.com --recv-key 6E3CBCE93372DCFA \\\n\t&& gpg --keyserver keyserver.ubuntu.com --recv-keys 0x52a43a1e4b77b059\n\n# point Python at a system-provided certificate database. Otherwise, we might hit CERTIFICATE_VERIFY_FAILED.\n# https:\/\/www.python.org\/dev\/peps\/pep-0476\/#trust-database\nENV SSL_CERT_FILE \/etc\/ssl\/certs\/ca-certificates.crt\n\nENV PYTHON_VERSION 3.6.15\n\n# if this is called \"PIP_VERSION\", pip explodes with \"ValueError: invalid truth value '<VERSION>'\"\nENV PYTHON_PIP_VERSION 21.2.4\n\nENV SETUPTOOLS_VERSION 58.0.0\n\nRUN set -x \\\n\t&& curl -SLO \"http:\/\/resin-packages.s3.amazonaws.com\/python\/v$PYTHON_VERSION\/Python-$PYTHON_VERSION.linux-alpine-amd64-libffi3.3.tar.gz\" \\\n\t&& echo \"b77741a57a57f5737b58926a08aa47034f7a3a78ce1183124a315f6f5fed41f3  Python-$PYTHON_VERSION.linux-alpine-amd64-libffi3.3.tar.gz\" | sha256sum -c - \\\n\t&& tar -xzf \"Python-$PYTHON_VERSION.linux-alpine-amd64-libffi3.3.tar.gz\" --strip-components=1 \\\n\t&& rm -rf \"Python-$PYTHON_VERSION.linux-alpine-amd64-libffi3.3.tar.gz\" \\\n\t&& if [ ! -e \/usr\/local\/bin\/pip3 ]; then : \\\n\t\t&& curl -SLO \"https:\/\/raw.githubusercontent.com\/pypa\/get-pip\/430ba37776ae2ad89f794c7a43b90dc23bac334c\/get-pip.py\" \\\n\t\t&& echo \"19dae841a150c86e2a09d475b5eb0602861f2a5b7761ec268049a662dbd2bd0c  get-pip.py\" | sha256sum -c - \\\n\t\t&& python3 get-pip.py \\\n\t\t&& rm get-pip.py \\\n\t; fi \\\n\t&& pip3 install --no-cache-dir --upgrade --force-reinstall pip==\"$PYTHON_PIP_VERSION\" setuptools==\"$SETUPTOOLS_VERSION\" \\\n\t&& find \/usr\/local \\\n\t\t\\( -type d -a -name test -o -name tests \\) \\\n\t\t-o \\( -type f -a -name '*.pyc' -o -name '*.pyo' \\) \\\n\t\t-exec rm -rf '{}' + \\\n\t&& cd \/ \\\n\t&& rm -rf \/usr\/src\/python ~\/.cache\n\n# install \"virtualenv\", since the vast majority of users of this image will want it\nRUN pip3 install --no-cache-dir virtualenv\n\nENV PYTHON_DBUS_VERSION 1.2.18\n\n# install dbus-python dependencies \nRUN apk add --no-cache \\\n\t\tdbus-dev \\\n\t\tdbus-glib-dev\n\n# install dbus-python\nRUN set -x \\\n\t&& mkdir -p \/usr\/src\/dbus-python \\\n\t&& curl -SL \"http:\/\/dbus.freedesktop.org\/releases\/dbus-python\/dbus-python-$PYTHON_DBUS_VERSION.tar.gz\" -o dbus-python.tar.gz \\\n\t&& curl -SL \"http:\/\/dbus.freedesktop.org\/releases\/dbus-python\/dbus-python-$PYTHON_DBUS_VERSION.tar.gz.asc\" -o dbus-python.tar.gz.asc \\\n\t&& gpg --verify dbus-python.tar.gz.asc \\\n\t&& tar -xzC \/usr\/src\/dbus-python --strip-components=1 -f dbus-python.tar.gz \\\n\t&& rm dbus-python.tar.gz* \\\n\t&& cd \/usr\/src\/dbus-python \\\n\t&& PYTHON_VERSION=$(expr match \"$PYTHON_VERSION\" '\\([0-9]*\\.[0-9]*\\)') .\/configure \\\n\t&& make -j$(nproc) \\\n\t&& make install -j$(nproc) \\\n\t&& cd \/ \\\n\t&& rm -rf \/usr\/src\/dbus-python\n\n# make some useful symlinks that are expected to exist\nRUN cd \/usr\/local\/bin \\\n\t&& ln -sf pip3 pip \\\n\t&& { [ -e easy_install ] || ln -s easy_install-* easy_install; } \\\n\t&& ln -sf idle3 idle \\\n\t&& ln -sf pydoc3 pydoc \\\n\t&& ln -sf python3 python \\\n\t&& ln -sf python3-config python-config\n\nCMD [\"echo\",\"'No CMD command was set in Dockerfile! Details about CMD command could be found in Dockerfile Guide section in our Docs. Here's the link: https:\/\/balena.io\/docs\"]\n\n RUN curl -SLO \"https:\/\/raw.githubusercontent.com\/balena-io-library\/base-images\/8accad6af708fca7271c5c65f18a86782e19f877\/scripts\/assets\/tests\/test-stack@python.sh\" \\\n  && echo \"Running test-stack@python\" \\\n  && chmod +x test-stack@python.sh \\\n  && bash test-stack@python.sh \\\n  && rm -rf test-stack@python.sh \n\nRUN [ ! -d \/.balena\/messages ] && mkdir -p \/.balena\/messages; echo $'Here are a few details about this Docker image (For more information please visit https:\/\/www.balena.io\/docs\/reference\/base-images\/base-images\/): \\nArchitecture: Intel 64-bit (x86-64) \\nOS: Alpine Linux 3.14 \\nVariant: build variant \\nDefault variable(s): UDEV=off \\nThe following software stack is preinstalled: \\nPython v3.6.15, Pip v21.2.4, Setuptools v58.0.0 \\nExtra features: \\n- Easy way to install packages with `install_packages <package-name>` command \\n- Run anywhere with cross-build feature  (for ARM only) \\n- Keep the container idling with `balena-idle` command \\n- Show base image details with `balena-info` command' > \/.balena\/messages\/image-info\n\nRUN echo $'#!\/bin\/bash\\nbalena-info\\nbusybox ln -sf \/bin\/busybox \/bin\/sh\\n\/bin\/sh \"$@\"' > \/bin\/sh-shim \\\n\t&& chmod +x \/bin\/sh-shim \\\n\t&& ln -f \/bin\/sh \/bin\/sh.real \\\n\t&& ln -f \/bin\/sh-shim \/bin\/sh","avg_line_length":51.5106382979,"max_line_length":731,"alphanum_fraction":0.7133415944,"licenses":["Apache-2.0"],"repository_name":"balena-io-library\/base-images","path":"balena-base-images\/python\/intel-nuc\/alpine\/3.14\/3.6.15\/build\/Dockerfile","size":4842,"lang":"Dockerfile"}
{"content":"-- g\n\nprint(\"Loading...\")\ngame.StarterGui:SetCore(\"SendNotification\", {\n    Title = \"ItachiPvPUchiha YBA Script\";\n    Text = \"Loading...\",\n    Duration = 5\n}) \nlocal library = {}\n\nlibrary.__index = library\n\nfunction library:Tween(asset, info, thing)\n    game:GetService(\"TweenService\"):Create(asset, info, thing):Play()\nend\n\nfunction library:DropInfo(asset, info, tbl)\n    if not tbl.debounce then\n        tbl.debounce = true\n\n        local newText = asset:FindFirstChild(\"Text\"):Clone()\n        newText.Parent = asset\n        newText.Name = \"Info\"\n        newText.TextTransparency = 1\n        newText.TextSize = 24\n        newText.Position = UDim2.new(asset:FindFirstChild(\"Text\").Position.X.Scale, asset:FindFirstChild(\"Text\").Position.X.Offset, ((asset:FindFirstChild(\"Text\").Position.Y.Scale \/ 2) * 3), asset:FindFirstChild(\"Text\").Position.Y.Offset)\n        newText.Text = info\n\n        local textAsset = asset:FindFirstChild(\"Text\")\n\n        library:Tween(asset, TweenInfo.new(0.5), {Size = UDim2.new(asset.Size.X.Scale, asset.Size.X.Offset, (asset.Size.Y.Scale * 2), asset.Size.Y.Offset)})\n        library:Tween(textAsset, TweenInfo.new(0.5), {Position = UDim2.new(textAsset.Position.X.Scale, textAsset.Position.X.Offset, (textAsset.Position.Y.Scale \/ 2), textAsset.Position.Y.Offset), Size = UDim2.new(textAsset.Size.X.Scale, textAsset.Size.X.Offset, (textAsset.Size.Y.Scale \/ 2), textAsset.Size.Y.Offset)})\n        library:Tween(asset[\"Down\"], TweenInfo.new(0.3), {Rotation = 180, Position = UDim2.new(asset[\"Down\"].Position.X.Scale, asset[\"Down\"].Position.X.Offset, (asset[\"Down\"].Position.Y.Scale \/ 2), asset[\"Down\"].Position.Y.Offset)})\n        wait(0.5)\n\n        library:Tween(newText, TweenInfo.new(0.5), {TextTransparency = 0})\n\n        wait(0.5)\n\n        tbl.debounce = false\n        tbl.showingInfo = true\n    end\nend\n\nfunction library:RetractInfo(asset, tbl)\n    if not tbl.debounce then\n        tbl.debounce = true\n        library:Tween(asset[\"Info\"], TweenInfo.new(0.25), {TextTransparency = 1})\n        library:Tween(asset[\"Down\"], TweenInfo.new(0.3), {Rotation = 0, Position = UDim2.new(asset[\"Down\"].Position.X.Scale, asset[\"Down\"].Position.X.Offset, (asset[\"Down\"].Position.Y.Scale * 2), asset[\"Down\"].Position.Y.Offset)})\n        library:Tween(asset, TweenInfo.new(0.5), {Size = UDim2.new(asset.Size.X.Scale, asset.Size.X.Offset, (asset.Size.Y.Scale \/ 2), asset.Size.Y.Offset)})\t\n\n        local textAsset = asset:FindFirstChild(\"Text\")\n        library:Tween(textAsset, TweenInfo.new(0.5), {Position = UDim2.new(textAsset.Position.X.Scale, textAsset.Position.X.Offset, (textAsset.Position.Y.Scale * 2), textAsset.Position.Y.Offset), Size = UDim2.new(textAsset.Size.X.Scale, textAsset.Size.X.Offset, (textAsset.Size.Y.Scale * 2), textAsset.Size.Y.Offset)})\n\n        wait(0.5)\n        asset[\"Info\"]:Destroy()\n        tbl.debounce = false\n        tbl.showingInfo = false\n    end\nend\n\nfunction library:RoundNumber(num, numDecimalPlaces)\n    return tonumber(string.format(\"%.\" .. (numDecimalPlaces or 0) .. \"f\", num))\nend\n\nfunction library:Ripple(ui, button, x, y, tbl)\n    --stole this from my old lib\n    --[[\n    spawn(function()\n        local circle = ui.Circle:Clone()\n        circle.Parent = button;\n        local pos = UDim2.new(0,x-button.AbsolutePosition.X,0,y-button.AbsolutePosition.Y-36)\n        circle.Position = pos\n        circle.Size = UDim2.new(0,1,0,1)\n        circle.ImageTransparency = .5\n\n        local goal = {}\n        goal.Size = UDim2.new((0.175)*7, 0, ((tbl and tbl.showingInfo == false and 2) or (tbl and tbl.showingInfo == true and 1))*7, 0)\n        goal.ImageTransparency = 1\n\n        local tween = game:GetService(\"TweenService\"):Create(circle, TweenInfo.new(0.7,Enum.EasingStyle.Sine,Enum.EasingDirection.Out), goal)\n        tween:Play()\n        tween.Completed:Wait()\n        circle:Destroy();\n    end)--]]\n\n    -- this is fresh code from a yt vid ik\n\n    if x and y then\n        spawn(function()\n            local c = ui.Circle:Clone()\n            c.Parent = button;\n\n            c.ImageTransparency = 0.6\n\n            local x, y = (x-button.AbsolutePosition.X), (y-button.AbsolutePosition.Y-36)\n            c.Position = UDim2.new(0, x, 0, y)\n            local len, size = 0.75, nil\n            if button.AbsoluteSize.X >= button.AbsoluteSize.Y then\n                size = (button.AbsoluteSize.X * 1.5)\n            else\n                size = (button.AbsoluteSize.Y * 1.5)\n            end\n            local tween = {}\n            tween.Size = UDim2.new(0, size, 0, size)\n            tween.Position = UDim2.new(0.5, (-size \/ 2), 0.5, (-size \/ 2))\n            tween.ImageTransparency = 1\n\n            local newTween = game:GetService(\"TweenService\"):Create(c, TweenInfo.new(len, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), tween)\n\n            newTween:Play()\n\n            newTween.Completed:Wait()\n\n            c:Destroy()\n        end)\n    end\nend\n\nfunction library.Create(title, titleUnder)\n    local lib = {}\n\n    lib.UI = game:GetObjects(\"rbxassetid:\/\/6849423853\")[1]\n    lib.UI.Parent = game.CoreGui\n\n    lib.Tabs = {}\n\n    lib.UI.Main.Left.UIName.Text = title\n    lib.UI.Main.Left.GameName.Text = titleUnder\n\n    local content, isReady = game.Players:GetUserThumbnailAsync(game.Players.LocalPlayer.UserId, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size48x48)\n    lib.UI.Main.Left.BottomLeft.Icon.Image = content\n    lib.UI.Main.Left.BottomLeft.PlayerName.Text = game.Players.LocalPlayer.Name\n\n    lib.Notifications = {}\n    lib.Notifications.Queue = {}\n    lib.Notifications.Current = nil\n\n    local MainFrame = lib.UI.Main\n\n    --Dragging\n    local dragging\n    local dragInput\n    local dragStart\n    local startPos\n\n    local function update(input)\n        local delta = input.Position - dragStart\n        game:GetService(\"TweenService\"):Create(MainFrame, TweenInfo.new(0.1), {Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)}):Play()\n    end\n\n    MainFrame.InputBegan:Connect(function(input)\n        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then\n            dragging = true\n            dragStart = input.Position\n            startPos = MainFrame.Position\n\n            input.Changed:Connect(function()\n                if input.UserInputState == Enum.UserInputState.End then\n                    dragging = false\n                end\n            end)\n        end\n    end)\n\n    MainFrame.InputChanged:Connect(function(input)\n        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then\n            dragInput = input\n        end\n    end)\n\n    game:GetService(\"UserInputService\").InputChanged:Connect(function(input)\n        if input == dragInput and dragging then\n            update(input)\n        end\n    end)\n\n    return setmetatable(lib, library)\nend\n\nfunction library:Tab(name, imageId)\n    local tab = {}\n\n    tab.Assets = {}\n\n    tab.Lib = self\n    tab.Tab = self.UI.Main.Left.Container.Template:Clone()\n    tab.Tab.Name = name\n    tab.Tab.TabName.Text = name\n    tab.Tab.Parent = self.UI.Main.Left.Container\n\n    if imageId then\n        tab.Tab.TabIcon.Image = \"rbxassetid:\/\/\" .. imageId\n    end\n\n    table.insert(self.Tabs, tab)\n\n    tab.Show = function()\n        tab.Tab.Visible = true\n    end\n\n    tab.Hide = function()\n        tab.Tab.Visible = false\n    end\n\n    tab.Fix = function()\n        self.UI.Main.Container.AutomaticCanvasSize = Enum.AutomaticSize.None\n        self.UI.Main.Container.AutomaticCanvasSize = Enum.AutomaticSize.Y\n    end\n\n    local totalAssets = 0\n    for i,v in pairs(self.Tabs) do\n        totalAssets = totalAssets + 1\n    end\n\n    if totalAssets == 1 then\n        -- first tab\n        delay(0.1, function()\n            for i,v in pairs(tab.Assets) do\n                if v then\n                    v.Show()\n                end\n            end\n            library:Tween(tab.Tab, TweenInfo.new(0.5), {BackgroundTransparency = 0})\n        end)\n    end\n\n    tab.Fix()\n\n    tab.Tab.MouseButton1Up:Connect(function()\n        for i,v in pairs(self.Tabs) do\n            library:Tween(v.Tab, TweenInfo.new(0.5), {BackgroundTransparency = 1})\n            for i,v in pairs(v.Assets) do\n                v.Hide()\n            end\n        end\n\n        for i,v in pairs(tab.Assets) do\n            v.Show()\n        end\n        tab.Fix()\n        library:Tween(tab.Tab, TweenInfo.new(0.5), {BackgroundTransparency = 0})\n    end)\n\n    tab.Show()\n\n    return setmetatable(tab, library)\nend\n\nfunction library:Button(text, info, callback)\n    local button = {}\n\n    button.callback = callback or function() end\n    button.debounce = false\n    button.showingInfo = false\n    button.button = self.Lib.UI.Main.Container.Button:Clone()\n    button.button.Parent = self.Lib.UI.Main.Container\n    button.button:FindFirstChild(\"Text\").Text = (text or \"No Text\")\n    button.button.Name = (text or \"No Text\")\n\n    button.Show = function()\n        button.button.Visible = true\n    end\n\n    button.Hide = function()\n        button.button.Visible = false\n    end\n\n    button.button.Down.MouseButton1Up:Connect(function()\n        if not button.showingInfo then\n            library:DropInfo(button.button, info, button)\n        else\n            library:RetractInfo(button.button, button)\n        end\n    end)\n\n    button.button.MouseButton1Up:Connect(function(x,y)\n        if not button.debounce then\n            library:Ripple(self.Lib.UI, button.button, x, y, button)\n            button.callback()\n        end\n    end)\n\n    table.insert(self.Assets, button)\n\n    return setmetatable(button, library)\nend\n\nfunction library:Toggle(text, info, state, callback)\n    local toggle = {}\n\n    toggle.callback = callback or function() end\n    toggle.debounce = false\n    toggle.showingInfo = false\n    toggle.state = state\n    toggle.toggle = self.Lib.UI.Main.Container.Toggle:Clone()\n    toggle.toggle.Parent = self.Lib.UI.Main.Container\n    toggle.toggle:FindFirstChild(\"Text\").Text = (text or \"No Text\")\n    toggle.toggle.Name = (text or \"No Text\")\n\n    toggle.Show = function()\n        toggle.toggle.Visible = true\n    end\n\n    toggle.Hide = function()\n        toggle.toggle.Visible = false\n    end\n\n    toggle.Refresh = function()\n        if toggle.state then\n            toggle.state = false\n            toggle.debounce = true\n            spawn(function()\n                toggle.callback(toggle.state)\n            end)\n            local circle = toggle.toggle.Whole.Inner\n            local newPosition = UDim2.new((circle.Position.X.Scale \/ 3), circle.Position.X.Offset, circle.Position.Y.Scale, circle.Position.Y.Offset)\n\n            library:Tween(circle, TweenInfo.new(0.2), {Position = newPosition})\n            library:Tween(circle.Parent, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(213, 213, 213)})\n\n            wait(0.3)\n            toggle.debounce = false\n        else \n            toggle.state = true\n            toggle.debounce = true\n            spawn(function()\n                toggle.callback(toggle.state)\n            end)\n            local circle = toggle.toggle.Whole.Inner\n            local newPosition = UDim2.new((circle.Position.X.Scale * 3), circle.Position.X.Offset, circle.Position.Y.Scale, circle.Position.Y.Offset)\n\n            library:Tween(circle, TweenInfo.new(0.2), {Position = newPosition})\n            library:Tween(circle.Parent, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(248, 86, 86)})\n\n            wait(0.3)\n            toggle.debounce = false\n        end\n    end\n\n    spawn(function()\n        if toggle.state then\n            toggle.debounce = true\n            local circle = toggle.toggle.Whole.Inner\n            local newPosition = UDim2.new((circle.Position.X.Scale * 3), circle.Position.X.Offset, circle.Position.Y.Scale, circle.Position.Y.Offset)\n\n            library:Tween(circle, TweenInfo.new(0.2), {Position = newPosition})\n            library:Tween(circle.Parent, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(248, 86, 86)})\n\n            wait(0.3)\n            toggle.debounce = false\n        end\n    end)\n\n    toggle.toggle.Down.MouseButton1Up:Connect(function()\n        if not toggle.showingInfo then\n            library:DropInfo(toggle.toggle, info, toggle)\n        else\n            library:RetractInfo(toggle.toggle, toggle)\n        end\n    end)\n\n    toggle.toggle.MouseButton1Up:Connect(function(x,y)\n        if not toggle.debounce then\n            library:Ripple(self.Lib.UI, toggle.toggle, x, y, toggle)\n            toggle.Refresh()\n        end\n    end)\n\n    local ran, failed = pcall(function()\n        toggle.callback(toggle.state)\n    end)\n\n    if ran then\n        print(\"Ran sucessfully.\")\n    else\n        print(\"Failed to run but no worries!\", failed)\n    end\n\n    table.insert(self.Assets, toggle)\n    return setmetatable(toggle, library)\nend\n\nfunction library:Seperator()\n    local seperator = {}\n\n    seperator.asset = self.Lib.UI.Main.Container.Seperator:Clone()\n    seperator.asset.Parent = self.Lib.UI.Main.Container\n\n    seperator.Show = function()\n        seperator.asset.Visible = true\n    end\n\n    seperator.Hide = function()\n        seperator.asset.Visible = false\n    end\n\n    table.insert(self.Assets, seperator)\n    return setmetatable(seperator, library)\nend\n\nfunction library:Slider(name, min, max, starting, callback)\n    local slider = {}\n\n    slider.callback = callback or function() end\n    slider.min = min or 1\n    slider.max = max or 100\n\n    slider.asset = self.Lib.UI.Main.Container.Slider:Clone()\n    slider.asset.Name = (name or \"None\")\n    slider.asset:FindFirstChild(\"Slider\").Text = (name or \"None\")\n    slider.asset.Parent = self.Lib.UI.Main.Container\n    slider.holdAsset = self.Lib.UI.Main.Container\n\n    slider.holdAsset = slider.asset.Holder.Holder.Circle\n\n    local mouse = game.Players.LocalPlayer:GetMouse()\n    local uis = game:GetService(\"UserInputService\")\n    local Value;\n\n    local bound = slider.holdAsset.Parent.Parent.AbsoluteSize.X\n    \n    function slider.Refresh(new, bool)\n        local pos = (bound * (new\/slider.max))\n\n        library:Tween(slider.holdAsset.Parent, TweenInfo.new(0.1), {Size = UDim2.new(0, pos, 1, 0)})\n\n        slider.asset.Percentage.Text = new\n        \n        if bool then\n            slider.callback(new)\n        end\n    end\n    \n    slider.Refresh(starting)\n    \n    slider.holdAsset.MouseButton1Down:Connect(function()\n        local Num = (((tonumber(slider.max) - tonumber(slider.min)) \/ bound) * slider.holdAsset.Parent.AbsoluteSize.X) + tonumber(slider.min)\n        local IsDecimal = select(2, math.modf(starting)) ~= 0\n        print(IsDecimal)\n        Value = (not IsDecimal and math.ceil(Num)) or (IsDecimal and library:RoundNumber(Num, 1)) or 0\n        pcall(function()\n            slider.callback(Value)\n        end)\n        library:Tween(slider.holdAsset.Parent, TweenInfo.new(0.1), {Size = UDim2.new(0, math.clamp(mouse.X - slider.holdAsset.Parent.AbsolutePosition.X, 0, bound), 1, 0)})\n        moveconnection = mouse.Move:Connect(function()\n            slider.asset.Percentage.Text = Value\n            local Num = (((tonumber(slider.max) - tonumber(slider.min)) \/ bound) * slider.holdAsset.Parent.AbsoluteSize.X) + tonumber(slider.min)\n            local IsDecimal = select(2, math.modf(starting)) ~= 0\n            Value = (not IsDecimal and math.ceil(Num)) or (IsDecimal and library:RoundNumber(Num, 1))\n            pcall(function()\n                slider.callback(Value)\n            end)\n            print((mouse.X - slider.holdAsset.Parent.AbsolutePosition.X))\n            library:Tween(slider.holdAsset.Parent, TweenInfo.new(0.1), {Size = UDim2.new(0, math.clamp(mouse.X - slider.holdAsset.Parent.AbsolutePosition.X, 0, bound), 1, 0)})\n        end)\n        releaseconnection = uis.InputEnded:Connect(function(Mouse)\n            if Mouse.UserInputType == Enum.UserInputType.MouseButton1 then\n                local Num = (((tonumber(slider.max) - tonumber(slider.min)) \/ bound) * slider.holdAsset.Parent.AbsoluteSize.X) + tonumber(slider.min)\n                local IsDecimal = select(2, math.modf(starting)) ~= 0\n                Value = (not IsDecimal and math.ceil(Num)) or (IsDecimal and library:RoundNumber(Num, 1)) \n                pcall(function()\n                    slider.callback(Value)\n                end)\n                library:Tween(slider.holdAsset.Parent, TweenInfo.new(0.1), {Size = UDim2.new(0, math.clamp(mouse.X - slider.holdAsset.Parent.AbsolutePosition.X, 0, bound), 1, 0)})\n                moveconnection:Disconnect()\n                releaseconnection:Disconnect()\n                \n                wait()\n                slider.Refresh(Value, true)\n            end\n        end)\n    end)\n    \n    slider.Show = function()\n        slider.asset.Visible = true\n    end\n\n    slider.Hide = function()\n        slider.asset.Visible = false\n    end\n\n    table.insert(self.Assets, slider)\n    return setmetatable(slider, library)\nend\n\nfunction library:Dropdown(name, list, callback)\n    local dropdown = {}\n\n    dropdown.table = list\n    dropdown.callback = callback or function() end\n\n    dropdown.debounce = false\n\n    dropdown.asset = self.Lib.UI.Main.Container.Dropdown:Clone()\n    dropdown.asset.Parent = self.Lib.UI.Main.Container\n\n    dropdown.assets = {}\n    dropdown.connections = {}\n\n    dropdown.asset:FindFirstChild(\"Text\").Text = dropdown.table[1]\n\n    function dropdown.Refresh()\n        if not table.find(dropdown.table, dropdown.asset:FindFirstChild(\"Text\").Text) then\n            dropdown.asset:FindFirstChild(\"Text\").Text = dropdown.table[1]\n        end\n    end\n\n    dropdown.showing = false\n\n    dropdown.asset.MouseButton1Up:Connect(function(x, y)\n        if not dropdown.debounce then\n            library:Ripple(self.Lib.UI, dropdown.asset, x, y, {[\"showingInfo\"] = false})\n            if #dropdown.assets < 1 then\n                dropdown.debounce = true\n                local passed = false\n                local num = 0\n                local assets = {}\n                for i,v in ipairs(dropdown.asset.Parent:GetChildren()) do\n                    if v.ClassName ~= \"Folder\" and v.ClassName ~= \"UIListLayout\" and v.ClassName ~= \"UIAspectRatioConstraint\"  and v.Visible and not passed and v == dropdown.asset then\n                        passed = true\n                    end\n\n                    if passed then\n                        if v ~= dropdown.asset then\n                            num = num + 1\n                            v.Parent = v.Parent.Hold\n                            table.insert(assets, v)\n                        end\n                    end\n                end\n\n                library:Tween(dropdown.asset[\"Down\"], TweenInfo.new(0.3), {Rotation = 180})\n\n                for i = 1, #dropdown.table do\n                    local newDrop = self.Lib.UI.Main.Container.DropdownDrop:Clone()\n                    newDrop.Parent = self.Lib.UI.Main.Container\n\n\n                    newDrop:FindFirstChild(\"Text\").Text = dropdown.table[i]\n\n                    newDrop.Visible = true\n                    library:Tween(newDrop, TweenInfo.new(0.2), {BackgroundTransparency = 0})\n                    library:Tween(newDrop:FindFirstChild(\"Text\"), TweenInfo.new(0.3), {TextTransparency = 0})\n\n                    local thing = {}\n\n                    thing.Asset = newDrop\n\n                    thing.Show = function()\n                        dropdown.assets[i].Visible = true\n                    end\n\n                    thing.Hide = function()\n                        dropdown.assets[i].Visible = false\n                    end\n\n                    table.insert(dropdown.assets, newDrop)\n                    table.insert(self.Assets, thing)\n\n                    local con;\n\n                    con = thing.Asset.MouseButton1Up:Connect(function(x, y)\n                        if dropdown.showing then\n                            table.insert(dropdown.connections, con)\n                            dropdown.debounce = true\n                            library:Tween(dropdown.asset[\"Down\"], TweenInfo.new(0.3), {Rotation = 0})\n\n                            if dropdown.asset:FindFirstChild(\"Text\").Text ~= dropdown.table[i] then\n                                dropdown.asset:FindFirstChild(\"Text\").Text = dropdown.table[i]\n                                dropdown.callback(dropdown.table[i])\n                            end\t\t\t\t\t\t\n\n                            for i,v in pairs(dropdown.connections) do\n                                v:Disconnect()\n                                table.remove(dropdown.connections, i)\n                            end\n\n                            for i = #dropdown.assets, 1, -1 do\n                                library:Tween(dropdown.assets[i], TweenInfo.new(0.2), {BackgroundTransparency = 1})\n                                library:Tween(dropdown.assets[i]:FindFirstChild(\"Text\"), TweenInfo.new(0.3), {TextTransparency = 1})\n\n                                game:GetService(\"RunService\").RenderStepped:Wait()\n\n                                dropdown.assets[i]:Destroy()\n\n                                for a,v in pairs(self.Assets) do\n                                    if v.Asset == dropdown.assets[i] then\n                                        table.remove(self.Assets, a)\n                                    end\n                                end\t\t\t\t\n                                table.remove(dropdown.assets, i)\n                            end\n\n                            dropdown.debounce = false\n                        end\n                    end)\n\n                    game:GetService(\"RunService\").RenderStepped:Wait()\n                end\n\n                for i,v in ipairs(assets) do\n                    v.Parent = v.Parent.Parent\n                end\n\n                for i,v in pairs(assets) do\n                    table.remove(assets, i)\n                end\n\n                dropdown.showing = true\n                dropdown.debounce = false\n            else\n                dropdown.debounce = true\n                library:Tween(dropdown.asset[\"Down\"], TweenInfo.new(0.3), {Rotation = 0})\n                for i = #dropdown.assets, 1, -1 do\n                    library:Tween(dropdown.assets[i], TweenInfo.new(0.2), {BackgroundTransparency = 1})\n                    library:Tween(dropdown.assets[i]:FindFirstChild(\"Text\"), TweenInfo.new(0.3), {TextTransparency = 1})\n\n                    game:GetService(\"RunService\").RenderStepped:Wait()\n\n                    dropdown.assets[i]:Destroy()\n\n                    for a,v in pairs(self.Assets) do\n                        if v.Asset == dropdown.assets[i] then\n                            table.remove(self.Assets, a)\n                        end\n                    end\t\t\t\t\n                    table.remove(dropdown.assets, i)\n                end\n                dropdown.showing = false\n                dropdown.debounce = false\n            end\n        end\n    end)\n\n    dropdown.Hide = function()\n        dropdown.asset.Visible = false\n    end\n\n    dropdown.Show = function()\n        dropdown.asset.Visible = true\n    end\n\n    table.insert(self.Assets, dropdown)\n    return setmetatable(dropdown, library)\nend\n\nfunction library:Label(text)\n    local label = {}\n\n    label.asset = self.Lib.UI.Main.Container.Label:Clone()\n    label.asset.Parent = self.Lib.UI.Main.Container\n\n    label.class = \"label\"\n\n    function label.Refresh(newText)\n        label.asset:FindFirstChild(\"Text\").Text = newText\n    end\n\n    label.Refresh(text)\n\n    label.Show = function()\n        label.asset.Visible = true\n    end\n\n    label.Hide = function()\n        label.asset.Visible = false\n    end\n\n    table.insert(self.Assets, label)\n    return setmetatable(label, library)\nend\n\nfunction library:TextBox(text, callback)\n    local textbox = {}\n    \n    textbox.Name = text\n    textbox.callback = callback or function() end\n    textbox.class = \"textbox\"\n    textbox.debounce = false\n    \n    textbox.asset = self.Lib.UI.Main.Container.TextBox:Clone()\n    textbox.asset.Parent = self.Lib.UI.Main.Container\n    textbox.asset:FindFirstChild(\"Text\").Text = text\n    \n    textbox.typing = false\n    \n    textbox.connections = {}\n    \n    textbox.asset.Outline.Box.Focused:Connect(function()\n        if not textbox.typing then\n            textbox.asset.Outline.Box:ReleaseFocus()\n        end\n    end)\n    \n    textbox.asset.MouseButton1Up:Connect(function(x,y)\n        if not textbox.debounce then\n            textbox.debounce = true\n            textbox.typing = true\n            library:Ripple(self.Lib.UI, textbox.asset, x, y, textbox)\n            library:Tween(textbox.asset.Outline, TweenInfo.new(0.35, Enum.EasingStyle.Quart), {\n                Size = UDim2.new((textbox.asset.Outline.Size.X.Scale + 0.225), textbox.asset.Outline.Size.X.Offset, textbox.asset.Outline.Size.Y.Scale, textbox.asset.Outline.Size.Y.Offset),\n                Position = UDim2.new((textbox.asset.Outline.Position.X.Scale - 0.1125), textbox.asset.Outline.Position.X.Offset, textbox.asset.Outline.Position.Y.Scale, textbox.asset.Outline.Position.Y.Offset)\n            })\n            wait(0.35)\n            textbox.asset.Outline.Box:CaptureFocus()\n            textbox.asset.Outline.Box.FocusLost:Wait()\n            textbox.typing = false\n            library:Tween(textbox.asset.Outline, TweenInfo.new(0.35, Enum.EasingStyle.Quart), {\n                Size = UDim2.new((textbox.asset.Outline.Size.X.Scale - 0.225), textbox.asset.Outline.Size.X.Offset, textbox.asset.Outline.Size.Y.Scale, textbox.asset.Outline.Size.Y.Offset),\n                Position = UDim2.new((textbox.asset.Outline.Position.X.Scale + 0.1125), textbox.asset.Outline.Position.X.Offset, textbox.asset.Outline.Position.Y.Scale, textbox.asset.Outline.Position.Y.Offset),\n            })\n            \n            textbox.callback(textbox.asset.Outline.Box.Text)\n            \n            wait(0.35)\n            \n            textbox.debounce = false\n        end\n    end)\n    \n    textbox.Show = function()\n        textbox.asset.Visible = true\n    end\n    \n    textbox.Hide = function()\n        textbox.asset.Visible = false\n    end\n    \n    table.insert(self.Assets, textbox)\n    return setmetatable(textbox, library)\nend\n\nfunction library:Notification(text)\n    local notification = {}\n    notification.NotifText = text\n    notification.Bind = nil\n    table.insert(self.Lib.Notifications.Queue, notification)\n    \n    spawn(function()\n\n        for notif = 1, #self.Lib.Notifications.Queue do\n            repeat wait() until not self.Lib.Notifications.Current\n            self.Lib.Notifications.Current = self.Lib.Notifications.Queue[notif]\n            \n            local Cover = self.Lib.UI.Main.BackgroundCover\n            Cover.Visible = true\n            \n            Cover.Notification.NotificationLabel.Text = (self.Lib.Notifications.Queue[notif].NotifText or \"No text provided\")\n            \n            local TweenData = {\n                Transparency = 0.5\n            }\n            \n            local CoverTween = game:GetService(\"TweenService\"):Create(Cover, TweenInfo.new(0.5), TweenData)\n            CoverTween:Play()\n            CoverTween.Completed:Wait()\n            \n            local TweenData2 = {\n                Position = UDim2.new(0.5, 0, 0.7, 0)\n            }\t\n            \n            local NotifTween = game:GetService(\"TweenService\"):Create(Cover.Notification, TweenInfo.new(0.5), TweenData2)\n            NotifTween:Play()\n            NotifTween.Completed:Wait()\n            \n            self.Lib.Notifications.Queue[notif].Bind = Cover.Notification.Ok.MouseButton1Click:Connect(function()\n                local TweenData3 = {\n                    Position = UDim2.new(0.5, 0, 1, 0)\n                }\t\n\n                local NotifTween2 = game:GetService(\"TweenService\"):Create(Cover.Notification, TweenInfo.new(0.5), TweenData3)\n                NotifTween2:Play()\n                NotifTween2.Completed:Wait()\n                \n                local TweenData4 = {\n                    Transparency = 1\n                }\n\n                local CoverTween2 = game:GetService(\"TweenService\"):Create(Cover, TweenInfo.new(0.5), TweenData4)\n                CoverTween2:Play()\n                CoverTween2.Completed:Wait()\n                Cover.Visible = false\n                \n                self.Lib.Notifications.Queue[notif].Bind:Disconnect()\t\t\t\n                table.remove(self.Lib.Notifications.Queue, notif)\n                \n                self.Lib.Notifications.Current = nil\n            end)\n        end\n\n    end)\nend\n\nfunction library:Update(new, new2, new3)\n    if self.table then\n        self.table = new\n        self.Refresh()\n    elseif self.min and self.max then\n        self.min = new\n        self.max = new2\n        self.Refresh(new3 or self.max\/2, true)\n    elseif self.toggle then\n        if new ~= self.state then\n            --self.state = (not new)\n            self.Refresh()\n        end\n    elseif self.class == \"label\" then\n        self.Refresh(new)\n    end\nend\n\nfunction library:ToggleUI()\n    self.UI.Enabled = not self.UI.Enabled \nend\n\n\n\nlocal HttpService = game:GetService(\"HttpService\")\n\nlocal http_request = http_request or request or HttpPost or syn.request or http.request\n\n\nlocal function SendMessage(webhook, msg, title, hidePicture)\n\n    local webhookcheck =\n        is_sirhurt_closure and \"Sirhurt\" or pebc_execute and \"ProtoSmasher\" or syn and \"Synapse X\" or\n        secure_load and \"Sentinel\" or\n        KRNL_LOADED and \"Krnl\" or\n        SONA_LOADED and \"Sona\" or\n        \"Kid with shit exploit\"\n\n    local url = webhook\n\n    local data;\n    if hidePicture then\n        data = {\n            [\"embeds\"] = {\n                {\n                    [\"title\"] = title,\n                    [\"description\"] = msg,\n                    [\"type\"] = \"rich\",\n                    [\"color\"] = tonumber(0x7269da)\n                }\n            }\n        }\n        \n    else\n        data = {\n            [\"embeds\"] = {\n                {\n                    [\"title\"] = title,\n                    [\"description\"] = msg,\n                    [\"type\"] = \"rich\",\n                    [\"color\"] = tonumber(0x7269da),\n                    [\"image\"] = {\n                        [\"url\"] = \"http:\/\/www.roblox.com\/Thumbs\/Avatar.ashx?x=150&y=150&Format=Png&username=\" .. tostring(game:GetService(\"Players\").LocalPlayer.Name)\n                    }\n                }\n            }\n        }\n    end\n\n    repeat wait() until data\n    local newdata = game:GetService(\"HttpService\"):JSONEncode(data)\n\n    local headers = {\n        [\"content-type\"] = \"application\/json\"\n    }\n    request = http_request or request or HttpPost or syn.request or http.request\n    local abcdef = {Url = url, Body = newdata, Method = \"POST\", Headers = headers}\n    request(abcdef)\nend\nlocal UserHWID = \"hahahh\"\nlocal PlayerHWID = \"haha\"\nlocal isWhitelisted = \"haha\"\n\nlocal exploit = is_sirhurt_closure and \"Sirhurt\" or pebc_execute and \"ProtoSmasher\" or syn and \"Synapse X\" or secure_load and \"Sentinel\" or KRNL_LOADED and \"KRNL\" or SONA_LOADED and \"Sona\" or isexecutorclosure and \"Script-Ware\" or \"Some shitty exploit idk\"\nlocal message = \"Premium script attempted use:\\nRoblox Name: \"..game.Players.LocalPlayer.Name..\"\\nRoblox Account: https:\/\/www.roblox.com\/users\/\"..game.Players.LocalPlayer.UserId..\"\/profile\"..\"\\nHWID: \"..PlayerHWID..\"\\nKey: \"..UserHWID..\"\\nWhitelisted: \"..tostring(isWhitelisted)..\"\\nExploit: \"..exploit..\"\\nAutohopping: \"..(tostring(getgenv().IsAutohopping))\n\nlocal function click(button, manual)\n    for i, v in pairs(getconnections(button.MouseButton1Click)) do\n        if manual then\n            v.Function()\n        else\n            v:Fire()\n        end\n    end\nend\n\nlocal neededFunctions = {getfenv, getsenv, hookfunction, getrawmetatable, getscriptclosure, getnamecallmethod, http_request, setclipboard}\nlocal missingSupport = \"\"\n\nfor i,v in pairs(neededFunctions) do\n    if not v then\n        if missingSupport == \"\" then\n            missingSupport = missingSupport..tostring(v)\n        else\n            missingSupport = missingSupport .. \" & \".. tostring(v)\n        end\n    end\nend\n\n\n    local Player = game:GetService(\"Players\").LocalPlayer\n    repeat wait() until Player.Character\n\n    if not Player.Character:FindFirstChild(\"RemoteEvent\") then\n        repeat wait() until (Player.PlayerGui:FindFirstChild(\"LoadingScreen1\") or Player.PlayerGui:FindFirstChild(\"LoadingScreen\"))\n    end\n\n    local TempData = {\n        [\"ScriptVer\"] = \"1.03\",\n\n        [\"Bypass_Enx\"] = false,\n        [\"Hooks\"] = {},\n        [\"Shiny Farm\"] = false,\n        [\"Auto Farm\"] = false,\n        [\"Auto Sell\"] = false,\n        [\"Item Farm\"] = false,\n        [\"ItemEsp\"] = false,\n        [\"Notify\"] = false,\n        [\"Anti-Burn\"]  = false,\n        [\"Attach_Victim\"] = nil,\n        [\"ItemUpdateSpeed\"] = 0.5,\n        [\"SellDelay\"] = 0.5,\n        [\"HopCount\"] = 7,\n        [\"RenderCONN\"] = { },\n        [\"StandToggles\"] = { },\n        [\"Item Toggles\"] = {},\n        [\"PickupItems\"] = {},\n        [\"WalkSpeed\"] = 100,\n        [\"JumpPower\"] = 100,\n        [\"SelectedStands\"] = {},\n        [\"Sell\"] = {},\n        [\"AllItems\"] = {\"Mysterious Arrow\", \"Pure Rokakaka\", \"Rokakaka\", \"Diamond\", \"Lucky Arrow\", \"DEO's Diary\", \"Steel Ball\", \"Rib Cage of The Saint's Corpse\", \"Stone Mask\", \"Gold Coin\", \"Quinton's Glove\", \"Ancient Scroll\", \"Zepellin's Headband\"},\n        [\"AllStands\"] = {\"White Poison\", \"Violet Fog\", \"Six Pistols\", \"Airsmith\", \"Scarlet King\", \"Golden Spirit\", \"Zipper Fingers\", \"Ice Album\", \"Ms. Vice President\", \"Ocean Boy\", \"That Hand\", \"Shining Sapphire\", \"Deadly King\", \"Red Hot Chili Pepper\", \"Violet Vine\", \"Tentacle Green\", \"Grey Rapier\", \"Magician's Ember\", \"Void\", \"Platinum Sun\", \"The Universe\", \"Anubiz\"}\n    }\n\n    for i,v in pairs(getconnections(Player.Idled)) do\n        v:Disable()\n    end --\/\/ anti afk\n\n    --skip loading thing\n\n    if getgenv().IsAutohopping then\n        repeat wait() until Player.PlayerGui:FindFirstChild(\"LoadingScreen1\") or Player.PlayerGui:FindFirstChild(\"LoadingScreen\") \n    end\n\n    if Player.PlayerGui:FindFirstChild(\"LoadingScreen1\") then\n        local Skip = Player.PlayerGui:FindFirstChild(\"LoadingScreen1\").Frame.LoadingFrame.Skip\n        repeat wait() until Skip.Visible\n\n        local LoadingScreen1 = Player.PlayerGui:FindFirstChild(\"LoadingScreen1\")\n\n        click(Skip.TextButton, true)\n\n        repeat wait() until not LoadingScreen1.Parent\n    end\t\n\n    if Player.PlayerGui:FindFirstChild(\"LoadingScreen\") then\n        local Prestige = Player.PlayerStats.Prestige.Value\n        Player.PlayerStats.Prestige.Value = 0\n\n        local LoadingScreen = Player.PlayerGui:FindFirstChild(\"LoadingScreen\")\n\n        click(LoadingScreen.Play)\n\n        repeat wait() until not LoadingScreen.Parent\n\n        Player.PlayerStats.Prestige.Value = Prestige\n    end\n\n    local function ItemCount(item)\n        local Count = 0\n    \n        for _, v in pairs(Player.Backpack:GetChildren()) do if v.Name == item then Count = Count + 1 end end\n    \n        return Count\n    end\n\n    local old;\n    local InvisbilityEnabled = false\n    local Queue = { }\n    old = hookfunction(getrawmetatable(game).__newindex, function(Event, Method, Function)\n        if Method == \"OnClientInvoke\" and Event.Name == \"ItemSpawn\" then\n            local OldInvoke = Function\n            Function = function(...)\n                local Arguments = {...}\n                local ItemData = Arguments[2]\n                local Run = true\n                pcall(function()\n                    local conn;\n                    local Run = true\n                    Queue[ItemData.CD] = {CFR = ItemData.CFrame, ItemName = ItemData.Replica.Name}\n\n                    for i,v in pairs(workspace:GetChildren()) do\n                        if (v:IsA(\"Part\") and v.Name == ItemData.Replica.Name and v.CFrame == ItemData.CFrame) then \n                            Run = false\n                        end\n                    end\n\n                    if Run then\n\n                        --[[\n                            spawn(function()\n                                conn = ItemData.CD:GetPropertyChangedSignal(\"Parent\"):Connect(function()\n                                    if ItemData.CD.Parent:IsA(\"Model\") then\n                                        if ItemData.CD.Parent:FindFirstChildWhichIsA(\"BasePart\").Transparency == 1 then\n                                            Queue[ItemData.CD] = nil\n                                            ItemData.CD.Parent:Destroy();\n                                            conn:Disconnect();\n                                        end\n                                    end\n                                end)\n                            end)--]]\n\n                        delay(0.5, function()\n                            local ESPPart = Instance.new(\"Part\", workspace)\n                            ESPPart.Name = ItemData.Replica.Name\n                            ESPPart.Size = Vector3.new(1,1,1)\n                            ESPPart.CFrame = ItemData.CFrame\n                            ESPPart.Anchored = true\n                            ESPPart.CanCollide = false\n                            ESPPart.Transparency = 1\n                            \n                            local Billboard = Instance.new(\"BillboardGui\", ESPPart)\n                            Billboard.AlwaysOnTop = true\n                            Billboard.Size = UDim2.new(8, 0, 2, 0)\n                            Billboard.StudsOffset = Vector3.new(0, 2, 0)\n                            Billboard.ClipsDescendants = false\n                            Billboard.Enabled = TempData.ItemEsp\n                            Billboard.Name = \"ESPBG\"\n\n                            local ESPLabel = Instance.new(\"TextLabel\", Billboard)\n                            ESPLabel.Size = UDim2.new(0, 100, 0, 100)\n                            ESPLabel.Position = UDim2.new(0.5, 0, 0.5, 0)\n                            ESPLabel.BackgroundTransparency = 1\n                            ESPLabel.AnchorPoint = Vector2.new(0.5, 0.5)\n                            ESPLabel.Text = ItemData.Replica.Name\n                            ESPLabel.TextColor3 = Color3.fromRGB(59, 255, 0)\n\n                            if TempData.Notify then\n                                game.StarterGui:SetCore(\"SendNotification\", {\n                                    Title = \"Item Spawned\";\n                                    Text = ItemData.Replica.Name,\n                                    Duration = 3\n                                })\n                            end\n\n                            if ItemData.Replica.Name == \"Lucky Arrow\" then\n                                local NewSound = Instance.new(\"Sound\")\n                                NewSound.Parent = game.Players.LocalPlayer.Character\n                                NewSound.SoundId = \"rbxassetid:\/\/6753175234\"\n                                NewSound.Volume = 10\n                        \n                                NewSound:Play()\n                                NewSound.Ended:Wait()\n                                NewSound:Destroy()\n                            end\n\n                            repeat wait(1) until not ItemData.CD:IsDescendantOf(game)\n                        --\tconn:Disconnect()\n                            if ItemName == \"Lucky Arrow\" then\n                                local censoredName = (string.sub(Player.Name, 1, 2))\n\n                                for i = 1, #Player.Name-2 do\n                                    censoredName = censoredName..\"*\"\n                                end\n\n                                local TotalItem = ItemCount(\"Lucky Arrow\")\n                                local message = \"Player: `\"..censoredName..\"`\\nItem: \"..ItemName..\"\\nItem Count: \"..TotalItem\n                               \n                            end\n                            ESPPart:Destroy()\n                        end)\n                end\n            end)\n                return OldInvoke(...)\t\n            end\n        end\n        return old(Event, Method, Function)\n    end)\n\n    getscriptclosure(game:GetService(\"ReplicatedFirst\"):WaitForChild(\"ItemSpawn\"))()\n\n    Player.Character.RemoteEvent:FireServer(\"Reset\", {[\"Anchored\"] = false})\n\n    local Hook;\n    Hook = hookfunction(getrawmetatable(game).__namecall, newcclosure(function(self, ...)\n        local args = {...}\n        if getnamecallmethod() == \"InvokeServer\" then\n            if args[1] == \"idklolbrah2de\" then\n                return \"  ___XP DE KEY\"\n            end\n        elseif getnamecallmethod() == \"FireServer\" and args[1] == \"Reset\" then\n            print(\"attempt\")\n            return wait(9e9)\n        end\n        \n        if getnamecallmethod() == \"InvokeServer\" and args[1] == \"Reset\" then\n            wait(9e9) \n        end\n        return Hook(self, ...)\n    end))\n\n    --\/\/ enxquity's invis and god bypass\n\n    function srchTable(tbl, index)\n        local newTBL = {}\n        for i,v in pairs(tbl) do\n            table.insert(newTBL, tostring(v))\n        end\n\n        if table.find(newTBL, index) then\n            newTBL = nil\n            return true\n        end\n\n        return false\n    end\n\n    Player.CharacterAdded:Connect(function()\n        TempData.Bypass_Enx = false;\n        if Player.PlayerScripts:FindFirstChild(\"ResetTimer\") then\n            Player.PlayerScripts.ResetTimer:Destroy()\n        end\n\n        --\/\/ fix reset\n        local NewEvent = Instance.new(\"BindableEvent\")\n        NewEvent.Event:Connect(function()\n            Player.Character.PrimaryPart:Destroy()\n        end)\n\n        game:GetService(\"StarterGui\"):SetCore(\"ResetButtonCallback\", NewEvent)\n    end)\t\n\n    Player.CharacterAdded:Wait()\n\n    local UI = library.Create(\"ItachiPvPUchiha\", \"YBA Script\")\n    local Credits = UI:Tab(\"Credits & Info\", 6026568227)\n    local ItemFarmTab = UI:Tab(\"ItemFarm\", 6031265970)\n    local MiscTab = UI:Tab(\"Misc\", 6022668951)\n    local PlayerTab = UI:Tab(\"Player\", 6023426915)\n    local StandsTab = UI:Tab(\"Stands\", 6034744057)\n    local LocationsTab = UI:Tab(\"Teleports\", 6035190846)\n    \n    --local FunTab = UI:Tab(\"Fun\", 6034848748)\n\n    --\/\/toggleable ui\n\n    game:GetService(\"UserInputService\").InputBegan:Connect(function(input, gpe)\n        if gpe then return end\n        if input.KeyCode == Enum.KeyCode.RightControl then\n            UI:ToggleUI()\n        end\n    end)\n    \n    local Data = { }\n\n    local Func = { }\n\n    Func.RequestFunct = function(ToUnpack)\n        if Player.Character and Player.Character:FindFirstChild(\"RemoteFunction\") then\n            Player.Character.RemoteFunction:InvokeServer(\"LearnSkill\", {[\"NPC\"] = tostring(Name), [\"Option\"] = \"Option1\", [\"Dialogue\"] = tostring(Dialogue)})\n        end\n    end\n\n    Func.RequestEvent = function(Name, Dialogue)\n        if Player.Character and Player.Character:FindFirstChild(\"RemoteEvent\") then\n            Player.Character.RemoteEvent:FireServer(\"EndDialogue\", {[\"NPC\"] = tostring(Name), [\"Option\"] = \"Option1\", [\"Dialogue\"] = tostring(Dialogue)})\n        end\n    end\n\n    Func.ReturnData = function(DataPath)\n        if DataPath == \"Stand\" then\n            return Player:WaitForChild(\"PlayerStats\").Stand.Value\n        elseif DataPath == \"HasStand\" then\n            if string.lower(Player:WaitForChild(\"PlayerStats\").Stand.Value) == \"none\" then\n                return false\n            end\n            return true\n        elseif DataPath == \"HasShiny\" then\n            if Player.PlayerGui:WaitForChild(\"HUD\").Main.Frames:WaitForChild(\"Settings\").Stand.TextLabel:FindFirstChild(\"Shiny\") then\n                return true\n            end\n            return false\n        elseif DataPath == \"Pity\" then\n            return (Player.PlayerGui:WaitForChild(\"HUD\").Main.Frames:WaitForChild(\"Store\").SkinChances1.TextLabel)\n        end\n    end\n\n    Func.LearnSkills = function(Skills)\n        for i,v in pairs(Skills) do\n            local args = {\n                [1] = \"LearnSkill\",\n                [2] = {\n                    [\"Skill\"] = v,\n                    [\"SkillTreeType\"] = \"Character\",\n                }\n            }\n\n            workspace.Living[game.Players.LocalPlayer.Name].RemoteFunction:InvokeServer(unpack(args))\n        end\n    end\n\n    local function SaveData()\n        writefile(\"crackedXenonFarm_1.json\", game:GetService('HttpService'):JSONEncode(Data))\n    end    \n\n    local function IsItem(name)\n        for i,v in pairs(TempData.PickupItems) do\n            if v == name then\n                return true\n            end\n        end\n\n        return false\n    end\n\n    local function RemoveTable(t, i)\n        for a, b in pairs(t) do\n            if b == i then\n                table.remove(t, a)\n            end\n        end\n    end\n\n    local File = pcall(function()\n        Data = game:GetService('HttpService'):JSONDecode(readfile(\"crackedXenonFarm_1.json\"))\n    end)\n\n    if not File then\n        Data = {\n            [\"Auto Invis\"] = false,\n            [\"Collect Delay\"] = 0.8,\n            [\"Callback Delay\"] = 0.8,\n            [\"StandToggles\"] = {},\n            [\"ItemToggles\"] = {}\n        }\n        writefile(\"crackedXenonFarm_1.json\", game:GetService('HttpService'):JSONEncode(Data))\n    end\n\n    local CollectDelay, CallbackDelay = 0, 0\n\n    ItemFarmTab:Label(\"KRNL is shit, buy Synapse X\")\n\n    ItemFarmTab:Seperator()\n\n    local Max = {\n        Diamond = 30,\n        [\"Gold Coin\"] = 45,\n        [\"Mysterious Arrow\"] = 25,\n        [\"Pure Rokakaka\"] = 10,\n        Rokakaka = 25,\n        [\"Stone Mask\"] = 10,\n        [\"Rib Cage of The Saint's Corpse\"] = 10,\n        [\"Steel Ball\"] = 10,\n        [\"Ancient Scroll\"] = 10,\n        [\"DEO's Diary\"] = 10,\n        [\"Zepellin's Headband\"] = 10,\n        [\"Quinton's Glove\"] = 10,\n        [\"Lucky Arrow\"] = 10\n    }\n\n    local function NewBypass()\n        if not TempData.Bypass_Enx then\n            \t\t\tfor i,v in pairs(getgc()) do\n\t\t\t\tif type(v) == \"function\" and tostring(getfenv(v).script) == 'Client' and #debug.getprotos(v) == 7 and srchTable(debug.getupvalues(v), \"RemoteEvent\") then\n\t\t\t\t\t\thookfunction(v, function()\n\t\t\t\t\t\t\treturn wait(9e9)\n\t\t\t\t\t\tend)\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n        end\n    end\n\n    ItemFarmTab:Toggle(\"Item Farm\", \"Ativa o item farm\", false, function(BooleanVal)\n        if BooleanVal then\n            TempData[\"Item Farm\"] = true\n            while wait(0.1) do\n                NewBypass()\n        if Player.Character and Player.Character:FindFirstChild(\"HumanoidRootPart\") and Player.Character:FindFirstChild(\"LowerTorso\") and Player.Character.LowerTorso:FindFirstChild(\"Root\") then\n            local Place1 = CFrame.new(Vector3.new(1750.6010742188, 770.61102294922, 28.486907958984))\n            local Place2 = Player.Character.HumanoidRootPart.CFrame\n            Player.Character.HumanoidRootPart.CFrame = Place1\n            wait(0.5)\n            Player.Character.LowerTorso.Root:Destroy()\n            wait(0.5)\n            Player.Character.HumanoidRootPart.CFrame = Place2\n        end\t\n                local ws = workspace;\nlocal lp = game.Players.LocalPlayer;\n\n_G.itemFarm = true;\n_G.foundItem = false; --Dont touch\n_G.grabbingItem = false;\n\n--Table function\nfunction searchTable(t, index)\n\tlocal temp = {};\n\tfor i,v in pairs(t) do\n\t\ttable.insert(temp, tostring(v));\n\tend\n\tif table.find(temp, index) then\n\t\ttemp = nil;\n\t\treturn true;\n\tend\n\treturn false;\nend\n\n--TP Bypass starts here\n--This is used to get the return key in case they change it\nlocal gc = getgc(true);\nlocal key = nil;\nfor i = #gc, 1, -1 do\n    if type(gc[i]) == \"table\" then\n        if rawget(gc[i], \"A\") and type(rawget(gc[i], \"A\")) == \"table\" and #(rawget(gc[i], \"A\")) > 2 then\n            key = rawget(gc[i], \"A\")[2];\n            break;\n        end\n    end\nend\n\nlocal oldNamecall;\noldNamecall = hookmetamethod(game, \"__namecall\", function(self, ...)\n    local args = {...};\n    if not checkcaller() and getnamecallmethod() == \"InvokeServer\" and tostring(self) == \"Returner\" and args[1] == \"idklolbrah2de\" then\n        if key then return key;\n\t\telse return \"  ___XP DE KEY\"; end\n    end\n\tif not checkcaller() and getnamecallmethod() == \"InvokeServer\" and args[1] == \"Reset\" then\n\t\treturn;\n\tend\n\tif not checkcaller() and getnamecallmethod() == \"FireServer\" and args[1] == \"Reset\" then\n\t\treturn;\n\tend\n    if not checkcaller() and getnamecallmethod() == \"Kick\" then\n        return;\n    end\n    return oldNamecall(self, ...);\nend);\n\nfor i,v in pairs(getgc()) do\n\tif type(v) == \"function\" and tostring(getfenv(v).script) == 'Client' and #debug.getprotos(v) == 7 and searchTable(debug.getupvalues(v), \"RemoteEvent\") then\n\t\thookfunction(v, function()\n\t\t\treturn wait(9e9);\n\t\tend);\n\t\tbreak;\n\tend\nend\nwait(0.5);\n\n--Coords I took from https:\/\/discord.gg\/rs9FCkMX5u\nlocal itemSpawns = \n{\n\tCFrame.new(-413.53112792969,  827.54278564453, 42.011169433594),\n\tCFrame.new(-191.24629211426 ,827.0869140625 , -10.055070877075),\n\tCFrame.new(-282.28414916992 ,826.04718017578 , -26.729415893555),\n\tCFrame.new(-205.62605285645 ,829.04846191406 , -67.532608032227),\n\tCFrame.new(-154.98663330078 ,829.00830078125 , -52.219764709473),\n\tCFrame.new(-89.047630310059 ,830.90832519531 , -66.026138305664),\n\tCFrame.new(826.30889892578 ,803.84655761719 , -226.66427612305),\n\tCFrame.new(699.22119140625 ,803.84655761719 , -208.68244934082),\n\tCFrame.new(776.76434326172 ,807.17486572266 ,-355.8134765625),\n\tCFrame.new(1050.7122802734 ,803.84729003906 ,-296.76510620117),\n\tCFrame.new(809.83520507812 ,803.84655761719 ,-81.491226196289),\n\tCFrame.new(796.341796875 ,810.68719482422 , -40.994129180908),\n\tCFrame.new(836.11309814453 ,810.33142089844 ,-41.200565338135),\n\tCFrame.new(1051.7955322266 ,815.47772216797 ,-25.381820678710001),\n\tCFrame.new(1915.4926757812 ,822.24658203125 ,-39.561851501465),\n\tCFrame.new(1985.0435791016 ,819.84655761719 ,-189.87425231934),\n\tCFrame.new(2341.68359375 ,819.84655761719 ,-228.87698364258),\n\tCFrame.new(305.22045898438 ,803.84655761719 ,-185.82682800293),\n\tCFrame.new(339.23501586914 ,826.84722900391 ,-110.79901123047),\n\tCFrame.new(409.59423828125 ,826.64733886719 ,-89.112976074219),\n\tCFrame.new(453.85363769531 ,826.64733886719 ,115.3904876709),\n\tCFrame.new(428.88458251953 ,861.05114746094 ,-175.99559020996),\n\tCFrame.new(124.43515014648 ,826.84722900391 ,-153.63478088379),\n\tCFrame.new(222.72418212891 ,827.80584716797 , -85.74934387207),\n\tCFrame.new(130.63851928711 ,826.84704589844 ,-49.86185836792),\n\tCFrame.new(46.80810546875 ,826.84698486328 ,-98.422576904297),\n\tCFrame.new(27.974872589111 ,861.29296875 ,-10.053286552429),\n\tCFrame.new(375.23657226562 ,826.84704589844 ,-162.12173461914),\n\tCFrame.new(341.62973022461 ,826.84704589844 ,-131.64344787598),\n\tCFrame.new(479.29449462891 ,826.84716796875 ,254.90055847168),\n\tCFrame.new(452.22775268555 ,826.84716796875 ,302.7751159668),\n\tCFrame.new(315.51916503906 ,826.84716796875 ,261.26873779297),\n\tCFrame.new(518.22473144531 ,826.24731445312 ,360.57772827148),\n\tCFrame.new(429.50021362305 ,875.04724121094 ,387.19262695312),\n\tCFrame.new(129.19146728516 ,826.84704589844 ,379.81701660156),\n\tCFrame.new(32.098743438721 ,828.24719238281 ,302.8957824707),\n\tCFrame.new(171.77783203125 ,826.84710693359 ,255.28721618652),\n\tCFrame.new(199.16697692871 ,857.84704589844 ,258.2873840332),\n\tCFrame.new(21.905725479126 ,870.04718017578 ,280.63858032227),\n\tCFrame.new(-74.956695556641 ,828.34704589844 ,386.41787719727),\n\tCFrame.new(-152.78285217285 ,830.97821044922 ,413.20315551758),\n\tCFrame.new(-99.575782775879 ,827.62579345703 ,429.30065917969),\n\tCFrame.new(-118.483543396 ,835.71136474609 ,402.61944580078),\n\tCFrame.new(-196.11956787109 ,826.84704589844 ,408.80563354492),\n\tCFrame.new(-192.16874694824 ,803.84710693359 ,458.53912353516),\n\tCFrame.new(-228.64126586914 ,826.84704589844 ,309.07147216797),\n\tCFrame.new(-334.5627746582 ,827.84716796875 ,382.34112548828),\n\tCFrame.new(-295.66107177734 ,827.7548828125 ,260.44488525390001),\n\tCFrame.new(-243.06549072266 ,826.84704589844 ,97.641380310059),\n\tCFrame.new(145.40446472168 ,827.79797363281 ,106.12605285645),\n\tCFrame.new(84.441474914551 ,826.84704589844 ,104.43872070312),\n\tCFrame.new(43.941471099854 ,826.84704589844 ,268.90521240234),\n\tCFrame.new(172.65376281738 ,826.84704589844 ,278.38635253906),\n\tCFrame.new(236.93182373047 ,826.84704589844 ,430.49688720703),\n\tCFrame.new(210.55850219727 ,803.84710693359 ,460.701171875),\n\tCFrame.new(448.04244995117 ,803.87713623047 ,438.78884887695),\n\tCFrame.new(126.77220153809 ,803.84710693359 ,560.0048828125),\n\tCFrame.new(-206.2195892334 ,890.84716796875 ,440.22219848633),\n\tCFrame.new(-470.92459106445 ,803.84710693359 ,381.17669677734),\n\tCFrame.new(-434.47100830078 ,803.84710693359 ,235.62271118164),\n\tCFrame.new(-442.24462890625 ,803.84710693359 ,-198.76741027832),\n\tCFrame.new(-101.06670379639 ,743.8486328125 ,8.9106760025024),\n\tCFrame.new(-355.35842895508 ,743.84289550781 ,204.35467529297),\n\tCFrame.new(-178.44441223145 ,720.17205810547 ,264.23211669922),\n\tCFrame.new(196.2378692627 ,671.93670654297 ,83.881690979004),\n\tCFrame.new(107.51532745361 ,749.04711914062 ,359.88635253906),\n\tCFrame.new(11.99014377594 ,744.07873535156 ,530.36346435547),\n\tCFrame.new(138.86274719238 ,743.84521484375 ,493.1076965332),\n\tCFrame.new(-38.685668945312 ,729.07989501953 ,365.58688354492),\n\tCFrame.new(13.609048843384 ,733.42077636719 ,267.63186645508),\n\tCFrame.new(-228.36434936523 ,751.04052734375 ,528.87542724609),\n\tCFrame.new(-426.47561645508 ,743.84716796875 ,460.21655273438),\n\tCFrame.new(-311.52005004883 ,722.84790039062 ,438.1628112793),\n\tCFrame.new(-475.11709594727 ,738.84729003906 ,212.75103759766)\n};\n\n--Functions for grabbing items start here\nlocal function grabItem()\n\tfor i,v in pairs(ws.Item_Spawns.Items:GetChildren()) do\n\t\tif v:IsA(\"Model\") and v:FindFirstChildWhichIsA(\"MeshPart\") or v:FindFirstChildWhichIsA(\"Part\") and v:FindFirstChildWhichIsA(\"ClickDetector\") then\n\t\t\tlocal mp;\n\t\t\tfor i2,val in pairs(v:GetChildren()) do\n\t\t\t\tif ((val:IsA(\"Part\") or val:IsA(\"MeshPart\")) and val.Transparency ~= 1) then\n\t\t\t\t\tmp = val;\n\t\t\t\t\tbreak;\n\t\t\t\tend\n\t\t\tend\n\t\t\tif mp and (mp.Position - lp.Character.HumanoidRootPart.Position).magnitude <= 5 then\n\t\t\t\t--print(\"Magnitude check passed\");\n\t\t\t\tif mp.Transparency ~= 1 then\n\t\t\t\t\t--print(\"Valid item check passed\");\n\t\t\t\t\t_G.grabbingItem = true;\n\t\t\t\t\tlp.Character.HumanoidRootPart.CFrame = CFrame.new(mp.Position) * CFrame.new(0, 3, 0);\n\t\t\t\t\twait(0.7);\n\t\t\t\t\tif v:FindFirstChildWhichIsA(\"ClickDetector\") then\n\t\t\t\t\t\tfireclickdetector(v:FindFirstChildWhichIsA(\"ClickDetector\"));\n\t\t\t\t\t\tfor i = 1, 4 do wait() \n\t\t\t\t\t\t\tif (lp.PlayerGui:FindFirstChild(\"Message\") and lp.PlayerGui.Message:FindFirstChild(\"TextLabel\")) then\n\t\t\t\t\t\t\t\tif string.match(lp.PlayerGui.Message.TextLabel.Text, \"You can't have more than\") then\n\t\t\t\t\t\t\t\t\tv:Destroy();\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t\twait(0.25);\n\t\t\t\t\t_G.grabbingItem = false;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\nend\n\nlocal function grabFoundItem(v)\n\tif v:IsA(\"Model\") and v:FindFirstChildWhichIsA(\"MeshPart\") or v:FindFirstChildWhichIsA(\"Part\") and v:FindFirstChildWhichIsA(\"ClickDetector\") then\n\t\tlocal mp;\n\t\tfor i,val in pairs(v:GetChildren()) do\n\t\t\tif ((val:IsA(\"Part\") or val:IsA(\"MeshPart\")) and val.Transparency ~= 1) then\n\t\t\t\tmp = val;\n\t\t\t\tbreak;\n\t\t\tend\n\t\tend\n\t\tif mp and mp.Transparency ~= 1 then\n\t\t\t--print(\"Valid item check passed(found item)\");\n\t\t\t_G.grabbingItem = true;\n\t\t\tlp.Character.HumanoidRootPart.CFrame = CFrame.new(mp.Position) * CFrame.new(0, 3, 0);\n\t\t\twait(0.7);\n\t\t\tif v:FindFirstChildWhichIsA(\"ClickDetector\") then\n\t\t\t\tfireclickdetector(v:FindFirstChildWhichIsA(\"ClickDetector\"));\n\t\t\t\tfor i = 1, 4 do wait() \n\t\t\t\t\tif (lp.PlayerGui:FindFirstChild(\"Message\") and lp.PlayerGui.Message:FindFirstChild(\"TextLabel\")) then\n\t\t\t\t\t\tif string.match(lp.PlayerGui.Message.TextLabel.Text, \"You can't have more than\") then\n\t\t\t\t\t\t\tv:Destroy();\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\t\twait(0.25);\n\t\t\t_G.grabbingItem = false;\n\t\tend\n\tend\nend\n--Functions for grabbing items end here\n\n--Item autofarm starts here\ncoroutine.wrap(function()\n\twhile wait(2) do\n\t\tif _G.itemFarm and #(ws.Item_Spawns.Items:GetChildren()) >= 1 then\n\t\t\tif _G.grabbingItem then repeat wait() until not _G.grabbingItem; end\n\t\t\t_G.foundItem = true;\n\t\t\tfor i,v in pairs(ws.Item_Spawns.Items:GetChildren()) do\n\t\t\t\tif (lp.Character and lp.Character:FindFirstChild(\"HumanoidRootPart\")) then\n\t\t\t\t\tgrabFoundItem(v);\n\t\t\t\t\twait(0.7);\n\t\t\t\t\t_G.foundItem = false;\n\t\t\t\tend\t\n\t\t\tend\n\t\tend\n\tend\nend)();\n\nwhile wait(2) do\n\tif _G.itemFarm then\n\t\tfor i,v in ipairs(itemSpawns) do\n\t\t\tif _G.foundItem then repeat wait() until not _G.foundItem; end\n\t\t\tif _G.grabbingItem then repeat wait() until not _G.grabbingItem; end\n\t\t\tif (lp.Character and lp.Character:FindFirstChild(\"HumanoidRootPart\")) then\n\t\t\t\tlp.Character.HumanoidRootPart.CFrame = v;\n\t\t\t\twait(2);\n\t\t\t\tgrabItem();\n\t\t\t\twait(2);\n\t\t\tend\n\t\tend\n\tend\t\nend\n--Item autofarm ends here\n                if not TempData[\"Item Farm\"] then\n                    break\n                end\n            end\n        else\n            TempData[\"Item Farm\"] = false\n        end\n    end)\n\n    ItemFarmTab:Seperator()\n\n    local LastShiny = nil\n    StandsTab:Toggle(\"Auto Stand\", \"Usa rokas e flechas para pegar o stand desejado\", false, function(BooleanVal)\n        if BooleanVal then\n            TempData[\"Stand Farm Cancel\"] = true\n            while TempData[\"Stand Farm Cancel\"] do\n                local isStand = false\n                for _, Stand in pairs(TempData.SelectedStands) do\n                    if Func.ReturnData(\"HasStand\") and Func.ReturnData(\"Stand\") == Stand then \n                        isStand = true\n                    end\n                end\n\n                if not TempData[\"Stand Farm Cancel\"] then \n                    break\n                end\n\n                if (Func.ReturnData(\"HasStand\") and TempData[\"Shiny Farm\"] and Func.ReturnData(\"HasShiny\")) then\n                    isStand = true\n                end\n\n                if not isStand then\n                    -- we need it to use roka and arrow here\n                    if Func.ReturnData(\"HasStand\") == false then\n                        local skills = {\n                            \"Vitality I\",\n                            \"Vitality II\",\n                            \"Vitality III\",\n                            \"Worthiness I\",\n                            \"Worthiness II\"\n                        }\n\n                        Func.LearnSkills(skills)\n\n                        local args = {\n                            [1] = \"EndDialogue\",\n                            [2] = {\n                                [\"NPC\"] = \"Mysterious Arrow\",\n                                [\"Option\"] = \"Option1\",\n                                [\"Dialogue\"] = \"Dialogue2\"\n                            }\n                        }\n\n                        game:GetService(\"Players\").LocalPlayer.Character.RemoteEvent:FireServer(unpack(args))\n                        if (Func.ReturnData(\"HasStand\") and TempData[\"Shiny Farm\"] and Func.ReturnData(\"HasShiny\") and not LastShiny) then\n                            local censoredName = (string.sub(Player.Name, 1, 2))\n\n                            for i = 1, #Player.Name-2 do\n                                censoredName = censoredName..\"*\"\n                            end\n\n                            local stand = Func.ReturnData(\"Stand\")\n                            local message = \"Player: `\"..censoredName..\"`\\nGot a shiny stand using shiny farm: \".. game.Players.LocalPlayer.Character:FindFirstChild(\"StandMorph\").StandSkin.Value\n                            LastShiny = game.Players.LocalPlayer.Character:FindFirstChild(\"StandMorph\").StandSkin.Value\n                            \n\n\n                        end\n                    else\n\n                        local args = {\n                            [1] = \"EndDialogue\",\n                            [2] = {\n                                [\"NPC\"] = \"Rokakaka\",\n                                [\"Option\"] = \"Option1\",\n                                [\"Dialogue\"] = \"Dialogue2\"\n                            }\n                        }\n\n                        game:GetService(\"Players\").LocalPlayer.Character.RemoteEvent:FireServer(unpack(args)) --\/\/ use roka\n\n                        Player.CharacterAdded:Wait()\n                        LastShiny = nil\n                        wait(0.5)\n                    end\n                end\n                wait()\n            end\n        else\n            TempData[\"Stand Farm Cancel\"] = false\n        end\n    end)\n\n    StandsTab:Toggle(\"Shiny Farm\", \"Para o Stand Farm em qualquer shiny\", false, function(BooleanVal)\n        TempData[\"Shiny Farm\"] = BooleanVal\n    end)\n\n    StandsTab:Seperator()\n\n    StandsTab:Button(\"Add all\", \"Adiciona todos os stands da lista\", function()\n        StandsTab:Notification(\"Todos os stands adicionados.\")\n        for i,v in pairs(TempData.StandToggles) do\n            spawn(function()\n                v:Update(true)\n            end)\n        end\n        SaveData()\n    end)\n\n    StandsTab:Button(\"Remove all\", \"Remove todos os stands da lista\", function()\n        StandsTab:Notification(\"Todos os Stands Removidos.\")\n        for i,v in pairs(TempData.StandToggles) do\n            spawn(function()\n                v:Update(false)\n            end)\n        end\n        SaveData()\n    end)\n\n    StandsTab:Seperator()\n\n    local PityLabel = StandsTab:Label(\"Pity: \"..Func.ReturnData(\"Pity\").Text)\n\n    spawn(function()\n        while wait(2) do\n            PityLabel:Update(\"Pity: \"..Func.ReturnData(\"Pity\").Text)\n        end\n    end)\n\n    StandsTab:Seperator()\n\n    for _, Stand in pairs(TempData.AllStands) do\n        local StandToggle = StandsTab:Toggle(Stand, \"Stand\", Data.StandToggles[Stand], function(BooleanVal)\n            if BooleanVal then\n                table.insert(TempData.SelectedStands, Stand)\n                Data.StandToggles[Stand] = true\n                SaveData()\n            else\n                RemoveTable(TempData.SelectedStands, Stand)\n                RemoveTable(Data.StandToggles, Stand)\n                Data.StandToggles[Stand] = false\n                SaveData()\n            end\n        end)\n\n        table.insert(TempData.StandToggles, StandToggle)\n    end\n\n    ItemFarmTab:Label(\"Item Counter\")\n\n    ItemFarmTab:Seperator()\n\n    for i,v in pairs(TempData.AllItems) do\n        local label = ItemFarmTab:Label(v..\": 0\")\n\n        spawn(function()\n            while wait(TempData[\"ItemUpdateSpeed\"]) do\n                local total = 0\n                for _, item in pairs(Player.Backpack:GetChildren()) do\n                    if item.Name == v then\n                        total = total + 1\n                    end\n                end\n\n                label:Update(v..\": \"..tostring(total))\n            end\n        end)\n    end\n\n    MiscTab:Seperator()\n\n    --[[\n    local MM;\n\n    MiscTab:Toggle(\"Multi-Moves\", \"Allows you to use more than one move at once\", false, function(BooleanVal)\n        if BooleanVal then\n            MM = game:GetService(\"RunService\").RenderStepped:Connect(function()\n                Func.RequestEvent(\"Prestige\", \"Dialogue2\")\n            end)\n        else\n            MM:Disconnect();\n        end\n    end)--]]\n\n  \n\n    MiscTab:Toggle(\"Anti TS\", \"Avoids any time stop.\", false, function(state)\n        if state then\n            TempData.RenderCONN[\"Anti_TS\"] = game:GetService(\"RunService\").RenderStepped:Connect(function()\n                if Player.Character and Player.Character:FindFirstChild(\"InTimeStop\") then\n                    Player.Character:FindFirstChild(\"InTimeStop\"):Destroy()\n                end\n            end)\n        else\n            if TempData.RenderCONN[\"Anti_TS\"] then\n                TempData.RenderCONN[\"Anti_TS\"]:Disconnect()\n            end\n        end\n    end)\n\n    MiscTab:Seperator()\n\n    PlayerTab:Seperator()\n\n    PlayerTab:Slider(\"Speed\", 16, 500, 100, function(IntVal)\n        TempData[\"WalkSpeed\"] = IntVal\n    end)\n\n    PlayerTab:Slider(\"Jump\", 50, 1000, 100, function(IntVal)\n        TempData[\"JumpPower\"] = IntVal\n    end)\n\n    PlayerTab:Toggle(\"Jump\", \"Sets your jump power\", false, function(BooleanVal)\n        if BooleanVal then\n            TempData.RenderCONN[\"Jumppower\"] = game:GetService(\"RunService\").RenderStepped:Connect(function()\n                if Player.Character and Player.Character:FindFirstChild(\"Humanoid\") then\n                    Player.Character.Humanoid.JumpPower = TempData[\"JumpPower\"]\n                end\n            end)\n        else\n            TempData.RenderCONN[\"Jumppower\"]:Disconnect()\n        end\n    end)\n\n    PlayerTab:Toggle(\"Speed\", \"Sets your walkspeed\", false, function(BooleanVal)\n        if BooleanVal then\n            TempData.RenderCONN[\"Walkspeed\"] = game:GetService(\"RunService\").RenderStepped:Connect(function()\n                if Player.Character and Player.Character:FindFirstChild(\"Humanoid\") then\n                    Player.Character.Humanoid.WalkSpeed = TempData[\"WalkSpeed\"]\n                end\n            end)\n        else\n            TempData.RenderCONN[\"Walkspeed\"]:Disconnect()\n        end\n    end)\n\n    PlayerTab:Seperator()\n\n    PlayerTab:Button(\"Invisbility(MAIN GAME)\", \"Enables Invisiblity\", function()\n        NewBypass()\n        if Player.Character and Player.Character:FindFirstChild(\"HumanoidRootPart\") and Player.Character:FindFirstChild(\"LowerTorso\") and Player.Character.LowerTorso:FindFirstChild(\"Root\") then\n            local Place1 = CFrame.new(Vector3.new(1750.6010742188, 770.61102294922, 28.486907958984))\n            local Place2 = Player.Character.HumanoidRootPart.CFrame\n            Player.Character.HumanoidRootPart.CFrame = Place1\n            wait(0.5)\n            Player.Character.LowerTorso.Root:Destroy()\n            wait(0.5)\n            Player.Character.HumanoidRootPart.CFrame = Place2\n        end\t\n    end)\nPlayerTab:Button(\"Invisbility(SBR)\", \"Enables Invisiblity in SBR\", function()\n        NewBypass()\n        if Player.Character and Player.Character:FindFirstChild(\"HumanoidRootPart\") and Player.Character:FindFirstChild(\"LowerTorso\") and Player.Character.LowerTorso:FindFirstChild(\"Root\") then\n            local Place1 = CFrame.new(Vector3.new(841.28497314453, 808.84655761719, -5.2998661994934))\n            local Place2 = Player.Character.HumanoidRootPart.CFrame\n            Player.Character.HumanoidRootPart.CFrame = Place1\n            wait(0.5)\n            Player.Character.LowerTorso.Root:Destroy()\n            wait(0.5)\n            Player.Character.HumanoidRootPart.CFrame = Place2\n        end\t\n    end)\nPlayerTab:Button(\"Reset(dont crash the game)\", \"...\", function()\ngame.Players.LocalPlayer.Character.Head:Destroy()\nend)\nPlayerTab:Button(\"Reset(1V1\/2V2)\", \"If u execute this u wont die in 2v2\/1v1 \", function()\ngame.Players.LocalPlayer.Character.Head.Parent = nil\nend)\n\n    LocationsTab:Button(\"Stage 4 SBR\", \"Teleports you to Stage 4 SBR\", function()\n        local Place = CFrame.new(Vector3.new(-1360.1188964844, 415.11627197266, 7921.3051757813))\n        if Player.Character and Player.Character:FindFirstChild(\"HumanoidRootPart\") then\n            Player.Character.HumanoidRootPart.CFrame = Place\n        end\n    end)   \n\nLocationsTab:Button(\"Heaven Arena\", \"Teleports you to The Heaven Arena\", function()\n        local Place = CFrame.new(Vector3.new(8544.7685546875, 53.020244598389, 8152.3969726563))\n        if Player.Character and Player.Character:FindFirstChild(\"HumanoidRootPart\") then\n            Player.Character.HumanoidRootPart.CFrame = Place\n        end\n    end)\n\n    Credits:Label(\n        \"Owner:ItachiPvPUchiha\"\n    )\n\n    Credits:Label(\n        \"KRNL Version by Itachi\"\n    )\n\n    Credits:Label(\n        \"Version: KRNL Edition\"\n    )\n\n    Credits:Label(\n        \"Exploit: \".. exploit\n    )\n\n    Credits:Label(\n        \"Missing Functions: \" .. (missingSupport == \"\" and \"None\" or missingSupport)\n    )\n\n    --auto farm down here cuz im not sorted :(\n            \n    TempData.Moves = {\n        [\"UseMove\"] = function(key)\n            local args = {\n                [1] = \"InputBegan\",\n                [2] = {\n                    [\"Input\"] = Enum.KeyCode[key:upper()]\n                }\n            }\n        \n            Player.Character.RemoteEvent:FireServer(unpack(args))\n        end,\n        [\"Punch\"] = function()\n            local args = {\n                [1] = \"Attack\",\n                [2] = \"m1\"\n            }\n    \n            Player.Character.RemoteFunction:InvokeServer(unpack(args))\n        end,\n        [\"PowerPunch\"] = function()\n            local args = {\n                [1] = \"Attack\",\n                [2] = \"m2\"\n            }\n    \n            Player.Character.RemoteFunction:InvokeServer(unpack(args))\n        end,\n\n        [\"All\"] = function()\n            if Func.ReturnData(\"HasStand\") then\n                for i,v in pairs(Player.Character.StandSkills:GetChildren()) do\n                    local key = string.sub(v.Name, 14, #v.Name):upper()\n                    if table.find(TempData.AutofarmSettings.UsedMoves, key) then\n                        TempData.Moves.UseMove(key)\n                    end\n                end\n            end\n            TempData.Moves.Punch()\n        end\n    } --\/\/ this is needed for autofarm srry its messy\n\n\n    TempData.AutofarmSettings = {\n        [\"Distance\"] = 5,\n        [\"Auto Spawn Stand\"] = true,\n        [\"UsedMoves\"] = {},\n        [\"NPC_Table\"] = {},\n        [\"SelectedNPC\"] = nil,\n        [\"Farming\"] = false,\n        [\"FixThread\"] = nil\n    }\n    \n    TempData.Completed = false\n\n    TempData.Kill = function(npc)\n        assert(npc, \"No NPC provided\")\n\n        if not TempData.Target then\n            TempData.Target = npc\n        end\n\n        TempData.AutofarmThread = game:GetService(\"RunService\").RenderStepped:Connect(function()\n            if TempData.Target:FindFirstChild(\"HumanoidRootPart\") and (TempData.Target:FindFirstChild(\"Humanoid\") and TempData.Target:FindFirstChild(\"Humanoid\").Health > 0.11) and not TempData.Completed and TempData.Farming then\n                Player.Character.PrimaryPart.CFrame = (TempData.Target:FindFirstChild(\"HumanoidRootPart\").CFrame - TempData.Target:FindFirstChild(\"HumanoidRootPart\").CFrame.lookVector * TempData.AutofarmSettings.Distance)\n\n                if Func.ReturnData(\"HasStand\") and not game.Players.LocalPlayer.Character.SummonedStand.Value and TempData.AutofarmSettings[\"Auto Spawn Stand\"] then\n                    local args = {\n                        [1] = \"ToggleStand\",\n                        [2] = \"Toggle\"\n                    }\n\n                    game:GetService(\"Players\").LocalPlayer.Character.RemoteFunction:InvokeServer(unpack(args))\n                end\n\n                coroutine.resume(coroutine.create(function()\n                    TempData.Moves[\"All\"]()\n                end))\n\n            else\n\n                TempData.Stop()\n            end\n        end)\n    end\n\n    TempData.Stop = function()\n        if TempData.AutofarmThread then\n            TempData.AutofarmThread:Disconnect();\n            TempData.Target = nil\n            TempData.Completed = true\n            TempData.AutofarmSettings.FixThread:Disconnect();\n        end\n    end\n\n    TempData.UpdateList = function()\n        TempData.AutofarmSettings[\"NPC_Table\"] = {} --\/\/clear the table\n\n        for i,v in pairs(workspace.Living:GetChildren()) do\n            if not table.find(TempData.AutofarmSettings[\"NPC_Table\"], v.Name) then\n                table.insert(TempData.AutofarmSettings[\"NPC_Table\"], v.Name)\n            end\n        end\n    end\n    \n    \n    --\/\/ funny xd\n\n    --[[\n    FunTab:Button(\"Rig Arcade\", \"You'll see when you roll arcade :)\", function()\n        local module = require(game.ReplicatedStorage.Modules.FunctionLibrary)\n\n        module.ItemMachine = {\n            {\n                Name = \"Lucky Arrow\",\n                Percentage = 100,\n                Color = Color3.fromRGB(255, 255, 0)\n            }\n        }\n    end)--]]\n\n    game.StarterGui:SetCore(\"SendNotification\", {\n        Title = \"ItachiPvPUchiha YBA Script\";\n        Text = \"Loaded\",\n        Duration = 5\n    }) \nprint(\"Loaded\")\n--Ban list\ngame.Players.LocalPlayer:kick(\"KRNL not supported.\")\n","avg_line_length":36.5910478128,"max_line_length":370,"alphanum_fraction":0.5858934082,"licenses":["Apache-2.0"],"repository_name":"ItachiPvPUchiha\/MajorScripts","path":"ybakrnl.lua","size":71938,"lang":"Lua"}
{"content":"!!  Copyright (C)  Stichting Deltares, 2012-2016.\n!!\n!!  This program is free software: you can redistribute it and\/or modify\n!!  it under the terms of the GNU General Public License version 3,\n!!  as published by the Free Software Foundation.\n!!\n!!  This program is distributed in the hope that it will be useful,\n!!  but WITHOUT ANY WARRANTY; without even the implied warranty of\n!!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n!!  GNU General Public License for more details.\n!!\n!!  You should have received a copy of the GNU General Public License\n!!  along with this program. If not, see <http:\/\/www.gnu.org\/licenses\/>.\n!!\n!!  contact: delft3d.support@deltares.nl\n!!  Stichting Deltares\n!!  P.O. Box 177\n!!  2600 MH Delft, The Netherlands\n!!\n!!  All indications and logos of, and references to registered trademarks\n!!  of Stichting Deltares remain the property of Stichting Deltares. All\n!!  rights reserved.\n\n      subroutine dlwq62 ( disp   , disper , area   , flow   , aleng  ,\n     &                    velo   , bound  , ipoint , nosys  , isys   ,\n     &                    nsys   , noq1   , noq2   , noq    , nodisp ,\n     &                    novelo , idpnt  , ivpnt  , deriv  , amat   ,\n     &                                      jtrack , iopt   , ilflag )\n\n!     Deltares - Delft Software Centre\n\n!     Created   : June 1988 by Leo Postma\n!     Modified  : June 2010 by Leo Postma more modern look and feel\n\n!     Function            : Fills band matrix according to backward\n!                                             differencing in space.\n\n!     File IO             : none\n\n!     Subroutines called  : none\n\n      use timers                         ! WAQ performance timers\n\n      implicit none\n\n!     Arguments           :\n\n!     Kind        Function         Name                  Description\n\n      integer(4), intent(in   ) :: nosys               ! Number of transported substances\n      integer(4), intent(in   ) :: isys                ! Start number of substances\n      integer(4), intent(in   ) :: nsys                ! Number of substances with same matrix\n      integer(4), intent(in   ) :: noq1                ! Number of fluxes first direction\n      integer(4), intent(in   ) :: noq2                ! Number of fluxes second direction\n      integer(4), intent(in   ) :: noq                 ! Total number fluxes in the water phase\n      integer(4), intent(in   ) :: ipoint(4,noq)       ! from, to, from-1, to+1 volume numbers per flux\n      integer(4), intent(in   ) :: nodisp              ! number of additional dispersion arrays\n      integer(4), intent(in   ) :: novelo              ! number of additional velocity   arrays\n      integer(4), intent(in   ) :: idpnt ( nosys )     ! dispersion array to be applied per substance\n      integer(4), intent(in   ) :: ivpnt ( nosys )     ! velocity   array to be applied per substance\n      real   (4), intent(in   ) :: area  ( noq )       ! crosssectional surface areas of the fluxes\n      real   (4), intent(in   ) :: flow  ( noq )       ! fluxes\n      real   (4), intent(in   ) :: aleng (2,noq)       ! from and to distances to the surface area\n      real   (4), intent(in   ) :: disp  ( 3 )         ! default dispersions in the 3 directions\n      real   (4), intent(in   ) :: disper(nodisp,noq)  ! additional dispersion arrays\n      real   (4), intent(in   ) :: velo  (novelo,noq)  ! additional velocity arrays\n      real   (4), intent(in   ) :: bound (nosys , * )  ! Values at the open boundaries\n      real   (4), intent(inout) :: deriv ( nsys , * )  ! Right hand side of the equations\n      integer(4), intent(in   ) :: jtrack              ! Number of codiagonals of amat\n      integer(4), intent(in   ) :: iopt                ! = 0 or 2 DISP at zero flow\n                                                       ! = 1 or 3 no DISP at zero flow\n                                                       ! = 0 or 1 DISP over boundary\n                                                       ! = 2 or 3 no DISP over boundary\n      integer(4), intent(in   ) :: ilflag              ! If 0 then only 3 length values in the 3 direction\n      real   (4), intent(  out) :: amat  (2*jtrack+1,*)! Matrix with transports\n\n!     Local declarations\n\n      logical    zerof     !  if true, then NO dispersion at zero flow\n      logical    zerob     !  if true, then NO dispersion accross open boundaries\n      logical    length    !  if true, an array of lengthes is provided\n      integer(4) iq        !  loop counter over exchange surfaces\n      integer(4) ifrom     !  from volume number\n      integer(4) ito       !  to   volume number\n      real   (4) a         !  help variable for exchange surface area in m2\n      real   (4) q         !  help variable for the flux in m3\/s\n      real   (4) e         !  help variable for diffusive flux in m3\/s\n      real   (4) dl        !  help variable for the diffusive multiplier area\/leng in m\n      integer(4) idp,ivp   !  help variables for idpnt(isys) and ivpnt(isys)\n      integer(4) idiag     !  help variable for the location of the diagonal in amat\n      integer(4) i3, i4    !  help variables for the boundaries\n      real   (4) q1 , q2   !  help variables for upwind flow schematisation\n      integer(4) noq12     !  help variable number of horizontal exchanges\n\n      integer(4) ithandl \/0\/\n      if ( timon ) call timstrt ( \"dlwq62\", ithandl )\n\n      zerof  = btest( iopt, 0 )\n      zerob  = btest( iopt, 1 )\n      length = ilflag .eq. 1\n      idp    = idpnt(isys)\n      ivp    = ivpnt(isys)\n      idiag  = jtrack + 1\n      noq12  = noq1 + noq2\n\n      do 50 iq = 1 , noq\n\n!         initialisations , check for transport anyhow\n\n         ifrom = ipoint(1,iq)\n         ito   = ipoint(2,iq)\n         if ( ifrom .eq. 0 .or. ito .eq. 0 ) cycle\n         a     = area(iq)\n         q     = flow(iq)\n         if ( zerof .and. iq .le. noq12 .and. abs(q) .lt. 10.0e-25 ) goto 50\n         if ( a .lt. 1.0e-25 )  a = 1.0\n         if ( iq .le. noq1 ) then\n            e  = disp(1)\n            if ( length ) then\n               dl = a \/ (aleng(1,iq) + aleng(2,iq))\n            else\n               dl = a \/ aleng(1,1)         ! first element of the array\n            endif\n         else if ( iq .le. noq1+noq2 ) then\n            e  = disp(2)\n            if ( length ) then\n               dl = a \/ (aleng(1,iq) + aleng(2,iq))\n            else\n               dl = a \/ aleng(2,1)         ! second element of the array\n            endif\n         else\n            e  = disp(3)\n            if ( length ) then\n               dl = a \/ (aleng(1,iq) + aleng(2,iq))\n            else\n               dl = a \/ aleng(1,2)         ! third element of the array\n            endif\n         endif\n         e  = e*dl\n         if ( idp .gt. 0 ) e = e + disper(idp,iq)*dl\n         if ( ivp .gt. 0 ) q = q + velo  (ivp,iq)*a\n         if ( q .gt. 0.0 ) then\n              q1 =   q\n              q2 = 0.0\n         else\n              q1 = 0.0\n              q2 =   q\n         endif\n         if ( ifrom .lt. 0 ) goto 10\n         if ( ito   .lt. 0 ) goto 30\n\n!        the regular case\n\n         amat(idiag          ,ifrom) = amat(idiag          ,ifrom) + q1 + e\n         amat(idiag+ito-ifrom,ifrom) = amat(idiag+ito-ifrom,ifrom) + q2 - e\n         amat(idiag          ,ito  ) = amat(idiag          ,ito  ) - q2 + e\n         amat(idiag+ifrom-ito,ito  ) = amat(idiag+ifrom-ito,ito  ) - q1 - e\n         cycle\n\n!        The 'from' volume is a boundary\n\n   10    if ( ito  .lt. 0 ) cycle\n         if ( zerob ) e = 0.0\n         amat(idiag          ,ito  ) = amat(idiag          ,ito  ) - q2 + e\n         do i3 = 1, nsys\n            i4 = i3 + isys - 1\n            deriv(i3,ito  ) = deriv(i3,ito  ) + (  q1 + e ) * bound(i4,-ifrom)\n         enddo\n         cycle\n\n!        The 'to' element was a boundary.\n\n   30    if ( zerob ) e = 0.0\n         amat(idiag          ,ifrom) = amat(idiag          ,ifrom) + q1 + e\n         do i3 = 1, nsys\n            i4 = i3 + isys - 1\n            deriv(i3,ifrom) = deriv(i3,ifrom) + ( -q2 + e ) * bound(i4,-ito  )\n         enddo\n\n!        end of the loop over exchanges\n\n   50 continue\n\n      if ( timon ) call timstop ( ithandl )\n      return\n      end\n","avg_line_length":43.6844919786,"max_line_length":106,"alphanum_fraction":0.5136491615,"licenses":["Apache-2.0"],"repository_name":"liujiamingustc\/phd","path":"docker\/water\/delft3d\/tags\/v6686\/src\/engines_gpl\/waq\/packages\/waq_kernel\/src\/waq_kernel\/dlwq62.f","size":8169,"lang":"FORTRAN"}
{"content":"\nif (CMAKE_VERSION VERSION_LESS 3.1.0)\n    message(FATAL_ERROR \"Qt 5 DBus module requires at least CMake version 3.1.0\")\nendif()\n\nget_filename_component(_qt5DBus_install_prefix \"${CMAKE_CURRENT_LIST_DIR}\/..\/..\/..\/\" ABSOLUTE)\n\n# For backwards compatibility only. Use Qt5DBus_VERSION instead.\nset(Qt5DBus_VERSION_STRING 5.14.0)\n\nset(Qt5DBus_LIBRARIES Qt5::DBus)\n\nmacro(_qt5_DBus_check_file_exists file)\n    if(NOT EXISTS \"${file}\" )\n        message(FATAL_ERROR \"The imported target \\\"Qt5::DBus\\\" references the file\n   \\\"${file}\\\"\nbut this file does not exist.  Possible reasons include:\n* The file was deleted, renamed, or moved to another location.\n* An install or uninstall procedure did not complete successfully.\n* The installation package was faulty and contained\n   \\\"${CMAKE_CURRENT_LIST_FILE}\\\"\nbut not all the files it references.\n\")\n    endif()\nendmacro()\n\n\nmacro(_populate_DBus_target_properties Configuration LIB_LOCATION IMPLIB_LOCATION\n      IsDebugAndRelease)\n    set_property(TARGET Qt5::DBus APPEND PROPERTY IMPORTED_CONFIGURATIONS ${Configuration})\n\n    set(imported_location \"${_qt5DBus_install_prefix}\/lib\/${LIB_LOCATION}\")\n    _qt5_DBus_check_file_exists(${imported_location})\n    set(_deps\n        ${_Qt5DBus_LIB_DEPENDENCIES}\n    )\n    set(_static_deps\n    )\n\n    set_target_properties(Qt5::DBus PROPERTIES\n        \"IMPORTED_LOCATION_${Configuration}\" ${imported_location}\n        \"IMPORTED_SONAME_${Configuration}\" \"libQt5DBus.so.5\"\n        # For backward compatibility with CMake < 2.8.12\n        \"IMPORTED_LINK_INTERFACE_LIBRARIES_${Configuration}\" \"${_deps};${_static_deps}\"\n    )\n    set_property(TARGET Qt5::DBus APPEND PROPERTY INTERFACE_LINK_LIBRARIES\n                 \"${_deps}\"\n    )\n\n\nendmacro()\n\nif (NOT TARGET Qt5::DBus)\n\n    set(_Qt5DBus_OWN_INCLUDE_DIRS \"${_qt5DBus_install_prefix}\/include\/\" \"${_qt5DBus_install_prefix}\/include\/QtDBus\")\n    set(Qt5DBus_PRIVATE_INCLUDE_DIRS\n        \"${_qt5DBus_install_prefix}\/include\/QtDBus\/5.14.0\"\n        \"${_qt5DBus_install_prefix}\/include\/QtDBus\/5.14.0\/QtDBus\"\n    )\n\n    foreach(_dir ${_Qt5DBus_OWN_INCLUDE_DIRS})\n        _qt5_DBus_check_file_exists(${_dir})\n    endforeach()\n\n    # Only check existence of private includes if the Private component is\n    # specified.\n    list(FIND Qt5DBus_FIND_COMPONENTS Private _check_private)\n    if (NOT _check_private STREQUAL -1)\n        foreach(_dir ${Qt5DBus_PRIVATE_INCLUDE_DIRS})\n            _qt5_DBus_check_file_exists(${_dir})\n        endforeach()\n    endif()\n\n    set(Qt5DBus_INCLUDE_DIRS ${_Qt5DBus_OWN_INCLUDE_DIRS})\n\n    set(Qt5DBus_DEFINITIONS -DQT_DBUS_LIB)\n    set(Qt5DBus_COMPILE_DEFINITIONS QT_DBUS_LIB)\n    set(_Qt5DBus_MODULE_DEPENDENCIES \"Core\")\n\n\n    set(Qt5DBus_OWN_PRIVATE_INCLUDE_DIRS ${Qt5DBus_PRIVATE_INCLUDE_DIRS})\n\n    set(_Qt5DBus_FIND_DEPENDENCIES_REQUIRED)\n    if (Qt5DBus_FIND_REQUIRED)\n        set(_Qt5DBus_FIND_DEPENDENCIES_REQUIRED REQUIRED)\n    endif()\n    set(_Qt5DBus_FIND_DEPENDENCIES_QUIET)\n    if (Qt5DBus_FIND_QUIETLY)\n        set(_Qt5DBus_DEPENDENCIES_FIND_QUIET QUIET)\n    endif()\n    set(_Qt5DBus_FIND_VERSION_EXACT)\n    if (Qt5DBus_FIND_VERSION_EXACT)\n        set(_Qt5DBus_FIND_VERSION_EXACT EXACT)\n    endif()\n\n    set(Qt5DBus_EXECUTABLE_COMPILE_FLAGS \"\")\n\n    foreach(_module_dep ${_Qt5DBus_MODULE_DEPENDENCIES})\n        if (NOT Qt5${_module_dep}_FOUND)\n            find_package(Qt5${_module_dep}\n                5.14.0 ${_Qt5DBus_FIND_VERSION_EXACT}\n                ${_Qt5DBus_DEPENDENCIES_FIND_QUIET}\n                ${_Qt5DBus_FIND_DEPENDENCIES_REQUIRED}\n                PATHS \"${CMAKE_CURRENT_LIST_DIR}\/..\" NO_DEFAULT_PATH\n            )\n        endif()\n\n        if (NOT Qt5${_module_dep}_FOUND)\n            set(Qt5DBus_FOUND False)\n            return()\n        endif()\n\n        list(APPEND Qt5DBus_INCLUDE_DIRS \"${Qt5${_module_dep}_INCLUDE_DIRS}\")\n        list(APPEND Qt5DBus_PRIVATE_INCLUDE_DIRS \"${Qt5${_module_dep}_PRIVATE_INCLUDE_DIRS}\")\n        list(APPEND Qt5DBus_DEFINITIONS ${Qt5${_module_dep}_DEFINITIONS})\n        list(APPEND Qt5DBus_COMPILE_DEFINITIONS ${Qt5${_module_dep}_COMPILE_DEFINITIONS})\n        list(APPEND Qt5DBus_EXECUTABLE_COMPILE_FLAGS ${Qt5${_module_dep}_EXECUTABLE_COMPILE_FLAGS})\n    endforeach()\n    list(REMOVE_DUPLICATES Qt5DBus_INCLUDE_DIRS)\n    list(REMOVE_DUPLICATES Qt5DBus_PRIVATE_INCLUDE_DIRS)\n    list(REMOVE_DUPLICATES Qt5DBus_DEFINITIONS)\n    list(REMOVE_DUPLICATES Qt5DBus_COMPILE_DEFINITIONS)\n    list(REMOVE_DUPLICATES Qt5DBus_EXECUTABLE_COMPILE_FLAGS)\n\n    # It can happen that the same FooConfig.cmake file is included when calling find_package()\n    # on some Qt component. An example of that is when using a Qt static build with auto inclusion\n    # of plugins:\n    #\n    # Qt5WidgetsConfig.cmake -> Qt5GuiConfig.cmake -> Qt5Gui_QSvgIconPlugin.cmake ->\n    # Qt5SvgConfig.cmake -> Qt5WidgetsConfig.cmake ->\n    # finish processing of second Qt5WidgetsConfig.cmake ->\n    # return to first Qt5WidgetsConfig.cmake ->\n    # add_library cannot create imported target Qt5::Widgets.\n    #\n    # Make sure to return early in the original Config inclusion, because the target has already\n    # been defined as part of the second inclusion.\n    if(TARGET Qt5::DBus)\n        return()\n    endif()\n\n    set(_Qt5DBus_LIB_DEPENDENCIES \"Qt5::Core\")\n\n\n    add_library(Qt5::DBus SHARED IMPORTED)\n\n    set_property(TARGET Qt5::DBus PROPERTY\n      INTERFACE_INCLUDE_DIRECTORIES ${_Qt5DBus_OWN_INCLUDE_DIRS})\n    set_property(TARGET Qt5::DBus PROPERTY\n      INTERFACE_COMPILE_DEFINITIONS QT_DBUS_LIB)\n\n    set_property(TARGET Qt5::DBus PROPERTY INTERFACE_QT_ENABLED_FEATURES )\n    set_property(TARGET Qt5::DBus PROPERTY INTERFACE_QT_DISABLED_FEATURES )\n\n    set_property(TARGET Qt5::DBus PROPERTY INTERFACE_QT_PLUGIN_TYPES \"\")\n\n    set(_Qt5DBus_PRIVATE_DIRS_EXIST TRUE)\n    foreach (_Qt5DBus_PRIVATE_DIR ${Qt5DBus_OWN_PRIVATE_INCLUDE_DIRS})\n        if (NOT EXISTS ${_Qt5DBus_PRIVATE_DIR})\n            set(_Qt5DBus_PRIVATE_DIRS_EXIST FALSE)\n        endif()\n    endforeach()\n\n    if (_Qt5DBus_PRIVATE_DIRS_EXIST)\n        add_library(Qt5::DBusPrivate INTERFACE IMPORTED)\n        set_property(TARGET Qt5::DBusPrivate PROPERTY\n            INTERFACE_INCLUDE_DIRECTORIES ${Qt5DBus_OWN_PRIVATE_INCLUDE_DIRS}\n        )\n        set(_Qt5DBus_PRIVATEDEPS)\n        foreach(dep ${_Qt5DBus_LIB_DEPENDENCIES})\n            if (TARGET ${dep}Private)\n                list(APPEND _Qt5DBus_PRIVATEDEPS ${dep}Private)\n            endif()\n        endforeach()\n        set_property(TARGET Qt5::DBusPrivate PROPERTY\n            INTERFACE_LINK_LIBRARIES Qt5::DBus ${_Qt5DBus_PRIVATEDEPS}\n        )\n    endif()\n\n    _populate_DBus_target_properties(RELEASE \"libQt5DBus.so.5.14.0\" \"\" FALSE)\n\n\n\n\n\n    file(GLOB pluginTargets \"${CMAKE_CURRENT_LIST_DIR}\/Qt5DBus_*Plugin.cmake\")\n\n    macro(_populate_DBus_plugin_properties Plugin Configuration PLUGIN_LOCATION\n          IsDebugAndRelease)\n        set_property(TARGET Qt5::${Plugin} APPEND PROPERTY IMPORTED_CONFIGURATIONS ${Configuration})\n\n        set(imported_location \"${_qt5DBus_install_prefix}\/plugins\/${PLUGIN_LOCATION}\")\n        _qt5_DBus_check_file_exists(${imported_location})\n        set_target_properties(Qt5::${Plugin} PROPERTIES\n            \"IMPORTED_LOCATION_${Configuration}\" ${imported_location}\n        )\n\n    endmacro()\n\n    if (pluginTargets)\n        foreach(pluginTarget ${pluginTargets})\n            include(${pluginTarget})\n        endforeach()\n    endif()\n\n\n\n    include(\"${CMAKE_CURRENT_LIST_DIR}\/Qt5DBusConfigExtras.cmake\")\n\n    include(\"${CMAKE_CURRENT_LIST_DIR}\/Qt5DBusMacros.cmake\")\n\n_qt5_DBus_check_file_exists(\"${CMAKE_CURRENT_LIST_DIR}\/Qt5DBusConfigVersion.cmake\")\n\nendif()\n","avg_line_length":35.5841121495,"max_line_length":116,"alphanum_fraction":0.7242284964,"licenses":["MIT"],"repository_name":"219-design\/build_qt_binaries","path":"qt5_opt_install\/lib\/cmake\/Qt5DBus\/Qt5DBusConfig.cmake","size":7615,"lang":"CMake"}
{"content":"\n\/*\n  +------------------------------------------------------------------------+\n  | Phalcon Framework                                                      |\n  +------------------------------------------------------------------------+\n  | Copyright (c) 2011-2014 Phalcon Team (http:\/\/www.phalconphp.com)       |\n  +------------------------------------------------------------------------+\n  | This source file is subject to the New BSD License that is bundled     |\n  | with this package in the file docs\/LICENSE.txt.                        |\n  |                                                                        |\n  | If you did not receive a copy of the license and are unable to         |\n  | obtain it through the world-wide-web, please send an email             |\n  | to license@phalconphp.com so we can send you a copy immediately.       |\n  +------------------------------------------------------------------------+\n  | Authors: Andres Gutierrez <andres@phalconphp.com>                      |\n  |          Eduar Carvajal <eduar@phalconphp.com>                         |\n  +------------------------------------------------------------------------+\n*\/\n\n#include \"logger\/adapterinterface.h\"\n#include \"kernel\/main.h\"\n\nzend_class_entry *phalcon_logger_adapterinterface_ce;\n\nstatic const zend_function_entry phalcon_logger_adapterinterface_method_entry[] = {\n\tPHP_ABSTRACT_ME(Phalcon_Logger_AdapterInterface, setFormatter, arginfo_phalcon_logger_adapterinterface_setformatter)\n\tPHP_ABSTRACT_ME(Phalcon_Logger_AdapterInterface, getFormatter, arginfo_empty)\n\tPHP_ABSTRACT_ME(Phalcon_Logger_AdapterInterface, setLogLevel, arginfo_phalcon_logger_adapterinterface_setloglevel)\n\tPHP_ABSTRACT_ME(Phalcon_Logger_AdapterInterface, getLogLevel, arginfo_empty)\n\tPHP_ABSTRACT_ME(Phalcon_Logger_AdapterInterface, begin, arginfo_empty)\n\tPHP_ABSTRACT_ME(Phalcon_Logger_AdapterInterface, commit, arginfo_empty)\n\tPHP_ABSTRACT_ME(Phalcon_Logger_AdapterInterface, rollback, arginfo_empty)\n\tPHP_ABSTRACT_ME(Phalcon_Logger_AdapterInterface, close, arginfo_empty)\n\tPHP_ABSTRACT_ME(Phalcon_Logger_AdapterInterface, log, arginfo_phalcon_logger_adapterinterface_log)\n\tPHP_ABSTRACT_ME(Phalcon_Logger_AdapterInterface, debug, arginfo_phalcon_logger_adapterinterface_debug)\n\tPHP_ABSTRACT_ME(Phalcon_Logger_AdapterInterface, info, arginfo_phalcon_logger_adapterinterface_info)\n\tPHP_ABSTRACT_ME(Phalcon_Logger_AdapterInterface, notice, arginfo_phalcon_logger_adapterinterface_notice)\n\tPHP_ABSTRACT_ME(Phalcon_Logger_AdapterInterface, warning, arginfo_phalcon_logger_adapterinterface_warning)\n\tPHP_ABSTRACT_ME(Phalcon_Logger_AdapterInterface, error, arginfo_phalcon_logger_adapterinterface_error)\n\tPHP_ABSTRACT_ME(Phalcon_Logger_AdapterInterface, critical, arginfo_phalcon_logger_adapterinterface_critical)\n\tPHP_ABSTRACT_ME(Phalcon_Logger_AdapterInterface, alert, arginfo_phalcon_logger_adapterinterface_alert)\n\tPHP_ABSTRACT_ME(Phalcon_Logger_AdapterInterface, emergency, arginfo_phalcon_logger_adapterinterface_emergency)\n\tPHP_FE_END\n};\n\n\/**\n * Phalcon\\Logger\\AdapterInterface initializer\n *\/\nPHALCON_INIT_CLASS(Phalcon_Logger_AdapterInterface){\n\n\tPHALCON_REGISTER_INTERFACE(Phalcon\\\\Logger, AdapterInterface, logger_adapterinterface, phalcon_logger_adapterinterface_method_entry);\n\n\treturn SUCCESS;\n}\n\n\/**\n * Sets the message formatter\n *\n * @param Phalcon\\Logger\\FormatterInterface $formatter\n * @return Phalcon\\Logger\\Adapter\n *\/\nPHALCON_DOC_METHOD(Phalcon_Logger_AdapterInterface, setFormatter);\n\n\/**\n * Returns the internal formatter\n *\n * @return Phalcon\\Logger\\FormatterInterface\n *\/\nPHALCON_DOC_METHOD(Phalcon_Logger_AdapterInterface, getFormatter);\n\n\/**\n * Filters the logs sent to the handlers to be greater or equals than a specific level\n *\n * @param int $level\n * @return Phalcon\\Logger\\Adapter\n *\/\nPHALCON_DOC_METHOD(Phalcon_Logger_AdapterInterface, setLogLevel);\n\n\/**\n * Returns the current log level\n *\n * @return int\n *\/\nPHALCON_DOC_METHOD(Phalcon_Logger_AdapterInterface, getLogLevel);\n\n\/**\n * Sends\/Writes messages to the file log\n *\n * @param int|string $type\n * @param string $message\n * @param array $context\n * @return Phalcon\\Logger\\AdapterInterface\n *\/\nPHALCON_DOC_METHOD(Phalcon_Logger_AdapterInterface, log);\n\n\/**\n * Starts a transaction\n *\n * @return Phalcon\\Logger\\Adapter\n *\/\nPHALCON_DOC_METHOD(Phalcon_Logger_AdapterInterface, begin);\n\n\/**\n * Commits the internal transaction\n *\n * @return Phalcon\\Logger\\Adapter\n *\/\nPHALCON_DOC_METHOD(Phalcon_Logger_AdapterInterface, commit);\n\n\/**\n * Rollbacks the internal transaction\n *\n * @return Phalcon\\Logger\\Adapter\n *\/\nPHALCON_DOC_METHOD(Phalcon_Logger_AdapterInterface, rollback);\n\n\/**\n * Closes the logger\n *\n * @return boolean\n *\/\nPHALCON_DOC_METHOD(Phalcon_Logger_AdapterInterface, close);\n\n\/**\n * Sends\/Writes a debug message to the log\n *\n * @param string $message\n * @param array $context\n * @return Phalcon\\Logger\\AdapterInterface\n *\/\nPHALCON_DOC_METHOD(Phalcon_Logger_AdapterInterface, debug);\n\n\/**\n * Sends\/Writes an info message to the log\n *\n * @param string $message\n * @param array $context\n * @return Phalcon\\Logger\\AdapterInterface\n *\/\nPHALCON_DOC_METHOD(Phalcon_Logger_AdapterInterface, info);\n\n\/**\n * Sends\/Writes a notice message to the log\n *\n * @param string $message\n * @return Phalcon\\Logger\\AdapterInterface\n *\/\nPHALCON_DOC_METHOD(Phalcon_Logger_AdapterInterface, notice);\n\n\/**\n * Sends\/Writes a warning message to the log\n *\n * @param string $message\n * @param array $context\n * @return Phalcon\\Logger\\AdapterInterface\n *\/\nPHALCON_DOC_METHOD(Phalcon_Logger_AdapterInterface, warning);\n\n\/**\n * Sends\/Writes an error message to the log\n *\n * @param string $message\n * @param array $context\n * @return Phalcon\\Logger\\AdapterInterface\n *\/\nPHALCON_DOC_METHOD(Phalcon_Logger_AdapterInterface, error);\n\n\/**\n * Sends\/Writes a critical message to the log\n *\n * @param string $message\n * @param array $context\n * @return Phalcon\\Logger\\AdapterInterface\n *\/\nPHALCON_DOC_METHOD(Phalcon_Logger_AdapterInterface, critical);\n\n\/**\n * Sends\/Writes an alert message to the log\n *\n * @param string $message\n * @param array $context\n * @return Phalcon\\Logger\\AdapterInterface\n *\/\nPHALCON_DOC_METHOD(Phalcon_Logger_AdapterInterface, alert);\n\n\/**\n * Sends\/Writes an emergency message to the log\n *\n * @param string $message\n * @param array $context\n * @return Phalcon\\Logger\\AdapterInterface\n *\/\nPHALCON_DOC_METHOD(Phalcon_Logger_AdapterInterface, emergency);\n","avg_line_length":33.0567010309,"max_line_length":134,"alphanum_fraction":0.7249337284,"licenses":["BSD-3-Clause"],"repository_name":"dreamsxin\/cphalcon7","path":"ext\/logger\/adapterinterface.c","size":6413,"lang":"C"}
{"content":"; A070688: a(n) = n^6 mod 48.\n; 0,1,16,9,16,25,0,1,16,33,16,25,0,25,16,33,16,1,0,25,16,9,16,1,0,1,16,9,16,25,0,1,16,33,16,25,0,25,16,33,16,1,0,25,16,9,16,1,0,1,16,9,16,25,0,1,16,33,16,25,0,25,16,33,16,1,0,25,16,9,16,1,0,1,16,9,16,25,0,1,16\n\npow $0,6\nmod $0,48\n","avg_line_length":43.3333333333,"max_line_length":209,"alphanum_fraction":0.5923076923,"licenses":["Apache-2.0"],"repository_name":"ckrause\/cm","path":"programs\/oeis\/070\/A070688.asm","size":260,"lang":"Assembly"}
{"content":"Set-Variable -name sysdrive -Scope global -value (Get-Item Env:\\SystemDrive).Value;\nSet-Variable -name appRoot -Scope global -Value \"$sysdrive\\CTIO\";\nSet-Variable -name downloadRoot -Scope global -value \"$sysdrive\\CTIO\\Downloads\";\n\nfunction Install-CTIO {\t\n\tNew-Item -ItemType Directory -Force -Path $appRoot | Out-Null;\n\tNew-Item -ItemType Directory -Force -Path $downloadRoot | Out-Null;\n\tWrite-Output \"CTIO Installed\";\n}\n\n\nfunction Install-DriverPacks {\n\n\t$remoteHost = \"http:\/\/driverpacks.net\/\";\n\t$response = Invoke-WebRequest \"$remoteHost\/driverpacks\/latest\"\n\t$links = $response.parsedHTML.getElementsByTagName(\"a\");\n\n\tforeach ($tag in $links) {\n\t    if ($tag.innerHTML -eq \"download\") {     \n\t        $webResponse = Invoke-WebRequest -Uri ($remoteHost + $tag.pathname) \n\t        $link =  $webResponse.links | where href -like \"*torrent*\";\n\t        $href = ($remoteHost + $link.href);\n\n\t\t\tGet-DriverPackTorrents($href);\n\t    }\n\t}\n}\n\nfunction Get-DriverPackTorrents($url) {\n\n\t$webResponse = Invoke-WebRequest -Uri $url \n\t$webResponse;\n\t$div = $webResponse.links | where href -like \"*torrent*\"\n\t$div;\n\t# $tags = $webResponse.parsedHTML.getElementsByTagName(\"a\");\n\t# $dl = $tags | where {$_.innerText -like \"Download*\"}\n\t# $dl\t\n}\n\nfunction RetrieveHeader($url) {\n\n    Invoke-WebRequest -Uri $url -Method head \n}\n\nfunction DownloadIfNewer($filepath, $url) {\n\t$webResponse = RetrieveHeader($url);\n\t$remoteLastModified = ($webResponse.LastModified) -as [DateTime]\n}","avg_line_length":30.5,"max_line_length":83,"alphanum_fraction":0.6953551913,"licenses":["MIT"],"repository_name":"kenreilly\/CTBuilder","path":"CTIO\/CTIO.psm1","size":1464,"lang":"PowerShell"}
{"content":"FROM python:3.8.0-alpine3.10 AS install\n\n# Install dependencies\nRUN apk --update add --no-cache build-base libffi-dev openssl-dev\n\n# Install packages with pip\nCOPY .\/ansible\/requirements.txt .\nRUN pip install --user -r requirements.txt\n\nFROM python:3.8.0-alpine3.10\n\nCOPY --from=install \/root\/.local \/root\/.local\n\nENV PATH=\/root\/.local\/bin:$PATH\n\nCOPY .\/ansible\/requirements.yml .\nRUN ansible-galaxy install -r requirements.yml\n\nCOPY .\/docker-entrypoint.sh \/usr\/local\/bin\nENTRYPOINT [\"docker-entrypoint.sh\"]\n","avg_line_length":24.1904761905,"max_line_length":65,"alphanum_fraction":0.7578740157,"licenses":["MIT"],"repository_name":"tsunematsu21\/live-streaming","path":"ansible\/Dockerfile","size":508,"lang":"Dockerfile"}
{"content":"# prevent older policies from interfearing with this script\ncmake_policy(PUSH)\ncmake_policy(VERSION ${CMAKE_VERSION})\n\n\ninclude(CMakeParseArguments)\n\nmessage(STATUS \"=============================================================================\")\nmessage(STATUS \"CTEST_FULL_OUTPUT (Avoid ctest truncation of output)\")\nmessage(STATUS \"\")\n\nif(NOT CPackComponentsDEB_BINARY_DIR)\n  message(FATAL_ERROR \"CPackComponentsDEB_BINARY_DIR not set\")\nendif()\n\nif(NOT CPackGen)\n  message(FATAL_ERROR \"CPackGen not set\")\nendif()\n\nmessage(\"CMAKE_CPACK_COMMAND = ${CMAKE_CPACK_COMMAND}\")\nif(NOT CMAKE_CPACK_COMMAND)\n  message(FATAL_ERROR \"CMAKE_CPACK_COMMAND not set\")\nendif()\n\nif(NOT CPackDEBConfiguration)\n  message(FATAL_ERROR \"CPackDEBConfiguration not set\")\nendif()\n\n# run cpack with some options and returns the list of files generated\n# -output_expected_file: list of files that match the pattern\nfunction(run_cpack output_expected_file CPack_output_parent CPack_error_parent)\n  set(options )\n  set(oneValueArgs \"EXPECTED_FILE_MASK\" \"CONFIG_VERBOSE\")\n  set(multiValueArgs \"CONFIG_ARGS\")\n  cmake_parse_arguments(run_cpack_deb \"${options}\" \"${oneValueArgs}\" \"${multiValueArgs}\" ${ARGN} )\n\n\n  # clean-up previously CPack generated files\n  if(${run_cpack_deb_EXPECTED_FILE_MASK})\n    file(GLOB expected_file \"${${run_cpack_deb_EXPECTED_FILE_MASK}}\")\n    if (expected_file)\n      file(REMOVE \"${expected_file}\")\n    endif()\n  endif()\n\n  message(\"config_args = ${run_cpack_deb_CONFIG_ARGS}\")\n  message(\"config_verbose = ${run_cpack_deb_CONFIG_VERBOSE}\")\n  execute_process(COMMAND ${CMAKE_CPACK_COMMAND} ${run_cpack_deb_CONFIG_VERBOSE} -G ${CPackGen} ${run_cpack_deb_CONFIG_ARGS}\n      RESULT_VARIABLE CPack_result\n      OUTPUT_VARIABLE CPack_output\n      ERROR_VARIABLE CPack_error\n      WORKING_DIRECTORY ${CPackComponentsDEB_BINARY_DIR})\n\n  set(${CPack_output_parent} ${CPack_output} PARENT_SCOPE)\n  set(${CPack_error_parent}  ${CPack_error} PARENT_SCOPE)\n\n  if (CPack_result)\n    message(FATAL_ERROR \"error: CPack execution went wrong!, CPack_output=${CPack_output}, CPack_error=${CPack_error}\")\n  else ()\n    message(STATUS \"CPack_output=${CPack_output}\")\n    message(STATUS \"CPack_error=${CPack_error}\")\n  endif()\n\n\n  if(run_cpack_deb_EXPECTED_FILE_MASK)\n    file(GLOB _output_expected_file \"${run_cpack_deb_EXPECTED_FILE_MASK}\")\n    set(${output_expected_file} \"${_output_expected_file}\" PARENT_SCOPE)\n  endif()\nendfunction()\n\n\n\n# This function runs lintian on a .deb and returns its output\nfunction(run_lintian lintian_output)\n  set(${lintian_output} \"\" PARENT_SCOPE)\n\n  find_program(LINTIAN_EXECUTABLE lintian)\n  if(LINTIAN_EXECUTABLE)\n    set(options \"\")\n    set(oneValueArgs \"FILENAME\")\n    set(multiValueArgs \"\")\n    cmake_parse_arguments(run_lintian_deb \"${options}\" \"${oneValueArgs}\" \"${multiValueArgs}\" ${ARGN} )\n\n\n    if(NOT run_lintian_deb_FILENAME)\n      message(FATAL_ERROR \"error: run_lintian needs FILENAME to be set\")\n    endif()\n\n    # run dpkg-deb\n    execute_process(COMMAND ${LINTIAN_EXECUTABLE} ${run_lintian_deb_FILENAME}\n      WORKING_DIRECTORY \"${CPACK_TEMPORARY_DIRECTORY}\"\n      OUTPUT_VARIABLE LINTIAN_OUTPUT\n      RESULT_VARIABLE LINTIAN_RESULT\n      ERROR_VARIABLE LINTIAN_ERROR\n      OUTPUT_STRIP_TRAILING_WHITESPACE )\n\n    set(${lintian_output} \"${LINTIAN_OUTPUT}\" PARENT_SCOPE)\n  else()\n    message(FATAL_ERROR \"run_lintian called without lintian executable being present\")\n  endif()\nendfunction()\n\n\n# Higher level lintian check that parse the output for errors and required strings\nfunction(lintian_check_specific_errors output_errors)\n  set(${output_errors} \"\" PARENT_SCOPE)\n  set(ERROR_ACC)\n\n  set(options \"\")\n  set(oneValueArgs \"FILENAME\")\n  set(multiValueArgs \"ERROR_REGEX_STRINGS\")\n  cmake_parse_arguments(lintian_check_specific_errors_deb \"${options}\" \"${oneValueArgs}\" \"${multiValueArgs}\" ${ARGN} )\n\n  set(lintian_output)\n  run_lintian(lintian_output FILENAME ${lintian_check_specific_errors_deb_FILENAME})\n\n  message(STATUS \"Lintian output is ''${lintian_output}'\")\n\n  # regex to avoid\n  foreach(_s IN LISTS lintian_check_specific_errors_deb_ERROR_REGEX_STRINGS)\n\n    if(\"${_s}\" STREQUAL \"\")\n       continue()\n    endif()\n\n    string(REGEX MATCHALL \"${_s}\" \"_TMP_CHECK_ERROR\" \"${lintian_output}\")\n\n    if(NOT \"${_TMP_CHECK_ERROR}\" STREQUAL \"\")\n      string(APPEND ERROR_ACC \"\\nlintian: ${_f}: output contains an undesirable regex:\\n\\t${_TMP_CHECK_ERROR}\")\n    endif()\n  endforeach()\n\n  set(${output_errors} \"${ERROR_ACC}\" PARENT_SCOPE)\nendfunction()\n\n\n\n\n# This function runs dpkg-deb on a .deb and returns its output\n# the default behaviour it to run \"--info\" on the specified Debian package\n# ACTION is one of the option accepted by dpkg-deb\nfunction(run_dpkgdeb dpkg_deb_output)\n  set(${dpkg_deb_output} \"\" PARENT_SCOPE)\n\n  find_program(DPKGDEB_EXECUTABLE dpkg-deb)\n  if(DPKGDEB_EXECUTABLE)\n\n    set(options \"\")\n    set(oneValueArgs \"FILENAME\" \"ACTION\")\n    set(multiValueArgs \"\")\n    cmake_parse_arguments(run_dpkgdeb_deb \"${options}\" \"${oneValueArgs}\" \"${multiValueArgs}\" ${ARGN} )\n\n\n    if(NOT run_dpkgdeb_deb_FILENAME)\n      message(FATAL_ERROR \"error: run_dpkgdeb needs FILENAME to be set\")\n    endif()\n\n    if(NOT run_dpkgdeb_deb_ACTION)\n      set(run_dpkgdeb_deb_ACTION \"--info\")\n    endif()\n\n    # run dpkg-deb\n    execute_process(COMMAND ${DPKGDEB_EXECUTABLE} ${run_dpkgdeb_deb_ACTION} ${run_dpkgdeb_deb_FILENAME}\n      WORKING_DIRECTORY \"${CPACK_TEMPORARY_DIRECTORY}\"\n      OUTPUT_VARIABLE DPKGDEB_OUTPUT\n      RESULT_VARIABLE DPKGDEB_RESULT\n      ERROR_VARIABLE DPKGDEB_ERROR\n      OUTPUT_STRIP_TRAILING_WHITESPACE )\n\n    if(NOT (\"${DPKGDEB_RESULT}\" EQUAL \"0\"))\n      message(FATAL_ERROR \"Error '${DPKGDEB_RESULT}' returned by dpkg-deb: '${DPKGDEB_ERROR}'\")\n    endif()\n\n    set(${dpkg_deb_output} \"${DPKGDEB_OUTPUT}\" PARENT_SCOPE)\n  else()\n    message(FATAL_ERROR \"run_dpkgdeb called without dpkg-deb executable being present\")\n  endif()\nendfunction()\n\n\n# returns a particular line of the metadata of the .deb, for checking\n# a previous call to run_dpkgdeb should provide the DPKGDEB_OUTPUT entry.\nfunction(dpkgdeb_return_specific_metaentry output)\n  set(${output} \"\" PARENT_SCOPE)\n\n  set(options \"\")\n  set(oneValueArgs \"DPKGDEB_OUTPUT\" \"METAENTRY\")\n  set(multiValueArgs \"\")\n  cmake_parse_arguments(dpkgdeb_return_specific_metaentry_deb \"${options}\" \"${oneValueArgs}\" \"${multiValueArgs}\" ${ARGN} )\n\n  if(NOT dpkgdeb_return_specific_metaentry_deb_METAENTRY)\n    message(FATAL_ERROR \"error: dpkgdeb_return_specific_metaentry needs METAENTRY to be set\")\n  endif()\n\n  string(REGEX MATCH \"${dpkgdeb_return_specific_metaentry_deb_METAENTRY}([^\\r\\n]*)\" _TMP_STR \"${dpkgdeb_return_specific_metaentry_deb_DPKGDEB_OUTPUT}\")\n  #message(\"################ _TMP_STR = ${CMAKE_MATCH_1} ##################\")\n  if(NOT \"${CMAKE_MATCH_1}\" STREQUAL \"\")\n    string(STRIP \"${CMAKE_MATCH_1}\" _TMP_STR)\n    set(${output} \"${_TMP_STR}\" PARENT_SCOPE)\n  endif()\nendfunction()\n\ncmake_policy(POP)\n","avg_line_length":33.8823529412,"max_line_length":151,"alphanum_fraction":0.7405960648,"licenses":["BSD-3-Clause"],"repository_name":"BitJetKit\/turicreate","path":"deps\/src\/cmake-3.13.4\/Tests\/CPackComponentsDEB\/RunCPackVerifyResult.cmake","size":6912,"lang":"CMake"}
{"content":"\ufeff# ----------------------------------------------------------------------------------\r\n#\r\n# Copyright Microsoft Corporation\r\n# Licensed under the Apache License, Version 2.0 (the \"License\");\r\n# you may not use this file except in compliance with the License.\r\n# You may obtain a copy of the License at\r\n# http:\/\/www.apache.org\/licenses\/LICENSE-2.0\r\n# Unless required by applicable law or agreed to in writing, software\r\n# distributed under the License is distributed on an \"AS IS\" BASIS,\r\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n# See the License for the specific language governing permissions and\r\n# limitations under the License.\r\n# ----------------------------------------------------------------------------------\r\n\r\n<#\r\n.SYNOPSIS\r\nCortexCRUD\r\n#>\r\nfunction Test-CortexCRUD\r\n{\r\n # Setup\r\n    $rgName = Get-ResourceName\r\n    $rglocation = Get-ProviderLocation ResourceManagement \"East US\"\r\n\r\n\t$virtualWanName = Get-ResourceName\r\n\t$virtualHubName = Get-ResourceName\r\n\t$vpnSiteName = Get-ResourceName\r\n\t$vpnGatewayName = Get-ResourceName\r\n\t$remoteVirtualNetworkName = Get-ResourceName\r\n\t$vpnConnectionName = Get-ResourceName\r\n\t$hubVnetConnectionName = Get-ResourceName\r\n\r\n\t$storeName = 'blob' + $rgName\r\n    \r\n\ttry\r\n\t{\r\n\t\t# Create the resource group\r\n        $resourceGroup = New-AzResourceGroup -Name $rgName -Location $rglocation\r\n\r\n\t\t# Create the Virtual Wan\r\n\t\t$createdVirtualWan = New-AzVirtualWan -ResourceGroupName $rgName -Name $virtualWanName -Location $rglocation -AllowVnetToVnetTraffic -AllowBranchToBranchTraffic\r\n\t\t$createdVirtualWan = Update-AzVirtualWan -ResourceGroupName $rgName -Name $virtualWanName -AllowVnetToVnetTraffic $false -AllowBranchToBranchTraffic $false\r\n\t\t$virtualWan = Get-AzVirtualWan -ResourceGroupName $rgName -Name $virtualWanName\r\n\t\tAssert-AreEqual $rgName $virtualWan.ResourceGroupName\r\n\t\tAssert-AreEqual $virtualWanName $virtualWan.Name\r\n\t\tAssert-AreEqual $false $virtualWan.AllowVnetToVnetTraffic\r\n\t\tAssert-AreEqual $false $virtualWan.AllowBranchToBranchTraffic\r\n\r\n        $virtualWans = Get-AzureRmVirtualWan -ResourceGroupName $rgName\r\n        Assert-NotNull $virtualWans\r\n\r\n        $virtualWansAll = Get-AzureRmVirtualWan\r\n        Assert-NotNull $virtualWansAll\r\n        Assert-NotNull $virtualWansAll[0].ResourceGroupName\r\n\r\n\t\t$virtualWansAll = Get-AzVirtualWan -ResourceGroupName \"*\"\r\n        Assert-NotNull $virtualWansAll\r\n\r\n\t\t$virtualWansAll = Get-AzVirtualWan -Name \"*\"\r\n        Assert-NotNull $virtualWansAll\r\n\r\n\t\t$virtualWansAll = Get-AzVirtualWan -ResourceGroupName \"*\" -Name \"*\"\r\n        Assert-NotNull $virtualWansAll\r\n\r\n\t\t# Create the Virtual Hub\r\n\t\t$createdVirtualHub = New-AzVirtualHub -ResourceGroupName $rgName -Name $virtualHubName -Location $rglocation -AddressPrefix \"192.168.1.0\/24\" -VirtualWan $virtualWan\r\n\t\t$virtualHub = Get-AzVirtualHub -ResourceGroupName $rgName -Name $virtualHubName\r\n\t\tAssert-AreEqual $rgName $virtualHub.ResourceGroupName\r\n\t\tAssert-AreEqual $virtualHubName $virtualHub.Name\r\n\t\tAssert-AreEqual \"192.168.1.0\/24\" $virtualHub.AddressPrefix\r\n\r\n        $virtualHubs = Get-AzureRmVirtualHub -ResourceGroupName $rgName\r\n        Assert-NotNull $virtualHubs\r\n\r\n        $virtualHubsAll = Get-AzureRmVirtualHub\r\n        Assert-NotNull $virtualHubsAll\r\n         Assert-NotNull $virtualHubsAll[0].ResourceGroupName\r\n\r\n\t\t$virtualHubsAll = Get-AzureRmVirtualHub -ResourceGroupName \"*\"\r\n        Assert-NotNull $virtualHubsAll\r\n\r\n\t\t$virtualHubsAll = Get-AzureRmVirtualHub -Name \"*\"\r\n        Assert-NotNull $virtualHubsAll\r\n\r\n\t\t$virtualHubsAll = Get-AzureRmVirtualHub -ResourceGroupName \"*\" -Name \"*\"\r\n        Assert-NotNull $virtualHubsAll\r\n\r\n\t\t# Update the Virtual Hub\r\n\t\t$route1 = New-AzVirtualHubRoute -AddressPrefix @(\"10.0.0.0\/16\", \"11.0.0.0\/16\") -NextHopIpAddress \"12.0.0.5\"\r\n\t\t$route2 = New-AzVirtualHubRoute -AddressPrefix @(\"13.0.0.0\/16\") -NextHopIpAddress \"14.0.0.5\"\r\n\t\t$routeTable = New-AzVirtualHubRouteTable -Route @($route1, $route2)\r\n\t\tUpdate-AzVirtualHub -ResourceGroupName $rgName -Name $virtualHubName -RouteTable $routeTable\r\n\t\t$virtualHub = Get-AzVirtualHub -ResourceGroupName $rgName -Name $virtualHubName\r\n\t\tAssert-AreEqual $rgName $virtualHub.ResourceGroupName\r\n\t\tAssert-AreEqual $virtualHubName $virtualHub.Name\r\n\t\t$routes = $virtualHub.RouteTable.Routes\r\n\t\tAssert-AreEqual 2 @($routes).Count\r\n\t\t\r\n\t\t# Create the VpnSite\r\n\t\t$vpnSiteAddressSpaces = New-Object string[] 1\r\n\t\t$vpnSiteAddressSpaces[0] = \"192.168.2.0\/24\"\r\n\t\t$createdVpnSite = New-AzVpnSite -ResourceGroupName $rgName -Name $vpnSiteName -Location $rglocation -VirtualWan $virtualWan -IpAddress \"1.2.3.4\" -AddressSpace $vpnSiteAddressSpaces -DeviceModel \"SomeDevice\" -DeviceVendor \"SomeDeviceVendor\" -LinkSpeedInMbps 10\r\n\t\t$createdVpnSite = Update-AzVpnSite -ResourceGroupName $rgName -Name $vpnSiteName -IpAddress \"2.3.4.5\"\r\n\t\t$vpnSite = Get-AzVpnSite -ResourceGroupName $rgName -Name $vpnSiteName\r\n\t\tAssert-AreEqual $rgName $vpnSite.ResourceGroupName\r\n\t\tAssert-AreEqual $vpnSiteName $vpnSite.Name\r\n\t\tAssert-AreEqual \"2.3.4.5\" $vpnSite.IpAddress\r\n\r\n        $vpnSites = Get-AzureRmVpnSite -ResourceGroupName $rgName\r\n        Assert-NotNull $vpnSites\r\n\r\n        $vpnSitesAll = Get-AzVpnSite\r\n        Assert-NotNull $vpnSitesAll\r\n        Assert-NotNull $vpnSitesAll[0].ResourceGroupName\r\n\r\n\t\t$vpnSitesAll = Get-AzVpnSite -ResourceGroupName \"*\"\r\n        Assert-NotNull $vpnSitesAll\r\n\r\n\t\t$vpnSitesAll = Get-AzVpnSite -Name \"*\"\r\n        Assert-NotNull $vpnSitesAll\r\n\r\n\t\t$vpnSitesAll = Get-AzVpnSite -ResourceGroupName \"*\" -Name \"*\"\r\n        Assert-NotNull $vpnSitesAll\r\n\r\n\t\t# Create the VpnGateway\r\n\t\t$createdVpnGateway = New-AzVpnGateway -ResourceGroupName $rgName -Name $vpnGatewayName -VirtualHub $virtualHub -VpnGatewayScaleUnit 3\r\n\t\t$createdVpnGateway = Update-AzVpnGateway -ResourceGroupName $rgName -Name $vpnGatewayName -VpnGatewayScaleUnit 4\r\n\t\t$vpnGateway = Get-AzVpnGateway -ResourceGroupName $rgName -Name $vpnGatewayName\r\n\t\tAssert-AreEqual $rgName $vpnGateway.ResourceGroupName\r\n\t\tAssert-AreEqual $vpnGatewayName $vpnGateway.Name\r\n\t\tAssert-AreEqual 4 $vpnGateway.VpnGatewayScaleUnit\r\n\r\n        $vpnGateways = Get-AzVpnGateway\r\n        Assert-NotNull $vpnGateways\r\n        Assert-NotNull $vpnGateways[0].ResourceGroupName\r\n\r\n        $vpnGateways = Get-AzureRmVpnGateway -ResourceGroupName $rgName\r\n        Assert-NotNull $vpnGateways\r\n\r\n        $vpnGatewaysAll = Get-AzureRmVpnGateway -ResourceGroupName \"*\"\r\n        Assert-NotNull $vpnGatewaysAll\r\n\r\n\t\t$vpnGatewaysAll = Get-AzureRmVpnGateway -Name \"*\"\r\n        Assert-NotNull $vpnGatewaysAll\r\n\r\n\t\t$vpnGatewaysAll = Get-AzureRmVpnGateway -ResourceGroupName \"*\" -Name \"*\"\r\n        Assert-NotNull $vpnGatewaysAll\r\n\r\n\t\t$vpnGatewaysAll = Get-AzureRmVpnGateway\r\n        Assert-NotNull $vpnGatewaysAll\r\n\r\n\t\t# Create the VpnConnection\r\n\t\t$createdVpnConnection = New-AzVpnConnection -ResourceGroupName $rgName -ParentResourceName $vpnGatewayName -Name $vpnConnectionName -VpnSite $vpnSite -ConnectionBandwidth 20 -UseLocalAzureIpAddress \r\n\t\tAssert-AreEqual $true $createdVpnConnection.UseLocalAzureIpAddress\r\n\t\t\r\n\t\t$createdVpnConnection = Update-AzVpnConnection -ResourceGroupName $rgName -ParentResourceName $vpnGatewayName -Name $vpnConnectionName -ConnectionBandwidth 30 -UseLocalAzureIpAddress $false\r\n\t\t$vpnConnection = Get-AzVpnConnection -ResourceGroupName $rgName -ParentResourceName $vpnGatewayName -Name $vpnConnectionName\r\n\t\tAssert-AreEqual $vpnConnectionName $vpnConnection.Name\r\n\t\tAssert-AreEqual 30 $vpnConnection.ConnectionBandwidth\r\n\t\tAssert-AreEqual $false $vpnConnection.UseLocalAzureIpAddress \r\n\r\n        $vpnConnections = Get-AzureRmVpnConnection -ResourceGroupName $rgName -ParentResourceName $vpnGatewayName\r\n        Assert-NotNull $vpnConnections\r\n\r\n\t\t$vpnConnections = Get-AzureRmVpnConnection -ResourceGroupName $rgName -ParentResourceName $vpnGatewayName -Name \"*\"\r\n        Assert-NotNull $vpnConnections\r\n\r\n\t\t# Create a HubVirtualNetworkConnection\r\n\t\t$remoteVirtualNetwork = New-AzVirtualNetwork -ResourceGroupName $rgName -Name $remoteVirtualNetworkName -Location $rglocation -AddressPrefix \"10.0.1.0\/24\"\r\n\t\t$createdHubVnetConnection = New-AzVirtualHubVnetConnection -ResourceGroupName $rgName -VirtualHubName $virtualHubName -Name $hubVnetConnectionName -RemoteVirtualNetwork $remoteVirtualNetwork\r\n\t\t$hubVnetConnection = Get-AzVirtualHubVnetConnection -ResourceGroupName $rgName -VirtualHubName $virtualHubName -Name $hubVnetConnectionName\r\n\t\tAssert-AreEqual $hubVnetConnectionName $hubVnetConnection.Name\r\n        $hubVnetConnections = Get-AzureRmVirtualHubVnetConnection -ResourceGroupName $rgName -VirtualHubName $virtualHubName\r\n        Assert-NotNull $hubVnetConnections\r\n        $hubVnetConnections = Get-AzureRmVirtualHubVnetConnection -ResourceGroupName $rgName -VirtualHubName $virtualHubName -Name \"*\"\r\n        Assert-NotNull $hubVnetConnections\r\n\r\n        # Clean up\r\n        $delete = Remove-AzVirtualHubVnetConnection -ResourceGroupName $rgName -ParentResourceName $virtualHubName -Name $hubVnetConnectionName -Force -PassThru\r\n        Assert-AreEqual $True $delete\r\n\r\n        $delete = Remove-AzVpnConnection -ResourceGroupName $rgName -ParentResourceName $vpnGatewayName -Name $vpnConnectionName -Force -PassThru\r\n        Assert-AreEqual $True $delete\r\n\r\n        $delete = Remove-AzVpnGateway -ResourceGroupName $rgName -Name $vpnGatewayName -Force -PassThru\r\n        Assert-AreEqual $True $delete\r\n\r\n        $delete = Remove-AzVpnSite -ResourceGroupName $rgName -Name $vpnSiteName -Force -PassThru\r\n        Assert-AreEqual $True $delete\r\n\r\n        $delete = Remove-AzVirtualHub -ResourceGroupName $rgName -Name $virtualHubName -Force -PassThru\r\n        Assert-AreEqual $True $delete\r\n\r\n        $delete = Remove-AzVirtualWan -ResourceGroupName $rgName -Name $virtualWanName -Force -PassThru\r\n        Assert-AreEqual $True $delete\r\n\t}\r\n\tfinally\r\n\t{\r\n\t\tClean-ResourceGroup $rgname\r\n\t}\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\nCortexDownloadConfig\r\n#>\r\nfunction Test-CortexDownloadConfig\r\n{\r\n # Setup\r\n    $rgName = Get-ResourceName\r\n    $rglocation = Get-ProviderLocation ResourceManagement \"East US\"\r\n\r\n\t$virtualWanName = Get-ResourceName\r\n\t$virtualHubName = Get-ResourceName\r\n\t$vpnSiteName = Get-ResourceName\r\n\t$vpnGatewayName = Get-ResourceName\r\n\t$remoteVirtualNetworkName = Get-ResourceName\r\n\t$vpnConnectionName = Get-ResourceName\r\n\t$hubVnetConnectionName = Get-ResourceName\r\n\r\n\t$storeName = 'blob' + $rgName\r\n    \r\n\ttry\r\n\t{\r\n\t\t# Create the resource group\r\n        $resourceGroup = New-AzResourceGroup -Name $rgName -Location $rglocation\r\n\r\n\t\t# Create the Virtual Wan\r\n\t\t$createdVirtualWan = New-AzVirtualWan -ResourceGroupName $rgName -Name $virtualWanName -Location $rglocation -AllowVnetToVnetTraffic -AllowBranchToBranchTraffic\r\n\t\t$virtualWan = Get-AzVirtualWan -ResourceGroupName $rgName -Name $virtualWanName\r\n\t\tAssert-AreEqual $rgName $virtualWan.ResourceGroupName\r\n\t\tAssert-AreEqual $virtualWanName $virtualWan.Name\r\n\t\t\r\n\t\t# Create the Virtual Hub\r\n\t\t$createdVirtualHub = New-AzVirtualHub -ResourceGroupName $rgName -Name $virtualHubName -Location $rglocation -AddressPrefix \"192.168.1.0\/24\" -VirtualWan $virtualWan\r\n\t\t$virtualHub = Get-AzVirtualHub -ResourceGroupName $rgName -Name $virtualHubName\r\n\t\tAssert-AreEqual $rgName $virtualHub.ResourceGroupName\r\n\t\tAssert-AreEqual $virtualHubName $virtualHub.Name\r\n\t\tAssert-AreEqual \"192.168.1.0\/24\" $virtualHub.AddressPrefix\r\n\r\n\t\t# Create the VpnSite\r\n\t\t$vpnSiteAddressSpaces = New-Object string[] 1\r\n\t\t$vpnSiteAddressSpaces[0] = \"192.168.2.0\/24\"\r\n\t\t$createdVpnSite = New-AzVpnSite -ResourceGroupName $rgName -Name $vpnSiteName -Location $rglocation -VirtualWan $virtualWan -IpAddress \"1.2.3.4\" -AddressSpace $vpnSiteAddressSpaces -DeviceModel \"SomeDevice\" -DeviceVendor \"SomeDeviceVendor\" -LinkSpeedInMbps 10\r\n\t\t$vpnSite = Get-AzVpnSite -ResourceGroupName $rgName -Name $vpnSiteName\r\n\t\tAssert-AreEqual $rgName $vpnSite.ResourceGroupName\r\n\t\tAssert-AreEqual $vpnSiteName $vpnSite.Name\r\n\t\t\r\n\t\t# Create the VpnGateway\r\n\t\t$createdVpnGateway = New-AzVpnGateway -ResourceGroupName $rgName -Name $vpnGatewayName -VirtualHub $virtualHub -VpnGatewayScaleUnit 3\r\n\t\t$vpnGateway = Get-AzVpnGateway -ResourceGroupName $rgName -Name $vpnGatewayName\r\n\t\tAssert-AreEqual $rgName $vpnGateway.ResourceGroupName\r\n\t\tAssert-AreEqual $vpnGatewayName $vpnGateway.Name\r\n\t\t\r\n\t\t# Create the VpnConnection\r\n\t\t$createdVpnConnection = New-AzVpnConnection -ResourceGroupName $rgName -ParentResourceName $vpnGatewayName -Name $vpnConnectionName -VpnSite $vpnSite -ConnectionBandwidth 20\r\n\t\t$vpnConnection = Get-AzVpnConnection -ResourceGroupName $rgName -ParentResourceName $vpnGatewayName -Name $vpnConnectionName\r\n\t\tAssert-AreEqual $vpnConnectionName $vpnConnection.Name\r\n\t\t\r\n\t\t# Download config\r\n\t\t$storetype = 'Standard_GRS'\r\n\t\t$containerName = 'cont' + $rgName\r\n\t\tNew-AzStorageAccount -ResourceGroupName $rgName -Name $storeName -Location $rglocation -Type $storetype\r\n\t\t$key = Get-AzStorageAccountKey -ResourceGroupName $rgName -Name $storeName\r\n\t\t$context = New-AzStorageContext -StorageAccountName $storeName -StorageAccountKey $key[0].Value\r\n\t\tNew-AzStorageContainer -Name $containerName -Context $context\r\n\t\t$container = Get-AzStorageContainer -Name $containerName -Context $context\r\n\t\tNew-Item -Name EmptyFile.txt -ItemType File -Force\r\n\t\tSet-AzStorageBlobContent -File \"EmptyFile.txt\" -Container $containerName -Blob \"emptyfile.txt\" -Context $context\r\n\t\t$now=get-date\r\n\t\t$blobSasUrl = New-AzStorageBlobSASToken -Container $containerName -Blob emptyfile.txt -Context $context -Permission \"rwd\" -StartTime $now.AddHours(-1) -ExpiryTime $now.AddDays(1) -FullUri\r\n\r\n\t\t$vpnSitesForConfig = New-Object Microsoft.Azure.Commands.Network.Models.PSVpnSite[] 1\r\n\t\t$vpnSitesForConfig[0] = $vpnSite\r\n\t\tGet-AzVirtualWanVpnConfiguration -VirtualWan $virtualWan -StorageSasUrl $blobSasUrl -VpnSite $vpnSitesForConfig\r\n\r\n\t\t$delete = Remove-AzVpnConnection -ResourceGroupName $rgName -ParentResourceName $vpnGatewayName -Name $vpnConnectionName -Force -PassThru\r\n\t\tAssert-AreEqual $True $delete\r\n\r\n\t\t$delete = Remove-AzVpnGateway -ResourceGroupName $rgName -Name $vpnGatewayName -Force -PassThru\r\n\t\tAssert-AreEqual $True $delete\r\n\r\n\t\t$delete = Remove-AzVpnSite -ResourceGroupName $rgName -Name $vpnSiteName -Force -PassThru\r\n\t\tAssert-AreEqual $True $delete\r\n\r\n\t\t$delete = Remove-AzVirtualHub -ResourceGroupName $rgName -Name $virtualHubName -Force -PassThru\r\n\t\tAssert-AreEqual $True $delete\r\n\r\n\t\t$delete = Remove-AzVirtualWan -ResourceGroupName $rgName -Name $virtualWanName -Force -PassThru\r\n\t\tAssert-AreEqual $True $delete\r\n\t}\r\n\tfinally\r\n\t{\r\n\t\tClean-ResourceGroup $rgname\r\n\t}\r\n}\r\n\r\nfunction Test-CortexExpressRouteCRUD\r\n{\r\n    # Setup\r\n    $rgName = Get-ResourceGroupName\r\n    $hubRgName = Get-ResourceGroupName\r\n    # ExpressRoute gateways have been enabled only in westcentralus region\r\n    $rglocation = Get-ProviderLocation \"ResourceManagement\" \"westcentralus\"\r\n\r\n    $virtualWanName = Get-ResourceName\r\n    $virtualHubName = Get-ResourceName\r\n    $expressRouteGatewayName = Get-ResourceName\r\n    $circuitName = Get-ResourceName\r\n    $expressRouteConnectionName = Get-ResourceName\r\n\r\n    try\r\n    {\r\n        # Create the resource group\r\n        $resourceGroup = New-AzureRmResourceGroup -Name $rgName -Location $rglocation\r\n        $resourceGroup = New-AzureRmResourceGroup -Name $hubRgName -Location $rglocation\r\n\r\n        # Create the Virtual Wan\r\n        $createdVirtualWan = New-AzureRmVirtualWan -ResourceGroupName $rgName -Name $virtualWanName -Location $rglocation -AllowVnetToVnetTraffic -AllowBranchToBranchTraffic\r\n        $virtualWan = Get-AzureRmVirtualWan -ResourceGroupName $rgName -Name $virtualWanName\r\n        Write-Debug \"Created Virtual WAN $virtualWan.Name successfully\"\r\n\r\n        $createdVirtualHub = New-AzureRmVirtualHub -ResourceGroupName $hubRgName -Name $virtualHubName -Location $rglocation -AddressPrefix \"10.8.0.0\/24\" -VirtualWan $virtualWan\r\n        $virtualHub = Get-AzureRmVirtualHub -ResourceGroupName $hubRgName -Name $virtualHubName\r\n        Write-Debug \"Created Virtual Hub virtualHub.Name successfully\"\r\n\r\n        # Create the ExpressRouteGateway\r\n        $createdExpressRouteGateway = New-AzureRmExpressRouteGateway -ResourceGroupName $rgName -Name $expressRouteGatewayName -VirtualHub $virtualHub -MinScaleUnits 2\r\n        Write-Debug \"Created ExpressRoute Gateway $expressRouteGatewayName successfully\"\r\n        $expressRouteGateway = Get-AzureRmExpressRouteGateway -ResourceGroupName $rgName -Name $expressRouteGatewayName\r\n        Assert-NotNull $expressRouteGateway\r\n        Write-Debug \"Retrieved ExpressRoute Gateway $expressRouteGatewayName successfully\"\r\n\r\n        # List the ExpressRouteGateway\r\n        $expressRouteGateways = Get-AzureRmExpressRouteGateway\r\n        Assert-NotNull $expressRouteGateways\r\n        Assert-True { $expressRouteGateways.Count -gt 0 }\r\n\r\n\t\t$expressRouteGateways = Get-AzureRmExpressRouteGateway -ResourceGroupName \"*\"\r\n        Assert-NotNull $expressRouteGateways\r\n        Assert-True { $expressRouteGateways.Count -gt 0 }\r\n\r\n\t\t$expressRouteGateways = Get-AzureRmExpressRouteGateway -Name \"*\"\r\n        Assert-NotNull $expressRouteGateways\r\n        Assert-True { $expressRouteGateways.Count -gt 0 }\r\n\r\n\t\t$expressRouteGateways = Get-AzureRmExpressRouteGateway -ResourceGroupName \"*\" -Name \"*\"\r\n        Assert-NotNull $expressRouteGateways\r\n        Assert-True { $expressRouteGateways.Count -gt 0 }\r\n\r\n\t\t$expressRouteGateways = Get-AzureRmExpressRouteGateway -ResourceGroupName $rgName\r\n        Assert-NotNull $expressRouteGateways\r\n        Assert-True { $expressRouteGateways.Count -gt 0 }\r\n\r\n        # Create the ExpressRouteCircuit with peering to which the connection needs to be established to\r\n        $peering = New-AzureRmExpressRouteCircuitPeeringConfig -Name AzurePrivatePeering -PeeringType AzurePrivatePeering -PeerASN 100 -PrimaryPeerAddressPrefix \"10.2.3.4\/30\" -SecondaryPeerAddressPrefix \"11.2.3.4\/30\" -VlanId 22\r\n        $circuit = New-AzureRmExpressRouteCircuit -Name $circuitName -Location $rglocation -ResourceGroupName $rgname -SkuTier Premium -SkuFamily MeteredData  -ServiceProviderName \"Zayo\" -PeeringLocation \"Denver\" -BandwidthInMbps 200 -Peering $peering\r\n        Write-Debug \"Created ExpressRoute Circuit with Private Peering $circuitName successfully\"\r\n\r\n        # Get Express Route Circuit Resource\r\n        $circuitResult = Get-AzureRmExpressRouteCircuit -Name $circuitName -ResourceGroupName $rgname\r\n        $peeringResult = Get-AzureRmExpressRouteCircuitPeeringConfig -Name AzurePrivatePeering -ExpressRouteCircuit $circuitResult\r\n        Write-Debug \"Created ExpressRoute Circuit with Private Peering $circuitName successfully\"\r\n\r\n        # Create the ExpressRoute Connection\r\n        $createdExpressRouteConnection = New-AzureRmExpressRouteConnection -ResourceGroupName $rgName -ExpressRouteGatewayName $expressRouteGatewayName -Name $expressRouteConnectionName -ExpressRouteCircuitPeeringId $peeringResult.Id -RoutingWeight 10\r\n        Write-Debug \"Created ExpressRoute Connection with Private Peering $expressRouteConnectionName successfully\"\r\n        $createdExpressRouteConnection = Set-AzureRmExpressRouteConnection -ResourceGroupName $rgName -ExpressRouteGatewayName $expressRouteGatewayName -Name $expressRouteConnectionName -RoutingWeight 30\r\n        Write-Debug \"Updated ExpressRoute Connection with Private Peering $expressRouteConnectionName successfully\"\r\n        $expressRouteConnection = Get-AzureRmExpressRouteConnection -ResourceGroupName $rgName -ExpressRouteGatewayName $expressRouteGatewayName -Name $expressRouteConnectionName\r\n        Assert-NotNull $expressRouteConnection\r\n        Write-Debug \"Retrieved ExpressRoute Connection with Private Peering $expressRouteConnectionName successfully\"\r\n        Assert-AreEqual $expressRouteConnectionName $expressRouteConnection.Name\r\n        Assert-AreEqual 30 $expressRouteConnection.RoutingWeight\r\n\r\n\t\t$expressRouteConnection = Get-AzureRmExpressRouteConnection -ResourceGroupName $rgName -ExpressRouteGatewayName $expressRouteGatewayName\r\n        Assert-NotNull $expressRouteConnection\r\n\t\tAssert-True { $expressRouteConnection.Count -ge 0}\r\n\r\n\t\t$expressRouteConnection = Get-AzureRmExpressRouteConnection -ResourceGroupName $rgName -ExpressRouteGatewayName $expressRouteGatewayName -Name \"*\"\r\n        Assert-NotNull $expressRouteConnection\r\n\t\tAssert-True { $expressRouteConnection.Count -ge 0}\r\n\r\n        # Clean up\r\n        Remove-AzureRmExpressRouteConnection -ResourceGroupName $rgName -ExpressRouteGatewayName $expressRouteGatewayName -Name $expressRouteConnectionName -Force\r\n        Assert-ThrowsLike { Get-AzureRmExpressRouteConnection -ResourceGroupName $rgName -ExpressRouteGatewayName $expressRouteGatewayName -Name $expressRouteConnectionName } \"*Not*Found*\"\r\n\r\n        Remove-AzureRmExpressRouteGateway -ResourceGroupName $rgName -Name $expressRouteGatewayName -Force\r\n        Assert-ThrowsLike { Get-AzureRmExpressRouteGateway -ResourceGroupName $rgName -Name $expressRouteGatewayName } \"*Not*Found*\"\r\n\r\n        Remove-AzureRmVirtualHub -ResourceGroupName $hubRgName -Name $virtualHubName -Force\r\n\r\n        Remove-AzureRmVirtualWan -ResourceGroupName $rgName -Name $virtualWanName -Force\r\n        Assert-ThrowsLike { Get-AzureRmVirtualWan -ResourceGroupName $rgName -Name $virtualWanName } \"*Not*Found*\"\r\n    }\r\n    finally\r\n    {\r\n        Clean-ResourceGroup $rgname\r\n    }\r\n}\r\n","avg_line_length":53.2593516209,"max_line_length":262,"alphanum_fraction":0.7565669336,"licenses":["MIT"],"repository_name":"AuxMon\/azure-powershell","path":"src\/Network\/Network.Test\/ScenarioTests\/CortexTests.ps1","size":20959,"lang":"PowerShell"}
{"content":"function Get-DbaServerProtocol {\n    <#\n    .SYNOPSIS\n    Gets the SQL Server related server protocols on a computer.\n\n    .DESCRIPTION\n    Gets the SQL Server related server protocols on one or more computers.\n\n    Requires Local Admin rights on destination computer(s).\n    The server protocols can be enabled and disabled when retrieved via WSMan.\n\n    .PARAMETER ComputerName\n    The SQL Server (or server in general) that you're connecting to. This command handles named instances.\n\n    .PARAMETER Credential\n    Credential object used to connect to the computer as a different user.\n\n   .PARAMETER EnableException\n   By default, when something goes wrong we try to catch it, interpret it and give you a friendly warning message.\n   This avoids overwhelming you with \"sea of red\" exceptions, but is inconvenient because it basically disables advanced scripting.\n   Using this switch turns this \"nice by default\" feature off and enables you to catch exceptions with your own try\/catch.\n\n    .NOTES\n    Author: Klaas Vandenberghe ( @PowerDBAKlaas )\n    Tags: Protocol\n    dbatools PowerShell module (https:\/\/dbatools.io)\n    Copyright (C) 2016 Chrissy LeMaire\n    License: MIT https:\/\/opensource.org\/licenses\/MIT\n\n    .LINK\n    https:\/\/dbatools.io\/Get-DbaServerProtocol\n\n    .EXAMPLE\n    Get-DbaServerProtocol -ComputerName sqlserver2014a\n\n    Gets the SQL Server related server protocols on computer sqlserver2014a.\n\n    .EXAMPLE\n    'sql1','sql2','sql3' | Get-DbaServerProtocol\n\n    Gets the SQL Server related server protocols on computers sql1, sql2 and sql3.\n\n    .EXAMPLE\n    Get-DbaServerProtocol -ComputerName sql1,sql2 | Out-Gridview\n\n    Gets the SQL Server related server protocols on computers sql1 and sql2, and shows them in a grid view.\n\n    .EXAMPLE\n    (Get-DbaServerProtocol -ComputerName sql1 | Where { $_.DisplayName = 'via' }).Disable()\n\n    Disables the VIA ServerNetworkProtocol on computer sql1.\n    If successful, returncode 0 is shown.\n\n#>\n    [CmdletBinding()]\n    Param (\n        [parameter(ValueFromPipeline)]\n        [Alias(\"cn\", \"host\", \"Server\")]\n        [DbaInstanceParameter[]]$ComputerName = $env:COMPUTERNAME,\n        [PSCredential]$Credential,\n        [switch][Alias('Silent')]$EnableException\n    )\n\n    process {\n        foreach ($Computer in $ComputerName.ComputerName) {\n            $Server = Resolve-DbaNetworkName -ComputerName $Computer -Credential $credential\n            if ($Server.FullComputerName) {\n                $Computer = $server.FullComputerName\n                Write-Message -Level Verbose -Message \"Getting SQL Server namespace on $computer\"\n                $namespace = Get-DbaCmObject -ComputerName $Computer -NameSpace root\\Microsoft\\SQLServer -Query \"Select * FROM __NAMESPACE WHERE Name Like 'ComputerManagement%'\" -ErrorAction SilentlyContinue |\n                    Where-Object { (Get-DbaCmObject -ComputerName $Computer -Namespace $(\"root\\Microsoft\\SQLServer\\\" + $_.Name) -ClassName ServerNetworkProtocol -ErrorAction SilentlyContinue).count -gt 0 } |\n                    Sort-Object Name -Descending | Select-Object -First 1\n                if ($namespace.Name) {\n                    Write-Message -Level Verbose -Message \"Getting Cim class ServerNetworkProtocol in Namespace $($namespace.Name) on $Computer\"\n                    try {\n                        $prot = Get-DbaCmObject -ComputerName $Computer -Namespace $(\"root\\Microsoft\\SQLServer\\\" + $namespace.Name) -ClassName ServerNetworkProtocol -ErrorAction SilentlyContinue\n                        $prot | Add-Member -Force -MemberType ScriptMethod -Name Enable -Value { Invoke-CimMethod -MethodName SetEnable -InputObject $this }\n                        $prot | Add-Member -Force -MemberType ScriptMethod -Name Disable -Value { Invoke-CimMethod -MethodName SetDisable -InputObject $this }\n                        foreach ($protocol in $prot) { Select-DefaultView -InputObject $protocol -Property 'PSComputerName as ComputerName', 'InstanceName', 'ProtocolDisplayName as DisplayName', 'ProtocolName as Name', 'MultiIpconfigurationSupport as MultiIP', 'Enabled as IsEnabled' }\n                    }\n                    catch {\n                        Write-Message -Level Warning -Message \"No Sql ServerNetworkProtocol found on $Computer\"\n                    }\n                }\n                else {\n                    Write-Message -Level Warning -Message \"No ComputerManagement Namespace on $Computer. Please note that this function is available from SQL 2005 up.\"\n                }\n            }\n            else {\n                Write-Message -Level Warning -Message \"Failed to connect to $Computer\"\n            }\n        }\n    }\n}\n","avg_line_length":49.1052631579,"max_line_length":285,"alphanum_fraction":0.6741693462,"licenses":["MIT"],"repository_name":"nullbind\/dbatools","path":"functions\/Get-DbaServerProtocol.ps1","size":4665,"lang":"PowerShell"}
{"content":"---\nid: advanced\ntitle: Advanced Options\nsidebar_label: Advanced Options\n---\n\n## Advanced configuration\n\n### `logger`\n\nChange the default log level for troubleshooting purposes.\n\n```yaml\nlogger:\n  # Optional: default log level (default: shown below)\n  default: info\n  # Optional: module by module log level configuration\n  logs:\n    frigate.mqtt: error\n```\n\nAvailable log levels are: `debug`, `info`, `warning`, `error`, `critical`\n\nExamples of available modules are:\n\n- `frigate.app`\n- `frigate.mqtt`\n- `frigate.edgetpu`\n- `frigate.zeroconf`\n- `detector.<detector_name>`\n- `watchdog.<camera_name>`\n- `ffmpeg.<camera_name>.<sorted_roles>` NOTE: All FFmpeg logs are sent as `error` level.\n\n### `environment_vars`\n\nThis section can be used to set environment variables for those unable to modify the environment of the container (ie. within HassOS)\n\n### `database`\n\nEvent and recording information is managed in a sqlite database at `\/media\/frigate\/frigate.db`. If that database is deleted, recordings will be orphaned and will need to be cleaned up manually. They also won't show up in the Media Browser within Home Assistant.\n\nIf you are storing your database on a network share (SMB, NFS, etc), you may get a `database is locked` error message on startup. You can customize the location of the database in the config if necessary.\n\nThis may need to be in a custom location if network storage is used for the media folder.\n\n```yaml\ndatabase:\n  path: \/path\/to\/frigate.db\n```\n\n### `model`\n\nIf using a custom model, the width and height will need to be specified.\n\nThe labelmap can be customized to your needs. A common reason to do this is to combine multiple object types that are easily confused when you don't need to be as granular such as car\/truck. By default, truck is renamed to car because they are often confused. You cannot add new object types, but you can change the names of existing objects in the model.\n\n```yaml\nmodel:\n  labelmap:\n    2: vehicle\n    3: vehicle\n    5: vehicle\n    7: vehicle\n    15: animal\n    16: animal\n    17: animal\n```\n\nNote that if you rename objects in the labelmap, you will also need to update your `objects -> track` list as well.\n","avg_line_length":31.0285714286,"max_line_length":355,"alphanum_fraction":0.7380294659,"licenses":["MIT"],"repository_name":"DataBitz\/frigate","path":"docs\/docs\/configuration\/advanced.md","size":2172,"lang":"Markdown"}
{"content":"import { Component } from '@stencil\/core';\n\n@Component({\n  tag: 'svg-stepper',\n  styleUrl: 'svg-stepper.css',\n})\nexport class SvgStepper {\n  render() {\n    return (\n      <div>\n        <p>Hello SvgStepper!<\/p>\n      <\/div>\n    );\n  }\n}\n","avg_line_length":14.75,"max_line_length":42,"alphanum_fraction":0.5466101695,"licenses":["MIT"],"repository_name":"tm-3\/svg-comp-lib","path":"src\/components\/svg-stepper\/svg-stepper.tsx","size":236,"lang":"TypeScript"}
{"content":"# coding: utf-8\n\n\"\"\"\n    Properties\n\n    All HubSpot objects store data in default and custom properties. These endpoints provide access to read and modify object properties in HubSpot.  # noqa: E501\n\n    The version of the OpenAPI document: v3\n    Generated by: https:\/\/openapi-generator.tech\n\"\"\"\n\n\nimport pprint\nimport re  # noqa: F401\n\nimport six\n\nfrom hubspot.crm.properties.configuration import Configuration\n\n\nclass PropertyGroupUpdate(object):\n    \"\"\"NOTE: This class is auto generated by OpenAPI Generator.\n    Ref: https:\/\/openapi-generator.tech\n\n    Do not edit the class manually.\n    \"\"\"\n\n    \"\"\"\n    Attributes:\n      openapi_types (dict): The key is attribute name\n                            and the value is attribute type.\n      attribute_map (dict): The key is attribute name\n                            and the value is json key in definition.\n    \"\"\"\n    openapi_types = {\n        'label': 'str',\n        'display_order': 'int'\n    }\n\n    attribute_map = {\n        'label': 'label',\n        'display_order': 'displayOrder'\n    }\n\n    def __init__(self, label=None, display_order=None, local_vars_configuration=None):  # noqa: E501\n        \"\"\"PropertyGroupUpdate - a model defined in OpenAPI\"\"\"  # noqa: E501\n        if local_vars_configuration is None:\n            local_vars_configuration = Configuration()\n        self.local_vars_configuration = local_vars_configuration\n\n        self._label = None\n        self._display_order = None\n        self.discriminator = None\n\n        if label is not None:\n            self.label = label\n        if display_order is not None:\n            self.display_order = display_order\n\n    @property\n    def label(self):\n        \"\"\"Gets the label of this PropertyGroupUpdate.  # noqa: E501\n\n        A human-readable label that will be shown in HubSpot.  # noqa: E501\n\n        :return: The label of this PropertyGroupUpdate.  # noqa: E501\n        :rtype: str\n        \"\"\"\n        return self._label\n\n    @label.setter\n    def label(self, label):\n        \"\"\"Sets the label of this PropertyGroupUpdate.\n\n        A human-readable label that will be shown in HubSpot.  # noqa: E501\n\n        :param label: The label of this PropertyGroupUpdate.  # noqa: E501\n        :type: str\n        \"\"\"\n\n        self._label = label\n\n    @property\n    def display_order(self):\n        \"\"\"Gets the display_order of this PropertyGroupUpdate.  # noqa: E501\n\n        Property groups are displayed in order starting with the lowest positive integer value. Values of -1 will cause the property group to be displayed after any positive values.  # noqa: E501\n\n        :return: The display_order of this PropertyGroupUpdate.  # noqa: E501\n        :rtype: int\n        \"\"\"\n        return self._display_order\n\n    @display_order.setter\n    def display_order(self, display_order):\n        \"\"\"Sets the display_order of this PropertyGroupUpdate.\n\n        Property groups are displayed in order starting with the lowest positive integer value. Values of -1 will cause the property group to be displayed after any positive values.  # noqa: E501\n\n        :param display_order: The display_order of this PropertyGroupUpdate.  # noqa: E501\n        :type: int\n        \"\"\"\n\n        self._display_order = display_order\n\n    def to_dict(self):\n        \"\"\"Returns the model properties as a dict\"\"\"\n        result = {}\n\n        for attr, _ in six.iteritems(self.openapi_types):\n            value = getattr(self, attr)\n            if isinstance(value, list):\n                result[attr] = list(map(\n                    lambda x: x.to_dict() if hasattr(x, \"to_dict\") else x,\n                    value\n                ))\n            elif hasattr(value, \"to_dict\"):\n                result[attr] = value.to_dict()\n            elif isinstance(value, dict):\n                result[attr] = dict(map(\n                    lambda item: (item[0], item[1].to_dict())\n                    if hasattr(item[1], \"to_dict\") else item,\n                    value.items()\n                ))\n            else:\n                result[attr] = value\n\n        return result\n\n    def to_str(self):\n        \"\"\"Returns the string representation of the model\"\"\"\n        return pprint.pformat(self.to_dict())\n\n    def __repr__(self):\n        \"\"\"For `print` and `pprint`\"\"\"\n        return self.to_str()\n\n    def __eq__(self, other):\n        \"\"\"Returns true if both objects are equal\"\"\"\n        if not isinstance(other, PropertyGroupUpdate):\n            return False\n\n        return self.to_dict() == other.to_dict()\n\n    def __ne__(self, other):\n        \"\"\"Returns true if both objects are not equal\"\"\"\n        if not isinstance(other, PropertyGroupUpdate):\n            return True\n\n        return self.to_dict() != other.to_dict()\n","avg_line_length":31.1589403974,"max_line_length":195,"alphanum_fraction":0.6095642933,"licenses":["Apache-2.0"],"repository_name":"cclauss\/hubspot-api-python","path":"hubspot\/crm\/properties\/models\/property_group_update.py","size":4705,"lang":"Python"}
{"content":"<?php\n\/**\n * @author    ThemePunch <info@themepunch.com>\n * @link      https:\/\/www.themepunch.com\/\n * @copyright 2019 ThemePunch\n *\/\n\nif(!defined('ABSPATH')) exit();\n\nglobal $revslider_rev_start_size_loaded;\n\n$revslider_rev_start_size_loaded = false;\n\nclass RevSliderFront extends RevSliderFunctions {\n\n\tconst TABLE_SLIDER\t\t\t = 'revslider_sliders';\n\tconst TABLE_SLIDES\t\t\t = 'revslider_slides';\n\tconst TABLE_STATIC_SLIDES\t = 'revslider_static_slides';\n\tconst TABLE_CSS\t\t\t\t = 'revslider_css';\n\tconst TABLE_LAYER_ANIMATIONS = 'revslider_layer_animations';\n\tconst TABLE_NAVIGATIONS\t\t = 'revslider_navigations';\n\tconst TABLE_SETTINGS\t\t = 'revslider_settings'; \/\/existed prior 5.0 and still needed for updating from 4.x to any version after 5.x\n\tconst CURRENT_TABLE_VERSION\t = '1.0.9';\n\n\tconst YOUTUBE_ARGUMENTS\t\t = 'hd=1&amp;wmode=opaque&amp;showinfo=0&amp;rel=0';\n\tconst VIMEO_ARGUMENTS\t\t = 'title=0&amp;byline=0&amp;portrait=0&amp;api=1';\n\n\tpublic function __construct(){\t\t\n\t\tadd_action('wp_enqueue_scripts', array('RevSliderFront', 'add_actions'));\n\t}\n\t\n\t\n\t\/**\n\t * START: DEPRECATED FUNCTIONS THAT ARE IN HERE FOR OLD ADDONS TO WORK PROPERLY\n\t **\/\n\t \n\t\/**\n\t * old version of add_admin_bar();\n\t **\/\n\tpublic static function putAdminBarMenus(){\n\t\treturn RevSliderFront::add_admin_bar();\n\t}\n\t\n\t\/**\n\t * END: DEPRECATED FUNCTIONS THAT ARE IN HERE FOR OLD ADDONS TO WORK PROPERLY\n\t **\/\n\t \n\t\/**\n\t * Add all actions that the frontend needs here\n\t **\/\n\tpublic static function add_actions(){\n\t\tglobal $wp_version, $revslider_is_preview_mode;\n\n\t\t$func\t = RevSliderGlobals::instance()->get('RevSliderFunctions');\n\t\t$css\t = RevSliderGlobals::instance()->get('RevSliderCssParser');\n\t\t$rs_ver\t = apply_filters('revslider_remove_version', RS_REVISION);\n\t\t$global\t = $func->get_global_settings();\n\t\t$inc_global = $func->_truefalse($func->get_val($global, 'allinclude', true));\n\t\t\n\t\t$inc_footer = $func->_truefalse($func->get_val($global, array('script', 'footer'), false));\n\t\t$waitfor = array('jquery');\n\t\t$widget\t = is_active_widget(false, false, 'rev-slider-widget', true);\n\t\t\n\t\t$load = false;\n\t\t$load = apply_filters('revslider_include_libraries', $load);\n\t\t$load = ($revslider_is_preview_mode === true) ? true : $load;\n\t\t$load = ($inc_global === true) ? true : $load;\n\t\t$load = (self::has_shortcode('rev_slider') === true) ? true : $load;\n\t\t$load = ($widget !== false) ? true : $load;\n\t\t\n\t\tif($inc_global === false){\n\t\t\t$output = new RevSliderOutput();\n\t\t\t$output->set_add_to($func->get_val($global, 'includeids', ''));\n\t\t\t$add_to = $output->check_add_to(true);\n\t\t\t$load\t= ($add_to === true) ? true : $load;\n\t\t}\n\n\t\tif($load === false) return false;\n\t\t\n\t\twp_enqueue_style('rs-plugin-settings', RS_PLUGIN_URL . 'public\/assets\/css\/rs6.css', array(), $rs_ver);\n\n\t\t\/**\n\t\t * Fix for WordPress versions below 3.7\n\t\t **\/\n\t\t$style_pre = ($wp_version < 3.7) ? '<style type=\"text\/css\">' : '';\n\t\t$style_post = ($wp_version < 3.7) ? '<\/style>' : '';\n\t\t$custom_css = $func->get_static_css();\n\t\t$custom_css = $css->compress_css($custom_css);\n\t\t$custom_css = (trim($custom_css) == '') ? '#rs-demo-id {}' : $custom_css;\n\n\t\twp_add_inline_style('rs-plugin-settings', $style_pre . $custom_css . $style_post);\n\t\twp_enqueue_script(array('jquery'));\n\t\t\n\t\t\/**\n\t\t * dequeue tp-tools to make sure that always the latest is loaded\n\t\t **\/\n\t\tglobal $wp_scripts;\n\t\tif(version_compare($func->get_val($wp_scripts, array('registered', 'tp-tools', 'ver'), '1.0'), RS_TP_TOOLS, '<')){\n\t\t\twp_deregister_script('tp-tools');\n\t\t\twp_dequeue_script('tp-tools');\n\t\t}\n\t\t\n\t\twp_enqueue_script('tp-tools', RS_PLUGIN_URL . 'public\/assets\/js\/rbtools.min.js', $waitfor, RS_TP_TOOLS, $inc_footer);\n\t\t\n\t\tif(!file_exists(RS_PLUGIN_PATH.'public\/assets\/js\/rs6.min.js')){\n\t\t\twp_enqueue_script('revmin', RS_PLUGIN_URL . 'public\/assets\/js\/dev\/rs6.main.js', 'tp-tools', $rs_ver, $inc_footer);\n\t\t\t\/\/if on, load all libraries instead of dynamically loading them\n\t\t\twp_enqueue_script('revmin-actions', RS_PLUGIN_URL . 'public\/assets\/js\/dev\/rs6.actions.js', 'tp-tools', $rs_ver, $inc_footer);\n\t\t\twp_enqueue_script('revmin-carousel', RS_PLUGIN_URL . 'public\/assets\/js\/dev\/rs6.carousel.js', 'tp-tools', $rs_ver, $inc_footer);\n\t\t\twp_enqueue_script('revmin-layeranimation', RS_PLUGIN_URL . 'public\/assets\/js\/dev\/rs6.layeranimation.js', 'tp-tools', $rs_ver, $inc_footer);\n\t\t\twp_enqueue_script('revmin-navigation', RS_PLUGIN_URL . 'public\/assets\/js\/dev\/rs6.navigation.js', 'tp-tools', $rs_ver, $inc_footer);\n\t\t\twp_enqueue_script('revmin-panzoom', RS_PLUGIN_URL . 'public\/assets\/js\/dev\/rs6.panzoom.js', 'tp-tools', $rs_ver, $inc_footer);\n\t\t\twp_enqueue_script('revmin-parallax', RS_PLUGIN_URL . 'public\/assets\/js\/dev\/rs6.parallax.js', 'tp-tools', $rs_ver, $inc_footer);\n\t\t\twp_enqueue_script('revmin-slideanims', RS_PLUGIN_URL . 'public\/assets\/js\/dev\/rs6.slideanims.js', 'tp-tools', $rs_ver, $inc_footer);\n\t\t\/\/\twp_enqueue_script('revmin-threejs', RS_PLUGIN_URL . 'public\/assets\/js\/libs\/three.min.js', 'tp-tools', $rs_ver, $inc_footer);\n\t\t\twp_enqueue_script('revmin-video', RS_PLUGIN_URL . 'public\/assets\/js\/dev\/rs6.video.js', 'tp-tools', $rs_ver, $inc_footer);\n\t\t}else{\n\t\t\twp_enqueue_script('revmin', RS_PLUGIN_URL . 'public\/assets\/js\/rs6.min.js', 'tp-tools', $rs_ver, $inc_footer);\n\t\t}\n\t\t\n\t\tadd_action('wp_head', array('RevSliderFront', 'add_meta_generator'));\n\t\tadd_action('wp_head', array('RevSliderFront', 'js_set_start_size'), 99);\n\t\tadd_action('admin_head', array('RevSliderFront', 'js_set_start_size'), 99);\n\t\tadd_action('wp_footer', array('RevSliderFront', 'load_icon_fonts'));\n\t\tadd_action('wp_footer', array('RevSliderFront', 'load_google_fonts'));\n\n\t\t\/\/Async JS Loading\n\t\tif($func->_truefalse($func->get_val($global, array('script', 'defer'), false)) === true){\n\t\t\tadd_filter('clean_url', array('RevSliderFront', 'add_defer_forscript'), 11, 1);\n\t\t}\n\n\t\tadd_action('wp_before_admin_bar_render', array('RevSliderFront', 'add_admin_menu_nodes'));\n\t\tadd_action('wp_footer', array('RevSliderFront', 'add_admin_bar'), 99);\n\t}\n\t\n\t\n\t\/**\n\t * Add Meta Generator Tag in FrontEnd\n\t * @since: 5.0\n\t *\/\n\tpublic static function add_meta_generator(){\n\t\techo apply_filters('revslider_meta_generator', '<meta name=\"generator\" content=\"Powered by Slider Revolution ' . RS_REVISION . ' - responsive, Mobile-Friendly Slider Plugin for WordPress with comfortable drag and drop interface.\" \/>' . \"\\n\");\n\t}\n\n\t\/**\n\t * Load Used Icon Fonts\n\t * @since: 5.0\n\t *\/\n\tpublic static function load_icon_fonts(){\n\t\tglobal $fa_var, $fa_icon_var, $pe_7s_var;\n\t\t$func\t= RevSliderGlobals::instance()->get('RevSliderFunctions');\n\t\t$global\t= $func->get_global_settings();\n\t\t$ignore_fa = $func->_truefalse($func->get_val($global, 'fontawesomedisable', false));\n\t\t\n\t\techo ($ignore_fa === false && ($fa_icon_var == true || $fa_var == true)) ? '<link rel=\"stylesheet\" property=\"stylesheet\" id=\"rs-icon-set-fa-icon-css\" href=\"' . RS_PLUGIN_URL . 'public\/assets\/fonts\/font-awesome\/css\/font-awesome.css\" type=\"text\/css\" media=\"all\" \/>'.\"\\n\" : '';\n\t\techo ($pe_7s_var) ? '<link rel=\"stylesheet\" property=\"stylesheet\" id=\"rs-icon-set-pe-7s-css\" href=\"' . RS_PLUGIN_URL . 'public\/assets\/fonts\/pe-icon-7-stroke\/css\/pe-icon-7-stroke.css\" type=\"text\/css\" media=\"all\" \/>'.\"\\n\" : '';\n\t}\n\t\n\t\n\t\/**\n\t * Load Used Google Fonts\n\t * add google fonts of all sliders found on the page\n\t * @since: 6.0\n\t *\/\n\tpublic static function load_google_fonts(){ \n\t\t$func\t= RevSliderGlobals::instance()->get('RevSliderFunctions');\n\t\t$fonts\t= $func->print_clean_font_import();\n\t\tif(!empty($fonts)){\n\t\t\techo $fonts.\"\\n\";\n\t\t}\n\t}\n\t\n\n\t\/**\n\t * add admin menu points in ToolBar Top\n\t * @since: 5.0.5\n\t * @before: putAdminBarMenus()\n\t *\/\n\tpublic static function add_admin_bar(){\n\t\tif(!is_super_admin() || !is_admin_bar_showing()){\n\t\t\treturn;\n\t\t}\n\n\t\t?>\n\t\t<script type=\"text\/javascript\">\n\t\t\tfunction rs_adminBarToolBarTopFunction() {\n\t\t\t\tif(jQuery('#wp-admin-bar-revslider-default').length > 0 && jQuery('rs-module-wrap').length > 0){\n\t\t\t\t\tvar aliases = new Array();\n\t\t\t\t\tjQuery('rs-module-wrap').each(function(){\n\t\t\t\t\t\taliases.push(jQuery(this).data('alias'));\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\tif(aliases.length > 0){\n\t\t\t\t\t\tjQuery('#wp-admin-bar-revslider-default li').each(function(){\n\t\t\t\t\t\t\tvar li = jQuery(this),\n\t\t\t\t\t\t\t\tt = li.find('.ab-item .rs-label').data('alias'); \/\/text()\n\t\t\t\t\t\t\tt = t!==undefined && t!==null ? t.trim() : t;\n\t\t\t\t\t\t\tif(jQuery.inArray(t,aliases)!=-1){\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tli.remove();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tjQuery('#wp-admin-bar-revslider').remove();\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar adminBarLoaded_once = false\n\t\t\tif (document.readyState === \"loading\") \n\t\t\t\tdocument.addEventListener('readystatechange',function(){\n\t\t\t\t\tif ((document.readyState === \"interactive\" || document.readyState === \"complete\") && !adminBarLoaded_once) {\n\t\t\t\t\t\tadminBarLoaded_once = true;\n\t\t\t\t\t\trs_adminBarToolBarTopFunction()\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\telse {\n\t\t\t\tadminBarLoaded_once = true;\n\t\t\t\trs_adminBarToolBarTopFunction();\n\t\t\t}\n\t\t<\/script>\n\t\t<?php\n}\n\n\t\/**\n\t * add admin nodes\n\t * @since: 5.0.5\n\t *\/\n\tpublic static function add_admin_menu_nodes(){\n\t\tif(!is_super_admin() || !is_admin_bar_showing()){\n\t\t\treturn;\n\t\t}\n\n\t\tself::_add_node('<span class=\"rs-label\">Slider Revolution<\/span>', false, admin_url('admin.php?page=revslider'), array('class' => 'revslider-menu'), 'revslider'); \/\/<span class=\"wp-menu-image dashicons-before dashicons-update\"><\/span>\n\n\t\t\/\/add all nodes of all Slider\n\t\t$sl = new RevSliderSlider();\n\t\t$sliders = $sl->get_slider_for_admin_menu();\n\n\t\tif(!empty($sliders)){\n\t\t\tforeach ($sliders as $id => $slider){\n\t\t\t\tself::_add_node('<span class=\"rs-label\" data-alias=\"' . esc_attr($slider['alias']) . '\">' . esc_html($slider['title']) . '<\/span>', 'revslider', admin_url('admin.php?page=revslider&view=slide&id=slider-'.$id), array('class' => 'revslider-sub-menu'), esc_attr($slider['alias'])); \/\/<span class=\"wp-menu-image dashicons-before dashicons-update\"><\/span>\n\t\t\t}\n\t\t}\n\t}\n\n\t\/**\n\t * add admin node\n\t * @since: 5.0.5\n\t *\/\n\tpublic static function _add_node($title, $parent = false, $href = '', $custom_meta = array(), $id = ''){\n\t\tif(!is_super_admin() || !is_admin_bar_showing()){\n\t\t\treturn;\n\t\t}\n\n\t\t$id = ($id == '') ? strtolower(str_replace(' ', '-', $title)) : $id;\n\t\t\n\t\t\/\/links from the current host will open in the current window\n\t\t$meta = (strpos($href, site_url()) !== false) ? array() : array('target' => '_blank'); \/\/external links open in new tab\/window\n\t\t$meta = array_merge($meta, $custom_meta);\n\t\t\n\t\tglobal $wp_admin_bar;\n\t\t$wp_admin_bar->add_node(array('parent'=> $parent, 'id' => $id, 'title' => $title, 'href' => $href, 'meta' => $meta));\n\t}\n\n\t\/**\n\t * adds async loading\n\t * @since: 5.0\n\t *\/\n\tpublic static function add_defer_forscript($url){\n\t\tif(strpos($url, 'rs6.min.js') === false && strpos($url, 'rbtools.min.js') === false){\n\t\t\treturn $url;\n\t\t}elseif(is_admin()){\n\t\t\treturn $url;\n\t\t}else{\n\t\t\treturn $url . \"' defer='defer\";\n\t\t}\n\t}\n\t\n\t\/**\n\t * Add functionality to gutenberg, elementor, visual composer and so on\n\t **\/\n\tpublic static function add_post_editor(){\n\t\t\/**\n\t\t * Page Editor Extensions\n\t\t **\/\n\t\tif(function_exists('is_user_logged_in') && is_user_logged_in()){\n\t\t\t\/\/only include gutenberg for production\n\t\t\tif(is_admin() && defined('ABSPATH')){\n\t\t\t\tinclude_once(ABSPATH . 'wp-admin\/includes\/plugin.php');\n\t\t\t\tif(function_exists('is_plugin_active') && !is_plugin_active('revslider-gutenberg\/plugin.php')){\n\t\t\t\t\trequire_once(RS_PLUGIN_PATH . 'admin\/includes\/shortcode_generator\/gutenberg\/gutenberg-block.php');\n\t\t\t\t\tnew RevSliderGutenberg('gutenberg\/');\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\trequire_once(RS_PLUGIN_PATH . 'admin\/includes\/shortcode_generator\/shortcode_generator.class.php');\n\t\t\t\n\t\t\t\/\/Shortcode Wizard Includes\n\t\t\t\/\/WPB Functionality\n\t\t\trequire_once(RS_PLUGIN_PATH . 'admin\/includes\/shortcode_generator\/wpbakery\/wpbakery.class.php');\n\t\t\tadd_action('vc_before_init', array('RevSliderWpbakeryShortcode', 'visual_composer_include')); \/\/VC functionality\n\t\t\tadd_action('admin_enqueue_scripts', array('RevSliderShortcodeWizard', 'enqueue_scripts'));\n\t\t\tadd_action('admin_footer', array('RevSliderShortcodeWizard', 'enqueue_files'));\n\t\t\t\/\/add_action('wp_footer', array('RevSliderShortcodeWizard', 'enqueue_files'));\n\t\t\tadd_action('vc_before_init', array('RevSliderShortcodeWizard', 'add_styles')); \/\/VC functionality\n\t\t}\n\t\t\n\t\t\n\n\t\t\/\/Elementor Functionality\n\t\trequire_once(RS_PLUGIN_PATH . 'admin\/includes\/shortcode_generator\/elementor\/elementor.class.php');\n\t\tadd_action('init', array('RevSliderElementor', 'init'));\n\t\tadd_action('elementor\/editor\/before_enqueue_scripts', array('RevSliderShortcodeWizard', 'enqueue_files'));\n\t}\n\n\t\/**\n\t * Add Meta Generator Tag in FrontEnd\n\t * @since: 5.4.3\n\t * @before: add_setREVStartSize()\n\t\t\/\/NOT COMPRESSED VERSION\n\t\tfunction setREVStartSize(e){\t\n\t\t\t\/\/window.requestAnimationFrame(function() {\t\n\t\t\t\twindow.RSIW = window.RSIW===undefined ? window.innerWidth : window.RSIW;\t\n\t\t\t\twindow.RSIH = window.RSIH===undefined ? window.innerHeight : window.RSIH;\t\n\t\t\t\ttry {\t\t\t\t\t\t\t\t\n\t\t\t\t\tvar pw = document.getElementById(e.c).parentNode.offsetWidth,\n\t\t\t\t\t\tnewh;\n\t\t\t\t\tpw = pw===0 || isNaN(pw) ? window.RSIW : pw;\n\t\t\t\t\te.tabw = e.tabw===undefined ? 0 : parseInt(e.tabw);\n\t\t\t\t\te.thumbw = e.thumbw===undefined ? 0 : parseInt(e.thumbw);\n\t\t\t\t\te.tabh = e.tabh===undefined ? 0 : parseInt(e.tabh);\n\t\t\t\t\te.thumbh = e.thumbh===undefined ? 0 : parseInt(e.thumbh);\n\t\t\t\t\te.tabhide = e.tabhide===undefined ? 0 : parseInt(e.tabhide);\n\t\t\t\t\te.thumbhide = e.thumbhide===undefined ? 0 : parseInt(e.thumbhide);\n\t\t\t\t\te.mh = e.mh===undefined || e.mh==\"\" || e.mh===\"auto\" ? 0 : parseInt(e.mh,0);\t\t\n\t\t\t\t\tif(e.layout===\"fullscreen\" || e.l===\"fullscreen\") \t\t\t\t\t\t\n\t\t\t\t\t\tnewh = Math.max(e.mh,window.RSIH);\t\t\t\t\t\n\t\t\t\t\telse{\t\t\t\t\t\n\t\t\t\t\t\te.gw = Array.isArray(e.gw) ? e.gw : [e.gw];\n\t\t\t\t\t\tfor (var i in e.rl) if (e.gw[i]===undefined || e.gw[i]===0) e.gw[i] = e.gw[i-1];\t\t\t\t\t\n\t\t\t\t\t\te.gh = e.el===undefined || e.el===\"\" || (Array.isArray(e.el) && e.el.length==0)? e.gh : e.el;\n\t\t\t\t\t\te.gh = Array.isArray(e.gh) ? e.gh : [e.gh];\n\t\t\t\t\t\tfor (var i in e.rl) if (e.gh[i]===undefined || e.gh[i]===0) e.gh[i] = e.gh[i-1];\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tvar nl = new Array(e.rl.length),\n\t\t\t\t\t\t\tix = 0,\t\t\t\t\t\t\n\t\t\t\t\t\t\tsl;\t\t\t\t\t\n\t\t\t\t\t\te.tabw = e.tabhide>=pw ? 0 : e.tabw;\n\t\t\t\t\t\te.thumbw = e.thumbhide>=pw ? 0 : e.thumbw;\n\t\t\t\t\t\te.tabh = e.tabhide>=pw ? 0 : e.tabh;\n\t\t\t\t\t\te.thumbh = e.thumbhide>=pw ? 0 : e.thumbh;\t\t\t\t\t\n\t\t\t\t\t\tfor (var i in e.rl) nl[i] = e.rl[i]<window.RSIW ? 0 : e.rl[i];\n\t\t\t\t\t\tsl = nl[0];\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tfor (var i in nl) if (sl>nl[i] && nl[i]>0) { sl = nl[i]; ix=i;}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tvar m = pw>(e.gw[ix]+e.tabw+e.thumbw) ? 1 : (pw-(e.tabw+e.thumbw)) \/ (e.gw[ix]);\t\t\t\t\t\n\t\t\t\t\t\tnewh =  (e.gh[ix] * m) + (e.tabh + e.thumbh);\n\t\t\t\t\t}\t\t\t\t\n\t\t\t\t\tif(window.rs_init_css===undefined) window.rs_init_css = document.head.appendChild(document.createElement(\"style\"));\t\t\t\t\t\n\t\t\t\t\tdocument.getElementById(e.c).height = newh+\"px\";\n\t\t\t\t\twindow.rs_init_css.innerHTML += \"#\"+e.c+\"_wrapper { height: \"+newh+\"px }\";\t\t\t\t\n\t\t\t\t} catch(e){\n\t\t\t\t\tconsole.log(\"Failure at Presize of Slider:\" + e)\n\t\t\t\t}\t\t\t\t\t   \n\t\t\t\/\/}\n\t\t  };\n\t *\/\n\tpublic static function js_set_start_size(){\n\t\tglobal $revslider_rev_start_size_loaded;\n\t\tif($revslider_rev_start_size_loaded === true) return false;\n\t\t\n\t\t$script = '<script type=\"text\/javascript\">';\t\t\n\t\t$script .= 'function setREVStartSize(e){\n\t\t\t\/\/window.requestAnimationFrame(function() {\t\t\t\t \n\t\t\t\twindow.RSIW = window.RSIW===undefined ? window.innerWidth : window.RSIW;\t\n\t\t\t\twindow.RSIH = window.RSIH===undefined ? window.innerHeight : window.RSIH;\t\n\t\t\t\ttry {\t\t\t\t\t\t\t\t\n\t\t\t\t\tvar pw = document.getElementById(e.c).parentNode.offsetWidth,\n\t\t\t\t\t\tnewh;\n\t\t\t\t\tpw = pw===0 || isNaN(pw) ? window.RSIW : pw;\n\t\t\t\t\te.tabw = e.tabw===undefined ? 0 : parseInt(e.tabw);\n\t\t\t\t\te.thumbw = e.thumbw===undefined ? 0 : parseInt(e.thumbw);\n\t\t\t\t\te.tabh = e.tabh===undefined ? 0 : parseInt(e.tabh);\n\t\t\t\t\te.thumbh = e.thumbh===undefined ? 0 : parseInt(e.thumbh);\n\t\t\t\t\te.tabhide = e.tabhide===undefined ? 0 : parseInt(e.tabhide);\n\t\t\t\t\te.thumbhide = e.thumbhide===undefined ? 0 : parseInt(e.thumbhide);\n\t\t\t\t\te.mh = e.mh===undefined || e.mh==\"\" || e.mh===\"auto\" ? 0 : parseInt(e.mh,0);\t\t\n\t\t\t\t\tif(e.layout===\"fullscreen\" || e.l===\"fullscreen\") \t\t\t\t\t\t\n\t\t\t\t\t\tnewh = Math.max(e.mh,window.RSIH);\t\t\t\t\t\n\t\t\t\t\telse{\t\t\t\t\t\n\t\t\t\t\t\te.gw = Array.isArray(e.gw) ? e.gw : [e.gw];\n\t\t\t\t\t\tfor (var i in e.rl) if (e.gw[i]===undefined || e.gw[i]===0) e.gw[i] = e.gw[i-1];\t\t\t\t\t\n\t\t\t\t\t\te.gh = e.el===undefined || e.el===\"\" || (Array.isArray(e.el) && e.el.length==0)? e.gh : e.el;\n\t\t\t\t\t\te.gh = Array.isArray(e.gh) ? e.gh : [e.gh];\n\t\t\t\t\t\tfor (var i in e.rl) if (e.gh[i]===undefined || e.gh[i]===0) e.gh[i] = e.gh[i-1];\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tvar nl = new Array(e.rl.length),\n\t\t\t\t\t\t\tix = 0,\t\t\t\t\t\t\n\t\t\t\t\t\t\tsl;\t\t\t\t\t\n\t\t\t\t\t\te.tabw = e.tabhide>=pw ? 0 : e.tabw;\n\t\t\t\t\t\te.thumbw = e.thumbhide>=pw ? 0 : e.thumbw;\n\t\t\t\t\t\te.tabh = e.tabhide>=pw ? 0 : e.tabh;\n\t\t\t\t\t\te.thumbh = e.thumbhide>=pw ? 0 : e.thumbh;\t\t\t\t\t\n\t\t\t\t\t\tfor (var i in e.rl) nl[i] = e.rl[i]<window.RSIW ? 0 : e.rl[i];\n\t\t\t\t\t\tsl = nl[0];\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tfor (var i in nl) if (sl>nl[i] && nl[i]>0) { sl = nl[i]; ix=i;}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tvar m = pw>(e.gw[ix]+e.tabw+e.thumbw) ? 1 : (pw-(e.tabw+e.thumbw)) \/ (e.gw[ix]);\t\t\t\t\t\n\t\t\t\t\t\tnewh =  (e.gh[ix] * m) + (e.tabh + e.thumbh);\n\t\t\t\t\t}\t\t\t\t\n\t\t\t\t\tif(window.rs_init_css===undefined) window.rs_init_css = document.head.appendChild(document.createElement(\"style\"));\t\t\t\t\t\n\t\t\t\t\tdocument.getElementById(e.c).height = newh+\"px\";\n\t\t\t\t\twindow.rs_init_css.innerHTML += \"#\"+e.c+\"_wrapper { height: \"+newh+\"px }\";\t\t\t\t\n\t\t\t\t} catch(e){\n\t\t\t\t\tconsole.log(\"Failure at Presize of Slider:\" + e)\n\t\t\t\t}\t\t\t\t\t   \n\t\t\t\/\/});\n\t\t  };';\n\t\t$script .= '<\/script>' . \"\\n\";\n\t\techo apply_filters('revslider_add_setREVStartSize', $script);\n\t\t\n\t\t$revslider_rev_start_size_loaded = true;\n\t}\n\t\n\t\/**\n\t * sets the post saving value to true, so that the output echo will not be done\n\t **\/\n\tpublic static function set_post_saving(){\n\t\tglobal $revslider_save_post;\n\t\t$revslider_save_post = true;\n\t}\n\t\n\t\/**\n\t * check the current post for the existence of a short code\n\t * @before: hasShortcode()\n\t *\/  \n\tpublic static function has_shortcode($shortcode = ''){  \n\t\t$found = false; \n\t\t\n\t\tif(empty($shortcode)) return false;\n\t\tif(!is_singular()) return false;\n\t\t\n\t\t$post = get_post(get_the_ID());  \n\t\tif(stripos($post->post_content, '[' . $shortcode) !== false) $found = true;  \n\t\t\n\t\treturn $found;  \n\t}\n\n\t\/**\n\t * Create Tables\n\t * @only_base needs to be false\n\t *  it can only be true by fixing database issues\n\t *  this protects that the _bkp tables are not filled after \n\t *  we are already on version 6.0\n\t **\/\n\tpublic static function create_tables($only_base = false){\n\t\t$table_version = get_option('revslider_table_version', '1.0.0');\n\t\t\n\t\tif(version_compare($table_version, self::CURRENT_TABLE_VERSION, '<')){\n\t\t\tglobal $wpdb;\n\n\t\t\trequire_once(ABSPATH . 'wp-admin\/includes\/upgrade.php');\n\n\t\t\t$sql = \"CREATE TABLE \" . $wpdb->prefix . self::TABLE_SLIDER . \" (\n\t\t\t  id int(9) NOT NULL AUTO_INCREMENT,\n\t\t\t  title tinytext NOT NULL,\n\t\t\t  alias tinytext,\n\t\t\t  params LONGTEXT NOT NULL,\n\t\t\t  settings text NULL,\n\t\t\t  type VARCHAR(191) NOT NULL DEFAULT '',\n\t\t\t  UNIQUE KEY id (id),\n\t\t\t  INDEX `type_index` (`type`(8))\n\t\t\t);\";\n\t\t\tdbDelta($sql);\n\n\t\t\t$sql = \"CREATE TABLE \" . $wpdb->prefix . self::TABLE_SLIDES . \" (\n\t\t\t  id int(9) NOT NULL AUTO_INCREMENT,\n\t\t\t  slider_id int(9) NOT NULL,\n\t\t\t  slide_order int not NULL,\n\t\t\t  params LONGTEXT NOT NULL,\n\t\t\t  layers LONGTEXT NOT NULL,\n\t\t\t  settings text NOT NULL DEFAULT '',\n\t\t\t  UNIQUE KEY id (id),\n\t\t\t  INDEX `slider_id_index` (`slider_id`)\n\t\t\t);\";\n\t\t\tdbDelta($sql);\n\n\t\t\t$sql = \"CREATE TABLE \" . $wpdb->prefix . self::TABLE_STATIC_SLIDES . \" (\n\t\t\t  id int(9) NOT NULL AUTO_INCREMENT,\n\t\t\t  slider_id int(9) NOT NULL,\n\t\t\t  params LONGTEXT NOT NULL,\n\t\t\t  layers LONGTEXT NOT NULL,\n\t\t\t  settings text NOT NULL,\n\t\t\t  UNIQUE KEY id (id),\n\t\t\t  INDEX `slider_id_index` (`slider_id`)\n\t\t\t);\";\n\t\t\tdbDelta($sql);\n\n\t\t\t$sql = \"CREATE TABLE \" . $wpdb->prefix . self::TABLE_CSS . \" (\n\t\t\t  id int(9) NOT NULL AUTO_INCREMENT,\n\t\t\t  handle TEXT NOT NULL,\n\t\t\t  settings LONGTEXT,\n\t\t\t  hover LONGTEXT,\n\t\t\t  advanced LONGTEXT,\n\t\t\t  params LONGTEXT NOT NULL,\n\t\t\t  UNIQUE KEY id (id),\n\t\t\t  INDEX `handle_index` (`handle`(64))\n\t\t\t);\";\n\t\t\tdbDelta($sql);\n\n\t\t\t$sql = \"CREATE TABLE \" . $wpdb->prefix . self::TABLE_LAYER_ANIMATIONS . \" (\n\t\t\t  id int(9) NOT NULL AUTO_INCREMENT,\n\t\t\t  handle TEXT NOT NULL,\n\t\t\t  params TEXT NOT NULL,\n\t\t\t  settings text NULL,\n\t\t\t  UNIQUE KEY id (id)\n\t\t\t);\";\n\t\t\tdbDelta($sql);\n\n\t\t\t$sql = \"CREATE TABLE \" . $wpdb->prefix . self::TABLE_NAVIGATIONS . \" (\n\t\t\t  id int(9) NOT NULL AUTO_INCREMENT,\n\t\t\t  name VARCHAR(191) NOT NULL,\n\t\t\t  handle VARCHAR(191) NOT NULL,\n\t\t\t  type VARCHAR(191) NOT NULL,\n\t\t\t  css LONGTEXT NOT NULL,\n\t\t\t  markup LONGTEXT NOT NULL,\n\t\t\t  settings LONGTEXT NULL,\n\t\t\t  UNIQUE KEY id (id)\n\t\t\t);\";\n\t\t\tdbDelta($sql);\n\n\t\t\t\/\/create CSS entries\n\t\t\t$result = $wpdb->get_row(\"SELECT COUNT( DISTINCT id ) AS NumberOfEntrys FROM \" . $wpdb->prefix . self::TABLE_CSS);\n\t\t\tif(!empty($result) && $result->NumberOfEntrys == 0){\n\t\t\t\t$css_class = RevSliderGlobals::instance()->get('RevSliderCssParser');\n\t\t\t\t$css_class->import_css_captions();\n\t\t\t}\n\n\t\t\tupdate_option('revslider_table_version', self::CURRENT_TABLE_VERSION);\n\t\t\t\/\/$table_version = self::CURRENT_TABLE_VERSION;\n\t\t}\n\t\t\n\t\t\n\t\t\/**\n\t\t * check if table version is below 1.0.8.\n\t\t * if yes, duplicate the tables into _bkp\n\t\t * this way, we can revert back to v5 if any slider\n\t\t * has issues in the v6 migration process\n\t\t **\/\n\t\tif(version_compare($table_version, '1.0.8', '<') && ($only_base === false || $only_base === '')){\n\t\t\tglobal $wpdb;\n\t\t\t\n\t\t\trequire_once(ABSPATH . 'wp-admin\/includes\/upgrade.php');\n\t\t\t\n\t\t\t$sql = \"CREATE TABLE IF NOT EXISTS \".$wpdb->prefix . self::TABLE_SLIDER.\"_bkp LIKE \".$wpdb->prefix . self::TABLE_SLIDER.\";\";\n\t\t\tdbDelta($sql);\n\t\t\t$result = $wpdb->get_row(\"SELECT EXISTS (SELECT 1 FROM \".$wpdb->prefix . self::TABLE_SLIDER.\"_bkp) AS `exists`;\", ARRAY_A);\n\t\t\tif(!empty($result) && isset($result['exists']) && $result['exists'] === '0'){\n\t\t\t\t$sql = \"INSERT \".$wpdb->prefix . self::TABLE_SLIDER.\"_bkp SELECT * FROM \".$wpdb->prefix . self::TABLE_SLIDER.\";\";\n\t\t\t\t$wpdb->query($sql);\n\t\t\t}\n\t\t\t\n\t\t\t$sql = \"CREATE TABLE IF NOT EXISTS \".$wpdb->prefix . self::TABLE_SLIDES.\"_bkp LIKE \".$wpdb->prefix . self::TABLE_SLIDES.\";\";\n\t\t\tdbDelta($sql);\n\t\t\t$result = $wpdb->get_row(\"SELECT EXISTS (SELECT 1 FROM \".$wpdb->prefix . self::TABLE_SLIDES.\"_bkp) AS `exists`;\", ARRAY_A);\n\t\t\tif(!empty($result) && isset($result['exists']) && $result['exists'] === '0'){\n\t\t\t\t$sql = \"INSERT \".$wpdb->prefix . self::TABLE_SLIDES.\"_bkp SELECT * FROM \".$wpdb->prefix . self::TABLE_SLIDES.\";\";\n\t\t\t\t$wpdb->query($sql);\n\t\t\t}\n\t\t\t\n\t\t\t$sql = \"CREATE TABLE IF NOT EXISTS \".$wpdb->prefix . self::TABLE_STATIC_SLIDES.\"_bkp LIKE \".$wpdb->prefix . self::TABLE_STATIC_SLIDES.\";\";\n\t\t\tdbDelta($sql);\n\t\t\t$result = $wpdb->get_row(\"SELECT EXISTS (SELECT 1 FROM \".$wpdb->prefix . self::TABLE_STATIC_SLIDES.\"_bkp) AS `exists`;\", ARRAY_A);\n\t\t\tif(!empty($result) && isset($result['exists']) && $result['exists'] === '0'){\n\t\t\t\t$sql = \"INSERT \".$wpdb->prefix . self::TABLE_STATIC_SLIDES.\"_bkp SELECT * FROM \".$wpdb->prefix . self::TABLE_STATIC_SLIDES.\";\";\n\t\t\t\t$wpdb->query($sql);\n\t\t\t}\n\t\t\t\n\t\t\t$sql = \"CREATE TABLE IF NOT EXISTS \".$wpdb->prefix . self::TABLE_CSS.\"_bkp LIKE \".$wpdb->prefix . self::TABLE_CSS.\";\";\n\t\t\tdbDelta($sql);\n\t\t\t$result = $wpdb->get_row(\"SELECT EXISTS (SELECT 1 FROM \".$wpdb->prefix . self::TABLE_CSS.\"_bkp) AS `exists`;\", ARRAY_A);\n\t\t\tif(!empty($result) && isset($result['exists']) && $result['exists'] === '0'){\n\t\t\t\t$sql = \"INSERT \".$wpdb->prefix . self::TABLE_CSS.\"_bkp SELECT * FROM \".$wpdb->prefix . self::TABLE_CSS.\";\";\n\t\t\t\t$wpdb->query($sql);\n\t\t\t}\n\t\t\t\n\t\t\t$sql = \"CREATE TABLE IF NOT EXISTS \".$wpdb->prefix . self::TABLE_LAYER_ANIMATIONS.\"_bkp LIKE \".$wpdb->prefix . self::TABLE_LAYER_ANIMATIONS.\";\";\n\t\t\tdbDelta($sql);\n\t\t\t$result = $wpdb->get_row(\"SELECT EXISTS (SELECT 1 FROM \".$wpdb->prefix . self::TABLE_LAYER_ANIMATIONS.\"_bkp) AS `exists`;\", ARRAY_A);\n\t\t\tif(!empty($result) && isset($result['exists']) && $result['exists'] === '0'){\n\t\t\t\t$sql = \"INSERT \".$wpdb->prefix . self::TABLE_LAYER_ANIMATIONS.\"_bkp SELECT * FROM \".$wpdb->prefix . self::TABLE_LAYER_ANIMATIONS.\";\";\n\t\t\t\t$wpdb->query($sql);\n\t\t\t}\n\t\t\t\n\t\t\t$sql = \"CREATE TABLE IF NOT EXISTS \".$wpdb->prefix . self::TABLE_NAVIGATIONS.\"_bkp LIKE \".$wpdb->prefix . self::TABLE_NAVIGATIONS.\";\";\n\t\t\tdbDelta($sql);\n\t\t\t$result = $wpdb->get_row(\"SELECT EXISTS (SELECT 1 FROM \".$wpdb->prefix . self::TABLE_NAVIGATIONS.\"_bkp) AS `exists`;\", ARRAY_A);\n\t\t\tif(!empty($result) && isset($result['exists']) && $result['exists'] === '0'){\n\t\t\t\t$sql = \"INSERT \".$wpdb->prefix . self::TABLE_NAVIGATIONS.\"_bkp SELECT * FROM \".$wpdb->prefix . self::TABLE_NAVIGATIONS.\";\";\n\t\t\t\t$wpdb->query($sql);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t\/**\n\t * get the images from posts\/pages for yoast seo\n\t **\/\n\tpublic static function get_images_for_seo($url, $type, $user){\n\t\tif(in_array($type, array('user', 'term'), true)) return $url;\n\t\tif(!is_object($user) || !isset($user->ID)) return $url;\n\t\t\n\t\t$post = get_post($user->ID);\n\t\tif(is_a($post, 'WP_Post') && has_shortcode($post->post_content, 'rev_slider')){\n\t\t\tpreg_match_all('\/\\[rev_slider.*alias=.(.*)\"\\]\/', $post->post_content, $shortcodes);\n\t\t\t\n\t\t\tif(isset($shortcodes[1]) && $shortcodes[1] !== ''){\n\t\t\t\tforeach($shortcodes[1] as $s){\n\t\t\t\t\tif(!RevSliderSlider::alias_exists($s)) continue;\n\t\t\t\t\t\n\t\t\t\t\t$sldr = new RevSliderSlider();\n\t\t\t\t\t$sldr->init_by_alias($s);\n\t\t\t\t\t$sldr->get_slides();\n\t\t\t\t\t$imgs = $sldr->get_images();\n\t\t\t\t\tif(!empty($imgs)){\n\t\t\t\t\t\tif(!isset($url['images'])) $url['images'] = array();\n\t\t\t\t\t\tforeach($imgs as $v){\n\t\t\t\t\t\t\t$url['images'][] = $v;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $url;\n\t}\n\t\n}","avg_line_length":40.2610062893,"max_line_length":354,"alphanum_fraction":0.6358665938,"licenses":["MIT"],"repository_name":"gmiconi\/Vivenciar","path":"wp-content\/plugins\/revslider\/public\/revslider-front.class.php","size":25606,"lang":"PHP"}
{"content":"# Copyright (c) 2013, Ruslan Baratov\n# All rights reserved.\n\n# !!! DO NOT PLACE HEADER GUARDS HERE !!!\n\ninclude(hunter_download)\ninclude(hunter_pick_scheme)\n\nhunter_pick_scheme(\n    DEFAULT\n    url_sha1_boost_library\n    IPHONEOS\n    url_sha1_boost_ios_library\n)\n\nhunter_download(\n    PACKAGE_NAME\n    Boost\n    PACKAGE_COMPONENT\n    program_options\n    PACKAGE_INTERNAL_DEPS_ID \"49\"\n)\n","avg_line_length":16.7826086957,"max_line_length":41,"alphanum_fraction":0.7461139896,"licenses":["BSD-2-Clause"],"repository_name":"CHChang810716\/hunter","path":"cmake\/projects\/Boost\/program_options\/hunter.cmake","size":386,"lang":"CMake"}
{"content":"\npackage ch.hslu.oop.sw05;\n\n\/**\n * extends from ISwitchable\n *\/\npublic interface ICountingSwitchable extends ISwitchable\n{\n  \/**\n   * \n   * @return switchCount\n   *\/\n  public long getSwitchCount();\n}\n","avg_line_length":13.3333333333,"max_line_length":56,"alphanum_fraction":0.675,"licenses":["Apache-2.0"],"repository_name":"ostaubzug\/FS22Java","path":"src\/main\/java\/ch\/hslu\/oop\/sw05\/ICountingSwitchable.java","size":200,"lang":"Java"}
{"content":"import { createGlobalStyle } from 'styled-components';\n\nexport const GlobalStyles = createGlobalStyle`\n    * {\n        margin: 0;\n        padding: 0;\n        font-family: 'Source Sans Pro', sans-serif;\n    }\n`;\n","avg_line_length":21.1,"max_line_length":54,"alphanum_fraction":0.6161137441,"licenses":["MIT"],"repository_name":"PedroHenrique-git\/FanPageRickAndMorty","path":"src\/styles\/GlobalStyle.tsx","size":211,"lang":"TypeScript"}
{"content":"BEGIN;\nCREATE OR REPLACE FUNCTION openreplay_version()\n    RETURNS text AS\n$$\nSELECT 'v1.4.0'\n$$ LANGUAGE sql IMMUTABLE;\n\nCREATE INDEX IF NOT EXISTS user_favorite_sessions_user_id_session_id_idx ON user_favorite_sessions (user_id, session_id);\n\nCREATE INDEX IF NOT EXISTS pages_session_id_timestamp_idx ON events.pages (session_id, timestamp);\n\nCREATE INDEX IF NOT EXISTS errors_timestamp_idx ON events.errors (timestamp);\nCREATE INDEX IF NOT EXISTS projects_project_key_idx ON public.projects (project_key);\n\nALTER TABLE sessions\n    ADD COLUMN IF NOT EXISTS utm_source   text NULL DEFAULT NULL,\n    ADD COLUMN IF NOT EXISTS utm_medium   text NULL DEFAULT NULL,\n    ADD COLUMN IF NOT EXISTS utm_campaign text NULL DEFAULT NULL;\n\nCREATE INDEX IF NOT EXISTS sessions_utm_source_gin_idx ON public.sessions USING GIN (utm_source gin_trgm_ops);\nCREATE INDEX IF NOT EXISTS sessions_utm_medium_gin_idx ON public.sessions USING GIN (utm_medium gin_trgm_ops);\nCREATE INDEX IF NOT EXISTS sessions_utm_campaign_gin_idx ON public.sessions USING GIN (utm_campaign gin_trgm_ops);\nCREATE INDEX IF NOT EXISTS requests_timestamp_session_id_failed_idx ON events_common.requests (timestamp, session_id) WHERE success = FALSE;\n\n\nDROP INDEX IF EXISTS sessions_project_id_user_browser_idx1;\nDROP INDEX IF EXISTS sessions_project_id_user_country_idx1;\nALTER INDEX IF EXISTS platform_idx RENAME TO sessions_platform_idx;\nALTER INDEX IF EXISTS events.resources_duration_idx RENAME TO resources_duration_durationgt0_idx;\nDROP INDEX IF EXISTS projects_project_key_idx1;\nCREATE INDEX IF NOT EXISTS errors_parent_error_id_idx ON errors (parent_error_id);\n\nCREATE INDEX IF NOT EXISTS performance_session_id_idx ON events.performance (session_id);\nCREATE INDEX IF NOT EXISTS performance_timestamp_idx ON events.performance (timestamp);\nCREATE INDEX IF NOT EXISTS performance_session_id_timestamp_idx ON events.performance (session_id, timestamp);\nCREATE INDEX IF NOT EXISTS performance_avg_cpu_gt0_idx ON events.performance (avg_cpu) WHERE avg_cpu > 0;\nCREATE INDEX IF NOT EXISTS performance_avg_used_js_heap_size_gt0_idx ON events.performance (avg_used_js_heap_size) WHERE avg_used_js_heap_size > 0;\n\nCREATE TABLE IF NOT EXISTS metrics\n(\n    metric_id  integer generated BY DEFAULT AS IDENTITY PRIMARY KEY,\n    project_id integer NOT NULL REFERENCES projects (project_id) ON DELETE CASCADE,\n    user_id    integer REFERENCES users (user_id) ON DELETE SET NULL,\n    name       text    NOT NULL,\n    is_public  boolean NOT NULL DEFAULT FALSE,\n    created_at timestamp        default timezone('utc'::text, now()) not null,\n    deleted_at timestamp\n);\nCREATE INDEX IF NOT EXISTS metrics_user_id_is_public_idx ON public.metrics (user_id, is_public);\nCREATE TABLE IF NOT EXISTS metric_series\n(\n    series_id  integer generated BY DEFAULT AS IDENTITY PRIMARY KEY,\n    metric_id  integer REFERENCES metrics (metric_id) ON DELETE CASCADE,\n    index      integer                                        NOT NULL,\n    name       text                                           NULL,\n    filter     jsonb                                          NOT NULL,\n    created_at timestamp DEFAULT timezone('utc'::text, now()) NOT NULL,\n    deleted_at timestamp\n);\nCREATE INDEX IF NOT EXISTS metric_series_metric_id_idx ON public.metric_series (metric_id);\n\nCREATE INDEX IF NOT EXISTS funnels_project_id_idx ON public.funnels (project_id);\n\n\nCREATE TABLE IF NOT EXISTS searches\n(\n    search_id  integer generated BY DEFAULT AS IDENTITY PRIMARY KEY,\n    project_id integer NOT NULL REFERENCES projects (project_id) ON DELETE CASCADE,\n    user_id    integer NOT NULL REFERENCES users (user_id) ON DELETE CASCADE,\n    name       text    not null,\n    filter     jsonb   not null,\n    created_at timestamp        default timezone('utc'::text, now()) not null,\n    deleted_at timestamp,\n    is_public  boolean NOT NULL DEFAULT False\n);\n\nCREATE INDEX IF NOT EXISTS searches_user_id_is_public_idx ON public.searches (user_id, is_public);\nCREATE INDEX IF NOT EXISTS searches_project_id_idx ON public.searches (project_id);\nCREATE INDEX IF NOT EXISTS alerts_project_id_idx ON alerts (project_id);\n\nALTER TABLE alerts\n    ADD COLUMN IF NOT EXISTS series_id integer NULL REFERENCES metric_series (series_id) ON DELETE CASCADE;\n\nCREATE INDEX IF NOT EXISTS alerts_series_id_idx ON alerts (series_id);\nUPDATE alerts\nSET options=jsonb_set(options, '{change}', '\"change\"')\nWHERE detection_method = 'change'\n  AND options -> 'change' ISNULL;\nCOMMIT;","avg_line_length":50.3370786517,"max_line_length":147,"alphanum_fraction":0.7758928571,"licenses":["MIT"],"repository_name":"domnantas\/openreplay","path":"scripts\/helm\/db\/init_dbs\/postgresql\/1.4.0\/1.4.0.sql","size":4480,"lang":"SQL"}
{"content":"package tk.csparpa.gofdp.interpreter;\n\npublic class AndExpression implements AbstractExpression {\n\n\tAbstractExpression operand1, operand2;\n\t\n\tpublic AndExpression(AbstractExpression operand1, AbstractExpression operand2) {\n\t\tthis.operand1 = operand1;\n\t\tthis.operand2 = operand2;\n\t}\n\t\n\t@Override\n\tpublic boolean interpret(Context context) {\n\t\treturn operand1.interpret(context) && operand2.interpret(context);\n\t}\n}\n","avg_line_length":24.3529411765,"max_line_length":81,"alphanum_fraction":0.7898550725,"licenses":["Unlicense"],"repository_name":"csparpa\/gof-design-patterns","path":"java\/src\/tk\/csparpa\/gofdp\/interpreter\/AndExpression.java","size":414,"lang":"Java"}
{"content":"# MMA Algorithms\n\n\"\"\"\n    MMA87\n\nThe original method of moving asymptotes (MMA) algorithm from the [1987 paper](https:\/\/onlinelibrary.wiley.com\/doi\/abs\/10.1002\/nme.1620240207).\n\"\"\"\n@params struct MMA87 <: AbstractOptimizer\n    dualoptimizer\nend\nfunction MMA87(; dualoptimizer = Optim.GradientDescent())\n    return MMA87(dualoptimizer)\nend\n\nconst MMA = MMA87\n\n\"\"\"\n    MMA02\n\nThe globally convergent method of moving asymptotes (MMA) algorithm from the [2002 paper](https:\/\/epubs.siam.org\/doi\/abs\/10.1137\/S1052623499362822).\n\"\"\"\n@params struct MMA02 <: AbstractOptimizer\n    dualoptimizer\nend\nfunction MMA02(; dualoptimizer = Optim.GradientDescent())\n    return MMA02(dualoptimizer)\nend\n\nconst GCMMA = MMA02\n\n\"\"\"\n    MMAOptions\n\nA struct that stores all the options of the MMA algorithms. Th following are the fields of `MMAOptions`:\n - `maxiter`: the maximum number of inner iterations. For `MMA87`, there is 1 inner iteration per outer iteration.\n - `outer_maxiter`: the maximum number of outer iterations.\n - `maxinner`: the maximum number of inner iterations per outer iteration of [`MMA02`](@ref). Not applicable for [`MMA87`](@ref).\n - `tol`: a tolerance struct of type [`Tolerance`](@ref).\n - `s_init`: defined in the original [`MMA02`](@ref) paper.\n - `s_incr`: defined in the original [`MMA02`](@ref) paper.\n - `s_decr`: defined in the original [`MMA02`](@ref) paper.\n - `store_trace`: if true, a trace will be stored.\n - `dual_options`: the options passed to the dual optimizer from [`Optim.jl`](https:\/\/github.com\/JuliaNLSolvers\/Optim.jl).\n\"\"\"\n@with_kw mutable struct MMAOptions{T, Ttol <: Tolerance, TSubOptions <: Optim.Options}\n    maxiter::Int = 1000\n    outer_maxiter::Int = 10^8\n    maxinner::Int = 10\n    tol::Ttol = Tolerance()\n    s_init::T = 0.5\n    s_incr::T = 1.2\n    s_decr::T = 0.7\n    store_trace::Bool = false\n    show_trace::Bool = false\n    auto_scale::Bool = false\n    keep_best::Bool = false\n    dual_options::TSubOptions = Optim.Options(\n        allow_outer_f_increases = true,\n        allow_f_increases = true,\n        iterations = 1000,\n        outer_iterations=1000,\n    )\nend\n\n\"\"\"\n    Trace\n\nA struct that stores the history of solutions.\n\"\"\"\nstruct Trace\n    tr::Vector\nend\n\n\"\"\"\n    MMAWorkspace\n\nA struct that stores all the intermediate states and memory allocations needed for the optimization. The following are the fields of the struct:\n - `model`: the original instance of [`MMAModel`](@ref) being optimized.\n - `dualmodel`: an instance of [`DualMMAModel`](@ref) which resembles the dual of the MMA approximation of the original model.\n - `x0`: the initial primal solution.\n - `solution`: an instance of [`Solution`](@ref) that resembles the current solution in the optimization algorithm.\n - `\u03c3`: the workspace move limit, explained in [`MMAApprox`](@ref).\n - `\u03c1`: the `\u03c1` parameter as explained in [`MMAApprox`](@ref).\n - `tempx`: a temporary vector used to store the 2nd previous primal solution.\n - `options`: an instance of [`MMAOptions`](@ref) that resembles the options of the MMA algorithm.\n - `convcriteria`: an instance of [`ConvergenceCriteria`](@ref) that specifies the convergence criteria of the MMA algorithm.\n - `callback`: a function that is called on `solution` in every iteration of the algorithm. This can be used to store information about the optimization process.\n - `optimizer`: an instance of [`AbstractOptimizer`](@ref) such as `MMA87()` or `MMA02()` that specifies the variant of MMA used to optimize the model.\n - `suboptimizer`: the dual optimization algorithm used to optimize the barrier problem. This should be an [`Optim.jl`](https:\/\/github.com\/JuliaNLSolvers\/Optim.jl) optimizer.\n - `tracing`: a Boolean that when true stores the trace of solutions evaluated during the optimization process.\n - `outer_iter`: the current outer iteration index. [`MMA87`](@ref) has 1 inner iteration per outer iteration. [`MMA02`](@ref) does multiple inner iterations per outer iteration.\n - `iter`: the current inner iteration index.\n - `fcalls`: the current number of objective and constraint function calls.\n\"\"\"\n@params mutable struct MMAWorkspace <: Workspace\n    model::VecModel\n    dualmodel::MMADualModel\n    x0::AbstractVector\n    solution::Solution\n    \u03c3::AbstractVector\n    \u03c1::AbstractVector\n    tempx::AbstractVector\n    convcriteria::ConvergenceCriteria\n    callback::Function\n    optimizer::AbstractOptimizer\n    options\n    trace::Trace\n    outer_iter::Int\n    iter::Int\n\tfcalls::Int\nend\nfunction MMAWorkspace(\n    model::VecModel,\n    optimizer::AbstractOptimizer,\n    x0::AbstractVector;\n    options = default_options(model, optimizer),\n    convcriteria::ConvergenceCriteria = KKTCriteria(),\n    plot_trace::Bool = false,\n    show_plot::Bool = plot_trace,\n    save_plot = nothing,\n    callback::Function = plot_trace ? LazyPlottingCallback(; show_plot = show_plot, save_plot = save_plot) : NoCallback(),\n    kwargs...,\n)\n    T = eltype(x0)\n    init!(model)\n    dualmodel = MMADualModel(MMAApproxModel(model, x0; kwargs...))\n\n    # Convergence\n    \u03bb = ones(getdim(getineqconstraints(model)))\n    solution = Solution(dualmodel, \u03bb)\n    assess_convergence!(solution, model, options.tol, convcriteria)\n    correctsolution!(solution, model, options)\n\n    # Trace\n    trace = Trace([])\n\n    # Iteraton counter\n    fcalls, outer_iter, iter = 1, 0, 0\n    \u03c3 = similar(x0)\n    \u03c1 = similar(\u03bb, length(\u03bb) + 1)\n    tempx = similar(x0)\n\n    return MMAWorkspace(\n        model,\n        dualmodel,\n        x0,\n        solution,\n        \u03c3,\n        \u03c1,\n        tempx,\n        convcriteria,\n        callback,\n        optimizer,\n        options,\n        trace,\n        outer_iter,\n        iter,\n        fcalls,\n    )\nend\n\nfunction reset!(w::MMAWorkspace, x0 = nothing)\n    @unpack solution = w\n    outer_iter, iter, fcalls = 0, 0, 0, 0\n    @pack! w = fcalls, iter, outer_iter\n    if x0 !== nothing\n        w.x0 .= x0\n        w.tempx .= solution.prevx\n        solution.prevx .= solution.x\n        solution.x .= x0\n        updateapprox!(w.dualmodel, x0)\n    end\n    assess_convergence!(w)\n    return w\nend\n\ndefault_options(model::VecModel, alg::MMA87) = MMAOptions()\ndefault_options(model::VecModel, alg::MMA02) = MMAOptions()\n\ninit!(model::VecModel) = model\n\nfunction Workspace(model::VecModel, optimizer::Union{MMA87, MMA02}, args...; kwargs...)\n    return MMAWorkspace(model, optimizer, args...; kwargs...)\nend\n\nfunction optimize!(workspace::MMAWorkspace)\n    @unpack dualmodel, solution, convcriteria = workspace\n    @unpack callback, optimizer, options, trace = workspace\n    @unpack x0, \u03c3, \u03c1, outer_iter, iter, fcalls = workspace\n    @unpack dualoptimizer = optimizer\n    @unpack dual_options, maxiter, outer_maxiter, auto_scale = options\n    @unpack prevx, x, g, \u03bb = solution\n    best_solution = deepcopy(solution)\n\n    T = eltype(x)\n    ni, nj = length(\u03bb), length(x)\n\n    # Original model\n    model = dualmodel |> getparent |> getparent\n\n    # Approximate MMA model\n    approxmodel = getparent(dualmodel)\n\n    # Dual objective to be maximized\n    dualobj = getobjective(dualmodel)\n\n    # Optim-compatible objective\n    # Calculates negative the dual objective and its gradient\n    optimobj = getoptimobj(dualobj, false)\n\n    # Lower and upper bounds on the dual variables\n    \u03bbl = zeros(ni) .+ 1e-10\n    \u03bbu = fill(Inf, ni)\n    \u03bb .= 1\n\n    # Callback, e.g. a trace plotting callback\n    callback(solution)\n\n    # Initialize the workspace's trust region \u03c3\n    initialize\u03c3!(workspace)\n    # Initialize the workspace's lift \u03c1, only used in MMA02\n    initialize\u03c1!(workspace)\n\n    while (!hasconverged(solution) || outer_iter == 0) && iter < maxiter && outer_iter < outer_maxiter\n        outer_iter += 1\n\n        # Adapt workspace's trust region \u03c3 using s_incr and s_decr\n        outer_iter > 2 && update\u03c3!(workspace)\n        # Decrease the workspace's lift \u03c1, only used in MMA02\n        decrease\u03c1!(workspace, optimizer)\n\n        # Update the model's \u03c3\n        set\u03c3!(dualmodel, \u03c3)\n        # Update the model's \u03c1, only used in MMA02\n        set\u03c1!(dualmodel, \u03c1)\n\n        # Update the convex approximation at the current x\n        updateapprox!(dualmodel)\n\n        # Assume the convex approximation is not an upper bound approximation at x\n        upperbounded = false\n        prev_iter = iter\n        while (!hasconverged(solution) || outer_iter == 1) && !upperbounded && iter < maxiter && iter < prev_iter + options.maxinner\n            iter += 1\n            # Solve the dual problem by minimizing negative the dual objective value\n            if length(\u03bb) > 0\n                \u03bb .= 1.0\n                \u03bb .= Optim.optimize(\n                    Optim.only_fg!(optimobj),\n                    \u03bbl,\n                    \u03bbu,\n                    \u03bb,\n                    Optim.Fminbox(dualoptimizer),\n                    dual_options,\n                ).minimizer\n            end\n            if debugging[]\n                @show \u03bb\n            end\n\n            # Revaluate the optimal primal solution at the optimal dual solution\n            dualobj(\u03bb)\n\n            # Update the x vector to the new one and update the previous 2 xs\n            updatex!(workspace)\n\n            # Evaluate the approximate objective and constraints at the optimal x\n            approxfg = getapproxfg(dualobj)\n\n            # Evaluates the exact objective and constraints and their gradients at the optimal x\n            optimalx = getoptimalx(dualmodel)\n\n            fg, \u2207fg = value_jacobian(\n                approxmodel.objective_ineq_constraints,\n                optimalx,\n            )\n            fcalls += 1\n\n            # Scale the objective appropriately\n            # Reduces the chance of overflow or underflow in \u03bbs \n            # Helps with the convergence\n            auto_scale && iter < 5 && scaleobjective!(model, fg, \u2207fg, approxfg, \u03bb)\n\n            # Check if the approximation is an upper bound at the current x.\n            # If not, increase \u03c1. Only used in MMA02\n            if iter > 1\n                upperbounded = increase\u03c1!(workspace, fg, approxfg, optimizer)\n                upperbounded || set\u03c1!(dualmodel, \u03c1)\n            end\n            # Update the convex approximation at the current x\n            updateapprox!(dualmodel, optimalx, fg, \u2207fg)\n            # Update the objective and constraint values and gradients in `solution`\n            updatefg!(solution, fg, \u2207fg)\n\n            # Check if the algorithm has converged\n            assess_convergence!(solution, model, options.tol, convcriteria)\n\n            # Callback, e.g. a trace plotting callback\n            callback(solution)\n        end\n        @pack! workspace = outer_iter, iter, fcalls\n\n        if options.keep_best\n            best_solution = get_best_solution(solution, best_solution, options)\n        else\n            best_solution = deepcopy(solution) \n        end\n        hasconverged(best_solution) && break\n\n        # Print some trace if flag is on\n        # @mmatrace()\n    end\n    @pack! workspace = outer_iter, iter, fcalls\n    workspace.solution = best_solution\n\n    # Reset the objective scaling factor to 1\n    set_objective_multiple!(model, 1)\n    callback(best_solution, update = true)\n    \n    results = GenericResult(\n        optimizer,\n        x0,\n        best_solution.x,\n        best_solution.f,\n        iter,\n        iter == options.maxiter,\n        options.tol,\n        best_solution.convstate,\n        fcalls,\n    )\n    return results\nend\n\n\"\"\"\n    scaleobjective!(model::VecModel, fg, \u2207fg, approxfg, \u03bb)\n\nScales the objective of `model` using the ratio of the \u221e norms of the constraint and objective values and gradients. After scaling, the \u221e norms will be the same.\n\"\"\"\nfunction scaleobjective!(model::VecModel, fg, \u2207fg, approxfg, \u03bb)\n    @views normratio = norm(\u2207fg[2:end,:], Inf) \/ norm(\u2207fg[1,:], Inf)\n    @views normratio = max(normratio, norm(fg[2:end], Inf) \/ abs(fg[1]))\n    normratio = isfinite(normratio) ? normratio : one(normratio)\n    set_objective_multiple!(model, get_objective_multiple(model) * normratio)\n    fg[1] = fg[1] * normratio\n    approxfg[1] = approxfg[1] * normratio\n    \u2207fg[1,:] .= \u2207fg[1,:] .* normratio\n    scalequadweight!(model, normratio)\n    \u03bb .*= normratio\n    return model\nend\n\nscalequadweight!(model::VecModel, s::Real) = model\n\nfunction correctsolution!(solution::Solution, model::VecModel, options::MMAOptions)\n    solution.f = solution.f \/ get_objective_multiple(model)\n    return solution\nend\n\nfunction get_best_solution(solution::Solution, best_solution::Solution, options)\n    best_infeas = best_solution.convstate.infeas\n    if max(solution.convstate.infeas, solution.convstate.kkt_residual) <= \n        max(best_solution.convstate.infeas, best_solution.convstate.kkt_residual)\n        best_solution = deepcopy(solution)\n    end\n    return best_solution\nend\n\nfunction updatex!(workspace::MMAWorkspace)\n    @unpack tempx, solution, dualmodel = workspace\n    @unpack prevx, x = solution\n    tempx .= prevx\n    prevx .= x\n    x .= getoptimalx(dualmodel)\n    return workspace\nend\n\nfunction updatefg!(solution::Solution, fg::AbstractVector, \u2207fg::AbstractMatrix)\n    solution.prevf = solution.f\n    solution.f = fg[1]\n    solution.g .= fg[2:end]\n    solution.\u2207f .= \u2207fg[1, :]\n    solution.\u2207g .= \u2207fg[2:end, :]\n    return solution\nend\n\nfunction initialize\u03c3!(workspace::MMAWorkspace)\n    @unpack \u03c3, optimizer, options, model = workspace\n    T = eltype(\u03c3)\n    map!(\u03c3, 1:length(\u03c3)) do j\n        diff = getmax(model, j) - getmin(model, j)\n        if !isfinite(diff)\n            diff = 1000 * one(T)\n        end\n        return options.s_init * diff\n    end\n    return workspace\nend\n\nfunction initialize\u03c1!(workspace::MMAWorkspace)\n    @unpack \u03c1 = workspace\n    \u03c1 .= 0\n    return workspace\nend\n\nfunction update\u03c3!(workspace::MMAWorkspace)\n    @unpack \u03c3, solution, tempx, optimizer, options, model = workspace\n    @unpack x, prevx = solution\n    T = eltype(x)\n    map!(\u03c3, 1:length(x)) do j\n        if x[j] == prevx[j] || prevx[j] == tempx[j]\n            d = \u03c3[j]\n        elseif xor(x[j] > prevx[j], prevx[j] > tempx[j])\n            d = \u03c3[j] * options.s_decr\n        else\n            d = \u03c3[j] * options.s_incr\n        end\n        diff = getmax(model, j) - getmin(model, j)\n        if !isfinite(diff)\n            diff = 1000 * one(T)\n        end\n        min = diff\/100\n        max = 10diff\n        if d <= min\n            return min\n        elseif d >= max\n            return max\n        else\n            return d\n        end\n    end\n    return workspace\nend\n\ndecrease\u03c1!(workspace::MMAWorkspace, ::MMA87) = workspace\nfunction decrease\u03c1!(workspace::MMAWorkspace, ::MMA02)\n    @unpack \u03c1 = workspace\n    \u03c1 .= max.(\u03c1 .\/ 10, 1e-5)\n    return workspace\nend\n\nincrease\u03c1!(workspace::MMAWorkspace, ::AbstractVector, ::AbstractVector, ::MMA87) = true\nfunction increase\u03c1!(\n    workspace::MMAWorkspace,\n    fg::AbstractVector,\n    approxfg::AbstractVector,\n    ::MMA02,\n)\n    @unpack dualmodel, solution, \u03c3, \u03c1 = workspace\n    @unpack x, prevx = solution\n    T = eltype(x)\n    w = zero(T)\n    for j in 1:length(x)\n        diff2 = (x[j] - prevx[j])^2\n        w += diff2 \/ (\u03c3[j]^2 - diff2)\n    end\n    w \/= 2\n\n    upperbounded = true\n    for i in 1:length(\u03c1)\n        if fg[i] > approxfg[i]\n            upperbounded = false\n            \u03c1[i] = min(10\u03c1[i], 1.1 * (\u03c1[i] + (fg[i] - approxfg[i]) \/ w))\n        end\n    end\n    return upperbounded\nend\n\nfunction getoptimobj(obj, minimize = true)\n    optimobj(z) = optimobj(1.0, nothing, z)\n    function optimobj(F, G, z)\n        if G !== nothing\n            val, grad = value_gradient(obj, z)\n            if minimize\n                G[:] .= grad\n            else\n                G[:] .= .-grad\n            end\n            if F !== nothing\n                if minimize\n                    return val\n                else\n                    return -val\n                end\n            end\n        end\n        # No gradient necessary, just return the log joint.\n        if F !== nothing\n            if minimize\n                return obj(z)\n            else\n                return -obj(z)\n            end\n        end\n        return nothing\n    end\n    return optimobj\nend\n","avg_line_length":32.218875502,"max_line_length":178,"alphanum_fraction":0.6324711748,"licenses":["MIT"],"repository_name":"JuliaNonconvex\/NonconvexMMA.jl","path":"src\/mma_algorithm.jl","size":16158,"lang":"Julia"}
{"content":"package z3.scala\r\n\r\nimport com.microsoft.z3.Native\r\n\r\nclass Z3Tactic private[z3](val ptr : Long, val context : Z3Context) extends Z3Object {\r\n  override def equals(that: Any) : Boolean = {\r\n    that != null &&\r\n      that.isInstanceOf[Z3Tactic] && {\r\n      val that2 = that.asInstanceOf[Z3Tactic]\r\n      that2.ptr == this.ptr \/\/ && context.isEqAST(this, that2)\r\n    }\r\n  }\r\n\r\n  def incRef(): Unit = {\r\n    Native.tacticIncRef(context.ptr, this.ptr)\r\n  }\r\n\r\n  def decRef(): Unit = {\r\n    Native.tacticDecRef(context.ptr, this.ptr)\r\n  }\r\n\r\n  locally {\r\n    context.tacticQueue.track(this)\r\n  }\r\n}\r\n","avg_line_length":22.9230769231,"max_line_length":87,"alphanum_fraction":0.6191275168,"licenses":["Apache-2.0"],"repository_name":"epfl-lara\/ScalaZ3","path":"src\/main\/scala\/z3\/scala\/Z3Tactic.scala","size":596,"lang":"Scala"}
{"content":"package main\n\nimport (\n\t\"crypto\/tls\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\n\t\"github.com\/docker\/libchan\"\n\t\"github.com\/docker\/libchan\/spdy\"\n)\n\n\/\/ RemoteCommand is the run parameters to be executed remotely\ntype RemoteCommand struct {\n\tCmd        string\n\tArgs       []string\n\tStdin      io.Writer\n\tStdout     io.Reader\n\tStderr     io.Reader\n\tStatusChan libchan.Sender\n}\n\n\/\/ CommandResponse is the returned response object from the remote execution\ntype CommandResponse struct {\n\tStatus int\n}\n\nfunc main() {\n\tif len(os.Args) < 2 {\n\t\tlog.Fatal(\"usage: <command> [<arg> ]\")\n\t}\n\n\tvar client net.Conn\n\tvar err error\n\tif os.Getenv(\"USE_TLS\") != \"\" {\n\t\tclient, err = tls.Dial(\"tcp\", \"127.0.0.1:9323\", &tls.Config{InsecureSkipVerify: true})\n\t} else {\n\t\tclient, err = net.Dial(\"tcp\", \"127.0.0.1:9323\")\n\t}\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\ttransport, err := spdy.NewClientTransport(client)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tsender, err := transport.NewSendChannel()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\treceiver, remoteSender := libchan.Pipe()\n\n\tcommand := &RemoteCommand{\n\t\tCmd:        os.Args[1],\n\t\tArgs:       os.Args[2:],\n\t\tStdin:      os.Stdin,\n\t\tStdout:     os.Stdout,\n\t\tStderr:     os.Stderr,\n\t\tStatusChan: remoteSender,\n\t}\n\n\terr = sender.Send(command)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tresponse := &CommandResponse{}\n\terr = receiver.Receive(response)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tos.Exit(response.Status)\n}\n","avg_line_length":18.1666666667,"max_line_length":88,"alphanum_fraction":0.6414961186,"licenses":["Apache-2.0"],"repository_name":"drewwells\/libchan","path":"examples\/rexec\/client.go","size":1417,"lang":"GO"}
{"content":"-- | \n-- Module: UeMap\n-- Description: Sharing for UEs, based on IntMaps.\n-- Copyright: (c) 2013 Tom Hawkins & Lee Pike\n--\n-- Sharing for 'UE's, based on IntMaps.  The idea is to share subexpressions\n-- of 'UE's.\n\nmodule Atom.Language.Atom.UeMap\n  ( UeElem (..)\n  , MUV (..)\n  , UeMap\n  , emptyMap\n  , Hash\n  , typeOf\n  , UeState\n  , recoverUE\n  , getUE\n  , newUE\n  , newUV\n  , maybeUpdate\n  , ueUpstream\n  , nearestUVs\n  , arrayIndices\n  , isMathHCall\n  ) where\n\nimport Control.Monad.State.Strict\nimport qualified Data.Bimap as M\nimport Data.List (nub)\n\nimport Atom.Language.Atom.Expressions hiding (typeOf)\nimport qualified Atom.Language.Atom.Expressions as E\n\ntype Hash = Int\n\n-- | Untyped variables map.\ndata MUV\n  = MUV Int String Const\n  | MUVArray UA Hash\n  | MUVExtern String Type\n  deriving (Show, Eq, Ord)\n\n-- | Transforms a 'UV' into a 'MUV', returning the possibly updated map.\nnewUV :: UV -> UeMap -> (MUV, UeMap)\nnewUV u mp =\n  case u of\n    UV i j k        -> (MUV i j k, mp)\n    UVExtern i j    -> (MUVExtern i j, mp)\n    UVArray arr ue_ -> let (h,mp') = newUE ue_ mp in\n                       (MUVArray arr h, mp')\n\n-- | Corresponds to 'UE's --- the elements in the sharing structure.\ndata UeElem\n  = MUVRef     !MUV\n  | MUConst    !Const\n  | MUCast     !Type !Hash\n  | MUAdd      !Hash !Hash\n  | MUSub      !Hash !Hash\n  | MUMul      !Hash !Hash\n  | MUDiv      !Hash !Hash\n  | MUMod      !Hash !Hash\n  | MUNot      !Hash\n  | MUAnd      [Hash]\n  | MUBWNot    !Hash\n  | MUBWAnd    !Hash !Hash\n  | MUBWOr     !Hash !Hash\n  | MUBWXor    !Hash !Hash\n  | MUBWShiftL !Hash !Hash\n  | MUBWShiftR !Hash !Hash\n  | MUEq       !Hash !Hash\n  | MULt       !Hash !Hash\n  | MUMux      !Hash !Hash !Hash\n  | MUF2B      !Hash\n  | MUD2B      !Hash\n  | MUB2F      !Hash\n  | MUB2D      !Hash\n-- math.h:\n  | MUPi\n  | MUExp      !Hash\n  | MULog      !Hash\n  | MUSqrt     !Hash\n  | MUPow      !Hash !Hash\n  | MUSin      !Hash\n  | MUAsin     !Hash\n  | MUCos      !Hash\n  | MUAcos     !Hash\n  | MUSinh     !Hash\n  | MUCosh     !Hash\n  | MUAsinh    !Hash\n  | MUAcosh    !Hash\n  | MUAtan     !Hash\n  | MUAtanh    !Hash\n  deriving (Show, Eq, Ord)\n\ntypeOf :: Hash -> UeMap -> Type\ntypeOf h mp = case getUE h mp of\n    MUVRef     (MUV _ _ a)     -> E.typeOf a\n    MUVRef     (MUVArray a _)  -> E.typeOf a\n    MUVRef     (MUVExtern _ t) -> t\n    MUCast     t _             -> t\n    MUConst    c               -> E.typeOf c\n    MUAdd      a _             -> typeOf' a\n    MUSub      a _             -> typeOf' a\n    MUMul      a _             -> typeOf' a\n    MUDiv      a _             -> typeOf' a\n    MUMod      a _             -> typeOf' a\n    MUNot      _               -> Bool\n    MUAnd      _               -> Bool\n    MUBWNot    a               -> typeOf' a\n    MUBWAnd    a _             -> typeOf' a\n    MUBWOr     a _             -> typeOf' a\n    MUBWXor    a _             -> typeOf' a\n    MUBWShiftL a _             -> typeOf' a\n    MUBWShiftR a _             -> typeOf' a\n    MUEq       _ _             -> Bool\n    MULt       _ _             -> Bool\n    MUMux      _ a _           -> typeOf' a\n    MUF2B      _               -> Word32\n    MUD2B      _               -> Word64\n    MUB2F      _               -> Float\n    MUB2D      _               -> Double\n-- math.h:\n    MUPi                       -> Double\n    MUExp     a                -> typeOf' a\n    MULog     a                -> typeOf' a\n    MUSqrt    a                -> typeOf' a\n    MUPow     a _              -> typeOf' a\n    MUSin     a                -> typeOf' a\n    MUAsin    a                -> typeOf' a\n    MUCos     a                -> typeOf' a\n    MUAcos    a                -> typeOf' a\n    MUSinh    a                -> typeOf' a\n    MUCosh    a                -> typeOf' a\n    MUAsinh   a                -> typeOf' a\n    MUAcosh   a                -> typeOf' a\n    MUAtan    a                -> typeOf' a\n    MUAtanh   a                -> typeOf' a\n  where\n  typeOf' h' = typeOf h' mp\n\n-- | An entry in the Map.\ntype UeMap = (Hash, M.Bimap Int UeElem)\n\n-- | Wrapped in the State Monad.\ntype UeState a = State UeMap a\n\n-- | Get the element associated with a 'Hash' value.  It's an error if the\n-- element is not in the map.\ngetUE :: Hash -> UeMap -> UeElem\ngetUE h (_,mp) =\n  case M.lookup h mp of\n    Nothing -> error $ \"Error looking up hash \" ++ show h ++ \" in the UE map\\n\" ++ show mp\n    Just e -> e\n\n-- | Put a new 'UE' in the map, unless it's already in there, and return the\n-- hash pointing to the 'UE' and a new map.\nnewUE :: UE -> UeMap -> (Hash, UeMap)\nnewUE ue_ mp = runState (share ue_) mp\n\nemptyMap :: UeMap\nemptyMap = (0, M.empty)\n\n-- | Create the sharing map.\nshare :: UE -> UeState Hash\nshare e = case e of\n  UVRef     (UV i j k)      -> maybeUpdate (MUVRef $ MUV i j k)\n  UVRef     (UVExtern i j)  -> maybeUpdate (MUVRef $ MUVExtern i j)\n  UVRef     (UVArray arr a) -> unOp a (\\x -> MUVRef (MUVArray arr x))\n  UConst    a     -> maybeUpdate (MUConst a)\n  UCast     t a   -> unOp a (MUCast t)\n  UAdd      a b   -> binOp (a,b) MUAdd\n  USub      a b   -> binOp (a,b) MUSub\n  UMul      a b   -> binOp (a,b) MUMul\n  UDiv      a b   -> binOp (a,b) MUDiv\n  UMod      a b   -> binOp (a,b) MUMod\n  UNot      a     -> unOp a MUNot\n  UAnd      ls    -> listOp ls MUAnd\n  UBWNot    a     -> unOp a MUBWNot\n  UBWAnd    a b   -> binOp (a,b) MUBWAnd\n  UBWOr     a b   -> binOp (a,b) MUBWOr\n  UBWXor    a b   -> binOp (a,b) MUBWXor\n  UBWShiftL a b   -> binOp (a,b) MUBWShiftL\n  UBWShiftR a b   -> binOp (a,b) MUBWShiftR\n  UEq       a b   -> binOp (a,b) MUEq\n  ULt       a b   -> binOp (a,b) MULt\n  UMux      a b c -> triOp (a,b,c) MUMux\n  UF2B      a     -> unOp a MUF2B\n  UD2B      a     -> unOp a MUD2B\n  UB2F      a     -> unOp a MUB2F\n  UB2D      a     -> unOp a MUB2D\n-- math.h:\n  UPi             -> maybeUpdate (MUPi)\n  UExp      a     -> unOp a MUExp\n  ULog      a     -> unOp a MULog\n  USqrt     a     -> unOp a MUSqrt\n  UPow      a b   -> binOp (a,b) MUPow\n  USin      a     -> unOp a MUSin\n  UAsin     a     -> unOp a MUAsin\n  UCos      a     -> unOp a MUCos\n  UAcos     a     -> unOp a MUAcos\n  USinh     a     -> unOp a MUSinh\n  UCosh     a     -> unOp a MUCosh\n  UAsinh    a     -> unOp a MUAsinh\n  UAcosh    a     -> unOp a MUAcosh\n  UAtan     a     -> unOp a MUAtan\n  UAtanh    a     -> unOp a MUAtanh\n\n-- XXX I could combine some of the following functions (unOp, binOp, etc.) to\n-- slightly reduce code...\nunOp :: UE -> (Hash -> UeElem) -> UeState Hash\nunOp e code = do\n  h <- share e\n  maybeUpdate (code h)\n\nbinOp :: (UE, UE) -> (Hash -> Hash -> UeElem) -> UeState Hash\nbinOp (e0,e1) code = do\n  h0 <- share e0\n  h1 <- share e1\n  maybeUpdate (code h0 h1)\n\ntriOp :: (UE, UE, UE) -> (Hash -> Hash -> Hash -> UeElem) -> UeState Hash\ntriOp (e0,e1,e2) code = do\n  h0 <- share e0\n  h1 <- share e1\n  h2 <- share e2\n  maybeUpdate (code h0 h1 h2)\n\nlistOp :: [UE] -> ([Hash] -> UeElem) -> UeState Hash\nlistOp es code = do\n  hashes <- foldM (\\hashes e -> do h <- share e\n                                   return (h:hashes)\n                  ) [] es\n  maybeUpdate (code hashes)\n\n-- | Lookup an element in the map, and if it's in there, do nothing, but return\n-- its hash value.  Otherwise, update the map and return the new hash value\n-- for the inserted element.\nmaybeUpdate :: UeElem -> UeState Hash\nmaybeUpdate e = do\n  st <- get\n  let mp = snd st\n  case M.lookupR e mp of\n    Nothing -> do let hash = fst st + 1\n                  put (hash, M.insert hash e mp)\n                  return hash\n    Just h -> return h\n\n-- -- Lookup an elem, returning 'Nothing' if no hash exists in the map and 'Just'\n-- -- the hash value otherwise.\n-- getHash :: UeElem -> UeMap -> Maybe Hash\n-- getHash e mp = M.lookupR e\n\n\n-- ((k,e'):_) | e == e' = Just k\n-- getHash e (_:es) | otherwise = getHash e es\n-- getHash _ [] = Nothing\n\n-- | Get a 'UE' back out of the 'UeMap'.\nrecoverUE :: UeMap -> Hash -> UE\nrecoverUE st h = case getUE h st of\n  MUVRef     (MUV i j k)     -> UVRef (UV i j k)\n  MUVRef     (MUVArray i a)  -> UVRef (UVArray i (recover' a))\n  MUVRef     (MUVExtern i j) -> UVRef (UVExtern i j)\n  MUCast     t a   -> UCast     t (recover' a)\n  MUConst    a     -> UConst    a\n  MUAdd      a b   -> UAdd      (recover' a) (recover' b)\n  MUSub      a b   -> USub      (recover' a) (recover' b)\n  MUMul      a b   -> UMul      (recover' a) (recover' b)\n  MUDiv      a b   -> UDiv      (recover' a) (recover' b)\n  MUMod      a b   -> UMod      (recover' a) (recover' b)\n  MUNot      a     -> UNot      (recover' a)\n  MUAnd      a     -> UAnd $ map recover' a\n  MUBWNot    a     -> UBWNot    (recover' a)\n  MUBWAnd    a b   -> UBWAnd    (recover' a) (recover' b)\n  MUBWOr     a b   -> UBWOr     (recover' a) (recover' b)\n  MUBWXor    a b   -> UBWXor    (recover' a) (recover' b)\n  MUBWShiftL a b   -> UBWShiftL (recover' a) (recover' b)\n  MUBWShiftR a b   -> UBWShiftR (recover' a) (recover' b)\n  MUEq       a b   -> UEq       (recover' a) (recover' b)\n  MULt       a b   -> ULt       (recover' a) (recover' b)\n  MUMux      a b c -> UMux      (recover' a) (recover' b) (recover' c)\n  MUF2B      a     -> UF2B      (recover' a)\n  MUD2B      a     -> UD2B      (recover' a)\n  MUB2F      a     -> UB2F      (recover' a)\n  MUB2D      a     -> UB2D      (recover' a)\n-- math.h:\n  MUPi             -> UPi\n  MUExp      a     -> UExp      (recover' a)\n  MULog      a     -> ULog      (recover' a)\n  MUSqrt     a     -> USqrt     (recover' a)\n  MUPow      a b   -> UPow      (recover' a) (recover' b)\n  MUSin      a     -> USin      (recover' a)\n  MUAsin     a     -> UAsin     (recover' a)\n  MUCos      a     -> UCos      (recover' a)\n  MUAcos     a     -> UAcos     (recover' a)\n  MUSinh     a     -> USinh     (recover' a)\n  MUCosh     a     -> UCosh     (recover' a)\n  MUAsinh    a     -> UAsinh    (recover' a)\n  MUAcosh    a     -> UAcosh    (recover' a)\n  MUAtan     a     -> UAtan     (recover' a)\n  MUAtanh    a     -> UAtanh    (recover' a)\n  where recover' h' = recoverUE st h'\n\n-- | The list of Hashes to adjacent upstream of a UE.\nueUpstream :: Hash -> UeMap -> [Hash]\nueUpstream h t = case getUE h t of\n  MUVRef     (MUV _ _ _)     -> []\n  MUVRef     (MUVArray _ a)  -> [a]\n  MUVRef     (MUVExtern _ _) -> []\n  MUCast     _ a             -> [a]\n  MUConst    _               -> []\n  MUAdd      a b             -> [a, b]\n  MUSub      a b             -> [a, b]\n  MUMul      a b             -> [a, b]\n  MUDiv      a b             -> [a, b]\n  MUMod      a b             -> [a, b]\n  MUNot      a               -> [a]\n  MUAnd      a               -> a\n  MUBWNot    a               -> [a]\n  MUBWAnd    a b             -> [a, b]\n  MUBWOr     a b             -> [a, b]\n  MUBWXor    a b             -> [a, b]\n  MUBWShiftL a b             -> [a, b]\n  MUBWShiftR a b             -> [a, b]\n  MUEq       a b             -> [a, b]\n  MULt       a b             -> [a, b]\n  MUMux      a b c           -> [a, b, c]\n  MUF2B      a               -> [a]\n  MUD2B      a               -> [a]\n  MUB2F      a               -> [a]\n  MUB2D      a               -> [a]\n-- math.h:\n  MUPi                       -> []\n  MUExp      a               -> [a]\n  MULog      a               -> [a]\n  MUSqrt     a               -> [a]\n  MUPow      a b             -> [a, b]\n  MUSin      a               -> [a]\n  MUAsin     a               -> [a]\n  MUCos      a               -> [a]\n  MUAcos     a               -> [a]\n  MUSinh     a               -> [a]\n  MUCosh     a               -> [a]\n  MUAsinh    a               -> [a]\n  MUAcosh    a               -> [a]\n  MUAtan     a               -> [a]\n  MUAtanh    a               -> [a]\n\n-- | The list of all UVs that directly control the value of an expression.\nnearestUVs :: Hash -> UeMap -> [MUV]\nnearestUVs h mp = nub $ f h\n  where\n  f :: Hash -> [MUV]\n  f hash = case getUE hash mp of\n             (MUVRef u@(MUVArray _ h')) -> [u] ++ f h'\n             (MUVRef u)                 -> [u]\n             _                          -> concatMap f $ ueUpstream hash mp\n\n-- | All array indexing subexpressions.\narrayIndices :: Hash -> UeMap -> [(UA, Hash)]\narrayIndices h mp = nub $ f h\n  where\n  f :: Hash -> [(UA, Hash)]\n  f hash = case getUE hash mp of\n             (MUVRef (MUVArray ua h')) -> (ua, h') : f h'\n             _ -> concatMap f $ ueUpstream hash mp\n\n-- XXX can put this back after making UE map---won't be expensive.\nisMathHCall :: UeElem -> Bool\nisMathHCall fc =\n  case fc of\n    MUPi        -> True\n    MUExp   _   -> True\n    MULog   _   -> True\n    MUSqrt  _   -> True\n    MUPow   _ _ -> True\n    MUSin   _   -> True\n    MUAsin  _   -> True\n    MUCos   _   -> True\n    MUAcos  _   -> True\n    MUSinh  _   -> True\n    MUCosh  _   -> True\n    MUAsinh _   -> True\n    MUAcosh _   -> True\n    MUAtan  _   -> True\n    MUAtanh _   -> True\n    _          -> False\n\n","avg_line_length":32.7205128205,"max_line_length":90,"alphanum_fraction":0.4795078756,"licenses":["BSD-3-Clause"],"repository_name":"WhoMeNope\/stm32f-atom-blinky","path":"src\/Atom\/Language\/Atom\/UeMap.hs","size":12761,"lang":"Haskell"}
{"content":"$zoneName = \"A.test\"\r\n$zoneScope = 'external'\r\n\r\n$ConfigurationData = @{\r\n    AllNodes    = , @{\r\n        NodeName        = 'localhost'\r\n        CertificateFile = $Null\r\n    }\r\n    NonNodeData = @{\r\n        DnsRecordAScoped_CreateRecord_Config = @{\r\n            ZoneName    = $zoneName\r\n            ZoneScope   = $zoneScope\r\n            Name        = 'www'\r\n            IPv4Address = '192.168.50.10'\r\n        }\r\n        DnsRecordAScoped_ModifyRecord_Config = @{\r\n            ZoneName    = $zoneName\r\n            ZoneScope   = $zoneScope\r\n            Name        = 'www'\r\n            IPv4Address = '192.168.50.10'\r\n            DnsServer   = 'localhost'\r\n            TimeToLive  = '05:00:00'\r\n            Ensure      = 'Present'\r\n        }\r\n        DnsRecordAScoped_DeleteRecord_Config = @{\r\n            ZoneName    = $zoneName\r\n            ZoneScope   = $zoneScope\r\n            Name        = 'www'\r\n            IPv4Address = '192.168.50.10'\r\n            Ensure      = 'Absent'\r\n        }\r\n    }\r\n}\r\n\r\n<#\r\n    .SYNOPSIS\r\n        Create an A record\r\n#>\r\nconfiguration DnsRecordAScoped_CreateRecord_Config\r\n{\r\n    Import-DscResource -ModuleName 'DnsServerDsc'\r\n\r\n    node $AllNodes.NodeName\r\n    {\r\n        DnsServerPrimaryZone \"Zone $zoneName\"\r\n        {\r\n            Name = $zoneName\r\n        }\r\n\r\n        DnsServerZoneScope \"external scope\" {\r\n            ZoneName = $zoneName\r\n            Name     = $zoneScope\r\n        }\r\n\r\n        DnsRecordAScoped 'Integration_Test'\r\n        {\r\n            ZoneName    = $ConfigurationData.NonNodeData.DnsRecordAScoped_CreateRecord_Config.ZoneName\r\n            ZoneScope   = $ConfigurationData.NonNodeData.DnsRecordAScoped_CreateRecord_Config.ZoneScope\r\n            Name        = $ConfigurationData.NonNodeData.DnsRecordAScoped_CreateRecord_Config.Name\r\n            IPv4Address = $ConfigurationData.NonNodeData.DnsRecordAScoped_CreateRecord_Config.IPv4Address\r\n        }\r\n    }\r\n}\r\n\r\n<#\r\n    .SYNOPSIS\r\n        Modifies an existing A record\r\n#>\r\nconfiguration DnsRecordAScoped_ModifyRecord_Config\r\n{\r\n    Import-DscResource -ModuleName 'DnsServerDsc'\r\n\r\n    node $AllNodes.NodeName\r\n    {\r\n        DnsServerPrimaryZone \"Zone $zoneName\"\r\n        {\r\n            Name = $zoneName\r\n        }\r\n\r\n        DnsServerZoneScope \"external scope\" {\r\n            ZoneName = $zoneName\r\n            Name     = $zoneScope\r\n        }\r\n\r\n        DnsRecordAScoped 'Integration_Test'\r\n        {\r\n            ZoneName    = $ConfigurationData.NonNodeData.DnsRecordAScoped_ModifyRecord_Config.ZoneName\r\n            ZoneScope   = $ConfigurationData.NonNodeData.DnsRecordAScoped_ModifyRecord_Config.ZoneScope\r\n            Name        = $ConfigurationData.NonNodeData.DnsRecordAScoped_ModifyRecord_Config.Name\r\n            IPv4Address = $ConfigurationData.NonNodeData.DnsRecordAScoped_ModifyRecord_Config.IPv4Address\r\n            DnsServer   = $ConfigurationData.NonNodeData.DnsRecordAScoped_ModifyRecord_Config.DnsServer\r\n            TimeToLive  = $ConfigurationData.NonNodeData.DnsRecordAScoped_ModifyRecord_Config.TimeToLive\r\n            Ensure      = $ConfigurationData.NonNodeData.DnsRecordAScoped_ModifyRecord_Config.Ensure\r\n        }\r\n    }\r\n}\r\n\r\n<#\r\n    .SYNOPSIS\r\n        Deletes an existing A record\r\n#>\r\nconfiguration DnsRecordAScoped_DeleteRecord_Config\r\n{\r\n    Import-DscResource -ModuleName 'DnsServerDsc'\r\n\r\n    node $AllNodes.NodeName\r\n    {\r\n        DnsServerPrimaryZone \"Zone $zoneName\"\r\n        {\r\n            Name = $zoneName\r\n        }\r\n\r\n        DnsServerZoneScope \"external scope\" {\r\n            ZoneName = $zoneName\r\n            Name     = $zoneScope\r\n        }\r\n\r\n        DnsRecordAScoped 'Integration_Test'\r\n        {\r\n            ZoneName    = $ConfigurationData.NonNodeData.DnsRecordAScoped_DeleteRecord_Config.ZoneName\r\n            ZoneScope   = $ConfigurationData.NonNodeData.DnsRecordAScoped_DeleteRecord_Config.ZoneScope\r\n            Name        = $ConfigurationData.NonNodeData.DnsRecordAScoped_DeleteRecord_Config.Name\r\n            IPv4Address = $ConfigurationData.NonNodeData.DnsRecordAScoped_DeleteRecord_Config.IPv4Address\r\n            Ensure      = $ConfigurationData.NonNodeData.DnsRecordAScoped_DeleteRecord_Config.Ensure\r\n        }\r\n    }\r\n}\r\n","avg_line_length":32.765625,"max_line_length":106,"alphanum_fraction":0.6087267525,"licenses":["MIT"],"repository_name":"PowerShell\/xDnsServer","path":"tests\/Integration\/Classes\/DnsRecordAScoped.config.ps1","size":4067,"lang":"PowerShell"}
{"content":"\ufeffnamespace Meraki.Api.Interfaces.General.Organizations;\n\npublic interface IOrganizationsAdaptivePolicySettings\n{\n\t\/\/\/ <summary>\n\t\/\/\/ Returns global adaptive policy settings in an organization\n\t\/\/\/ <\/summary>\n\t\/\/\/ <exception cref=\"ApiException\">Thrown when fails to make API call<\/exception>\n\t\/\/\/ <param name=\"organizationId\">The organization id<\/param>\n\t[Get(\"\/organizations\/{organizationId}\/adaptivePolicy\/settings\")]\n\tTask<AdaptivePolicySettings> GetOrganizationAdaptivePolicySettingsAsync(\n\t\t[AliasAs(\"organizationId\")] string organizationId,\n\t\tCancellationToken cancellationToken = default);\n\n\t\/\/\/ <summary>\n\t\/\/\/ Returns global adaptive policy settings in an organization\n\t\/\/\/ <\/summary>\n\t\/\/\/ <exception cref=\"ApiException\">Thrown when fails to make API call<\/exception>\n\t\/\/\/ <param name=\"organizationId\">The organization id<\/param>\n\t[Put(\"\/organizations\/{organizationId}\/adaptivePolicy\/settings\")]\n\tTask<AdaptivePolicySettings> UpdateOrganizationAdaptivePolicySettingsAsync(\n\t\t[AliasAs(\"organizationId\")] string organizationId,\n\t\t[Body] AdaptivePolicySettings adaptivePolicySettings,\n\t\tCancellationToken cancellationToken = default);\n}","avg_line_length":45.6,"max_line_length":82,"alphanum_fraction":0.7877192982,"licenses":["MIT"],"repository_name":"Pituzek\/Meraki.Api","path":"Meraki.Api\/Interfaces\/General\/Organizations\/IOrganizationsAdaptivePolicySettings.cs","size":1142,"lang":"C#"}
{"content":"\\hypertarget{struct__ADI__USEQ__REGS__MAP1__GAINTAG0CLKCTRL1__t}{}\\doxysection{\\+\\_\\+\\+A\\+D\\+I\\+\\_\\+\\+U\\+S\\+E\\+Q\\+\\_\\+\\+R\\+E\\+G\\+S\\+\\_\\+\\+M\\+A\\+P1\\+\\_\\+\\+G\\+A\\+I\\+N\\+T\\+A\\+G0\\+C\\+L\\+K\\+C\\+T\\+R\\+L1\\+\\_\\+t Struct Reference}\n\\label{struct__ADI__USEQ__REGS__MAP1__GAINTAG0CLKCTRL1__t}\\index{\\_ADI\\_USEQ\\_REGS\\_MAP1\\_GAINTAG0CLKCTRL1\\_t@{\\_ADI\\_USEQ\\_REGS\\_MAP1\\_GAINTAG0CLKCTRL1\\_t}}\n\\doxysubsection*{Public Attributes}\n\\begin{DoxyCompactItemize}\n\\item \n\\begin{tabbing}\nxx\\=xx\\=xx\\=xx\\=xx\\=xx\\=xx\\=xx\\=xx\\=\\kill\nunion \\{\\\\\n\\>struct \\{\\\\\n\\>\\>unsigned int \\mbox{\\hyperlink{group__USE__CASE__0__ROI__2__ROI__TYPE_gaf291c7a09b0db46b349b326f6df9869d}{\\_ADI\\_USEQ\\_REGS\\_MAP1\\_GAINTAG0CLKCTRL1\\_t::GAINTAG0\\_CLK\\_RISE\\_CLK\\_CNT}}: 8\\\\\n\\>\\>unsigned int \\mbox{\\hyperlink{group__USE__CASE__0__ROI__2__ROI__TYPE_ga7c75b650299a2f285aef8850d6b91385}{\\_ADI\\_USEQ\\_REGS\\_MAP1\\_GAINTAG0CLKCTRL1\\_t::GAINTAG0\\_CLK\\_FALL\\_CLK\\_CNT}}: 8\\\\\n\\>\\} \\\\\n\\>uint16\\_t {\\bfseries VALUE16}\\\\\n\\}; \\\\\n\n\\end{tabbing}\\end{DoxyCompactItemize}\n\n\nThe documentation for this struct was generated from the following file\\+:\\begin{DoxyCompactItemize}\n\\item \nnewton\\+\\_\\+typedefs.\\+h\\end{DoxyCompactItemize}\n","avg_line_length":52.9090909091,"max_line_length":221,"alphanum_fraction":0.7422680412,"licenses":["MIT"],"repository_name":"analogdevicesinc\/ToF","path":"examples\/tof-viewer\/external\/newton_host_driver\/src\/host_api\/docs\/doxygen\/latex\/struct__ADI__USEQ__REGS__MAP1__GAINTAG0CLKCTRL1__t.tex","size":1164,"lang":"TeX"}
{"content":"#include \"global.h\"\n#include \"RageSurface.h\"\n#include \"RageSurfaceUtils.h\"\n#include \"RageSurface_Save_JPEG.h\"\n\n#include \"RageUtil.h\"\n#include \"RageFile.h\"\n\n#undef FAR \/\/ fix for VC\n\/** @brief A helper to get the jpeg lib. *\/\nnamespace jpeg\n{\n\textern \"C\"\n\t{\n#include \"jpeglib.h\"\n\t}\n}\n\n\/\/ Only Xcode wants this. FIXME\n#if defined(PBBUILD) && defined(SYSTEM_JPEGLIB)\n#define TRUE jpeg::TRUE\n#define FALSE jpeg::FALSE\n#endif\n\n#define OUTPUT_BUFFER_SIZE\t4096\ntypedef struct\n{\n\tstruct jpeg::jpeg_destination_mgr pub;\n\n\tRageFile *f;\n\tuint8_t buffer[OUTPUT_BUFFER_SIZE];\n} my_destination_mgr;\n\n\n\/*\n * Initialize source --- called by jpeg_read_header\n * before any data is actually read.\n *\/\nstatic void init_destination( jpeg::j_compress_ptr cinfo )\n{\n\t\/* nop *\/\n\treturn;\n}\n\n\/* Empty the output buffer; called whenever buffer is full. *\/\nstatic jpeg::boolean empty_output_buffer( jpeg::j_compress_ptr cinfo )\n{\n\tmy_destination_mgr * dest = (my_destination_mgr *) cinfo->dest;\n\tdest->f->Write( dest->buffer, OUTPUT_BUFFER_SIZE );\n\t\/\/ XXX err\n\tdest->pub.next_output_byte = dest->buffer;\n\tdest->pub.free_in_buffer = OUTPUT_BUFFER_SIZE;\n\n\treturn TRUE;\n}\n\n\n\/*\n * Terminate source --- called by jpeg_finish_decompress\n * after all data has been read.\n *\/\nstatic void term_destination (jpeg::j_compress_ptr cinfo)\n{\n\t\/* Write data remaining in the buffer *\/\n\tmy_destination_mgr *dest = (my_destination_mgr *) cinfo->dest;\n\tdest->f->Write( dest->buffer, OUTPUT_BUFFER_SIZE - dest->pub.free_in_buffer );\n\t\/\/ XXX err\n\tdest->pub.next_output_byte = dest->buffer;\n\tdest->pub.free_in_buffer = OUTPUT_BUFFER_SIZE;\n}\n\n\/*\n * Prepare for output to a stdio stream.\n * The caller must have already opened the stream, and is responsible\n * for closing it after finishing decompression.\n *\/\nstatic void jpeg_RageFile_dest( jpeg::j_compress_ptr cinfo, RageFile &f )\n{\n\tASSERT( cinfo->dest == NULL );\n\n\tcinfo->dest = (struct jpeg::jpeg_destination_mgr *)\n\t\t(*cinfo->mem->alloc_small) ( (jpeg::j_common_ptr) cinfo, JPOOL_PERMANENT,\n\t\t\tsizeof(my_destination_mgr) );\n\n\tmy_destination_mgr *dest = (my_destination_mgr *) cinfo->dest;\n\tdest->pub.init_destination = init_destination;\n\tdest->pub.empty_output_buffer = empty_output_buffer;\n\tdest->pub.term_destination = term_destination;\n\tdest->pub.free_in_buffer = OUTPUT_BUFFER_SIZE; \/* forces fill_input_buffer on first read *\/\n\tdest->pub.next_output_byte = dest->buffer; \/* until buffer loaded *\/\n\n\tdest->f = &f;\n}\n\n\/* Save a JPEG to a file.  cjpeg.c and example.c from jpeglib were helpful in writing this. *\/\nbool RageSurfaceUtils::SaveJPEG( RageSurface *surface, RageFile &f, bool bHighQual )\n{\n\tRageSurface *dst_surface;\n\tif( RageSurfaceUtils::ConvertSurface( surface, dst_surface,\n\t\tsurface->w, surface->h, 24, Swap24BE(0xFF0000), Swap24BE(0x00FF00), Swap24BE(0x0000FF), 0 ) )\n\t\tsurface = dst_surface;\n\n\tstruct jpeg::jpeg_compress_struct cinfo;\n\n\t\/* Set up the error handler. *\/\n\tstruct jpeg::jpeg_error_mgr jerr;\n\tcinfo.err = jpeg::jpeg_std_error( &jerr );\n\n\t\/* Now we can initialize the JPEG compression object. *\/\n\tjpeg::jpeg_CreateCompress(&cinfo, JPEG_LIB_VERSION, \\\n\t\t(size_t) sizeof(struct jpeg::jpeg_compress_struct));\n\n\tcinfo.image_width = surface->w; \t\/* image width and height, in pixels *\/\n\tcinfo.image_height = surface->h;\n\tcinfo.input_components = 3;\t\t\/* # of color components per pixel *\/\n\tcinfo.in_color_space = jpeg::JCS_RGB; \t\/* colorspace of input image *\/\n\n\t\/* Set compression parameters.  You must set at least cinfo.in_color_space before\n\t * calling this.*\/\n\tjpeg::jpeg_set_defaults(&cinfo);\n\n\tif( bHighQual )\n\t\tjpeg::jpeg_set_quality( &cinfo, 150, TRUE );\n\telse\n\t\tjpeg::jpeg_set_quality( &cinfo, 70, TRUE );\n\n\tjpeg_RageFile_dest( &cinfo, f );\n\n\t\/* Start the compressor. *\/\n\tjpeg::jpeg_start_compress( &cinfo, TRUE );\n\n\t\/* Here we use the library's state variable cinfo.next_scanline as the\n\t * loop counter, so that we don't have to keep track ourselves.\n\t * To keep things simple, we pass one scanline per call; you can pass\n\t * more if you wish, though. *\/\n\tconst int row_stride = surface->pitch;\t\/* JSAMPLEs per row in image_buffer *\/\n\n\twhile( cinfo.next_scanline < cinfo.image_height )\n\t{\n\t\t\/* jpeg_write_scanlines expects an array of pointers to scanlines.\n\t\t * Here the array is only one element long, but you could pass\n\t\t * more than one scanline at a time if that's more convenient. *\/\n\t\tjpeg::JSAMPROW row_pointer = & ((jpeg::JSAMPLE*)surface->pixels)[cinfo.next_scanline * row_stride];\n\t\tjpeg::jpeg_write_scanlines( &cinfo, &row_pointer, 1 );\n\t}\n\n\t\/* Finish compression. *\/\n\tjpeg::jpeg_finish_compress( &cinfo );\n\tjpeg::jpeg_destroy_compress( &cinfo );\n\n\tdelete dst_surface;\n\treturn true;\n}\n\n\/*\n * (c) 2004 Chris Danford\n * All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, and\/or sell copies of the Software, and to permit persons to\n * whom the Software is furnished to do so, provided that the above\n * copyright notice(s) and this permission notice appear in all copies of\n * the Software and that both the above copyright notice(s) and this\n * permission notice appear in supporting documentation.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF\n * THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS\n * INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT\n * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\n * OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n *\/\n","avg_line_length":33.2569832402,"max_line_length":101,"alphanum_fraction":0.7384512011,"licenses":["MIT"],"repository_name":"Tatsh\/stepmania","path":"src\/RageSurface_Save_JPEG.cpp","size":5953,"lang":"C++"}
{"content":"<!DOCTYPE HTML PUBLIC \"-\/\/W3C\/\/DTD HTML 4.01 Transitional\/\/EN\" \"http:\/\/www.w3.org\/TR\/html4\/loose.dtd\">\n<!-- NewPage -->\n<html lang=\"en\">\n<head>\n<!-- Generated by javadoc (1.8.0_191) on Sun May 12 12:07:49 UTC 2019 -->\n<meta http-equiv=\"Content-Type\" content=\"text\/html; charset=UTF-8\">\n<title>PostAnalyticsReportingScheduleRunreportRequest (platform-client-v2 60.0.0 API)<\/title>\n<meta name=\"date\" content=\"2019-05-12\">\n<link rel=\"stylesheet\" type=\"text\/css\" href=\"..\/..\/..\/..\/..\/..\/stylesheet.css\" title=\"Style\">\n<script type=\"text\/javascript\" src=\"..\/..\/..\/..\/..\/..\/script.js\"><\/script>\n<\/head>\n<body>\n<script type=\"text\/javascript\"><!--\n    try {\n        if (location.href.indexOf('is-external=true') == -1) {\n            parent.document.title=\"PostAnalyticsReportingScheduleRunreportRequest (platform-client-v2 60.0.0 API)\";\n        }\n    }\n    catch(err) {\n    }\n\/\/-->\nvar methods = {\"i0\":10,\"i1\":9,\"i2\":9,\"i3\":10,\"i4\":10,\"i5\":10,\"i6\":10,\"i7\":10,\"i8\":10,\"i9\":10};\nvar tabs = {65535:[\"t0\",\"All Methods\"],1:[\"t1\",\"Static Methods\"],2:[\"t2\",\"Instance Methods\"],8:[\"t4\",\"Concrete Methods\"]};\nvar altColor = \"altColor\";\nvar rowColor = \"rowColor\";\nvar tableTab = \"tableTab\";\nvar activeTableTab = \"activeTableTab\";\n<\/script>\n<noscript>\n<div>JavaScript is disabled on your browser.<\/div>\n<\/noscript>\n<!-- ========= START OF TOP NAVBAR ======= -->\n<div class=\"topNav\"><a name=\"navbar.top\">\n<!--   -->\n<\/a>\n<div class=\"skipNav\"><a href=\"#skip.navbar.top\" title=\"Skip navigation links\">Skip navigation links<\/a><\/div>\n<a name=\"navbar.top.firstrow\">\n<!--   -->\n<\/a>\n<ul class=\"navList\" title=\"Navigation\">\n<li><a href=\"..\/..\/..\/..\/..\/..\/overview-summary.html\">Overview<\/a><\/li>\n<li><a href=\"package-summary.html\">Package<\/a><\/li>\n<li class=\"navBarCell1Rev\">Class<\/li>\n<li><a href=\"class-use\/PostAnalyticsReportingScheduleRunreportRequest.html\">Use<\/a><\/li>\n<li><a href=\"package-tree.html\">Tree<\/a><\/li>\n<li><a href=\"..\/..\/..\/..\/..\/..\/deprecated-list.html\">Deprecated<\/a><\/li>\n<li><a href=\"..\/..\/..\/..\/..\/..\/index-all.html\">Index<\/a><\/li>\n<li><a href=\"..\/..\/..\/..\/..\/..\/help-doc.html\">Help<\/a><\/li>\n<\/ul>\n<\/div>\n<div class=\"subNav\">\n<ul class=\"navList\">\n<li><a href=\"..\/..\/..\/..\/..\/..\/com\/mypurecloud\/sdk\/v2\/api\/request\/PostAnalyticsReportingExportsRequest.Builder.html\" title=\"class in com.mypurecloud.sdk.v2.api.request\"><span class=\"typeNameLink\">Prev&nbsp;Class<\/span><\/a><\/li>\n<li><a href=\"..\/..\/..\/..\/..\/..\/com\/mypurecloud\/sdk\/v2\/api\/request\/PostAnalyticsReportingScheduleRunreportRequest.Builder.html\" title=\"class in com.mypurecloud.sdk.v2.api.request\"><span class=\"typeNameLink\">Next&nbsp;Class<\/span><\/a><\/li>\n<\/ul>\n<ul class=\"navList\">\n<li><a href=\"..\/..\/..\/..\/..\/..\/index.html?com\/mypurecloud\/sdk\/v2\/api\/request\/PostAnalyticsReportingScheduleRunreportRequest.html\" target=\"_top\">Frames<\/a><\/li>\n<li><a href=\"PostAnalyticsReportingScheduleRunreportRequest.html\" target=\"_top\">No&nbsp;Frames<\/a><\/li>\n<\/ul>\n<ul class=\"navList\" id=\"allclasses_navbar_top\">\n<li><a href=\"..\/..\/..\/..\/..\/..\/allclasses-noframe.html\">All&nbsp;Classes<\/a><\/li>\n<\/ul>\n<div>\n<script type=\"text\/javascript\"><!--\n  allClassesLink = document.getElementById(\"allclasses_navbar_top\");\n  if(window==top) {\n    allClassesLink.style.display = \"block\";\n  }\n  else {\n    allClassesLink.style.display = \"none\";\n  }\n  \/\/-->\n<\/script>\n<\/div>\n<div>\n<ul class=\"subNavList\">\n<li>Summary:&nbsp;<\/li>\n<li><a href=\"#nested.class.summary\">Nested<\/a>&nbsp;|&nbsp;<\/li>\n<li>Field&nbsp;|&nbsp;<\/li>\n<li><a href=\"#constructor.summary\">Constr<\/a>&nbsp;|&nbsp;<\/li>\n<li><a href=\"#method.summary\">Method<\/a><\/li>\n<\/ul>\n<ul class=\"subNavList\">\n<li>Detail:&nbsp;<\/li>\n<li>Field&nbsp;|&nbsp;<\/li>\n<li><a href=\"#constructor.detail\">Constr<\/a>&nbsp;|&nbsp;<\/li>\n<li><a href=\"#method.detail\">Method<\/a><\/li>\n<\/ul>\n<\/div>\n<a name=\"skip.navbar.top\">\n<!--   -->\n<\/a><\/div>\n<!-- ========= END OF TOP NAVBAR ========= -->\n<!-- ======== START OF CLASS DATA ======== -->\n<div class=\"header\">\n<div class=\"subTitle\">com.mypurecloud.sdk.v2.api.request<\/div>\n<h2 title=\"Class PostAnalyticsReportingScheduleRunreportRequest\" class=\"title\">Class PostAnalyticsReportingScheduleRunreportRequest<\/h2>\n<\/div>\n<div class=\"contentContainer\">\n<ul class=\"inheritance\">\n<li><a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/Object.html?is-external=true\" title=\"class or interface in java.lang\">java.lang.Object<\/a><\/li>\n<li>\n<ul class=\"inheritance\">\n<li>com.mypurecloud.sdk.v2.api.request.PostAnalyticsReportingScheduleRunreportRequest<\/li>\n<\/ul>\n<\/li>\n<\/ul>\n<div class=\"description\">\n<ul class=\"blockList\">\n<li class=\"blockList\">\n<hr>\n<br>\n<pre>public class <span class=\"typeNameLabel\">PostAnalyticsReportingScheduleRunreportRequest<\/span>\nextends <a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/Object.html?is-external=true\" title=\"class or interface in java.lang\">Object<\/a><\/pre>\n<\/li>\n<\/ul>\n<\/div>\n<div class=\"summary\">\n<ul class=\"blockList\">\n<li class=\"blockList\">\n<!-- ======== NESTED CLASS SUMMARY ======== -->\n<ul class=\"blockList\">\n<li class=\"blockList\"><a name=\"nested.class.summary\">\n<!--   -->\n<\/a>\n<h3>Nested Class Summary<\/h3>\n<table class=\"memberSummary\" border=\"0\" cellpadding=\"3\" cellspacing=\"0\" summary=\"Nested Class Summary table, listing nested classes, and an explanation\">\n<caption><span>Nested Classes<\/span><span class=\"tabEnd\">&nbsp;<\/span><\/caption>\n<tr>\n<th class=\"colFirst\" scope=\"col\">Modifier and Type<\/th>\n<th class=\"colLast\" scope=\"col\">Class and Description<\/th>\n<\/tr>\n<tr class=\"altColor\">\n<td class=\"colFirst\"><code>static class&nbsp;<\/code><\/td>\n<td class=\"colLast\"><code><span class=\"memberNameLink\"><a href=\"..\/..\/..\/..\/..\/..\/com\/mypurecloud\/sdk\/v2\/api\/request\/PostAnalyticsReportingScheduleRunreportRequest.Builder.html\" title=\"class in com.mypurecloud.sdk.v2.api.request\">PostAnalyticsReportingScheduleRunreportRequest.Builder<\/a><\/span><\/code>&nbsp;<\/td>\n<\/tr>\n<\/table>\n<\/li>\n<\/ul>\n<!-- ======== CONSTRUCTOR SUMMARY ======== -->\n<ul class=\"blockList\">\n<li class=\"blockList\"><a name=\"constructor.summary\">\n<!--   -->\n<\/a>\n<h3>Constructor Summary<\/h3>\n<table class=\"memberSummary\" border=\"0\" cellpadding=\"3\" cellspacing=\"0\" summary=\"Constructor Summary table, listing constructors, and an explanation\">\n<caption><span>Constructors<\/span><span class=\"tabEnd\">&nbsp;<\/span><\/caption>\n<tr>\n<th class=\"colOne\" scope=\"col\">Constructor and Description<\/th>\n<\/tr>\n<tr class=\"altColor\">\n<td class=\"colOne\"><code><span class=\"memberNameLink\"><a href=\"..\/..\/..\/..\/..\/..\/com\/mypurecloud\/sdk\/v2\/api\/request\/PostAnalyticsReportingScheduleRunreportRequest.html#PostAnalyticsReportingScheduleRunreportRequest--\">PostAnalyticsReportingScheduleRunreportRequest<\/a><\/span>()<\/code>&nbsp;<\/td>\n<\/tr>\n<\/table>\n<\/li>\n<\/ul>\n<!-- ========== METHOD SUMMARY =========== -->\n<ul class=\"blockList\">\n<li class=\"blockList\"><a name=\"method.summary\">\n<!--   -->\n<\/a>\n<h3>Method Summary<\/h3>\n<table class=\"memberSummary\" border=\"0\" cellpadding=\"3\" cellspacing=\"0\" summary=\"Method Summary table, listing methods, and an explanation\">\n<caption><span id=\"t0\" class=\"activeTableTab\"><span>All Methods<\/span><span class=\"tabEnd\">&nbsp;<\/span><\/span><span id=\"t1\" class=\"tableTab\"><span><a href=\"javascript:show(1);\">Static Methods<\/a><\/span><span class=\"tabEnd\">&nbsp;<\/span><\/span><span id=\"t2\" class=\"tableTab\"><span><a href=\"javascript:show(2);\">Instance Methods<\/a><\/span><span class=\"tabEnd\">&nbsp;<\/span><\/span><span id=\"t4\" class=\"tableTab\"><span><a href=\"javascript:show(8);\">Concrete Methods<\/a><\/span><span class=\"tabEnd\">&nbsp;<\/span><\/span><\/caption>\n<tr>\n<th class=\"colFirst\" scope=\"col\">Modifier and Type<\/th>\n<th class=\"colLast\" scope=\"col\">Method and Description<\/th>\n<\/tr>\n<tr id=\"i0\" class=\"altColor\">\n<td class=\"colFirst\"><code>void<\/code><\/td>\n<td class=\"colLast\"><code><span class=\"memberNameLink\"><a href=\"..\/..\/..\/..\/..\/..\/com\/mypurecloud\/sdk\/v2\/api\/request\/PostAnalyticsReportingScheduleRunreportRequest.html#addCustomHeader-java.lang.String-java.lang.String-\">addCustomHeader<\/a><\/span>(<a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/String.html?is-external=true\" title=\"class or interface in java.lang\">String<\/a>&nbsp;name,\n               <a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/String.html?is-external=true\" title=\"class or interface in java.lang\">String<\/a>&nbsp;value)<\/code>&nbsp;<\/td>\n<\/tr>\n<tr id=\"i1\" class=\"rowColor\">\n<td class=\"colFirst\"><code>static <a href=\"..\/..\/..\/..\/..\/..\/com\/mypurecloud\/sdk\/v2\/api\/request\/PostAnalyticsReportingScheduleRunreportRequest.Builder.html\" title=\"class in com.mypurecloud.sdk.v2.api.request\">PostAnalyticsReportingScheduleRunreportRequest.Builder<\/a><\/code><\/td>\n<td class=\"colLast\"><code><span class=\"memberNameLink\"><a href=\"..\/..\/..\/..\/..\/..\/com\/mypurecloud\/sdk\/v2\/api\/request\/PostAnalyticsReportingScheduleRunreportRequest.html#builder--\">builder<\/a><\/span>()<\/code>&nbsp;<\/td>\n<\/tr>\n<tr id=\"i2\" class=\"altColor\">\n<td class=\"colFirst\"><code>static <a href=\"..\/..\/..\/..\/..\/..\/com\/mypurecloud\/sdk\/v2\/api\/request\/PostAnalyticsReportingScheduleRunreportRequest.Builder.html\" title=\"class in com.mypurecloud.sdk.v2.api.request\">PostAnalyticsReportingScheduleRunreportRequest.Builder<\/a><\/code><\/td>\n<td class=\"colLast\"><code><span class=\"memberNameLink\"><a href=\"..\/..\/..\/..\/..\/..\/com\/mypurecloud\/sdk\/v2\/api\/request\/PostAnalyticsReportingScheduleRunreportRequest.html#builder-java.lang.String-\">builder<\/a><\/span>(<a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/String.html?is-external=true\" title=\"class or interface in java.lang\">String<\/a>&nbsp;scheduleId)<\/code>&nbsp;<\/td>\n<\/tr>\n<tr id=\"i3\" class=\"rowColor\">\n<td class=\"colFirst\"><code><a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/Map.html?is-external=true\" title=\"class or interface in java.util\">Map<\/a>&lt;<a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/String.html?is-external=true\" title=\"class or interface in java.lang\">String<\/a>,<a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/String.html?is-external=true\" title=\"class or interface in java.lang\">String<\/a>&gt;<\/code><\/td>\n<td class=\"colLast\"><code><span class=\"memberNameLink\"><a href=\"..\/..\/..\/..\/..\/..\/com\/mypurecloud\/sdk\/v2\/api\/request\/PostAnalyticsReportingScheduleRunreportRequest.html#getCustomHeaders--\">getCustomHeaders<\/a><\/span>()<\/code>&nbsp;<\/td>\n<\/tr>\n<tr id=\"i4\" class=\"altColor\">\n<td class=\"colFirst\"><code><a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/String.html?is-external=true\" title=\"class or interface in java.lang\">String<\/a><\/code><\/td>\n<td class=\"colLast\"><code><span class=\"memberNameLink\"><a href=\"..\/..\/..\/..\/..\/..\/com\/mypurecloud\/sdk\/v2\/api\/request\/PostAnalyticsReportingScheduleRunreportRequest.html#getScheduleId--\">getScheduleId<\/a><\/span>()<\/code>&nbsp;<\/td>\n<\/tr>\n<tr id=\"i5\" class=\"rowColor\">\n<td class=\"colFirst\"><code>void<\/code><\/td>\n<td class=\"colLast\"><code><span class=\"memberNameLink\"><a href=\"..\/..\/..\/..\/..\/..\/com\/mypurecloud\/sdk\/v2\/api\/request\/PostAnalyticsReportingScheduleRunreportRequest.html#setCustomHeaders-java.util.Map-\">setCustomHeaders<\/a><\/span>(<a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/Map.html?is-external=true\" title=\"class or interface in java.util\">Map<\/a>&lt;<a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/String.html?is-external=true\" title=\"class or interface in java.lang\">String<\/a>,<a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/String.html?is-external=true\" title=\"class or interface in java.lang\">String<\/a>&gt;&nbsp;customHeaders)<\/code>&nbsp;<\/td>\n<\/tr>\n<tr id=\"i6\" class=\"altColor\">\n<td class=\"colFirst\"><code>void<\/code><\/td>\n<td class=\"colLast\"><code><span class=\"memberNameLink\"><a href=\"..\/..\/..\/..\/..\/..\/com\/mypurecloud\/sdk\/v2\/api\/request\/PostAnalyticsReportingScheduleRunreportRequest.html#setScheduleId-java.lang.String-\">setScheduleId<\/a><\/span>(<a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/String.html?is-external=true\" title=\"class or interface in java.lang\">String<\/a>&nbsp;scheduleId)<\/code>&nbsp;<\/td>\n<\/tr>\n<tr id=\"i7\" class=\"rowColor\">\n<td class=\"colFirst\"><code><a href=\"..\/..\/..\/..\/..\/..\/com\/mypurecloud\/sdk\/v2\/api\/request\/PostAnalyticsReportingScheduleRunreportRequest.html\" title=\"class in com.mypurecloud.sdk.v2.api.request\">PostAnalyticsReportingScheduleRunreportRequest<\/a><\/code><\/td>\n<td class=\"colLast\"><code><span class=\"memberNameLink\"><a href=\"..\/..\/..\/..\/..\/..\/com\/mypurecloud\/sdk\/v2\/api\/request\/PostAnalyticsReportingScheduleRunreportRequest.html#withCustomHeader-java.lang.String-java.lang.String-\">withCustomHeader<\/a><\/span>(<a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/String.html?is-external=true\" title=\"class or interface in java.lang\">String<\/a>&nbsp;name,\n                <a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/String.html?is-external=true\" title=\"class or interface in java.lang\">String<\/a>&nbsp;value)<\/code>&nbsp;<\/td>\n<\/tr>\n<tr id=\"i8\" class=\"altColor\">\n<td class=\"colFirst\"><code><a href=\"..\/..\/..\/..\/..\/..\/com\/mypurecloud\/sdk\/v2\/ApiRequest.html\" title=\"interface in com.mypurecloud.sdk.v2\">ApiRequest<\/a>&lt;<a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/Void.html?is-external=true\" title=\"class or interface in java.lang\">Void<\/a>&gt;<\/code><\/td>\n<td class=\"colLast\"><code><span class=\"memberNameLink\"><a href=\"..\/..\/..\/..\/..\/..\/com\/mypurecloud\/sdk\/v2\/api\/request\/PostAnalyticsReportingScheduleRunreportRequest.html#withHttpInfo--\">withHttpInfo<\/a><\/span>()<\/code>&nbsp;<\/td>\n<\/tr>\n<tr id=\"i9\" class=\"rowColor\">\n<td class=\"colFirst\"><code><a href=\"..\/..\/..\/..\/..\/..\/com\/mypurecloud\/sdk\/v2\/api\/request\/PostAnalyticsReportingScheduleRunreportRequest.html\" title=\"class in com.mypurecloud.sdk.v2.api.request\">PostAnalyticsReportingScheduleRunreportRequest<\/a><\/code><\/td>\n<td class=\"colLast\"><code><span class=\"memberNameLink\"><a href=\"..\/..\/..\/..\/..\/..\/com\/mypurecloud\/sdk\/v2\/api\/request\/PostAnalyticsReportingScheduleRunreportRequest.html#withScheduleId-java.lang.String-\">withScheduleId<\/a><\/span>(<a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/String.html?is-external=true\" title=\"class or interface in java.lang\">String<\/a>&nbsp;scheduleId)<\/code>&nbsp;<\/td>\n<\/tr>\n<\/table>\n<ul class=\"blockList\">\n<li class=\"blockList\"><a name=\"methods.inherited.from.class.java.lang.Object\">\n<!--   -->\n<\/a>\n<h3>Methods inherited from class&nbsp;java.lang.<a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/Object.html?is-external=true\" title=\"class or interface in java.lang\">Object<\/a><\/h3>\n<code><a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/Object.html?is-external=true#clone--\" title=\"class or interface in java.lang\">clone<\/a>, <a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/Object.html?is-external=true#equals-java.lang.Object-\" title=\"class or interface in java.lang\">equals<\/a>, <a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/Object.html?is-external=true#finalize--\" title=\"class or interface in java.lang\">finalize<\/a>, <a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/Object.html?is-external=true#getClass--\" title=\"class or interface in java.lang\">getClass<\/a>, <a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/Object.html?is-external=true#hashCode--\" title=\"class or interface in java.lang\">hashCode<\/a>, <a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/Object.html?is-external=true#notify--\" title=\"class or interface in java.lang\">notify<\/a>, <a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/Object.html?is-external=true#notifyAll--\" title=\"class or interface in java.lang\">notifyAll<\/a>, <a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/Object.html?is-external=true#toString--\" title=\"class or interface in java.lang\">toString<\/a>, <a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/Object.html?is-external=true#wait--\" title=\"class or interface in java.lang\">wait<\/a>, <a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/Object.html?is-external=true#wait-long-\" title=\"class or interface in java.lang\">wait<\/a>, <a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/Object.html?is-external=true#wait-long-int-\" title=\"class or interface in java.lang\">wait<\/a><\/code><\/li>\n<\/ul>\n<\/li>\n<\/ul>\n<\/li>\n<\/ul>\n<\/div>\n<div class=\"details\">\n<ul class=\"blockList\">\n<li class=\"blockList\">\n<!-- ========= CONSTRUCTOR DETAIL ======== -->\n<ul class=\"blockList\">\n<li class=\"blockList\"><a name=\"constructor.detail\">\n<!--   -->\n<\/a>\n<h3>Constructor Detail<\/h3>\n<a name=\"PostAnalyticsReportingScheduleRunreportRequest--\">\n<!--   -->\n<\/a>\n<ul class=\"blockListLast\">\n<li class=\"blockList\">\n<h4>PostAnalyticsReportingScheduleRunreportRequest<\/h4>\n<pre>public&nbsp;PostAnalyticsReportingScheduleRunreportRequest()<\/pre>\n<\/li>\n<\/ul>\n<\/li>\n<\/ul>\n<!-- ============ METHOD DETAIL ========== -->\n<ul class=\"blockList\">\n<li class=\"blockList\"><a name=\"method.detail\">\n<!--   -->\n<\/a>\n<h3>Method Detail<\/h3>\n<a name=\"getScheduleId--\">\n<!--   -->\n<\/a>\n<ul class=\"blockList\">\n<li class=\"blockList\">\n<h4>getScheduleId<\/h4>\n<pre>public&nbsp;<a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/String.html?is-external=true\" title=\"class or interface in java.lang\">String<\/a>&nbsp;getScheduleId()<\/pre>\n<\/li>\n<\/ul>\n<a name=\"setScheduleId-java.lang.String-\">\n<!--   -->\n<\/a>\n<ul class=\"blockList\">\n<li class=\"blockList\">\n<h4>setScheduleId<\/h4>\n<pre>public&nbsp;void&nbsp;setScheduleId(<a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/String.html?is-external=true\" title=\"class or interface in java.lang\">String<\/a>&nbsp;scheduleId)<\/pre>\n<\/li>\n<\/ul>\n<a name=\"withScheduleId-java.lang.String-\">\n<!--   -->\n<\/a>\n<ul class=\"blockList\">\n<li class=\"blockList\">\n<h4>withScheduleId<\/h4>\n<pre>public&nbsp;<a href=\"..\/..\/..\/..\/..\/..\/com\/mypurecloud\/sdk\/v2\/api\/request\/PostAnalyticsReportingScheduleRunreportRequest.html\" title=\"class in com.mypurecloud.sdk.v2.api.request\">PostAnalyticsReportingScheduleRunreportRequest<\/a>&nbsp;withScheduleId(<a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/String.html?is-external=true\" title=\"class or interface in java.lang\">String<\/a>&nbsp;scheduleId)<\/pre>\n<\/li>\n<\/ul>\n<a name=\"getCustomHeaders--\">\n<!--   -->\n<\/a>\n<ul class=\"blockList\">\n<li class=\"blockList\">\n<h4>getCustomHeaders<\/h4>\n<pre>public&nbsp;<a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/Map.html?is-external=true\" title=\"class or interface in java.util\">Map<\/a>&lt;<a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/String.html?is-external=true\" title=\"class or interface in java.lang\">String<\/a>,<a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/String.html?is-external=true\" title=\"class or interface in java.lang\">String<\/a>&gt;&nbsp;getCustomHeaders()<\/pre>\n<\/li>\n<\/ul>\n<a name=\"setCustomHeaders-java.util.Map-\">\n<!--   -->\n<\/a>\n<ul class=\"blockList\">\n<li class=\"blockList\">\n<h4>setCustomHeaders<\/h4>\n<pre>public&nbsp;void&nbsp;setCustomHeaders(<a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/Map.html?is-external=true\" title=\"class or interface in java.util\">Map<\/a>&lt;<a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/String.html?is-external=true\" title=\"class or interface in java.lang\">String<\/a>,<a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/String.html?is-external=true\" title=\"class or interface in java.lang\">String<\/a>&gt;&nbsp;customHeaders)<\/pre>\n<\/li>\n<\/ul>\n<a name=\"addCustomHeader-java.lang.String-java.lang.String-\">\n<!--   -->\n<\/a>\n<ul class=\"blockList\">\n<li class=\"blockList\">\n<h4>addCustomHeader<\/h4>\n<pre>public&nbsp;void&nbsp;addCustomHeader(<a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/String.html?is-external=true\" title=\"class or interface in java.lang\">String<\/a>&nbsp;name,\n                            <a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/String.html?is-external=true\" title=\"class or interface in java.lang\">String<\/a>&nbsp;value)<\/pre>\n<\/li>\n<\/ul>\n<a name=\"withCustomHeader-java.lang.String-java.lang.String-\">\n<!--   -->\n<\/a>\n<ul class=\"blockList\">\n<li class=\"blockList\">\n<h4>withCustomHeader<\/h4>\n<pre>public&nbsp;<a href=\"..\/..\/..\/..\/..\/..\/com\/mypurecloud\/sdk\/v2\/api\/request\/PostAnalyticsReportingScheduleRunreportRequest.html\" title=\"class in com.mypurecloud.sdk.v2.api.request\">PostAnalyticsReportingScheduleRunreportRequest<\/a>&nbsp;withCustomHeader(<a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/String.html?is-external=true\" title=\"class or interface in java.lang\">String<\/a>&nbsp;name,\n                                                                       <a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/String.html?is-external=true\" title=\"class or interface in java.lang\">String<\/a>&nbsp;value)<\/pre>\n<\/li>\n<\/ul>\n<a name=\"withHttpInfo--\">\n<!--   -->\n<\/a>\n<ul class=\"blockList\">\n<li class=\"blockList\">\n<h4>withHttpInfo<\/h4>\n<pre>public&nbsp;<a href=\"..\/..\/..\/..\/..\/..\/com\/mypurecloud\/sdk\/v2\/ApiRequest.html\" title=\"interface in com.mypurecloud.sdk.v2\">ApiRequest<\/a>&lt;<a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/Void.html?is-external=true\" title=\"class or interface in java.lang\">Void<\/a>&gt;&nbsp;withHttpInfo()<\/pre>\n<\/li>\n<\/ul>\n<a name=\"builder--\">\n<!--   -->\n<\/a>\n<ul class=\"blockList\">\n<li class=\"blockList\">\n<h4>builder<\/h4>\n<pre>public static&nbsp;<a href=\"..\/..\/..\/..\/..\/..\/com\/mypurecloud\/sdk\/v2\/api\/request\/PostAnalyticsReportingScheduleRunreportRequest.Builder.html\" title=\"class in com.mypurecloud.sdk.v2.api.request\">PostAnalyticsReportingScheduleRunreportRequest.Builder<\/a>&nbsp;builder()<\/pre>\n<\/li>\n<\/ul>\n<a name=\"builder-java.lang.String-\">\n<!--   -->\n<\/a>\n<ul class=\"blockListLast\">\n<li class=\"blockList\">\n<h4>builder<\/h4>\n<pre>public static&nbsp;<a href=\"..\/..\/..\/..\/..\/..\/com\/mypurecloud\/sdk\/v2\/api\/request\/PostAnalyticsReportingScheduleRunreportRequest.Builder.html\" title=\"class in com.mypurecloud.sdk.v2.api.request\">PostAnalyticsReportingScheduleRunreportRequest.Builder<\/a>&nbsp;builder(<a href=\"http:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/String.html?is-external=true\" title=\"class or interface in java.lang\">String<\/a>&nbsp;scheduleId)<\/pre>\n<\/li>\n<\/ul>\n<\/li>\n<\/ul>\n<\/li>\n<\/ul>\n<\/div>\n<\/div>\n<!-- ========= END OF CLASS DATA ========= -->\n<!-- ======= START OF BOTTOM NAVBAR ====== -->\n<div class=\"bottomNav\"><a name=\"navbar.bottom\">\n<!--   -->\n<\/a>\n<div class=\"skipNav\"><a href=\"#skip.navbar.bottom\" title=\"Skip navigation links\">Skip navigation links<\/a><\/div>\n<a name=\"navbar.bottom.firstrow\">\n<!--   -->\n<\/a>\n<ul class=\"navList\" title=\"Navigation\">\n<li><a href=\"..\/..\/..\/..\/..\/..\/overview-summary.html\">Overview<\/a><\/li>\n<li><a href=\"package-summary.html\">Package<\/a><\/li>\n<li class=\"navBarCell1Rev\">Class<\/li>\n<li><a href=\"class-use\/PostAnalyticsReportingScheduleRunreportRequest.html\">Use<\/a><\/li>\n<li><a href=\"package-tree.html\">Tree<\/a><\/li>\n<li><a href=\"..\/..\/..\/..\/..\/..\/deprecated-list.html\">Deprecated<\/a><\/li>\n<li><a href=\"..\/..\/..\/..\/..\/..\/index-all.html\">Index<\/a><\/li>\n<li><a href=\"..\/..\/..\/..\/..\/..\/help-doc.html\">Help<\/a><\/li>\n<\/ul>\n<\/div>\n<div class=\"subNav\">\n<ul class=\"navList\">\n<li><a href=\"..\/..\/..\/..\/..\/..\/com\/mypurecloud\/sdk\/v2\/api\/request\/PostAnalyticsReportingExportsRequest.Builder.html\" title=\"class in com.mypurecloud.sdk.v2.api.request\"><span class=\"typeNameLink\">Prev&nbsp;Class<\/span><\/a><\/li>\n<li><a href=\"..\/..\/..\/..\/..\/..\/com\/mypurecloud\/sdk\/v2\/api\/request\/PostAnalyticsReportingScheduleRunreportRequest.Builder.html\" title=\"class in com.mypurecloud.sdk.v2.api.request\"><span class=\"typeNameLink\">Next&nbsp;Class<\/span><\/a><\/li>\n<\/ul>\n<ul class=\"navList\">\n<li><a href=\"..\/..\/..\/..\/..\/..\/index.html?com\/mypurecloud\/sdk\/v2\/api\/request\/PostAnalyticsReportingScheduleRunreportRequest.html\" target=\"_top\">Frames<\/a><\/li>\n<li><a href=\"PostAnalyticsReportingScheduleRunreportRequest.html\" target=\"_top\">No&nbsp;Frames<\/a><\/li>\n<\/ul>\n<ul class=\"navList\" id=\"allclasses_navbar_bottom\">\n<li><a href=\"..\/..\/..\/..\/..\/..\/allclasses-noframe.html\">All&nbsp;Classes<\/a><\/li>\n<\/ul>\n<div>\n<script type=\"text\/javascript\"><!--\n  allClassesLink = document.getElementById(\"allclasses_navbar_bottom\");\n  if(window==top) {\n    allClassesLink.style.display = \"block\";\n  }\n  else {\n    allClassesLink.style.display = \"none\";\n  }\n  \/\/-->\n<\/script>\n<\/div>\n<div>\n<ul class=\"subNavList\">\n<li>Summary:&nbsp;<\/li>\n<li><a href=\"#nested.class.summary\">Nested<\/a>&nbsp;|&nbsp;<\/li>\n<li>Field&nbsp;|&nbsp;<\/li>\n<li><a href=\"#constructor.summary\">Constr<\/a>&nbsp;|&nbsp;<\/li>\n<li><a href=\"#method.summary\">Method<\/a><\/li>\n<\/ul>\n<ul class=\"subNavList\">\n<li>Detail:&nbsp;<\/li>\n<li>Field&nbsp;|&nbsp;<\/li>\n<li><a href=\"#constructor.detail\">Constr<\/a>&nbsp;|&nbsp;<\/li>\n<li><a href=\"#method.detail\">Method<\/a><\/li>\n<\/ul>\n<\/div>\n<a name=\"skip.navbar.bottom\">\n<!--   -->\n<\/a><\/div>\n<!-- ======== END OF BOTTOM NAVBAR ======= -->\n<p class=\"legalCopy\"><small>Copyright &#169; 2019. All rights reserved.<\/small><\/p>\n<\/body>\n<\/html>\n","avg_line_length":59.9879227053,"max_line_length":1713,"alphanum_fraction":0.6933360177,"licenses":["MIT"],"repository_name":"Dschinds\/platform-client-sdk-java","path":"build\/target\/apidocs\/com\/mypurecloud\/sdk\/v2\/api\/request\/PostAnalyticsReportingScheduleRunreportRequest.html","size":24835,"lang":"HTML"}
{"content":"\/*\n * Copyright 2000-2016 JetBrains s.r.o.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\npackage com.intellij.execution;\n\nimport com.intellij.openapi.components.ServiceManager;\nimport com.intellij.openapi.project.Project;\nimport com.intellij.openapi.util.ThrowableComputable;\nimport com.intellij.openapi.util.io.FileUtilRt;\nimport com.intellij.openapi.vfs.newvfs.persistent.FlushingDaemon;\nimport com.intellij.util.containers.ContainerUtil;\nimport com.intellij.util.io.DataExternalizer;\nimport com.intellij.util.io.EnumeratorStringDescriptor;\nimport com.intellij.util.io.IOUtil;\nimport com.intellij.util.io.PersistentHashMap;\nimport consulo.container.boot.ContainerPathManager;\nimport consulo.disposer.Disposable;\nimport consulo.logging.Logger;\n\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\nimport jakarta.inject.Inject;\nimport jakarta.inject.Singleton;\n\nimport java.io.DataInput;\nimport java.io.DataOutput;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Date;\nimport java.util.Map;\nimport java.util.concurrent.ScheduledFuture;\n\n\/**\n * @author Dmitry Avdeev\n *\/\n@Singleton\npublic class TestStateStorage implements Disposable {\n\n  private static final File TEST_HISTORY_PATH = new File(ContainerPathManager.get().getSystemPath(), \"testHistory\");\n\n  private static final int CURRENT_VERSION = 1;\n\n  private final File myFile;\n\n  public static File getTestHistoryRoot(Project project) {\n    return new File(TEST_HISTORY_PATH, project.getLocationHash());\n  }\n\n  public static class Record {\n    public final int magnitude;\n    public final long configurationHash;\n    public final Date date;\n\n    public Record(int magnitude, Date date, long configurationHash) {\n      this.magnitude = magnitude;\n      this.date = date;\n      this.configurationHash = configurationHash;\n    }\n  }\n\n  private static final Logger LOG = Logger.getInstance(TestStateStorage.class);\n  @Nullable\n  private PersistentHashMap<String, Record> myMap;\n  private volatile ScheduledFuture<?> myMapFlusher;\n\n  public static TestStateStorage getInstance(@Nonnull Project project) {\n    return ServiceManager.getService(project, TestStateStorage.class);\n  }\n\n  @Inject\n  public TestStateStorage(Project project) {\n    String directoryPath = getTestHistoryRoot(project).getPath();\n\n    myFile = new File(directoryPath + \"\/testStateMap\");\n    FileUtilRt.createParentDirs(myFile);\n\n    try {\n      myMap = initializeMap();\n    } catch (IOException e) {\n      LOG.error(e);\n    }\n    myMapFlusher = FlushingDaemon.everyFiveSeconds(this::flushMap);\n  }\n\n  private PersistentHashMap<String, Record> initializeMap() throws IOException {\n    return IOUtil.openCleanOrResetBroken(getComputable(myFile), myFile);\n  }\n\n  private synchronized void flushMap() {\n    if (myMapFlusher == null) return; \/\/ disposed\n    if (myMap != null && myMap.isDirty()) myMap.force();\n  }\n\n  @Nonnull\n  private static ThrowableComputable<PersistentHashMap<String, Record>, IOException> getComputable(final File file) {\n    return () -> new PersistentHashMap<>(file, EnumeratorStringDescriptor.INSTANCE, new DataExternalizer<Record>() {\n      @Override\n      public void save(@Nonnull DataOutput out, Record value) throws IOException {\n        out.writeInt(value.magnitude);\n        out.writeLong(value.date.getTime());\n        out.writeLong(value.configurationHash);\n      }\n\n      @Override\n      public Record read(@Nonnull DataInput in) throws IOException {\n        return new Record(in.readInt(), new Date(in.readLong()), in.readLong());\n      }\n    }, 4096, CURRENT_VERSION);\n  }\n\n  @Nullable\n  public synchronized Record getState(String testUrl) {\n    try {\n      return myMap == null ? null : myMap.get(testUrl);\n    }\n    catch (IOException e) {\n      thingsWentWrongLetsReinitialize(e, \"Can't get state for \" + testUrl);\n      return null;\n    }\n  }\n\n  public synchronized void removeState(String url) {\n    if (myMap != null) {\n      try {\n        myMap.remove(url);\n      }\n      catch (IOException e) {\n        thingsWentWrongLetsReinitialize(e, \"Can't remove state for \" + url);\n      }\n    }\n  }\n\n  @Nullable\n  public synchronized Map<String, Record> getRecentTests(int limit, Date since) {\n    if (myMap == null) return null;\n\n    Map<String, Record> result = ContainerUtil.newHashMap();\n    try {\n      for (String key : myMap.getAllKeysWithExistingMapping()) {\n        Record record = myMap.get(key);\n        if (record != null && record.date.compareTo(since) > 0) {\n          result.put(key, record);\n          if (result.size() >= limit) {\n            break;\n          }\n        }\n      }\n    }\n    catch (IOException e) {\n      thingsWentWrongLetsReinitialize(e, \"Can't get recent tests\");\n    }\n\n    return result;\n  }\n\n  public synchronized void writeState(@Nonnull String testUrl, Record record) {\n    if (myMap == null) return;\n    try {\n      myMap.put(testUrl, record);\n    }\n    catch (IOException e) {\n      thingsWentWrongLetsReinitialize(e, \"Can't write state for \" + testUrl);\n    }\n  }\n\n  @Override\n  public synchronized void dispose() {\n    myMapFlusher.cancel(false);\n    myMapFlusher = null;\n    if (myMap == null) return;\n    try {\n      myMap.close();\n    }\n    catch (IOException e) {\n      LOG.error(e);\n    }\n    finally {\n      myMap = null;\n    }\n  }\n\n  private void thingsWentWrongLetsReinitialize(IOException e, String message) {\n    try {\n      if (myMap != null) {\n        try {\n          myMap.close();\n        }\n        catch (IOException ignore) {\n        }\n        IOUtil.deleteAllFilesStartingWith(myFile);\n      }\n      myMap = initializeMap();\n      LOG.error(message, e);\n    }\n    catch (IOException e1) {\n      LOG.error(\"Cannot repair\", e1);\n      myMap = null;\n    }\n  }\n}\n","avg_line_length":29.1971830986,"max_line_length":117,"alphanum_fraction":0.6911078952,"licenses":["Apache-2.0"],"repository_name":"MC-JY\/consulo","path":"modules\/base\/lang-impl\/src\/main\/java\/com\/intellij\/execution\/TestStateStorage.java","size":6219,"lang":"Java"}
{"content":"\ninitdb asyncplay -E utf-8\npostgres -D asyncplay &\nsleep 2\n\ncreatedb asyncplay\npsql asyncplay -f CreateDatabase.sql\n","avg_line_length":14.5,"max_line_length":36,"alphanum_fraction":0.7931034483,"licenses":["BSD-3-Clause"],"repository_name":"AshyIsMe\/haskell-asyncplay","path":"createdatabase.sh","size":116,"lang":"Shell"}
{"content":"\/* Layout for document \n\nGeneral Formating\nIdividual Backgrounds\nBody Formatting\nNav\nMain section\nFooter\nSocial Icons\n\n*\/\n\n\n    \/* General formating classes *\/\n\n.center {\n    text-align: center;\n}\n\n.left {\n    text-align: left;\n\n}\n\n.body {\n    font-family: 'Trebuchet MS', Helvetica, sans-serif; \n    \n}\n\n\n    \/* Internal Padding *\/\n\nbody {\n  -webkit-box-sizing: border-box; \/* Safari 3.0 - 5.0, Chrome 1 - 9, Android 2.1 - 3.x *\/\n  -moz-box-sizing: border-box;    \/* Firefox 1 - 28 *\/\n  box-sizing: border-box;         \/* Safari 5.1+, Chrome 10+, Firefox 29+, Opera 7+, IE 8+, Android 4.0+, iOS any *\/\n}\n\n\n\/* Individual backrounds *\/\n\n.index {\n    background-image: url(..\/images\/Index%20background.jpg);\n}\n\n.contact {\n     background-image: url(..\/images\/contact.jpg);\n}\n\n.histroy_of_cycling { \n    background-image: url(..\/images\/History%20of%20touring.jpg);\n    \n}\n\n.histroy_of_the_bike {\n    background-image: url(..\/images\/history%20of%20the%20bike.jpg);\n}\n\n.what_is_touirng {\n    background-image: url(..\/images\/What%20is%20toruing.jpg)\n}\n\n.how_to_tour {\n    background-image: url(..\/images\/How%20to%20tour.jpg)\n}\n\n.the_kit {\n    background-image: url(..\/images\/The%20kit.jpg)\n}\n\n.lw_kit {\n    background-image: url(..\/images\/light%20weight%20kit.jpg)\n}\n\n.mw_kit {\n    background-image: url(..\/images\/Medium%20weight%20kit.jpg)\n}\n\n.hw_kit {\n    background-image: url(..\/images\/Heavy%20weight%20kit.jpg)\n}\n\n.trip_ideas {\n    background-image: url(..\/images\/Trip%20Ideas.jpg)\n}\n\n.ireland {\n    background-image: url(..\/images\/Cycling%20Ireland.jpg)\n}\n\n.europe {\n    background-image: url(..\/images\/Cycle%20Europe.jpg)\n}\n\n.america {\n    background-image: url(..\/images\/Cycle%20America.jpg)\n}\n\n.aisa {\n    background-image: url(..\/images\/Cycling%20Aisa.JPG)\n}\n\n.blogs {\n    background-image: url(..\/images\/Blogs.jpg)\n}\n\n\n\/* General Background *\/\n\n@media (max-width: 670px) {\n    body {\n        background: center center fixed; \n        -webkit-background-size: cover;\n        -moz-background-size: cover;\n        -o-background-size: cover;\n        background-size: cover;\n        background-color: #adb0b8;\n    }\n}\n\n@media (min-width: 670px) {\n    body {\n        background-position: 0rem 0rem;\n        background-size : 100% 100%;\n        background-attachment: fixed;\n        \/*-webkit-background-size: cover;\n        -moz-background-size: cover;\n        -o-background-size: cover;*\/\n    }\n}\n\n\/* Banner *\/\n\n.banner {\n    color: red;\n    text-align: center;\n    background-color: #adb0b8;\n    width: 100%;\n    height: 10rem;\n    background-color: #adb0b8;\n    margin: 0 0 0 0;\n    max-width: none; \/* Otherwise contaienr makes problems *\/ \n    background-image: url(..\/images\/banner.jpg);\n    background-size: 100% 10rem;\n    background-repeat: no-repeat;\n    color: orangered;\n    font-size: 2rem\n}\n\n.banner_text {\n    padding: 1rem 0 0 0;\n}\n\n\/* Nav Bar *\/\n\n\n.nav {\n    width: 100%;\n    margin-top: .75rem;\n    margin-bottom: .75rem;\n}\n\n.nav li {\n    text-align: center;\n}\n\nnav {\n    margin: 10px 10px 10px 10px;   \n}\n\n.nav ul {\n    text-align: center;\n\tlist-style:none;\n\tposition:relative;\n\tmargin:0;\n\tpadding:0;\n}\n\n.nav ul a {\n\tdisplay:block;\n\tcolor:white;\n\ttext-decoration:none;\n\tfont-weight:700;\n\tfont-size:1.2rem;\n\tline-height:3.2rem;\n\tpadding:0 1.5rem;\n    border: 3.5px solid #0a274f;\n    background-color: #4660a7;\n    border-radius: 20px;\n}\n\n.nav ul li\n{\n\tposition: relative;\n    display: inline-block;\n\tmargin:0;\n\tpadding:0;\n\n}\n\n.nav ul li a:hover\n{\n\tbackground:#20b2aa;\n}\n\n.nav ul ul\n{\n\tdisplay:none;\n\tposition:absolute;\n\ttop:100%;\n\tleft:0;\n\tbackground:#fff;\n\tpadding:0;\n    z-index: 999;\n    width: auto;\n    background-color: rgba(255,255,255,0);\n    min-width: 100%;\n}\n\n.nav ul ul li\n{\n\tfloat:none;\n\twidth:auto;\n    display: block;\n    white-space:nowrap;\n    margin-top: .25rem;\n}\n\n.nav ul ul a\n{\n\n\tpadding:0 .4rem 0 .4rem;\n    z-index: 999;\n    background-color: white;\n    color:#4660a7; \n}\n\n\n.nav ul li:hover > ul{\n\tdisplay:block\n}\n\nnav select {\n  display: none;\n}\n\n@media (max-width: 670px) {\n    nav ul     { \n        display: none; \n}\n    nav select { \n        display: inline-block; \n}\n    .mobile_nav {\n    text-align: center;\n    border: 3.5px solid #0a274f;\n    background-color: #4660a7;\n    border-radius: 20px;\n    padding: 5px 0 5px 0;\n    width:80%;\n    margin-left: auto; margin-right: auto;\n}\n    .banner {\n        display: none;\n    }\n}\n\n\/* Main section wrapper *\/\n\n.main {\n    z-index: 500; \/* So the the nav bar floats over the top *\/    \n}\n\n.tran_back {\n    \n}\n\n.main_header {\n    text-align: center;\n    font-size: 2rem;\n    background-color: rgba(77,151,225,.9);\n    border: .1rem solid black;\n    border-top-left-radius: 20px;\n    border-top-right-radius: 20px;\n}\n\n.main_row1 {\n    background-color: rgba(77,151,225,.8);\n    border-top-left-radius: 20px;\n    border-top-right-radius: 20px;\n}\n\n.main_row2 {\n    background-color: rgba(77,151,225,.8);\n}\n\n.main_row3 {\n    background-color: rgba(77,151,225,.8);\n    border-bottom-left-radius: 20px;\n    border-bottom-right-radius: 20px;\n}\n\n\/* Footer *\/\n\n.footer {\n    background-color:#e14d4d;\n    color: white;\n    height:auto;\n    width: 100%;\n    max-width: none;\n    padding: 1rem 1rem 1rem 1rem;\n    margin-top: 2rem;\n}\n        \/* Footer to change with screen size *\/\n\n@media screen and (max-width : 550px){\n    .small_footer { \n        text-align: center;\n        border: 2px solid black;\n    }\n    .small_social {\n        border-bottom: 2px solid black;\n        border-left: 2px solid black;\n        border-right: 2px solid black;\n    }    \n}\n\n\n\n\/* Social media buttons *\/\n\n.social a {\n    margin: 0 .5rem 0 .5rem;\n}\n\n\/* Make an Image rotate *\/\n\n.rotate    {\n    -webkit-transition-duration:0.8s;   \n    -moz-transition-duration:0.8s;    \n    -o-transition-duration:0.8s;    \n    transition-duration:0.8s;\n\n    -webkit-transition-property: -webkit-transform;\n    -moz-transition-property: -moz-transform;\n    -o-transition-property: -o-transform;\n    transition-property: transform;\n    overflow:hidden;   \n}  \n \n.rotate:hover  {\n    -webkit-transform:rotate(360deg);\n    -moz-transform:rotate(360deg);\n    -o-transform:rotate(360deg);\n} \na.email {\n    color: white;\n}\n\na.email:visited {\n    color: white;\n}\n\na.email:hover {\n    color: white;\n}\n\na.red:visited {\n    color: #990000;\n}\na.red:hover {\n    color: #990000;\n}\na.red {\n    color: #990000;\n}\n\na:visited {\n    color: black;\n}\na:hover {\n    color: black;\n}\na {\n    color: black;\n}\n\n\/* Genreal page formatting *\/\n\n.bold_lined {\n    text-decoration: underline;\n    font-weight: bold;\n}\n\n.bold {\n    font-weight: bold;\n}\n\n.not_lined {\n    text-decoration: none;   \n}\n\n\/* Individual page formating *\/\n\n\n.index_row1 {\n    margin-top: 1rem;\n    font-size: 20px;\n    height: auto;\n    \n}\n\n\/* Avoid internal padding within main sectio with left and right *\/\n\n.main_box_left {\n    padding: 1.5rem 0rem 1.5rem 1.5rem;\n}\n\n.main_box_right {\n    padding: 1.5rem 1.5rem 1.5rem 0rem;\n}\n\n.main_box_center {\n    padding: 1.5rem 1.5rem 1.5rem 1.5rem;\n}\n\/* adds back in margin when colums shift*\/\n\n@media screen and (max-width:700px){\n    .main_box_left {\n        padding: 1.5rem 2rem 1.5rem 2rem;\n    }\n\n    .main_box_right {\n        padding: 1.5rem 2rem 1.5rem 2rem;\n    }\n\n}\n\/* background for boxes *\/\n.box_back {\n    background-color:#35699d; \n    border-radius: 20px;\n    padding: 1.5rem 1.5rem 1.5rem 2rem;\n}\n\n.box_no_back {\n    border-radius: 20px;\n    padding: 1.5rem 1.5rem 1.5rem 2rem;\n}\n\n\/* Image manipluation *\/\n.img_fit {\n    max-width:100%;\n    max-height:100%;\n}\n\n.img_fit_round {\n    max-width:100%;\n    max-height:100%;\n    border-radius: 20px;\n    border: .5px solid black;\n}\n\n.index_images_left {\n    padding: 1.5rem 0 0 1.5rem;\n}\n\n.index_images_center {\n    padding: 1.5rem .75rem 0 .75rem;\n}\n\n.index_images_right {\n    padding: 1.5rem 1.5rem 0 0;\n    \n}\n\/* Image box on index *\/\n.index_side_pic {\n    height: auto;\n    width: auto;\n}\n\n\n@media screen and (max-width:700px){\n    .index_images_left {\n        padding: .75rem 1.5rem .75rem 1.5rem;\n    }\n\n    .index_images_center {\n        padding: .75rem 1.5rem .75rem 1.5rem;\n    }\n\n    .index_images_right {\n        padding: .75rem 1.5rem .75rem 1.5rem;\n\n    }\n    .main_row1 {\n    background-color: rgba(77,151,225,.8);\n    border-top-left-radius: 0px;\n    border-top-right-radius: 0px;\n}\n}\n\n\/* twitter element *\/\n\n.twitter-timeline {\n    width: 100%;\n    align-content: center;\n    min-width: 20rem;\n}\n\n\/* Responsive element for contact us form *\/\n\n.text_area {\n    width: 90%;\n}\n\n.spaced td {\n    padding-bottom: 1.5rem;\n}\n\n@media only screen and (max-width: 750px)  {\n\n\ttable, td, tr { \n\t\tdisplay: block; \n\t}\n\t\n\ttr { \n        border: 1px solid #ccc; \n    }\n\t\n\ttd { \n        padding: 0 0 0 2rem;\n\t}\n}\n\n\/* text wraped image on what is touring page *\/\n.what_tour_text_wraped {\n    height:50rem; \n    float:right;\n    padding: 2rem 0rem 2rem 2rem;\n}\n\n.blog_text_wraped {\n    width:  50%; \n    float:right;\n    padding: 2rem 0rem 2rem 2rem;\n}\n\n@media screen and (max-width:800px){\n    .blog_text_wraped {\n    width:100%;\n    float:right;\n    padding: 2rem 0rem 2rem 2rem;\n}\n    .text_img_blog {\n        padding: 1rem 0rem 1rem 1rem;\n        align-content: center;\n    }\n}\n\nkit_text_wraped {\n    height:50rem; \n    float:right;\n    padding: 2rem 0rem 2rem 2rem;\n}\n\n\n@media screen and (max-width:650px){\n    .what_tour_text_wraped {\n        width:100%;\n        float:right;\n    }   \n    .text_img_wit {\n        padding: 1rem 0rem 1rem 1rem;\n        align-content: center;\n    }\n    \n.text_img_kit {\n    padding: 1rem 1rem 1rem 1rem;\n    align-content: center;\n    width: 95%;\n    border: 2px solid black; \n}\n}\n\n.box_back_entire_row {\n    background-color: white; \n    border-radius: 20px;\n    padding: 1.5rem 1.5rem 1.5rem 1.5rem;\n}\n\n.border {\n    border: .1rem solid #9e0b0f;\n    border-radius: 20px;\n    padding: .5rem .5rem .5rem .5rem;\n}\n\n.border_black {\n    border: 2px solid black;\n}\n\n\n\n.trips_image {\n    padding: 1.5rem 1.5rem 1.5rem 1.5rem;\n}\n\n.trip_image {\n    width:80%;\n    margin-left: auto;\n    margin-right: auto;\n    padding: 1rem 0 1rem 0;\n}\n\n\n\n.center_colum {\n    margin-left: auto;\n    margin-right: auto;\n}\n\n\n\n.lined td{\n    border:5px solid black;\n}\n\n.pressue_display {\n    display: none;\n}\n\n.wind_speed_display {\n    display: none;\n}\n\n.humidity_display {\n    display: none;\n}\n\n\n.day_1_extend_forcast  {\n    display: none;\n}\n\n.day_2_extend_forcast {\n    display: none;\n}\n\n.day_3_extend_forcast {\n    display: none;\n}\n\n.day_4_extend_forcast {\n    display: none;\n}\n\n.day_5_extend_forcast {\n    display: none;\n}\n\n","avg_line_length":15.9575757576,"max_line_length":116,"alphanum_fraction":0.6167869351,"licenses":["MIT"],"repository_name":"c-okelly\/Software_eng_Dublin_bikes","path":"website\/css\/styles.css","size":10532,"lang":"CSS"}
{"content":"C   1  84      SUBROUTINE AARGS                    2 19 68              00000000\nFILE  1 = OMNITAB,UNIT=READER                                           00000100\nFILE  3 = OMNITAB,UNIT=PRINTER                                          00000200\nFILE  2 = OMNITAB,UNIT=PUNCH                                            00000300\nFILE  4 = OMNITAB,UNIT=DISK,AREA=6030,BLOCKING=30,RECORD=11,BUFFER=2    00000400\nC          THE PROGRAM WAS DEVELOPED AT THE NATIONAL BUREAU OF STANDARDS00000500\nC     IN WASHINGTON D.C.   MOST OF ITS IDEAS AND PHILOSOPHIES ARE DUE   00000600\nC     TO J. HILSENRATH AND ARE EXPLAINED IN \"OMNITAB\", A COMPUTER       00000700\nC     PROGRAM FOR STATISTICAL AND NUMERICAL ANALYSIS, NATIONAL BUREAU   00000800\nC     OF STANDARD HANDBOOK 101 (1968), A MANUAL WRITTEN TO DESCRIBE THE 00000900\nC     ORIGINAL VERSION.    THIS HANDBOOK MAY BE PROCURED FROM THE       00001000\nC     GOVERNMENT PRINTING OFFICE, WASHINGTON, D. C.                     00001100\nC          THE ORIGINAL VERSION WAS WRITTEN PRIMARILY IN ASSEMBLY       00001200\nC     LANGUAGE FOR THE IBM 7094 AND WAS THEREFORE ALMOST EXCLUSIVELY    00001300\nC     AVAILABLE ONLY TO THOSE PERSONS WHO HAD ACCESS TO SUCH A MACHINE. 00001400\nC     BECAUSE OMNITAB PROVED TO BE SUCH A SUCCESS IN PROVIDING ACCESS TO00001500\nC     THE COMPUTER FOR PEOPLE WHO KNOW ALMOST NOTHING ABOUT COMPUTER    00001600\nC     PROGRAMMING, THE PROGRAM WAS REWITTEN DURING THE PAST YEAR IN     00001700\nC     FORTRAN IN AN ATTEMPT TO MAKE THE PROGRAM AVAILABLE TO AS MANY    00001800\nC     INSTALLATIONS AS POSSIBLE.                                        00001900\nC          THE VERSION OF THE PROGRAM DESCRIBED HERE WAS WRITTEN FOR    00002000\nC     THE NATIONAL BUREAU OF STANDARDS\" UNIVAC 1108 INSTALLATION BY     00002100\nC     WALTER J. GILBERT, PHILIP WALSH, CARLA MESSINA, SALLY PEAVY, AND  00002200\nC     RUTH VARNER WITH THE COOPERATION OF THEIR STATISTICAL ENGINEERING 00002300\nC     LABORATORY.   IT WAS ADAPTED FOR USE ON THE IBM 360\/65 OF IOWA    00002400\nC     STATE UNIVERSITY BY R. L. CHAMBERLAIN UNDER PROJECT 101 OF THE    00002500\nC     IOWA AGRICULTURAL EXPERIMENT STATION, WHERE IT HAS PROVED         00002600\nC     INVALUABLE IN STATISTICAL CONSULTING.  IT WAS CONVERTED FOR USE   00002700\nC     ON THE B5500 OF THE NAVAL AIR TEST CENTER BY SYSTEMS DESIGN AND   00002800\nC     PROGRAMMING SECTION OF COMPUTER SERVICES AND OPERATIONS BRANCH    00002900\nC     OF COMPUTER SERVICES DIVISION NAVAL AIR TEST CENTER PATUXENT      00003000\nC     RIVER, MARYLAND                                                   00003100\n      SUBROUTINE AARGS                                                  00003200\n      COMMON \/ BLOCKA\/MODE,M,KARD(83),KARG,ARG,ARG2,NEWCD(80),KRDEND    00003300\n      COMMON\/CONSTS\/PI,E,HALFPI,DEG,RAD,XEXP,XTRIG,XALOG,CC( 192 )      00003400\nC                                                                       00003500\nC     THIS SUBROUTINE ASSEMBLES A FLOATING POINT NUMBER FROM A STRING OF00003600\nC     DIGITS ETC.  M INITIALLY POINTS AT THE FIRST NUMBER. IT IS LEFT   00003700\nC     POINTING AT THE FIRST CHARACTER AFTER THE NUMBER.                 00003800\nC                                                                       00003900\nC     VALUE RETURNED IN ARG                                             00004000\nC                                                                       00004100\nC     KARG = 1 = FLOATING POINT, = 0 = INTEGER, -1 = ERROR.             00004200\nC                                                                       00004300\n      ARG=KARD(M)                                                       00004400\n      SIG =1.                                                           00004500\n      JEXP=0                                                            00004600\n      IXS=1                                                             00004700\n      IEXP=0                                                            00004800\n      KARG=0                                                            00004900\nC                                                                       00005000\nC     LOOK BACK FOR MINUS SIGN AND\/OR DECIMAL POINT                     00005100\nC                                                                       00005200\n      K=KARD(M-1)                                                       00005300\n      IF(K.NE.37)GO TO 10                                               00005400\n      KARG=1                                                            00005500\n      IEXP=-1                                                           00005600\n      K=KARD(M-2)                                                       00005700\n  10  IF(K.EQ.38)SIG =-1.                                               00005800\n  20  M=M+1                                                             00005900\n      K=KARD(M)                                                         00006000\n      IF(K.GE.10)GO TO 30                                               00006100\n      IEXP=IEXP-KARG                                                    00006200\n      ARG=10.*ARG+FLOAT(K)                                              00006300\n      GO TO 20                                                          00006400\n  30  IF(K.NE.37)GO TO 50                                               00006500\nC                                                                       00006600\nC     DECIMAL POINT FOUND                                               00006700\nC                                                                       00006800\n      IF(KARG.EQ.0)GO TO 40                                             00006900\n      CALL ERROR(3)                                                     00007000\n      KARG=-1                                                           00007100\n      RETURN                                                            00007200\n  40  KARG=1                                                            00007300\n      GO TO 20                                                          00007400\nC                                                                       00007500\nC     CHECK FOR EXPONENT   E X, E+X, E-X, +X, -X                        00007600\nC                                                                       00007700\n  50  IF( K .NE. 14 ) GO TO 54                                          00007800\n      M = M + 1                                                         00007900\n      K = KARD( M )                                                     00008000\n      IF( K .NE. 44 ) IF( K - 10 ) 56, 54, 54                           00008100\n  52  M = M + 1                                                         00008200\n      K = KARD( M )                                                     00008300\n      IF( K - 10 ) 56, 100, 100                                         00008400\n  54  IF( K .NE. 38 ) IF( K - 39 ) 100, 52, 100                         00008500\n      IXS = -1                                                          00008600\n      GO TO 52                                                          00008700\n  56  KARG = KARG + 1                                                   00008800\n  70  JEXP=10*JEXP+K                                                    00008900\n      M=M+1                                                             00009000\n      K=KARD(M)                                                         00009100\n      IF( K .LT. 10 ) GO TO 70                                          00009200\nC                                                                       00009300\nC     DONE WITH ARGUMENT                                                00009400\nC                                                                       00009500\n 100  IF(KARG.NE.0)GO TO 120                                            00009600\n 110  ARG=SIG *ARG                                                      00009700\n      RETURN                                                            00009800\n 120  KARG=1                                                            00009900\n      IEXP = IXS * JEXP + IEXP                                          00010000\nC                                                                       00010100\nC     THE FOLLOWING CODING YIELDS MORE ACCURATE RESULTS THAN THE        00010200\nC     OBVIOUS    ARG = ARG * 10. * IEXP                                 00010300\nC                                                                       00010400\n      JEXP = IABS( IEXP )                                               00010500\n      IF( JEXP .GT. IFIX( XALOG ) ) GO TO 130                           00010600\n      IF( IEXP ) 123, 110, 126                                          00010700\n 123  ARG = ARG \/ 10. ** JEXP                                           00010800\n      GO TO 110                                                         00010900\n 126  ARG = ARG * 10. ** JEXP                                           00011000\n      GO TO 110                                                         00011100\n 130  CALL ERROR( 102 )                                                 00011200\n      ARG = 0.                                                          00011300\n      GO TO 110                                                         00011400\n      END                                                               00011500\nC   2  21      SUBROUTINE ADRESS( I, J )           2 19 68              00011600\n      SUBROUTINE ADRESS( I, J )                                         00011700\n      COMMON \/ BLOCKF \/ NCTOP                                           00011800\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00011900\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00012000\n      DIMENSION ARGS(100)                                               00012100\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00012200\nC                                                                       00012300\nC         CALCULATE ADDRESS OF ARGUMENT( I ). IF ARGUMENT( I ) IS A     00012400\nC         FLOATING POINT NUMBER, J = -(I+5000). IF ILLEGAL COLUMN NUMBER00012500\nC         J = 0.  IF OK, J = ADDRESS                                    00012600\nC                                                                       00012700\n      IF( KIND( I ) .EQ. 0 ) GO TO 10                                   00012800\nC     THE 10000 IS THE SIZE OF THE ARRAY                                00012900\n      J = -( I + 10000)                                                 00013000\n      GO TO 30                                                          00013100\n  10  IF( IARGS( I ) .GE. 1 .AND. IARGS( I ) . LE. NCOL ) GO TO 20      00013200\n      J = 0                                                             00013300\n      GO TO 30                                                          00013400\n   20 J = ( NROW+NCTOP-1 ) * ( IARGS(I)-1 ) + NCTOP                     00013500\n  30  RETURN                                                            00013600\n      END                                                               00013700\nC   3 155      SUBROUTINE ALLSUB                   2 19 68              00013800\n      SUBROUTINE ALLSUB                                                 00013900\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00014000\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00014100\n      DIMENSION ARGS(100)                                               00014200\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00014300\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00014400\n      COMMON \/ SCRAT \/ SCRA(10000),NS                                   00014500\n      EQUIVALENCE(L11,LL1),(L22,LL2)                                    00014600\nC     PROGRAMMED BY PHILIP J. WALSH (NBS 453.40) MAY, 1967              00014700\nC                                                                       00014800\nC                                                                       00014900\nC     COMMAND IS OF THE FORM XXXX OF ORDER ++ OF COL ++, STORE IN ++    00015000\nC     XXXX MAY BE  (A) NLSUB FOR NORMALIZED LAGUERRE POLYNOMIALS        00015100\nC                  (B) LSUB  FOR LAGUERRE POLYNOMIALS                   00015200\nC                  (C) HSUB  FOR HERMITE POLYNOMIALS                    00015300\nC                  (D) USUB  FOR CHEBYSHEV POLYNOMIALS                  00015400\nC                  (E) PSUB  FOR LEGENDRE  POLYNOMIALS                  00015500\nC                  (F) TSUB  FOR CHEBYSHEV POLYNOMIALS                  00015600\nC    SEE RECURSIVE FORMULAE FOR THESE POLYNOMIALS FURTHER IN CODE       00015700\nC     EACH OF THE COMMANDS REQUIRE THREE ARGUMENTS                      00015800\n      IF ( NARGS .EQ. 3 ) GO TO 1                                       00015900\n  200 CALL ERROR(10)                                                    00016000\n      GO TO 99                                                          00016100\n   1  IF( KIND( 1 ) + KIND( 3 ) .EQ. 0 ) GO TO 2                        00016200\n  13  CALL ERROR( 3 )                                                   00016300\n      GO TO 99                                                          00016400\nC CHECK THAT X IS WITHIN WORKSHEET AND GET ADDRESS OF ARGUMENT COLUMN   00016500\n    2 CALL ADRESS( 2, L11 )                                             00016600\n      IF( L11 ) 13, 25, 3                                               00016700\n  25  CALL ERROR( 11 )                                                  00016800\n      GO TO 99                                                          00016900\n   3  IARGS( 4 ) = IARGS( 1 ) + IARGS( 3 ) - 1                          00017000\n      KIND( 4 ) = 0                                                     00017100\n      CALL ADRESS( 4, L22 )                                             00017200\n      IF( L22 .LE. 0 ) GO TO 25                                         00017300\n   4  CALL ADRESS( 3, L22 )                                             00017400\n      IF (NRMAX .NE. 0 ) GO TO 6                                        00017500\n      CALL ERROR(9)                                                     00017600\n      GO TO 99                                                          00017700\n   6  IF( NERROR .NE. 0 ) GO TO 99                                      00017800\n      IJK = LL1                                                         00017900\n      IJ = LL2                                                          00018000\n      DO 12 I = 1, NRMAX                                                00018100\n      SCRA( 1 ) = RC( IJK )                                             00018200\n      GO TO ( 8,8,9,9,10,10) , L2                                       00018300\n   8  RC( IJ ) = 1. - SCRA( 1 )                                         00018400\n      GO TO 11                                                          00018500\n   9  RC( IJ ) = 2. * SCRA( 1 )                                         00018600\n      GO TO 11                                                          00018700\n  10  RC( IJ ) = SCRA( 1 )                                              00018800\n  11  IJK = IJK + 1                                                     00018900\n  12  IJ = IJ + 1                                                       00019000\n      IF(IARGS(1) .EQ. 1 ) GO TO 99                                     00019100\n      N = IARGS(1)-1                                                    00019200\n      DO 101 J = 1,NRMAX                                                00019300\n      IJK = LL1 + J                                                     00019400\n      IJ = LL2 + J                                                      00019500\n      SCRA (1) = 1.0                                                    00019600\n      SCRA( 2 ) = RC( IJK - 1 )                                         00019700\n      SCRA( 3 ) = RC( IJ - 1 )                                          00019800\n      SCRA (4) = 1.0                                                    00019900\n      SCRA (5) = 2.0                                                    00020000\n      DO 100 I = 1,N                                                    00020100\n      IARGS( 4 ) = IARGS( 3 ) + I                                       00020200\n      CALL ADRESS( 4, LL22 )                                            00020300\n      GO TO(30,40,50,60,70,80) , L2                                     00020400\nC   ITYPE = 1      NLSUB          NORMALIZED LAGUERRE POLYNOMIALS       00020500\nC             RECURSION FORMULA  L(N+1) =(1.+2.*N-X)*L(N)-N**2 *L(N-1)  00020600\nC             L(0) = 1.                                                 00020700\nC             L(1) = -X+1.                                              00020800\nC             L(2) = X**2 - 4.0*X +2.                                   00020900\nC             L(3) =-X**3 + 9.0*X**2-18.0*X+6.                          00021000\nC                                                                       00021100\nC     L(N)= EXP(X)*(DN\/DXN(X**N*EXP(-X)))                               00021200\nC                                                                       00021300\n   30 SCRA (4) = I                                                      00021400\n      SCRA (6) = 1.0 + 2.0*SCRA (4)                                     00021500\n      SCRA (7) = SCRA (4)*SCRA (4)                                      00021600\n      SCRA (8) = (SCRA (6)-SCRA (2))*SCRA (3)-SCRA (7)*SCRA (1)         00021700\n      GO TO 90                                                          00021800\nC   ITYPE = 2      LSUB           LAGUERRE POLYNOMIALS                  00021900\nC             RECURSION FORMULA  L(N+1)=(((2.*N+1)-X)*L(N)-N*L(N-1))\/   00022000\nC                                        (N+1)                          00022100\nC             L(0) =  1.                                                00022200\nC             L(1) =  -X+1.                                             00022300\nC             L(2) =  .5 (XX*2 - 4.*X +2)                               00022400\nC             L(3) =  (-X**3 + 9.*X**2 - 18.* X +6.)\/6.                 00022500\nC                                                                       00022600\nC  **** SEE  ABRAMOWITZ, M. AND STEGUN, I.A.,  HANDBOOK OF MATHEMATICAL 00022700\nC            FUNCTIONS, NATIONAL BUREAU OF STANDARDS APPLIED MATHEMATICS00022800\nC            SERIES 55, SUPERINTENDENT OF DOCUMENTS, U.S. GOVERNMENT    00022900\nC            PRINTING OFFICE, WASHINGTON, D.C. 20402                    00023000\nC                                                                       00023100\nC  **** SEE  HILSENRATH,ZIEGLER,MESSINA,WALSH,HERBOLD,, OMNITAB, NBS    00023200\nC            HANDBOOK 101 (MARCH 4, 1966) -  FOR FORMULAE USED          00023300\n   40 SCRA (4) = I                                                      00023400\n      SCRA (6) = SCRA (4) + 1.0                                         00023500\n      SCRA (7) = SCRA (4) + SCRA (6)                                    00023600\n      SCRA (8) = ((SCRA (7)-SCRA (2))*SCRA (3)-SCRA (4)*SCRA (1))\/      00023700\n     1           SCRA (6)                                               00023800\n      GO TO 90                                                          00023900\nC   ITYPE = 3      HSUB           HERMITE POLYNOMIALS                   00024000\nC             RECURSION FORMULA  H(N+1) = 2.0*X*H(N)-2.0*N*H(N-1)       00024100\nC                                                                       00024200\nC             H(0) = 1.                                                 00024300\nC             H(1) = 2.0*X                                              00024400\nC             H(2) = 4.0*X**2-2.                                        00024500\nC             H(3) = 8.0*X**3-12.*X                                     00024600\n   50 SCRA (8)=2.0*(SCRA (2)*SCRA (3)-SCRA (4)*SCRA (1))                00024700\n      SCRA (4) = SCRA (4) + 1.0                                         00024800\n      GO TO 90                                                          00024900\nC   ITYPE = 4      USUB           CHEBYSHEV POLYNOMIALS                 00025000\nC                                                                       00025100\nC             RECURSION FORMULA  U(N) = 2.0*X*U(N-1)-U(N-2)             00025200\nC                                                                       00025300\nC             U(0) = 1.                                                 00025400\nC             U(1) = 2.0*X                                              00025500\nC             U(2) = 4.0*X**2-1.0                                       00025600\nC             U(3) = 8.0*X**3-4.0*X                                     00025700\nC                                                                       00025800\n   60 SCRA (8) = 2.0*SCRA (2)*SCRA (3)-SCRA (1)                         00025900\n      GO TO 90                                                          00026000\nC   ITYPE = 5      PSUB           LEGENDRE POLYNOMIALS                  00026100\nC                                                                       00026200\nC             RECUSION FORMULA  P(N+1) =X*P(N)+(N\/N+1)*(X*P(N)-P(N-1))  00026300\nC                                                                       00026400\nC             P(0) = 1.                                                 00026500\nC             P(1) = X.                                                 00026600\nC             P(2) = (3.\/2.)*X**2-(1.\/2.)                               00026700\nC             P(3) = 2.5*X**3-1.5*X                                     00026800\nC                                                                       00026900\n   70 SCRA (6)=SCRA (4)\/SCRA (5)                                        00027000\n      SCRA (8)=(1.0+SCRA (6))*SCRA (2)*SCRA (3)-SCRA (6)*SCRA (1)       00027100\n      SCRA (4) = SCRA (5)                                               00027200\n      SCRA (5) = SCRA (5) + 1.0                                         00027300\n      GO TO 90                                                          00027400\nC   ITYPE = 6      TSUB           CHEBYSHEV POLYNOMIALS                 00027500\nC                                                                       00027600\nC             RECURSION FORMULA                                         00027700\nC                                                                       00027800\nC             T(0) = 1.                                                 00027900\nC             T(1) = X                                                  00028000\nC             T(2) = 2.*X**2-1.                                         00028100\nC             T(3) = 4.*X**3-3.*X                                       00028200\n   80 SCRA (8) = 2.0 * SCRA (2)*SCRA (3)-SCRA (1)                       00028300\n   90 CONTINUE                                                          00028400\n  91  LJMN = LL22 + J                                                   00028500\n      RC( LJMN - 1 ) = SCRA( 8 )                                        00028600\n      SCRA (1) = SCRA (3)                                               00028700\n      SCRA (3) = SCRA (8)                                               00028800\n   98 CONTINUE                                                          00028900\n  100 CONTINUE                                                          00029000\n  101 CONTINUE                                                          00029100\n   99 RETURN                                                            00029200\n      END                                                               00029300\nC   4  35      SUBROUTINE APRINT                   2 19 68              00029400\n      SUBROUTINE APRINT                                                 00029500\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00029600\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00029700\n      DIMENSION ARGS(100)                                               00029800\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00029900\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00030000\n      IF( NARGS .EQ. 4 ) GO TO 30                                       00030100\n  10  CALL ERROR( 205 )                                                 00030200\n  20  RETURN                                                            00030300\n  30  J = 1                                                             00030400\n      I = 4                                                             00030500\n      CALL CKIND( I )                                                   00030600\n      IF( I .NE. 0 ) GO TO 10                                           00030700\n      K = IARGS( 1 )                                                    00030800\n      CALL MTXCHK( J )                                                  00030900\n      IF( J .NE. 0 .OR. IARGS( 4 ) .GE. 50 ) GO TO 10                   00031000\n      IARGS( 1 ) = K                                                    00031100\n      K = IARGS( 3 )                                                    00031200\n      IARGS( 51 ) = IARGS( 1 )                                          00031300\n      IARGS( 52 ) = IARGS( 2 )                                          00031400\n      L = IARGS( 4 )                                                    00031500\n      DO 40 I = 2, L                                                    00031600\n      IARGS( I+1 ) = IARGS( I ) + 1                                     00031700\n      IARGS( I+51 ) = IARGS( I+1 )                                      00031800\n  40  KIND( I+1 ) = 0                                                   00031900\n      NARGS = L + 1                                                     00032000\n      L1 = 6                                                            00032100\n      LL = IARGS( 1 )                                                   00032200\n  50  DO 60 I = 1, K                                                    00032300\n      CALL PRINTX                                                       00032400\n      IARGS( 51 ) = LL + I                                              00032500\n      DO 60 J = 1, NARGS                                                00032600\n  60  IARGS( J ) = IARGS( J+50 )                                        00032700\n      GO TO 20                                                          00032800\n      END                                                               00032900\nC   5  90      SUBROUTINE ARITH                    2 19 68              00033000\n      SUBROUTINE ARITH                                                  00033100\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00033200\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00033300\n      DIMENSION ARGS(100)                                               00033400\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00033500\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00033600\n      DIMENSION II( 4 ), KK( 4 )                                        00033700\n      EQUIVALENCE (I1,II(1)),(I2,II(2)),(I3,II(3)),(I4,II(4))           00033800\nC                                                                       00033900\nC         THIS SUBROUTINE PERFORMS ADD, SUB, MULT DIV, RAISE FOR        00034000\nC         THREE AND FOUR ARGUMENTS.                                     00034100\nC                                                                       00034200\n      IF( NARGS .EQ. 3 .OR. NARGS .EQ. 4 ) GO TO 2                      00034300\n      CALL ERROR( 10 )                                                  00034400\n      GO TO 10                                                          00034500\n    2 IF( KIND( NARGS ) .EQ. 0 ) GO TO 15                               00034600\n      CALL ERROR ( 20 )                                                 00034700\n      GO TO 10                                                          00034800\n    5 CALL ERROR( 11 )                                                  00034900\n   10 RETURN                                                            00035000\n   15 DO 30 I = 1, NARGS                                                00035100\n      KK( I ) = 1                                                       00035200\n      CALL ADRESS( I, II( I ) )                                         00035300\n      IF( II( I ) ) 20, 5, 30                                           00035400\n   20 KK( I ) = 0                                                       00035500\n      II( I ) = -II( I )                                                00035600\n   30 CONTINUE                                                          00035700\n      IF( NERROR .NE. 0 ) GO TO 10                                      00035800\n      IF( NRMAX .GT. 0 ) GO TO 40                                       00035900\n      CALL ERROR( 9 )                                                   00036000\n      GO TO 10                                                          00036100\n  40  JJ = II( NARGS ) + NRMAX - 1                                      00036200\n      IJ = L2 + 5 * ( NARGS - 3 )                                       00036300\n      GO TO (100,200,300,400,500,600,700,800,900,1000), IJ              00036400\n  100 DO 110 I = I3, JJ                                                 00036500\n      RC( I ) = RC( I1 ) + RC( I2 )                                     00036600\n      I1 = I1 + KK( 1 )                                                 00036700\n  110 I2 = I2 + KK( 2 )                                                 00036800\n      GO TO 10                                                          00036900\n  200 DO 210 I = I3, JJ                                                 00037000\n      RC( I ) = RC( I2 ) - RC( I1 )                                     00037100\n      I1 = I1 + KK( 1 )                                                 00037200\n  210 I2 = I2 + KK( 2 )                                                 00037300\n      GO TO 10                                                          00037400\n  300 DO 310 I = I3, JJ                                                 00037500\n      RC( I ) = RC( I1 ) * RC( I2 )                                     00037600\n      I1 = I1 + KK( 1 )                                                 00037700\n  310 I2 = I2 + KK( 2 )                                                 00037800\n      GO TO 10                                                          00037900\n  400 DO 410 I = I3, JJ                                                 00038000\n      RC( I ) = RC( I1 ) \/ RC( I2 )                                     00038100\n      I1 = I1 + KK( 1 )                                                 00038200\n  410 I2 = I2 + KK( 2 )                                                 00038300\n      GO TO 10                                                          00038400\n  500 DO 510 I = I3, JJ                                                 00038500\n      RC( I ) = FEXP2( RC( I1 ), RC( I2 ) )                             00038600\n      I1 = I1 + KK( 1 )                                                 00038700\n  510 I2 = I2 + KK( 2 )                                                 00038800\n      GO TO 10                                                          00038900\n  600 DO 610 I = I4, JJ                                                 00039000\n      RC( I ) = RC( I ) + ( RC( I1 ) + RC( I2 ) ) * RC( I3 )            00039100\n      I1 = I1 + KK( 1 )                                                 00039200\n      I2 = I2 + KK( 2 )                                                 00039300\n  610 I3 = I3 + KK( 3 )                                                 00039400\n      GO TO 10                                                          00039500\n  700 DO 710 I = I4, JJ                                                 00039600\n      RC( I ) = RC( I ) + ( RC( I2 ) - RC( I1 ) ) * RC( I3 )            00039700\n      I1 = I1 + KK( 1 )                                                 00039800\n      I2 = I2 + KK( 2 )                                                 00039900\n  710 I3 = I3 + KK( 3 )                                                 00040000\n      GO TO 10                                                          00040100\n  800 DO 810 I = I4, JJ                                                 00040200\n      RC( I ) = RC( I ) + ( RC( I1 ) * RC( I2 ) ) * RC( I3 )            00040300\n      I1 = I1 + KK( 1 )                                                 00040400\n      I2 = I2 + KK( 2 )                                                 00040500\n  810 I3 = I3 + KK( 3 )                                                 00040600\n      GO TO 10                                                          00040700\n  900 DO 910 I = I4, JJ                                                 00040800\n      RC( I ) = RC( I ) + ( RC( I1 ) \/ RC( I2 ) ) * RC( I3 )            00040900\n      I1 = I1 + KK( 1 )                                                 00041000\n      I2 = I2 + KK( 2 )                                                 00041100\n  910 I3 = I3 + KK( 3 )                                                 00041200\n      GO TO 10                                                          00041300\n 1000 DO 1010 I = I4, JJ                                                00041400\n      RC( I ) = RC( I ) + RC( I3 ) * FEXP2( RC( I1 ), RC( I2 ) )        00041500\n      I1 = I1 + KK( 1 )                                                 00041600\n      I2 = I2 + KK( 2 )                                                 00041700\n 1010 I3 = I3 + KK( 3 )                                                 00041800\n      GO TO 10                                                          00041900\n      END                                                               00042000\nC   6 134      SUBROUTINE ARYVEC                   2 19 68              00042100\n      SUBROUTINE ARYVEC                                                 00042200\nC     SUBROUTINE ARYVEC              9\/27\/67                            00042300\nC *****                                                                 00042400\nC     SUBROUTINE TO MULTIPLY MATRIX TIME VECTOR                         00042500\nC                        OR VECTOR TRANSPOSE TIME MATRIX                00042600\nC     L2=1 MULTIPLY MATRIX TIME VECTOR                                  00042700\nC          GENERAL FORM OF COMMAND                                      00042800\nC              M(AV)  A (,) N,K   VECTOR IN COL I  STORE IN COLUMN J    00042900\nC              M(AV)  A (,) N,K   VECTOR IN COL I  STORE IN ROW K COL J 00043000\nC                   N AND K MUST BE SPECIFIED                           00043100\nC     L2=2 MULTIPLY VECTOR TRANSPOSE TIMES MATRIX                       00043200\nC          GENERAL FORM OF COMMAND                                      00043300\nC              M(VTA) A (,) N,K  VECTOR IN COL I  STORE IN ROW  J       00043400\nC              M(VTA) A (,) N,K  VECTOR IN COL I  STORE IN ROW K COL J  00043500\nC                   N AND K MUST BE SPECIFIED                           00043600\nC                   IF ONLY ROW IS GIVEN FOR STORAGE  COL  1 IS ASSUMED 00043700\nC *****                                                                 00043800\n      COMMON \/ HEADER\/NMCARD(72),ITLE(64,6),IHEAD(4,50),IFMT(17,6),     00043900\n     1 IFMTX(4),LNCNT,IPRINT,NPAGE,IPUNCH                               00044000\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00044100\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00044200\n      DIMENSION ARGS(100)                                               00044300\n      EQUIVALENCE( ARGS(1), RC(5001) )                                  00044400\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00044500\n      COMMON \/ SCRAT \/ X , NS                                           00044600\n      DIMENSION A( 10000 )                                              00044700\n      DOUBLE PRECISION X(5000), SUM                                     00044800\n      COMMON \/MULTC\/ NS2                                                00044900\n      NS2 = NS\/2                                                        00045000\nC *****                                                                 00045100\nC     CHECK FOR CORRECT NUMBER OF ARGUMENTS                             00045200\nC *****                                                                 00045300\n      IF(NARGS.NE.6.AND.NARGS.NE.7) CALL ERROR(10)                      00045400\nC *****                                                                 00045500\nC     CHECK TO SEE IF ALL ARGUMENTS ARE INTEGERS                        00045600\nC *****                                                                 00045700\n      J=NARGS                                                           00045800\n      CALL CKIND(J)                                                     00045900\n      IF(J.NE.0) CALL ERROR(3)                                          00046000\nC *****                                                                 00046100\nC     CHECK TO SEE IF DIMENSIONS ARE OUT OF RANGE                       00046200\nC *****                                                                 00046300\n      GO TO (200,220),L2                                                00046400\n 200  IADD=IARGS(4)                                                     00046500\n      IADD2=IARGS(3)                                                    00046600\n      ICOMP=NROW                                                        00046700\n      GO TO 240                                                         00046800\n 220  IADD=IARGS(3)                                                     00046900\n      IADD2=IADD                                                        00047000\n      ICOMP=NCOL                                                        00047100\nC *****                                                                 00047200\nC     COMPUTE ADDRESSES OF COLUMNS                                      00047300\nC *****                                                                 00047400\n  240 IARGS(10)=IARGS(NARGS)                                            00047500\n      IARGS(8)=1                                                        00047600\n      GO TO ( 440 , 410 ),L2                                            00047700\n 410  IF(NARGS.EQ.7) GO TO 420                                          00047800\n      J=2                                                               00047900\n      IROWSV=IARGS(6)                                                   00048000\n      GO TO 430                                                         00048100\n 420  IARGS(12)=IARGS(4)                                                00048200\n      IARGS(11)=1                                                       00048300\n      IARGS(9)=IARGS(6)                                                 00048400\n      J=3                                                               00048500\n 430  IARGS(7)=IARGS(3)                                                 00048600\n      GO TO 460                                                         00048700\n 440  J=3                                                               00048800\n      IARGS(12)=1                                                       00048900\n      IARGS(11)=IARGS(3)                                                00049000\n      IARGS(7)=IARGS(4)                                                 00049100\n      IF(NARGS.EQ.6) GO TO 450                                          00049200\n      IARGS(9)=IARGS(6)                                                 00049300\n      GO TO 460                                                         00049400\n 450  IARGS(9)=1                                                        00049500\n 460  IARGS(6)=IARGS(5)                                                 00049600\n      IARGS(5)=1                                                        00049700\n      CALL MTXCHK(J)                                                    00049800\n      IF(J-1) 490,470,480                                               00049900\n  470 CALL ERROR(3)                                                     00050000\n      RETURN                                                            00050100\n  480 CALL ERROR (17)                                                   00050200\n      RETURN                                                            00050300\nC *****                                                                 00050400\nC     CHECK FOR PREVIOUS ERRORS                                         00050500\nC *****                                                                 00050600\n  490 IF(NERROR.NE.0) RETURN                                            00050700\n      GO TO (580 ,600  ),L2                                             00050800\n 580  ICS=IARGS(9)                                                      00050900\n      IAP=IARGS(1)                                                      00051000\n      IP=IARGS(3)                                                       00051100\n      JP=IARGS(4)                                                       00051200\n      IAD1=NROW                                                         00051300\n      IAD2=1                                                            00051400\n      IBP=IARGS(5)                                                      00051500\n      GO TO 660                                                         00051600\n 600  IBP=IARGS(1)                                                      00051700\n      IAP=IARGS(5)                                                      00051800\n      IP=IARGS(4)                                                       00051900\n      IF(NARGS.EQ.7) GO TO 620                                          00052000\n      JP=IARGS(3)                                                       00052100\n      ICS=IROWSV                                                        00052200\n      GO TO 640                                                         00052300\n 620  JP=IARGS(3)                                                       00052400\n      ICS=IARGS(9)                                                      00052500\n 640  IAD1=1                                                            00052600\n      IAD2=NROW                                                         00052700\n 660  IC=1                                                              00052800\n      DO 740  I=1,IP                                                    00052900\n      IA=IAP                                                            00053000\n      IB=IBP                                                            00053100\n      IS=NS2                                                            00053200\n      DO 680  J=1,JP                                                    00053300\n      X(IS)=RC(IA)*RC(IB)                                               00053400\n      IS=IS-1                                                           00053500\n      IA=IA+IAD1                                                        00053600\n 680  IB=IB+1                                                           00053700\n      CALL SORTSM(JP,SUM)                                               00053800\n      A(IC) = SUM                                                       00053900\n      IC=IC+1                                                           00054000\n      GO TO (700,720),L2                                                00054100\n 700  IAP=IAP+1                                                         00054200\n      GO TO 740                                                         00054300\n 720  IBP=IBP+NROW                                                      00054400\n 740  CONTINUE                                                          00054500\nC *****                                                                 00054600\nC     STORE RESULTS IN WORKSHEET                                        00054700\nC *****                                                                 00054800\n      IS=1                                                              00054900\n      DO  800    I=1,IP                                                 00055000\n      RC(ICS) = A(IS)                                                   00055100\n      IS=IS+1                                                           00055200\n      ICS=ICS+IAD2                                                      00055300\n 800  CONTINUE                                                          00055400\n      RETURN                                                            00055500\n      END                                                               00055600\nC   7  88      SUBROUTINE ASTER                    2 19 68              00055700\n      SUBROUTINE ASTER                                                  00055800\n      COMMON \/ BLOCKA\/MODE,M,KARD(83),KARG,ARG,ARG2,NEWCD(80),KRDEND    00055900\n      DIMENSION NAM(2)                                                  00056000\nC                                                                       00056100\nC     ASTERISKS HAVE BEEN FOUND, LOOK FOR A SPECIAL FORM OF ARGUMENT.   00056200\nC                                                                       00056300\nC     FORMS CAN BE..                                                    00056400\nC                                                                       00056500\nC     *PHYSCON*    A PHYSICAL CONSTANT NAME, FL.PT.                     00056600\nC     **VARCON**   A -VARIABLE- CONSTANT TO BE USED AS AN INTEGER (TRUN)00056700\nC     *VARCON*     A -VARIABLE- CONSTANT TO BE USED AS A FL.PT. NUMBER  00056800\nC     **ROW,COLUMN**   A WORKSHEET ENTRY TO BE TRUNCATED AND USED AS INT00056900\nC     *ROW,COLUMN*     A WORKSHEET ENTRY TO BE USED AS FLOATING POINT   00057000\nC                                                                       00057100\nC     NONBLA IS A FUNCTION WHICH RETURNS THE NEXT NON-BLANK CHARACTER   00057200\nC     IN THE CARD AND ALSO POINTS M AT IT                               00057300\nC                                                                       00057400\nC        KARG = 1, SINGLE *.  KARG = 0, DOUBLE *.                       00057500\nC                                                                       00057600\n  155 CONTINUE                                                          00057700\n      I=M                                                               00057800\n      L=KARG                                                            00057900\n      K=NONBLA(I)                                                       00058000\n  10  IF(K.NE.40)GO TO 20                                               00058100\nC                                                                       00058200\nC     A LONG LINE OF ASTERISKS FOUND, SKIP OVER THEM AND IGNORE         00058300\nC                                                                       00058400\n      KARG=7                                                            00058500\n  15  M=M+1                                                             00058600\n      IF(KARD(M)-40)120,15,120                                          00058700\n  20  IF(K.GE.36)GO TO 999                                              00058800\n      IF(K.GE.10)GO TO 50                                               00058900\nC                                                                       00059000\nC     NUMBER IS FIRST NON-BLANK CHARACTER, SET N = COMMA                00059100\nC                                                                       00059200\n      N=43                                                              00059300\n  30  CALL AARGS                                                        00059400\n      IF(KARG.NE.0) GO TO 999                                           00059500\n      I = M                                                             00059600\n      IF(NONBLA(I).EQ.N)IF(N-40)40,45,40                                00059700\n      GO TO 999                                                         00059800\n   40 I = M + 1                                                         00059900\n      IF(NONBLA( I ).GE.10)GO TO 999                                    00060000\nC                                                                       00060100\nC     SET N = ASTERISK                                                  00060200\nC                                                                       00060300\n      N=40                                                              00060400\n      T=ARG                                                             00060500\n      GO TO 30                                                          00060600\n  45  ARG2=ARG                                                          00060700\n      ARG=T                                                             00060800\n      KARG=5                                                            00060900\n      GO TO 100                                                         00061000\nC                                                                       00061100\nC     LETTER FOUND FIRST                                                00061200\nC                                                                       00061300\n  50  CALL NNAME(NAM(1))                                                00061400\n      CALL PHYCON(NAM(1))                                               00061500\n      IF(ARG.EQ.0.)GO TO 60                                             00061600\nC                                                                       00061700\nC     PHYSICAL CONSTANT FOUND, SET KARG = 1                             00061800\nC                                                                       00061900\n      KARG=1                                                            00062000\n      IF(L)999,999,90                                                   00062100\nC                                                                       00062200\nC     NAME NOT IN PHYSICAL CONSTANT LIST, TRY VARIABLE LIST             00062300\nC                                                                       00062400\n  60  CALL VARCON(NAM(1))                                               00062500\n      IF(ARG.NE.0.)GO TO 80                                             00062600\n      CALL ERROR(8)                                                     00062700\n  70  KARG=1                                                            00062800\n      RETURN                                                            00062900\n  80  KARG=3                                                            00063000\n   90 I = M                                                             00063100\n      IF(NONBLA(I).NE.40)GO TO 999                                      00063200\n 100  M=M+1                                                             00063300\nC                                                                       00063400\nC     CHECK THAT THE NUMBER OF ASTERISKS AT THE END OF THE EXPRESSION   00063500\nC     IS THE SAME AS AT THE BEGINNING. L=0 MEANS 1, L=1 MEANS 2         00063600\nC                                                                       00063700\n      IF(L.NE.0)IF(KARD(M)-40)110,999,110                               00063800\n      IF(KARD(M).NE.40.OR.KARD(M+1).EQ.40)GO TO 999                     00063900\n      M=M+1                                                             00064000\n 110  KARG=KARG+L                                                       00064100\n 120  RETURN                                                            00064200\n 999  CALL ERROR(7)                                                     00064300\n      GO TO 70                                                          00064400\n      END                                                               00064500\nC   8  44      SUBROUTINE BEGIN                    2 19 68              00064600\n      SUBROUTINE BEGIN                                                  00064700\n      COMMON \/ BLOCKA\/MODE,M,KARD(83),KARG,ARG,ARG2,NEWCD(80),KRDEND    00064800\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00064900\n      COMMON \/BLOCKB\/NSTMT,NSTMTX,NSTMTH,NCOM,LCOM,IOVFL,COM(2000)      00065000\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00065100\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00065200\n      DIMENSION ARGS(100)                                               00065300\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00065400\nC                                                                       00065500\nC     THIS SUBROUTINE CONTAINS THE CODING FOR BEGIN AND SCAN, AN        00065600\nC     ARGITRARY GROUPING.                                               00065700\nC                                                                       00065800\n      IF( L2 .EQ. 1 ) GO TO 50                                          00065900\nC                                                                       00066000\nC     SCAN  (CARD UP TO AND INCLUDING CARD COLUMN ++ )                  00066100\n      IF(NARGS .EQ. 1 .AND. KIND(1) .EQ. 0 .AND. IARGS(1) .GE. 6 .AND.  00066200\n     1 IARGS(1) .LE. 80 ) GO TO 10                                      00066300\n      K = 205                                                           00066400\n      GO TO 60                                                          00066500\n  10  KRDEND = IARGS( 1 )                                               00066600\n      GO TO 20                                                          00066700\nC                                                                       00066800\nC     BEGIN STORING INSTRUCTIONS AT NUMBER ++                           00066900\nC     IF NO NUMBER IS GIVEN, 1 IS ASSUMED.                              00067000\nC                                                                       00067100\n  50  IF( MODE .EQ. 1 ) GO TO 70                                        00067200\n      K = 5                                                             00067300\n  60  CALL ERROR( K )                                                   00067400\n  20  RETURN                                                            00067500\n  70  IF( NARGS - 1 ) 90, 100, 80                                       00067600\n  80  K = 10                                                            00067700\n      GO TO 60                                                          00067800\n  90  NSTMT = 0                                                         00067900\n  95  MODE = 3                                                          00068000\n      GO TO 20                                                          00068100\n 100  IF ( KIND(1) . EQ. 0 ) GO TO 110                                  00068200\n      K = 20                                                            00068300\n      GO TO 60                                                          00068400\n 110  IF( IARGS( 1 ) .GT. 0 .AND. IARGS( 1 ) .LT. 1000 ) GO TO 120      00068500\n      K = 7                                                             00068600\n      GO TO 60                                                          00068700\n 120  NSTMT = 10 * ( IARGS( 1 ) - 1 )                                   00068800\n      GO TO 95                                                          00068900\n      END                                                               00069000\nC   9  80      SUBROUTINE BEJN                     2 19 68              00069100\n      SUBROUTINE BEJN                                                   00069200\n      COMMON \/RJN\/R(100),Z,J                                            00069300\n      DOUBLE PRECISION X,R,Z,A,B,C,D,E,F,G,P,Q,Y                        00069400\n      Y=1.D0                                                            00069500\n  102 X=Z                                                               00069600\n      DO 101 N=1,100                                                    00069700\n  101 R(N)=0.0                                                          00069800\n      LA=0                                                              00069900\n      IF (X.LE.60.) GO TO 10                                            00070000\n      LA=1                                                              00070100\n      IF (X.LE.100.) GO TO 9                                            00070200\n      WRITE (6,31)                                                      00070300\n   31 FORMAT (37H  X GREATER THAN 100. NO VALUES GIVEN)                 00070400\n      GO TO 25                                                          00070500\n    9 X=X\/2.D0                                                          00070600\n   10 A=X\/2.D0                                                          00070700\n      IF (X.GT.15.) GO TO 5                                             00070800\n      B=1.D0                                                            00070900\n      C=1.D0                                                            00071000\n      DO 1 N=1,30                                                       00071100\n      J=N                                                               00071200\n      B=B*A\/C                                                           00071300\n      C=C+1.D0                                                          00071400\n      IF (B.LT..5D-9) GO TO 2                                           00071500\n    1 CONTINUE                                                          00071600\n    2 D=B*A\/C                                                           00071700\n      A=A**2                                                            00071800\n      K=X+6.D0                                                          00071900\n      E=K                                                               00072000\n      F=K+J                                                             00072100\n      G=F+1.D0                                                          00072200\n      P=1.D0                                                            00072300\n      Q=1.D0                                                            00072400\n      DO 3 N=1,K                                                        00072500\n      P=1.D0-P*A\/(E*F)*Y                                                00072600\n      Q=1.D0-Q*A\/(E*G)*Y                                                00072700\n      E=E-1.D0                                                          00072800\n      F=F-1.D0                                                          00072900\n    3 G=G-1.D0                                                          00073000\n      R(J+1)=B*P                                                        00073100\n      R(J+2)=D*Q                                                        00073200\n   20 DO 4 N=1,J                                                        00073300\n      K=J-N+1                                                           00073400\n      A=K                                                               00073500\n    4 R(K)=2.D0*A*R(K+1)\/X-R(K+2)*Y                                     00073600\n      IF (LA.EQ.0) GO TO 25                                             00073700\n      LA=LA-1                                                           00073800\n      A=R(1)*R(100)                                                     00073900\n      B=.0D0                                                            00074000\n      DO 11 N=1,99                                                      00074100\n      K=100-N                                                           00074200\n      A=A+R(N+1)*R(K)                                                   00074300\n   11 B=B+R(N)*R(K)                                                     00074400\n      J=98                                                              00074500\n      R(100)=A                                                          00074600\n      R(99)=B                                                           00074700\n      X=Z                                                               00074800\n      GO TO 20                                                          00074900\n    5 K=1.5*X                                                           00075000\n      B=1.D0                                                            00075100\n      C=K                                                               00075200\n      DO 6 N=1,K                                                        00075300\n      B=A*B\/C                                                           00075400\n    6 C=C-1.D0                                                          00075500\n      P=2.D-9                                                           00075600\n      IF (LA.EQ.1) P=5.D-20                                             00075700\n      C=K+1                                                             00075800\n      DO 7 N=1,30                                                       00075900\n      J=K+N                                                             00076000\n      B=B*A\/C                                                           00076100\n      C=C+1.D0                                                          00076200\n      IF (B.LT.P) GO TO 2                                               00076300\n      IF (J.EQ.98) GO TO 2                                              00076400\n    7 CONTINUE                                                          00076500\n      GO TO 2                                                           00076600\n   25 RETURN                                                            00076700\n      ENTRY BEIN                                                        00076800\n      Y=-1.D0                                                           00076900\n      GO TO 102                                                         00077000\n      END                                                               00077100\nC  10 265      SUBROUTINE BESSEL                   2 19 68              00077200\n      SUBROUTINE BESSEL                                                 00077300\n      COMMON \/BLOCKD\/R(10100),IA(100),KI(100),ART(100),NR,NRO,NC,NARGS, 00077400\n     1VWX(8),NER                                                        00077500\n      DIMENSION ARGS(100)                                               00077600\n      EQUIVALENCE( ARGS(1), R(10001) )                                  00077700\n      DOUBLE PRECISION X,Y,A(200),B(200),W(200),Z,E,P,Q,S,T             00077800\n      COMMON \/ RJN \/ Z,W                                                00077900\n      COMMON \/ BEZON \/ A,B,K,L                                          00078000\n      COMMON \/ ABEKI \/ X,Y,P,Q,S,T                                      00078100\n      COMMON \/BLOCKE\/NAME(4),L1,L2,ISR                                  00078200\nC                                                                       00078300\nC        WJG PATCH   )())()()())()()()()()()()()()()()()()              00078400\nC                                                                       00078500\n      IF( NARGS .GE. 3 ) IF( KI  ( 1 ) ) 8805, 8808, 8805               00078600\n      CALL ERROR( 10 )                                                  00078700\n8802  RETURN                                                            00078800\n8805  CALL ERROR( 3 )                                                   00078900\n      GO TO 8802                                                        00079000\n8808  L2 = IA   ( 1 )                                                   00079100\n      IF( L2 .LT. 1 .OR. L2 .GT. 37 ) GO TO 8805                        00079200\n      DO 8812 I = 2, NARGS                                              00079300\n      KI  ( I-1 ) = KI  ( I )                                           00079400\n      IA   ( I-1 ) = IA   ( I )                                         00079500\n8812  ARGS( I-1 ) = ARGS( I )                                           00079600\n      NARGS = NARGS - 1                                                 00079700\nC                                                                       00079800\nC         END PATCH    )()()()()()()()()())()()()()()                   00079900\nC                                                                       00080000\n      IF (L2.GT.28) GO TO 20                                            00080100\n      N=0                                                               00080200\n      L=L2\/2                                                            00080300\n      L=2*L                                                             00080400\n      IF (L.EQ.L2) N=1                                                  00080500\n      IF (L2.GT.12) GO TO 10                                            00080600\n      IF (NARGS.GT.2) CALL ERROR(10)                                    00080700\n      CALL ADRESS(NARGS,J)                                              00080800\n      IF (J.LE.0) CALL ERROR(11)                                        00080900\n      LT=1                                                              00081000\n      IF (KI(1).EQ.1) GO TO 1                                           00081100\n      CALL ADRESS (1,JA)                                                00081200\n      LT=2                                                              00081300\n    1 M=1                                                               00081400\n      IF (L2.GT.2) M=5                                                  00081500\n      IF (L2.GT.4) M=3                                                  00081600\n      IF (L2.GT.6) M=7                                                  00081700\n      IF (L2.GT.8) M=3                                                  00081800\n      IF (L2.GT.10) M=7                                                 00081900\n      L=0                                                               00082000\n      IF (L2.GT.4) L=1                                                  00082100\n      IF (L2.GT.8) L=2                                                  00082200\n      K=0                                                               00082300\n      IF (LT.EQ.1) GO TO 6                                              00082400\n      DO 4 I=1,NR                                                       00082500\n      X=R(JA)                                                           00082600\n      JA=JA+1                                                           00082700\n      Y=1.D0                                                            00082800\n      IF (L.EQ.0) GO TO 3                                               00082900\n      IF (L.EQ.2) GO TO 2                                               00083000\n      IF (DABS(X).LT.85.) GO TO 3                                       00083100\n      K=K+1                                                             00083200\n    2 IF (DABS(X).GT.700.) GO TO 3                                      00083300\n      Y=DEXP(X)                                                         00083400\n      IF (M.EQ.3) Y=1.D0\/Y                                              00083500\n    3 R(J)=Y*DBEJ(X,N,M)                                                00083600\n    4 J=J+1                                                             00083700\n    5 IF (K.NE.0) CALL ERROR(105)                                       00083800\n      RETURN                                                            00083900\n    6 X=ARGS(1)                                                         00084000\n      Y=1.D0                                                            00084100\n      IF (L.EQ.0) GO TO 8                                               00084200\n      IF (L.EQ.2) GO TO 7                                               00084300\n      IF (DABS(X).LT.85.) GO TO 8                                       00084400\n      K=1                                                               00084500\n    7 IF (DABS(X).GT.700.) GO TO 8                                      00084600\n      Y=DEXP(X)                                                         00084700\n      IF (M.EQ.3) Y=1.D0\/Y                                              00084800\n    8 X=Y*DBEJ(X,N,M)                                                   00084900\n      DO 9 I=1,NR                                                       00085000\n      R(J)=X                                                            00085100\n    9 J=J+1                                                             00085200\n      GO TO 5                                                           00085300\n   10 IF (L2.GT.20) GO TO 30                                            00085400\n      IF (NARGS.GT.3) CALL ERROR(10)                                    00085500\n      M=1                                                               00085600\n      IF (L2.GT.14) M=2                                                 00085700\n      IF (L2.GT.16) M=1                                                 00085800\n      IF (L2.GT.18) M=2                                                 00085900\n      L=0                                                               00086000\n      IF (L2.GT.16) L=1                                                 00086100\n      Y=.785398163397D0                                                 00086200\n      LV=0                                                              00086300\n      JX=0                                                              00086400\n   11 CALL ADRESS(NARGS,J2)                                             00086500\n      IF (J2.LE.0) CALL ERROR(11)                                       00086600\n      CALL ADRESS (NARGS-1,J1)                                          00086700\n      IF (J1.LE.0) CALL ERROR(11)                                       00086800\n      LT=0                                                              00086900\n      IF (KI(1).EQ.1) GO TO 12                                          00087000\n      CALL ADRESS (1,JA)                                                00087100\n      LT=1                                                              00087200\n   12 K=0                                                               00087300\n      KA=0                                                              00087400\n      IF (LT+LV.EQ.0) GO TO 19                                          00087500\n      IF (LV.EQ.0) GO TO 32                                             00087600\n      IF (LT.EQ.0) GO TO 33                                             00087700\n  111 DO 17 I=1,NR                                                      00087800\n      IF (KA.EQ.0) X=R(JA)                                              00087900\n      JA=JA+1                                                           00088000\n      E=1.D0                                                            00088100\n      IF (JX.NE.0) Y=R(JB)                                              00088200\n      JB=JB+1                                                           00088300\n      IF(M.EQ.2) CALL CBEK                                              00088400\n      IF(M.EQ.1) CALL CBEI                                              00088500\n      Z=X*DCOS(Y)                                                       00088600\n      IF (L.EQ.1) GO TO 13                                              00088700\n      IF (DABS(Z).LT.85.) GO TO 14                                      00088800\n      K=K+1                                                             00088900\n   13 E=DEXP(Z)                                                         00089000\n      IF (M.EQ.1) E=1.D0\/E                                              00089100\n   14 IF (N.EQ.0) GO TO 15                                              00089200\n      R(J1)=E*S                                                         00089300\n      R(J2)=E*T                                                         00089400\n      GO TO 16                                                          00089500\n   15 R(J1)=E*P                                                         00089600\n      R(J2)=E*Q                                                         00089700\n   16 J1=J1+1                                                           00089800\n   17 J2=J2+1                                                           00089900\n   18 IF (K.NE.0) CALL ERROR(105)                                       00090000\n      RETURN                                                            00090100\n   19 IF (JX.EQ.0) GO TO 33                                             00090200\n      Y=ARGS(2)                                                         00090300\n      X=ARGS(1)                                                         00090400\n      KA=1                                                              00090500\n      JX=0                                                              00090600\n      GO TO 111                                                         00090700\n   30 IF (NARGS.GT.4) CALL ERROR(10)                                    00090800\n      JX=1                                                              00090900\n      LV=0                                                              00091000\n      IF (KI(2).EQ.1) GO TO 31                                          00091100\n      CALL ADRESS (2,JB)                                                00091200\n      IF (JB.LE.0) CALL ERROR(11)                                       00091300\n      LV=1                                                              00091400\n   31 M=1                                                               00091500\n      IF (L2.GT.22) M=2                                                 00091600\n      IF (L2.GT.24) M=1                                                 00091700\n      IF (L2.GT.26) M=2                                                 00091800\n      L=0                                                               00091900\n      IF (L2.GT.24) L=1                                                 00092000\n      GO TO 11                                                          00092100\n   32 IF (JX.EQ.0) GO TO 111                                            00092200\n      Y=ARGS(2)                                                         00092300\n      JX=0                                                              00092400\n      GO TO 111                                                         00092500\n   33 KA=1                                                              00092600\n      X=ARGS(1)                                                         00092700\n      GO TO 111                                                         00092800\n   20 IF (L2.GT.32) GO TO 27                                            00092900\n  200 IF (NARGS.GT.2) CALL ERROR (10)                                   00093000\n      CALL ADRESS(NARGS,J)                                              00093100\n      IF (J.LE.0) CALL ERROR(11)                                        00093200\n      LT=0                                                              00093300\n      IF (KI(1).EQ.1) GO TO 21                                          00093400\n      CALL ADRESS (1,JA)                                                00093500\n      IF (JA.LE.0) CALL ERROR(11)                                       00093600\n      LT=1                                                              00093700\n   21 IF (LT.EQ.0) X=ARGS(1)                                            00093800\n      IF (L2.GT.37) GO TO 25                                            00093900\n      IF (L2.EQ.32) GO TO 25                                            00094000\n      IF (L2.GT.29) GO TO 23                                            00094100\n      DO 22 N=1,NR                                                      00094200\n      IF (LT.EQ.1) X=R(JA)                                              00094300\n      JA=JA+1                                                           00094400\n      R(J)=BINTJ0(X)                                                    00094500\n   22 J=J+1                                                             00094600\n      RETURN                                                            00094700\n   23 K=1                                                               00094800\n      IF (L2.EQ.31) K=2                                                 00094900\n      DO 24 N=1,NR                                                      00095000\n      IF (LT.EQ.1) X=R(JA)                                              00095100\n      JA=JA+1                                                           00095200\n      R(J)=COMELL(X,K)                                                  00095300\n   24 J=J+1                                                             00095400\n      RETURN                                                            00095500\n   25 IF (LT.EQ.1) CALL ERROR (20)                                      00095600\n      Z=X                                                               00095700\n      IF (L2.EQ.32) CALL BEJN                                           00095800\n      IF (L2.EQ.38) CALL BEIN                                           00095900\n      IF (L2.EQ.39) GO TO 49                                            00096000\n      K=NR                                                              00096100\n      IF (K.GT.100) K=100                                               00096200\n      DO 26 N=1,K                                                       00096300\n      R(J)=W(N)                                                         00096400\n   26 J=J+1                                                             00096500\n      RETURN                                                            00096600\n   27 IF (L2.GT.34) GO TO 42                                            00096700\n      L=NR                                                              00096800\n      IF (NR.GT.200) L=200                                              00096900\n      IF (NARGS.GT.2) CALL ERROR(10)                                    00097000\n      CALL ADRESS (NARGS,J)                                             00097100\n      IF (J.LE.0) CALL ERROR(11)                                        00097200\n      IF (KI(1).EQ.1) CALL ERROR(20)                                    00097300\n      CALL ADRESS (1,JA)                                                00097400\n      IF (JA.LE.0) CALL ERROR(11)                                       00097500\n      IF (L2.EQ.33) GO TO 29                                            00097600\n      CALL BEZONE                                                       00097700\n      GO TO 28                                                          00097800\n   29 CALL BEZERO                                                       00097900\n   28 DO 40 N=1,L                                                       00098000\n      R(JA)=A(N)                                                        00098100\n      R(J)=B(N)                                                         00098200\n      JA=JA+1                                                           00098300\n   40 J=J+1                                                             00098400\n      RETURN                                                            00098500\n   42 IF (L2.GT.36) GO TO 46                                            00098600\n      IF (NARGS.GT.2) CALL ERROR(10)                                    00098700\n      CALL ADRESS(NARGS,J)                                              00098800\n      IF (J.LE.0) CALL ERROR(11)                                        00098900\n      LT=0                                                              00099000\n      IF (KI(1).EQ.1) GO TO 43                                          00099100\n      CALL ADRESS (1,JA)                                                00099200\n      IF (JA.LE.0) CALL ERROR(11)                                       00099300\n      LT=1                                                              00099400\n   43 IF (LT.EQ.0) X=ARGS(1)                                            00099500\n      K=0                                                               00099600\n      IF (L2.EQ.36) K=1                                                 00099700\n      DO 45 N=1,NR                                                      00099800\n      IF (LT.NE.0) X=R(JA)                                              00099900\n      JA=JA+1                                                           00100000\n      CALL STRUVE (X,Y,Z)                                               00100100\n      IF (K.EQ.0) GO TO 44                                              00100200\n      R(J)=Z                                                            00100300\n      GO TO 45                                                          00100400\n   44 R(J)=Y                                                            00100500\n   45 J=J+1                                                             00100600\n      RETURN                                                            00100700\n   46 IF (L2.GT.37) GO TO 200                                           00100800\n      IF (NARGS.GT.3) CALL ERROR(10)                                    00100900\n      CALL ADRESS (NARGS,J)                                             00101000\n      IF (J.LE.0) CALL ERROR(11)                                        00101100\n      IF (KI(1).EQ.1) CALL ERROR (20)                                   00101200\n      CALL ADRESS (1,JA)                                                00101300\n      IF (JA.LE.0) CALL ERROR(11)                                       00101400\n      JB=IA(2)                                                          00101500\n      K=IA(2)                                                           00101600\n      DO 47 N=1,NR                                                      00101700\n      A(N)=R(JA)                                                        00101800\n   47 JA=JA+1                                                           00101900\n      CALL FOURIA                                                       00102000\n      DO 48 N=1,JB                                                      00102100\n      R(J)=B(N)                                                         00102200\n   48 J=J+1                                                             00102300\n      RETURN                                                            00102400\n   49 A(1)=DBEJ(X,0,7)                                                  00102500\n      A(2)=DBEJ(X,1,7)                                                  00102600\n      R(J)=A(1)                                                         00102700\n      R(J+1)=A(2)                                                       00102800\n      J=J+2                                                             00102900\n      DO 50 I=3,NR                                                      00103000\n      Z=I-2                                                             00103100\n      A(I)=A(I-2)+2.*Z*A(I-1)\/X                                         00103200\n      R(J)=A(I)                                                         00103300\n   50 J=J+1                                                             00103400\n      RETURN                                                            00103500\n      END                                                               00103600\nC  11  59      SUBROUTINE BEZERO                   2 19 68              00103700\n      SUBROUTINE BEZERO                                                 00103800\n      DOUBLE PRECISION A(200),B(200),X,Y,AA,AB,AC                       00103900\n      COMMON \/BEZON\/A,B,M,L                                             00104000\n      KB=1                                                              00104100\n      N=M                                                               00104200\n   25 J=4*N-1                                                           00104300\n      IF (J.GT.44) GO TO 20                                             00104400\n      GO TO (1,2,3,4,5,6,7,8,9,10,11),N                                 00104500\n    1 X=2.404825577D0                                                   00104600\n      Y=.5191474973D0                                                   00104700\n      GO TO 30                                                          00104800\n    2 X=5.5200781103D0                                                  00104900\n      Y=-.3402648065D0                                                  00105000\n      GO TO 30                                                          00105100\n    3 X=8.6537279129D0                                                  00105200\n      Y=.2714522999D0                                                   00105300\n      GO TO 30                                                          00105400\n    4 X=11.7915344391D0                                                 00105500\n      Y=-.2324598314D0                                                  00105600\n      GO TO 30                                                          00105700\n    5 X=14.9309177086D0                                                 00105800\n      Y=.2065464331D0                                                   00105900\n      GO TO 30                                                          00106000\n    6 X=18.0710639679D0                                                 00106100\n      Y=-.187728803D0                                                   00106200\n      GO TO 30                                                          00106300\n    7 X=21.2116366299D0                                                 00106400\n      Y=.1732658942D0                                                   00106500\n      GO TO 30                                                          00106600\n    8 X=24.3524715308D0                                                 00106700\n      Y=-.1617015507D0                                                  00106800\n      GO TO 30                                                          00106900\n    9 X=27.493479132D0                                                  00107000\n      Y=.1521812138D0                                                   00107100\n      GO TO 30                                                          00107200\n   10 X=30.6346064684D0                                                 00107300\n      Y=-.1441659777D0                                                  00107400\n      GO TO 30                                                          00107500\n   11 X=33.7758202136D0                                                 00107600\n      Y=.1372969434D0                                                   00107700\n      GO TO 30                                                          00107800\n   20 X=J                                                               00107900\n      X=X*3.1415926536D0                                                00108000\n      AA=1.D0\/X**2                                                      00108100\n      AB=1.D0+2.D0*AA*(1.D0-AA*(31.D0-AA*(3779.D0-AA*6277237.D0\/7)\/5.D0)00108200\n     1\/3.D0)                                                            00108300\n      J=N\/2                                                             00108400\n      J=2*J                                                             00108500\n      AC=1.D0                                                           00108600\n      IF (J.EQ.N) AC=-1.D0                                              00108700\n      Y=AC*1.595769122D0*(1.-AA**2*56.D0\/3.D0)\/DSQRT(X)                 00108800\n      X=X*AB\/4.D0                                                       00108900\n   30 A(KB)=X                                                           00109000\n      B(KB)=Y                                                           00109100\n      N=N+1                                                             00109200\n      KB=KB+1                                                           00109300\n      IF (KB.LE.L) GO TO 25                                             00109400\n      RETURN                                                            00109500\n      END                                                               00109600\nC  12  58      SUBROUTINE BEZONE                   2 19 68              00109700\n      SUBROUTINE BEZONE                                                 00109800\n      DOUBLE PRECISION A(200),B(200),R,S,T,X,Y                          00109900\n      COMMON \/BEZON\/A,B,M,L                                             00110000\n      KB=1                                                              00110100\n      N=M                                                               00110200\n   25 J=4*N+1                                                           00110300\n      IF (J.GT.46) GO TO 20                                             00110400\n      GO TO (1,2,3,4,5,6,7,8,9,10,11),N                                 00110500\n    1 X=3.8317059702D0                                                  00110600\n      Y=-.4027593957D0                                                  00110700\n      GO TO 30                                                          00110800\n    2 X=7.0155866698D0                                                  00110900\n      Y= .3001157525D0                                                  00111000\n      GO TO 30                                                          00111100\n    3 X=10.1734681351D0                                                 00111200\n      Y= -.2497048771D0                                                 00111300\n      GO TO 30                                                          00111400\n    4 X=13.3236919363D0                                                 00111500\n      Y=  .2183594072D0                                                 00111600\n      GO TO 30                                                          00111700\n    5 X=16.4706300509D0                                                 00111800\n      Y= -.1964653715D0                                                 00111900\n      GO TO 30                                                          00112000\n    6 X=19.6158585105D0                                                 00112100\n      Y=  .180063375D0                                                  00112200\n      GO TO 30                                                          00112300\n    7 X=22.7600843806D0                                                 00112400\n      Y= -.1671846005D0                                                 00112500\n      GO TO 30                                                          00112600\n    8 X=25.9036720876D0                                                 00112700\n      Y=  .1567249863D0                                                 00112800\n      GO TO 30                                                          00112900\n    9 X=29.0468285349D0                                                 00113000\n      Y= -.1480111100D0                                                 00113100\n      GO TO 30                                                          00113200\n   10 X=32.1896799110D0                                                 00113300\n      Y=  .1406057982D0                                                 00113400\n      GO TO 30                                                          00113500\n   11 X=35.3323075501D0                                                 00113600\n      Y= -.1342112403D0                                                 00113700\n      GO TO 30                                                          00113800\n   20 X=J                                                               00113900\n      X=X*3.1415926536D0                                                00114000\n      R=1.D0\/X**2                                                       00114100\n      S=1.D0-6.D0*R*(1.D0-R*(1.D0-R*(157.2D0-130080.6D0*R\/7.D0)))       00114200\n      J=N\/2                                                             00114300\n      J=2*J                                                             00114400\n      T=1.D0                                                            00114500\n      IF (J.NE.N) T=-1.D0                                               00114600\n      Y=T*1.595769122D0*(1.D0+R**2*24.D0*(1.D0-81.6*R))\/DSQRT(X)        00114700\n      X=S*X\/4.D0                                                        00114800\n   30 A(KB)=X                                                           00114900\n      B(KB)=Y                                                           00115000\n      N=N+1                                                             00115100\n      KB=KB+1                                                           00115200\n      IF (KB.LE.L) GO TO 25                                             00115300\n      RETURN                                                            00115400\n      END                                                               00115500\nC  13  21      FUNCTION BINTJ0(X)                  2 19 68              00115600\n      DOUBLE PRECISION FUNCTION BINTJ0(X)                               00115700\n      COMMON \/RJN\/A(100),Z                                              00115800\n      DOUBLE PRECISION A,Z,X,B,C                                        00115900\n      Z=DABS(X)                                                         00116000\n      IF (Z.GT.100.) GO TO 20                                           00116100\n      CALL BEJN                                                         00116200\n      IF (Z.GT.60.) GO TO 2                                             00116300\n      B=.0D0                                                            00116400\n      DO 1 N=2,100,2                                                    00116500\n    1 B=B+A(N)                                                          00116600\n      B=2.D0*B                                                          00116700\n      GO TO 3                                                           00116800\n   20 A(1)=DBEJ(Z,0,7)                                                  00116900\n      A(2)=DBEJ(Z,1,7)                                                  00117000\n    2 C=1.D0\/Z**2                                                       00117100\n      B=1.D0+A(2)*(1.D0-C*(1.D0-C*(9.D0-C*(225.D0-C*11025.D0))))        00117200\n      C=1.D0-C*(3.D0-C*(45.D0-C*(1575.D0-99225.D0*C)))                  00117300\n      B=B-A(1)*C\/Z                                                      00117400\n    3 BINTJ0=B                                                          00117500\n      RETURN                                                            00117600\n      END                                                               00117700\nC  14  45      BLOCK DATA                          2 19 68              00117800\n      BLOCK DATA                                                        00117900\n      COMMON\/CONSTS\/PI,E,HALFPI,DEG,RAD,XEXP,XTRIG,XALOG,CC( 192 )      00118000\n      COMMON \/ HEADER\/NMCARD(72),ITLE(64,6),IHEAD(4,50),IFMT(17,6),     00118100\n     1 IFMTX(4),LNCNT,IPRINT,NPAGE,IPUNCH                               00118200\n      COMMON \/ ABCDEF \/ L( 48 )                                         00118300\n      COMMON \/ PCONST \/ P( 40 ), N( 40 )                                00118400\nC                                                                       00118500\nC     THIS BLOCK DEFINES CONSTANTS TO BE USED THROUGHOUT OMNITAB        00118600\nC     WHOSE VALUE (ACCURACY) WILL HAVE TO BE CHANGED IN GOING FROM      00118700\nC     ONE SIZE FLOATING POINT NUMBER TO ANOTHER                         00118800\nC                                                                       00118900\n      DATA PI,E,HALFPI,DEG,RAD,XEXP,XTRIG,XALOG\/3.14159265359,          00119000\n     12.71828182846,1.57079632679,57.295779513,1.74532925199E-2,158.,   00119100\n     2.8E6,549755813887.\/                                               00119200\n      DATA NMCARD \/ 15*1H ,1HY,1HO,1HU,1H ,1HD,1HU,2*1HM,1HY,1H,,1H ,   00119300\n     1 1HY,1HO,1HU,1H ,1HL,1HE,1HF,1HT,1H ,1HO,2*1HF,1H ,1HT,1HH,1HE,   00119400\n     2 1H ,1H-,1HO,1HM,1HN,1HI,1HT,1HA,1HB,1H-,1H ,1HC,1HA,1HR,1HD,     00119500\n     3 15*1H  \/                                                         00119600\n      DATA  L(1),L(2),L(3),L(4),L(5),L(6),L(7),L(8),L(9),L(10)\/         00119700\n     1 1H0,1H1,1H2,1H3,1H4,1H5,1H6,1H7,1H8,1H9\/                         00119800\n      DATA  L(11),L(12),L(13),L(14),L(15),L(16),L(17),L(18),L(19),L(20)\/00119900\n     1 1HA,1HB,1HC,1HD,1HE,1HF,1HG,1HH,1HI,1HJ\/                         00120000\n      DATA  L(21),L(22),L(23),L(24),L(25),L(26),L(27),L(28),L(29),L(30)\/00120100\n     1 1HK,1HL,1HM,1HN,1HO,1HP,1HQ,1HR,1HS,1HT\/                         00120200\n      DATA  L(31),L(32),L(33),L(34),L(35),L(36),L(37),L(38),L(39),L(40)\/00120300\n     1 1HU,1HV,1HW,1HX,1HY,1HZ,1H\/,1H.,1H-,1H+\/                         00120400\n      DATA  L(41),L(42),L(43),L(44),L(45),L(46),L(47),L(48)\/            00120500\n     1 1H*,1H(,1H),1H,,1H ,1H=,1H\",1H$\/                                 00120600\n      DATA P(1),P(2),P(3),P(4),P(5),P(6),P(7),P(8),P(9),P(10)\/          00120700\n     12*3.14159265359,2*2.71828182846,2.997925E8,2.997925E10,           00120800\n     2 1.60210E-19,1.60210E-20,2*6.02252E23\/                            00120900\n      DATA P(11),P(12),P(13),P(14),P(15),P(16),P(17),P(18),P(19),P(20)\/ 00121000\n     1 9.1091E-31,9.1091E-28,1.67252E-27,1.67252E-24,9.64870E4,9648.70, 00121100\n     2 66.256E-34,6.6256E-27,2*7.29720E-3\/                              00121200\n      DATA P(21),P(22),P(23),P(24),P(25),P(26),P(27),P(28),P(29),P(30)\/ 00121300\n     1 1.758796E11,17587960.,10973731.,109737.31,2.67519E8,26751.9,     00121400\n     2 9.2732E-24,9.2732E-21,8.3143,8.3143E7\/                           00121500\n      DATA P(31),P(32),P(33),P(34),P(35),P(36),P(37),P(38),P(39),P(40)\/ 00121600\n     1 1.38054E-23,1.38054E-16,3.7405E-16,3.7405E-5,1.43879E-2,1.43879, 00121700\n     2 5.6697E-8,5.6697E-5,6.670E-11,6.670E-8\/                          00121800\nC                                                                       00121900\n      DATA N(1),N(2),N(3),N(4),N(5),N(6),N(7),N(8),N(9),N(10)\/          00122000\n     1 11907,3645,2187,12393,10206,9612,9909,4374,5832,1069\/            00122100\n      DATA N(11),N(12),N(13),N(14),N(15),N(16),N(17),N(18),N(19),N(20)\/ 00122200\n     1 12749,13379,5143,10046,13122,8019,2606,2750,14101,5103\/          00122300\n      END                                                               00122400\nC  15  79      SUBROUTINE CBEI                     2 19 68              00122500\n      SUBROUTINE CBEI                                                   00122600\nC         COMPUTES I0(Z) AND I1(Z) FOR COMPLEX ARGUMENT  R*E(IS)=Z      00122700\n      COMMON \/ABEKI\/R,S,A,B,C,D                                         00122800\n      DOUBLE PRECISION A,B,C,D,E,F,G,H,P,Q,R,S,T,X,Y,Z,V,U,W,AA         00122900\n      E=DCOS(S)                                                         00123000\n      F=DSIN(S)                                                         00123100\n      IF (R.GT.15.5) GO TO 3                                            00123200\n      P=1.D0-2.D0*F**2                                                  00123300\n      AA=P                                                              00123400\n      Q=2.D0*E*F                                                        00123500\n      W=Q                                                               00123600\n      A=1.D0                                                            00123700\n      B=0.D0                                                            00123800\n      C=1.D0                                                            00123900\n      U=0.D0                                                            00124000\n      G=1.D0                                                            00124100\n      T=2.D0                                                            00124200\n      X=(R\/2.D0)**2                                                     00124300\n      V=X                                                               00124400\n      Y=X                                                               00124500\n      DO 1 N=1,60                                                       00124600\n      Z=1.D0\/G**2                                                       00124700\n      H=1.D0\/(G*T)                                                      00124800\n      A=A+X*Z*P                                                         00124900\n      B=B+X*Z*Q                                                         00125000\n      C=C+V*H*P                                                         00125100\n      U=U+V*H*Q                                                         00125200\n      X=X*Y*Z                                                           00125300\n      IF (X.LT..5D-10) GO TO 2                                          00125400\n      V=V*Y*H                                                           00125500\n      Z=P                                                               00125600\n      P=Z*AA-Q*W                                                        00125700\n      Q=Q*AA+Z*W                                                        00125800\n      G=G+1.D0                                                          00125900\n    1 T=T+1.D0                                                          00126000\n    2 D=R*(C*F+U*E)\/2.D0                                                00126100\n      C=R*(C*E-U*F)\/2.D0                                                00126200\n      GO TO 6                                                           00126300\n    3 Z=DEXP(R*E)\/DSQRT(6.283185307D0*R)                                00126400\n      X=S\/2.D0-R*F                                                      00126500\n      Y=Z*DCOS(X)                                                       00126600\n      Z=Z*DSIN(X)                                                       00126700\n      W=-1.D0                                                           00126800\n      G=1.D0                                                            00126900\n      H=3.D0                                                            00127000\n      P=E                                                               00127100\n      Q=F                                                               00127200\n      T=1.D0                                                            00127300\n      U=0.D0                                                            00127400\n      V=1.D0                                                            00127500\n      X=0.D0                                                            00127600\n      A=1.D0                                                            00127700\n      B=1.D0\/(8.D0*R)                                                   00127800\n      C=B                                                               00127900\n      D=B                                                               00128000\n      DO 4 N=1,20                                                       00128100\n      AA=B*G**2\/A                                                       00128200\n      T=T+AA*P                                                          00128300\n      U=U+AA*Q                                                          00128400\n      AA=C*W*H\/A                                                        00128500\n      V=V+AA*P                                                          00128600\n      X=X+AA*Q                                                          00128700\n      B=B*D*G**2\/A                                                      00128800\n      IF (B.LT..5D-10) GO TO 5                                          00128900\n      C=C*D*W*H\/A                                                       00129000\n      W=W+2.D0                                                          00129100\n      G=G+2.D0                                                          00129200\n      H=H+2.D0                                                          00129300\n      A=A+1.D0                                                          00129400\n      AA=P*E-Q*F                                                        00129500\n      Q=F*P+E*Q                                                         00129600\n    4 P=AA                                                              00129700\n    5 A=Y*T-Z*U                                                         00129800\n      B=-(Y*U+T*Z)                                                      00129900\n      C=Y*V-Z*X                                                         00130000\n      D=-(Y*X+Z*V)                                                      00130100\n    6 RETURN                                                            00130200\n      END                                                               00130300\nC  16 102      SUBROUTINE CBEK                     2 19 68              00130400\n      SUBROUTINE CBEK                                                   00130500\nC       COMPUTES K0(Z) AND K1(Z) FOR COMPLEX ARGUMENT Z=R*E(IS)         00130600\n      COMMON \/ABEKI\/R,S,A,B,C,D                                         00130700\n      DOUBLE PRECISION A,B,C,D,E,F,G,H,P,Q,R,S,T,U,V,W,X,Y,Z,           00130800\n     1AA(40),AB(40),AC,AD,AE                                            00130900\n      E=DCOS(S)                                                         00131000\n      F=DSIN(S)                                                         00131100\n      IF (R.GT.8.) GO TO 5                                              00131200\n      P=1.D0-2.D0*F**2                                                  00131300\n      Q=2.D0*E*F                                                        00131400\n      W=P                                                               00131500\n      Z=Q                                                               00131600\n      X=(R\/2.D0)**2                                                     00131700\n      Y=X                                                               00131800\n      V=X                                                               00131900\n      G=E*(4.D0*E**2-3.D0)                                              00132000\n      H=F*(3.D0-4.D0*F**2)                                              00132100\n      T=DLOG(R\/2.D0)+.5772156649D0                                      00132200\n      A=-T                                                              00132300\n      B=-S                                                              00132400\n      C=E*(T-0.5D0)-S*F                                                 00132500\n      U=F*(T-0.5D0)+S*E                                                 00132600\n      AC=1.D0                                                           00132700\n      AD=2.D0                                                           00132800\n      L=L-10                                                            00132900\n      IF (L.GT.1) GO TO 2                                               00133000\n      AA(1)=1.D0                                                        00133100\n      AB(1)=1.25D0                                                      00133200\n      DO 1 N=2,40                                                       00133300\n      AE=N                                                              00133400\n      AA(N)=AA(N-1)+1.D0\/AE                                             00133500\n    1 AB(N)=AA(N)+1.D0\/(2.D0*(AE+1.D0))                                 00133600\n    2 L=20                                                              00133700\n      DO 3 N=1,40                                                       00133800\n      AE=T-AA(N)                                                        00133900\n      D=P*AE-S*Q                                                        00134000\n      AE=Q*AE+S*P                                                       00134100\n      A=A-D*X\/AC**2                                                     00134200\n      B=B-AE*X\/AC**2                                                    00134300\n      AE=T-AB(N)                                                        00134400\n      D=G*AE-H*S                                                        00134500\n      AE=H*AE+G*S                                                       00134600\n      C=C+D*Y\/(AC*AD)                                                   00134700\n      U=U+AE*Y\/(AC*AD)                                                  00134800\n      X=X*V\/AC**2                                                       00134900\n      IF (X.LT..5D-10) GO TO 4                                          00135000\n      Y=Y*V\/(AC*AD)                                                     00135100\n      AC=AC+1.D0                                                        00135200\n      AD=AD+1.D0                                                        00135300\n      AE=P                                                              00135400\n      P=AE*W-Q*Z                                                        00135500\n      Q=Q*W+AE*Z                                                        00135600\n      AE=G                                                              00135700\n      G=AE*W-H*Z                                                        00135800\n    3 H=H*W+AE*Z                                                        00135900\n    4 C=E\/R+R*C\/2.D0                                                    00136000\n      D=-F\/R+R*U\/2.D0                                                   00136100\n      GO TO 8                                                           00136200\n    5 U=DEXP(-R*E)*DSQRT(1.5707963268D0\/R)                              00136300\n      V=R*F+S\/2.D0                                                      00136400\n      Y=U*DCOS(V)                                                       00136500\n      Z=U*DSIN(V)                                                       00136600\n      W=-1.D0                                                           00136700\n      G=1.D0                                                            00136800\n      H=3.D0                                                            00136900\n      P=E                                                               00137000\n      Q=F                                                               00137100\n      T=1.D0                                                            00137200\n      U=0.D0                                                            00137300\n      V=1.D0                                                            00137400\n      X=0.D0                                                            00137500\n      A=1.D0                                                            00137600\n      B=1.D0\/(8.D0*R)                                                   00137700\n      C=B                                                               00137800\n      D=B                                                               00137900\n      AC=-1.D0                                                          00138000\n      DO 6 N=1,12                                                       00138100\n      AD=AC*B*G**2\/A                                                    00138200\n      AE=AC*C*W*H\/A                                                     00138300\n      T=T+AD*P                                                          00138400\n      U=U-AD*Q                                                          00138500\n      V=V+AE*P                                                          00138600\n      X=X-AE*Q                                                          00138700\n      AD=B                                                              00138800\n      B=B*D*G**2\/A                                                      00138900\n      IF (B.GT.AD) GO TO 7                                              00139000\n      IF (B.LT..5D-10) GO TO 7                                          00139100\n      C=C*D*W*H\/A                                                       00139200\n      W=W+2.D0                                                          00139300\n      H=H+2.D0                                                          00139400\n      G=G+2.D0                                                          00139500\n      A=A+1.D0                                                          00139600\n      AC=-1.D0*AC                                                       00139700\n      AD=P                                                              00139800\n      P=AD*E-Q*F                                                        00139900\n    6 Q=Q*E+AD*F                                                        00140000\n    7 A=Y*T+U*Z                                                         00140100\n      B=Y*U-T*Z                                                         00140200\n      C=Y*V+X*Z                                                         00140300\n      D=Y*X-V*Z                                                         00140400\n    8 RETURN                                                            00140500\n      END                                                               00140600\nC  17  24      SUBROUTINE CHANGE                   2 19 68              00140700\n      SUBROUTINE CHANGE                                                 00140800\nC                                                                       00140900\nC CHANGE SIGNS OF COLS ++, ++, ++, ETC.                                 00141000\nC                                                                       00141100\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00141200\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00141300\n      DIMENSION ARGS(100)                                               00141400\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00141500\n      IF (NARGS) 910,910,5                                              00141600\n    5 DO 20 I=1,NARGS                                                   00141700\n      CALL ADRESS( I, J )                                               00141800\n      IF(J) 903,911,10                                                  00141900\n   10 IF (NERROR .NE. 0) RETURN                                         00142000\n      DO 20 N=1,NRMAX                                                   00142100\n      JJ=J+N-1                                                          00142200\n   20 RC(JJ)=-RC(JJ)                                                    00142300\n      GO TO 999                                                         00142400\n  903 CALL ERROR (3)                                                    00142500\n      GO TO 999                                                         00142600\n  910 CALL ERROR (10)                                                   00142700\n      GO TO 999                                                         00142800\n  911 CALL ERROR (11)                                                   00142900\n  999 RETURN                                                            00143000\n      END                                                               00143100\nC  18  19      SUBROUTINE CHKCOL( J )              2 19 68              00143200\n      SUBROUTINE CHKCOL( J )                                            00143300\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00143400\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00143500\n      DIMENSION ARGS(100)                                               00143600\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00143700\nC                                                                       00143800\nC         THIS ROUTINE CHECKS THAT ALL \"NARGS\" ARGUMENTS ARE LEGAL      00143900\nC         COLUMN NUMBERS AND CONVERTS THEM IN IARGS TO THEIR BEGINNING  00144000\nC         ADDRESSES.                                                    00144100\n      IF( NARGS .GT. 0 ) GO TO 20                                       00144200\n  10  J = 1                                                             00144300\n      GO TO 40                                                          00144400\n  20  DO 30 I = 1, NARGS                                                00144500\n      CALL ADRESS( I, IARGS( I ) )                                      00144600\n      IF( IARGS( I ) .LE. 0 ) GO TO 10                                  00144700\n  30  CONTINUE                                                          00144800\n      J = 0                                                             00144900\n  40  RETURN                                                            00145000\n      END                                                               00145100\nC  19  26      SUBROUTINE CKIND(J)                 2 19 68              00145200\n      SUBROUTINE CKIND(J)                                               00145300\nC**** CKIND                                                             00145400\nC**** S PEAVY    5\/22\/67                                                00145500\nC**** THE FIRST J VALUES OF KIND ARE CHECKED                            00145600\nC**** IF ALL ARE =0 THEN J=0                                            00145700\nC**** IF ALL ARE =1 THEN J=1                                            00145800\nC**** IF SOME ARE 0 AND SOME 1   J=2                                    00145900\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00146000\n     ONROW,                                                             00146100\n     1NCOL,NARGS,VWXYZ(8),NERROR                                        00146200\n      DIMENSION ARGS(100)                                               00146300\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00146400\n      JA=J                                                              00146500\n      J=0                                                               00146600\n      DO  10 I=1,JA                                                     00146700\n      IF(KIND(I).NE.0) GO TO 15                                         00146800\n   10 CONTINUE                                                          00146900\n      RETURN                                                            00147000\n   15 J=1                                                               00147100\n      DO  20 I=1,JA                                                     00147200\n      IF(KIND(I).NE.1) GO TO 30                                         00147300\n   20 CONTINUE                                                          00147400\n      RETURN                                                            00147500\n   30 J=2                                                               00147600\n      RETURN                                                            00147700\n      END                                                               00147800\nC  20  46      FUNCTION COMELL (Z,I)               2 19 68              00147900\n      DOUBLE PRECISION FUNCTION COMELL (Z,I)                            00148000\nC       COMPLETE ELLIPTIC INTEGRALS - FIRST AND SECOND KIND             00148100\n      DOUBLE PRECISION Z,X,A,B,C,D,E,P,Q                                00148200\n      X=Z                                                               00148300\n      IF (DABS(Z).LT.1.D0) GO TO 1                                      00148400\n      WRITE (6,2)                                                       00148500\n    2 FORMAT (50H MODULUS GREATER OR EQUAL TO 1.+VALUE SET TO .9999)    00148600\n      X=.9999                                                           00148700\n    1 A=X**2                                                            00148800\n      B=DSQRT(1.D0-A)                                                   00148900\n      IF (X.GT..996) GO TO 6                                            00149000\n      B=(1.D0-B)\/(1.D0+B)                                               00149100\n      A=B**2                                                            00149200\n      B=1.D0+B                                                          00149300\n      C=1.D0                                                            00149400\n      D=C                                                               00149500\n      E=2.D0                                                            00149600\n      IF (I.EQ.1) GO TO 3                                               00149700\n      B=1.D0\/B                                                          00149800\n      D=-1.D0                                                           00149900\n    3 P=A                                                               00150000\n      DO 4 N=1,90                                                       00150100\n      C=C+P*(D\/E)**2                                                    00150200\n      P=P*A*(D\/E)**2                                                    00150300\n      IF (P.LT..1D-9) GO TO 5                                           00150400\n      D=D+2.D0                                                          00150500\n    4 E=E+2.D0                                                          00150600\n    5 A=B*C*1.570796326D0                                               00150700\n      GO TO 8                                                           00150800\n    6 A=DLOG(4.D0\/B)                                                    00150900\n      Q=B**2                                                            00151000\n      IF (I.GT.1) GO TO 7                                               00151100\n      B=.25D0*(A-1.D0)                                                  00151200\n      C=.140625D0*(A-1.666666666D0)                                     00151300\n      D=9.765625D-2*(A-1.233333333D0)                                   00151400\n      E=1255.D0*(A-1.27904761904D0)\/16384.D0                            00151500\n      A=A+Q*(B+Q*(C+Q*(D+Q*E)))                                         00151600\n      GO TO 8                                                           00151700\n    7 B=.5D0*(A-.5D0)                                                   00151800\n      C=.1875D0*(A-1.083333333D0)                                       00151900\n      D=.1171875D0*(A-1.2D0)                                            00152000\n      E=175.D0*(A-1.251190476D0)\/2048.D0                                00152100\n      A=1.+Q*(B+Q*(C+Q*(D+Q*E)))                                        00152200\n    8 COMELL=A                                                          00152300\n      RETURN                                                            00152400\n      END                                                               00152500\nC  21 113      FUNCTION DBEJ(X,N,M)                2 19 68              00152600\n      DOUBLE PRECISION FUNCTION DBEJ(X,N,M)                             00152700\n      DOUBLE PRECISION E,H,X,A,B,C,D,Y,S(120),T(1200)                   00152800\n    1 IF (DABS(X).GT.16.5) GO TO 10                                     00152900\n      A=(X\/2.D0)**2                                                     00153000\n      J=X\/.4+6.8                                                        00153100\n      B=J                                                               00153200\n      C=J+N                                                             00153300\n      D=-1.D0                                                           00153400\n      IF (M.GT.1) D=1.D0                                                00153500\n      IF (M.GT.3) GO TO 3                                               00153600\n      Y=1.D0                                                            00153700\n      DO 2 I=1,J                                                        00153800\n      Y=1.D0+Y*A\/(B*C)*D                                                00153900\n      B=B-1.D0                                                          00154000\n    2 C=C-1.D0                                                          00154100\n      IF (N.GT.0) Y=X*Y\/2.D0                                            00154200\n      GO TO 55                                                          00154300\n    3 L=L-10                                                            00154400\n      IF (L.GT.0) GO TO 5                                               00154500\n      E=1.0D0                                                           00154600\n      S(1)=.5772156649015D0                                             00154700\n      S(61)=S(1)-.5D0                                                   00154800\n      DO 4 I=2,60                                                       00154900\n      S(I)=S(I-1)-1.D0\/E                                                00155000\n      S(I+60)=S(I)-1.D0\/(2.D0*(E+1.D0))                                 00155100\n    4 E=E+1.D0                                                          00155200\n    5 L=100                                                             00155300\n      E=DLOG(X\/2.D0)                                                    00155400\n      DO 6 I=1,120                                                      00155500\n    6 T(I)=S(I)+E                                                       00155600\n      IF (M.LT.6) GO TO 11                                              00155700\n      IF (X.GT.8.) GO TO 10                                             00155800\n   11 IA=0                                                              00155900\n      IF (N.GT.0) IA=60                                                 00156000\n      IF (M.GT.5) D=-1.D0                                               00156100\n      I=J+IA+1                                                          00156200\n      Y=T(I)                                                            00156300\n      DO 7IB=1,J                                                        00156400\n      I=J-IB+IA+1                                                       00156500\n      Y=T(I)-D*A*Y\/(B*C)                                                00156600\n      B=B-1.D0                                                          00156700\n    7 C=C-1.D0                                                          00156800\n      IF (N.GT.0) Y=X*Y\/2.D0                                            00156900\n      IF (M.GT.5) GO TO 8                                               00157000\n      Y=Y*.636619772368D0                                               00157100\n      IF (N.NE.0) Y=-.636619772368D0\/X+Y                                00157200\n      GO TO 55                                                          00157300\n    8 Y=-Y                                                              00157400\n      IF (N.NE.0) Y=1.D0\/X-Y                                            00157500\n      GO TO 55                                                          00157600\n   10 A=8.D0*X                                                          00157700\n      H=N                                                               00157800\n      H=(2.*H)**2                                                       00157900\n      T(1)=(H-1.D0)\/A                                                   00158000\n      D=T(1)                                                            00158100\n      DO 30 I=2,20                                                      00158200\n      K=I                                                               00158300\n      B=I                                                               00158400\n      C=(2*I-1)**2                                                      00158500\n      T(I)=(H-C)\/(A*B)                                                  00158600\n      E=D                                                               00158700\n      D=T(I)*D                                                          00158800\n      E=DABS(D\/E)                                                       00158900\n      IF (DABS(D).LT..5D-10) GO TO 32                                   00159000\n      IF (E.GT..91) GO TO 32                                            00159100\n   30 T(I+2)=0.0D0                                                      00159200\n   32 A=-1.D0                                                           00159300\n      IF (M.LE.1) GO TO 20                                              00159400\n      IF (M.LE.3) GO TO 12                                              00159500\n      IF (M.LE.5) GO TO 20                                              00159600\n      A=1.D0                                                            00159700\n   12 Y=1.D0                                                            00159800\n      DO 14 I=1,K                                                       00159900\n      J=K-I+1                                                           00160000\n   14 Y=1.D0+A*Y*T(J)                                                   00160100\n      A=1.D0                                                            00160200\n      IF (X.LT.700.D0) A=DEXP(X)                                        00160300\n      IF (M.LE.5) GO TO 16                                              00160400\n      Y=Y\/(A*DSQRT(.636619772368D0*X))                                  00160500\n      GO TO 55                                                          00160600\n   16 Y=Y*A\/DSQRT(6.283185307D0*X)                                      00160700\n      GO TO 55                                                          00160800\n   20 Y=DSQRT(3.1415926536D0*X)                                         00160900\n      J=K\/2                                                             00161000\n      K=2*J                                                             00161100\n      J=J-1                                                             00161200\n      A=1.D0                                                            00161300\n      H=A                                                               00161400\n      DO 21 I=1,J                                                       00161500\n      IA=K-2*I+1                                                        00161600\n      A=1.D0-A*T(IA)*T(IA+1)                                            00161700\n   21 H=1.D0-H*T(IA)*T(IA-1)                                            00161800\n      A=(1.D0-T(1)*T(2)*A)\/Y                                            00161900\n      H=T(1)*H\/Y                                                        00162000\n      B=DSIN(X)                                                         00162100\n      C=DCOS(X)                                                         00162200\n      D=A-H                                                             00162300\n      E=A+H                                                             00162400\n      IF (M.GT.2) GO TO 24                                              00162500\n      IF (N.EQ.0) GO TO 22                                              00162600\n      Y=E*B-D*C                                                         00162700\n      GO TO 55                                                          00162800\n   22 Y=D*B+E*C                                                         00162900\n      GO TO 55                                                          00163000\n   24 IF (N.EQ.0) GO TO 26                                              00163100\n      Y=-D*B-E*C                                                        00163200\n      GO TO 55                                                          00163300\n   26 Y=E*B-D*C                                                         00163400\n      GO TO 55                                                          00163500\n   55 DBEJ=Y                                                            00163600\n   60 RETURN                                                            00163700\n      END                                                               00163800\nC  22  10      FUNCTION DBEY( X , N )              2 19 68              00163900\n      DOUBLE PRECISION FUNCTION DBEY (X,N)                              00164000\n      DOUBLE PRECISION X                                                00164100\nC                                                                       00164200\nC      THIS IS A DUMMY FUNCTION. THIS FUNCTION WAS LEFT OUT OF          00164300\nC   THE LATEST LISTING OF THE OMNITAB PROGRAM FROM THE BUREAU OF        00164400\nC   STANDARDS. SO THIS ROUTINE WAS SUBSTITUTED UNTIL THE CORRECT ROUTINE00164500\nC   CAN BE OBTAINED.                            R. L. CHAMBERLAIN 2\/12\/600164600\nC                                                                       00164700\n      RETURN                                                            00164800\n      END                                                               00164900\nC  23  47      SUBROUTINE DEFINE                   2 19 68              00165000\n      SUBROUTINE DEFINE                                                 00165100\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00165200\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00165300\n      DIMENSION ARGS(100)                                               00165400\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00165500\nC                                                                       00165600\nC     DEFINE $$ INTO ROW ++, COL ++.                                    00165700\nC     DEFINE ROW ++, COL ++ INTO ROW ++, COL ++.                        00165800\nC     DEFINE ROW ++, COL ++ INTO COL ++.                                00165900\nC                                                                       00166000\n      IF( NARGS .NE. 3 ) IF( NARGS - 4 ) 200, 40, 200                   00166100\n      IF( KIND( 1 ) .EQ. 0 ) GO TO 40                                   00166200\n  10  I = NARGS                                                         00166300\n      GO TO 100                                                         00166400\n  20  IF( NERROR .EQ. 0 ) RC( L ) = ARGS( 1 )                           00166500\n  30  RETURN                                                            00166600\n  40  I = 2                                                             00166700\n      GO TO 100                                                         00166800\n  50  ARGS( 1 ) = RC( L )                                               00166900\n      IF( NARGS .EQ. 4 ) GO TO 10                                       00167000\n      CALL ADRESS( 3, I )                                               00167100\n      IF ( I ) 210, 220, 60                                             00167200\n  60  IF( NERROR .NE. 0 ) GO TO 30                                      00167300\n      IF( NRMAX .EQ. 0 ) GO TO 70                                       00167400\n      CALL VECTOR( ARGS( 1 ), I )                                       00167500\n      GO TO 30                                                          00167600\n  70  I = 9                                                             00167700\n  80  CALL ERROR( I )                                                   00167800\n      GO TO 30                                                          00167900\nC                                                                       00168000\nC     CHECK AND CALCULATE WORKSHEET ENTRY LOCATION INTO L               00168100\nC                                                                       00168200\n 100  CALL ADRESS (I, L )                                               00168300\n      IF ( L ) 210, 220, 110                                            00168400\n 110  IF( KIND(I-1) .EQ. 0 .AND. IARGS(I-1) .GT. 0 .AND. IARGS(I-1) .LE.00168500\n     1 NROW ) GO TO 120                                                 00168600\n      I = 16                                                            00168700\n      GO TO 80                                                          00168800\n 120  L = L + IARGS(I-1) - 1                                            00168900\n      IF( I - 2 ) 50, 50, 20                                            00169000\n 200  I = 10                                                            00169100\n      GO TO 80                                                          00169200\n 210  I = 20                                                            00169300\n      GO TO 80                                                          00169400\n 220  I = 11                                                            00169500\n      GO TO 80                                                          00169600\n      END                                                               00169700\nC  24  21      SUBROUTINE DIMENS                   2 19 68              00169800\n      SUBROUTINE DIMENS                                                 00169900\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00170000\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00170100\n      DIMENSION ARGS(100)                                               00170200\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00170300\n      NRC = 10000                                                       00170400\n      IF( NARGS .EQ. 2 ) IF( KIND( 1 ) + KIND( 2 ) ) 30, 40, 30         00170500\n      K = 10                                                            00170600\n  10  CALL ERROR( K )                                                   00170700\n  20  RETURN                                                            00170800\n  30  K = 20                                                            00170900\n      GO TO 10                                                          00171000\n  40  IF( IARGS( 1 ) .GT. 0 .AND. IARGS( 2 ) .GT. 0 .AND. IARGS( 1 ) *  00171100\n     1 IARGS( 2 ) .LE. NRC ) GO TO 50                                   00171200\n      K = 3                                                             00171300\n      GO TO 10                                                          00171400\n  50  NROW = IARGS( 1 )                                                 00171500\n      NCOL = IARGS( 2 )                                                 00171600\n      NRMAX = MIN0( NROW, NRMAX )                                       00171700\n      GO TO 20                                                          00171800\n      END                                                               00171900\nC  25   4      SUBROUTINE DUMMY                    2 19 68              00172000\n      SUBROUTINE DUMMY                                                  00172100\n      CALL X( 5HDUMMY )                                                 00172200\n      RETURN                                                            00172300\n      END                                                               00172400\nC  26  27      SUBROUTINE ERASE                    2 19 68              00172500\n      SUBROUTINE ERASE                                                  00172600\nC                                                                       00172700\nC ERASE COL ++,++, ++, ETC.                                             00172800\nC                                                                       00172900\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00173000\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00173100\n      DIMENSION ARGS(100)                                               00173200\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00173300\n      IF( NARGS .EQ. 0 ) GO TO 50                                       00173400\n      CALL CHKCOL( I )                                                  00173500\n      IF( I .EQ. 0 ) GO TO 30                                           00173600\n      I = 20                                                            00173700\n  10  CALL ERROR( I )                                                   00173800\n  20  RETURN                                                            00173900\n  30  IF( NERROR .NE. 0 .OR. NRMAX .EQ. 0 ) GO TO 20                    00174000\n      DO 40 I = 1, NARGS                                                00174100\n  40  CALL VECTOR( 0., IARGS( I ) )                                     00174200\n      GO TO 20                                                          00174300\nC                                                                       00174400\nC     CLEAR ALL OF DIMENSIONED WORKSHEET.                               00174500\nC                                                                       00174600\n  50  IF( NERROR .NE. 0 ) GO TO 20                                      00174700\n      NRMAX = NROW * NCOL                                               00174800\n      CALL VECTOR( 0., 1 )                                              00174900\n      NRMAX = 0                                                         00175000\n      GO TO 20                                                          00175100\n      END                                                               00175200\nC  27 199      SUBROUTINE ERROR(I)                 2 19 68              00175300\n      SUBROUTINE ERROR(I)                                               00175400\n      COMMON \/BLOCKC\/KIO,INUNIT,ISCRAT,KBDOUT,KRDKNT                    00175500\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00175600\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00175700\n      DIMENSION ARGS(100)                                               00175800\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00175900\n      COMMON \/ BLOCKX \/ INDEX( 6, 8 ), LEVEL                            00176000\n      COMMON \/ SPRV \/ NERCON,NERR                                       00176100\n      DIMENSION IL(2)                                                   00176200\n      DATA INCERR, IBL, IL(1),IL(2)  \/ 1 , 2H  , 2H\/I, 2H\/F   \/         00176300\n      ISCRUN=ISCRAT                                                     00176400\nC                                                                       00176500\nC     IF I IS NEGATIVE, SET INCERR = 1, SO THAT ERRORS WILL BE TALLIED. 00176600\nC     IF I IS ZERO, SET INCERR = 0 AND CLEAR NERROR TO ZERO.  ERRORS    00176700\nC         WILL NOT BE TALLIED.  (THEY ARE FORGIVEN).                    00176800\nC     IF   1 .LE. I .LE. 100, FATAL ERROR                               00176900\nC     IF 101 .LE. I .LE. 200, ARITHMETIC ERROR                          00177000\nC     IF 201 .LE. I .LE.      INFORMATIVE DIAGNOSTIC                    00177100\nC                                                                       00177200\n      NERR = NERR + 1                                                   00177300\n      IF( I ) 7000, 7001, 7003                                          00177400\n 7000 INCERR = 1                                                        00177500\n      GO TO 7002                                                        00177600\n 7001 INCERR = 0                                                        00177700\n      NERROR = 0                                                        00177800\n 7002 RETURN                                                            00177900\n 7003 IF( I .GT. 100 ) GO TO 200                                        00178000\n      NERROR = NERROR + INCERR                                          00178100\n      WRITE(ISCRUN,8000)                                                00178200\n 8000 FORMAT(84X)                                                       00178300\n      WRITE(ISCRUN,8001)                                                00178400\n 8001 FORMAT(15H*** FATAL ERROR,69X)                                    00178500\n      GO TO (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,  00178600\n     1 23,24,25,26,27,28,29,30), I                                      00178700\n   1  WRITE(ISCRUN,801)                                                 00178800\n 801  FORMAT(29H*** NAME NOT FOUND IN LIBRARY,55X)                      00178900\n      GO TO 900                                                         00179000\n   2  WRITE(ISCRUN,802)                                                 00179100\n 802  FORMAT(28H*** ILLEGAL STATEMENT NUMBER,56X)                       00179200\n      GO TO 888                                                         00179300\n   3  WRITE(ISCRUN,803)                                                 00179400\n 803  FORMAT(28H*** ILLEGAL ARGUMENT ON CARD,56X)                       00179500\n      GO TO 888                                                         00179600\n   4  GO TO 900                                                         00179700\n   5  WRITE(ISCRUN,805)                                                 00179800\n 805  FORMAT(38H*** COMMAND NOT ALLOWED IN REPEAT MODE,46X)             00179900\n      GO TO 900                                                         00180000\n   6  WRITE(ISCRUN,806)                                                 00180100\n 806  FORMAT(54H*** NUMBER MAY NOT BEGIN CARD BETWEEN BEGIN AND FINISH, 00180200\n     130X)                                                              00180300\n      GO TO 900                                                         00180400\n   7  WRITE(ISCRUN,807)                                                 00180500\n 807  FORMAT(23H*** ILLEGAL *STATEMENT*,61X)                            00180600\n      GO TO 900                                                         00180700\n   8  WRITE(ISCRUN,808)                                                 00180800\n 808  FORMAT(34H*** PHYSICAL CONSTANT NOT IN TABLE,50X)                 00180900\n      GO TO 900                                                         00181000\n   9  WRITE(ISCRUN,809)                                                 00181100\n 809  FORMAT(13H*** NRMAX = 0,71X)                                      00181200\n      GO TO 900                                                         00181300\n  10  WRITE(ISCRUN,810)                                                 00181400\n 810  FORMAT(31H*** ILLEGAL NUMBER OF ARGUMENTS,53X)                    00181500\n      GO TO 888                                                         00181600\n  11  WRITE(ISCRUN,811)                                                 00181700\n 811  FORMAT(40H*** COLUMN NUMBER TOO BIG OR LESS THAN 1,44X)           00181800\n      GO TO 888                                                         00181900\n  12  WRITE(ISCRUN,812)                                                 00182000\n 812  FORMAT(33H*** COMMAND STORAGE AREA OVERFLOW,51X)                  00182100\n      GO TO 900                                                         00182200\n  13  WRITE(ISCRUN,813)                                                 00182300\n 813  FORMAT(30H*** STATEMENT NUMBER NOT FOUND,54X)                     00182400\n      GO TO 888                                                         00182500\n  14  WRITE(ISCRUN,814)                                                 00182600\n 814  FORMAT(35H*** ILLEGAL OR NO FORMAT DESIGNATOR,49X)                00182700\n      GO TO 900                                                         00182800\n  15  WRITE(ISCRUN,815)                                                 00182900\n 815  FORMAT(34H*** DIMENSIONED AREA EXCEEDS LIMIT,50X)                 00183000\n      GO TO 888                                                         00183100\n  16  WRITE(ISCRUN,816)                                                 00183200\n 816  FORMAT(27H*** ILLEGAL SIZE ROW NUMBER,57X)                        00183300\n      GO TO 888                                                         00183400\n  17  WRITE(ISCRUN,817)                                                 00183500\n 817  FORMAT(39H*** DEFINED MATRIX OVERFLOWS WORKSHEET,45X)             00183600\n      GO TO 888                                                         00183700\n  18  WRITE(ISCRUN,818)                                                 00183800\n 818  FORMAT(36H*** INTEGER ARGUMENT LESS THAN -8191,48X)               00183900\n      GO TO 888                                                         00184000\n  19  WRITE(ISCRUN,819)                                                 00184100\n 819  FORMAT(48H*** STORED PERFORM STATEMENT WILL EXECUTE ITSELF,36X)   00184200\n      GO TO 900                                                         00184300\n  20  WRITE(ISCRUN,820)                                                 00184400\n 820  FORMAT(29H*** IMPROPER TYPE OF ARGUMENT,55X)                      00184500\n      GO TO 888                                                         00184600\n  21  WRITE(ISCRUN,821)                                                 00184700\n 821  FORMAT(26H*** COMMAND MUST BE STORED,58X)                         00184800\n      GO TO 900                                                         00184900\n  22  WRITE(ISCRUN,822)                                                 00185000\n 822  FORMAT(31H*** MATRIX IS (NEARLY) SINGULAR,53X)                    00185100\n      GO TO 900                                                         00185200\n  23  WRITE(ISCRUN,823)                                                 00185300\n 823  FORMAT(33H*** MATRIX IS TOO LARGE TO INVERT,51X)                  00185400\n      GO TO 900                                                         00185500\n  24  CONTINUE                                                          00185600\n  25  CONTINUE                                                          00185700\n  26  CONTINUE                                                          00185800\n  27  CONTINUE                                                          00185900\n  28  CONTINUE                                                          00186000\n  29  CONTINUE                                                          00186100\n  30  GO TO 900                                                         00186200\n  888 IF( LEVEL .EQ. 0 ) GO TO 900                                      00186300\n      NRG = MIN0( NARGS , 10 )                                          00186400\n      DO 890 II = 1,8                                                   00186500\n  890 KIND( II + 89 ) = IBL                                             00186600\n      IF( NARGS .EQ. 0 ) GO TO 894                                      00186700\n      DO 892 II = 1,NRG                                                 00186800\n      J = KIND( II )                                                    00186900\n      IF( J .EQ. 0 ) ARGS( II ) = IARGS( II )                           00187000\n  892 KIND( II + 89 ) = IL( J+1 )                                       00187100\n  894 WRITE(ISCRUN,896) NARGS                                           00187200\n  896 FORMAT(4X,I6,70H ARGUMENTS IN COMMAND. THE FIRST  8 ENTRIES IN THE00187300\n     1 ARGUMENT POOL ARE..,4X)                                          00187400\n      WRITE(ISCRUN,897) ( ARGS( II ) , KIND( II+89 ), II = 1,8 )        00187500\n  897 FORMAT(4X,8(F8.2,A2))                                             00187600\n 900  IF( LEVEL .NE. 0 ) CALL RNDOWN                                    00187700\nC     FORCE OUT OF REPEAT MODE IF FATAL ERROR                           00187800\n      IF( I .LE. 100 ) LEVEL = 0                                        00187900\n      WRITE( ISCRUN, 901 )                                              00188000\n 901  FORMAT(84X)                                                       00188100\n      RETURN                                                            00188200\n  200 IF( NERR.LE.NERCON) GO TO 201                                     00188300\n      WRITE(ISCRUN,9999) NERCON                                         00188400\n 9999 FORMAT(1H*,I5,58H INFORMATIVE AND ARITHMETIC DIAGNOSTICS HAVE BEEN00188500\n     1 PRINTED.,20X)                                                    00188600\n      WRITE(ISCRUN,9998)                                                00188700\n 9998 FORMAT(61H* THE PRINTING OF ANY SUCH ADDITIONAL DIAGNOSTICS IS DEL00188800\n     1ETED.     ,23X  )                                                 00188900\n      RETURN                                                            00189000\n  201 IF( I .GT. 200 ) GO TO 400                                        00189100\nC                                                                       00189200\nC                                                                       00189300\nC     ARITHMETIC TROUBLES, SET FLAGS                                    00189400\nC                                                                       00189500\n      CALL AERR(I-100)                                                  00189600\n  250 RETURN                                                            00189700\nC                                                                       00189800\nC     INFORMATIVE DIAGNOSTIC                                            00189900\nC                                                                       00190000\n  400 IF( MOD( LLIST , 2 ) .EQ. 0 ) GO TO 250                           00190100\n      WRITE(ISCRUN, 901)                                                00190200\n      WRITE(ISCRUN, 490)                                                00190300\n 490  FORMAT(24H* INFORMATIVE DIAGNOSTIC,60X)                           00190400\n      II=I-200                                                          00190500\n      GO TO (401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412,00190600\n     1 413, 414, 415 ), II                                              00190700\n 401  WRITE(ISCRUN,501)                                                 00190800\n 501  FORMAT(52H* TOO MUCH DATA IN SET, READ OR GENERATE, SPILL LOST,   00190900\n     132X)                                                              00191000\n      GO TO 900                                                         00191100\n 402  WRITE(ISCRUN,502)                                                 00191200\n 502  FORMAT(61H* COMMAND NOT ALLOWED IN REPEAT MODE. EXECUTED BUT NOT S00191300\n     1TORED,23X)                                                        00191400\n      GO TO 900                                                         00191500\n 403  WRITE( ISCRUN, 503 )                                              00191600\n 503  FORMAT(38H* VALUE REQUESTED IN SHORTEN NOT FOUND,46X)             00191700\n      GO TO 900                                                         00191800\n 404  WRITE( ISCRUN, 504 )                                              00191900\n 504  FORMAT(32H* BAD HEAD. COLUMN GT 50 OR NO \/,52X)                   00192000\n      GO TO 900                                                         00192100\n 405  WRITE( ISCRUN, 505 )                                              00192200\n 505  FORMAT(68H* THIS COMMAND WAS NOT EXECUTED BECAUSE ITS MEANING WAS 00192300\n     1QUESTIONABLE,16X)                                                 00192400\n      GO TO 900                                                         00192500\n 406  WRITE(ISCRUN,506)                                                 00192600\n 506  FORMAT(24H* F LESS THAT 0, SET = 0,60X)                           00192700\n      GO TO 900                                                         00192800\n 407  WRITE(ISCRUN,507)                                                 00192900\n 507  FORMAT(24H* NU1 OR NU2 LESS THAN 1,60X)                           00193000\n      GO TO 900                                                         00193100\n 408  WRITE(ISCRUN,508)                                                 00193200\n 508  FORMAT(33H* NU1 OR NU2 TRUNCATED TO INTEGER,51X)                  00193300\n      GO TO 900                                                         00193400\n 409  WRITE(ISCRUN,509)                                                 00193500\n 509  FORMAT(34H* IMPROPER TITLE NUMBER, ASSUMED 1,50X)                 00193600\n      GO TO 900                                                         00193700\n 410  WRITE(ISCRUN,510)                                                 00193800\n 510  FORMAT(36H* COLUMN TOO SHORT FOR ENTIRE MATRIX,48X)               00193900\n      GO TO 900                                                         00194000\n 411  WRITE(ISCRUN,511)                                                 00194100\n 511  FORMAT(52H* ASTERISK STRING IMPLYING \"THRU\" INCORRECT, IGNORED,   00194200\n     1 32X)                                                             00194300\n      GO TO 900                                                         00194400\n 412  WRITE(ISCRUN,512)                                                 00194500\n 512  FORMAT(34H* LAST ARGUMENT IN COMMAND IGNORED,50X)                 00194600\n      GO TO 900                                                         00194700\n 413  WRITE(ISCRUN,513)                                                 00194800\n 513  FORMAT(50H* DEMOTE WENT PAST BOTTOM OF WORKSHEET, SPILL LOST,34X) 00194900\n 414  CONTINUE                                                          00195000\n 415  CONTINUE                                                          00195100\n      GO TO 900                                                         00195200\n      END                                                               00195300\nC  28  32      SUBROUTINE EXCHNG                   2 19 68              00195400\n      SUBROUTINE EXCHNG                                                 00195500\nC                                                                       00195600\nC EXCHANGE COL ++ WITH ++, COL ++ WITH ++, ETC.                         00195700\nC                                                                       00195800\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00195900\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00196000\n      DIMENSION ARGS(100)                                               00196100\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00196200\n      IF (NARGS) 910,910,5                                              00196300\n    5 IF (NARGS.NE.(NARGS\/2)*2) GO TO 910                               00196400\n      DO 30 I=1,NARGS,2                                                 00196500\n      CALL ADRESS( I, J )                                               00196600\n      IF (J) 903,911,10                                                 00196700\n  10  CALL ADRESS( I+1, K )                                             00196800\n      IF (K) 903,911,11                                                 00196900\n   11 IF (NERROR.NE.0) RETURN                                           00197000\n      DO 20 N=1,NRMAX                                                   00197100\n      JJ=J+N-1                                                          00197200\n      KK=K+N-1                                                          00197300\n      WORK=RC(JJ)                                                       00197400\n      RC(JJ)=RC(KK)                                                     00197500\n      RC(KK)=WORK                                                       00197600\n   20 CONTINUE                                                          00197700\n   30 CONTINUE                                                          00197800\n      GO TO 999                                                         00197900\n  903 CALL ERROR (3)                                                    00198000\n      GO TO 999                                                         00198100\n  910 CALL ERROR (10)                                                   00198200\n      GO TO 999                                                         00198300\n  911 CALL ERROR (11)                                                   00198400\n  999 RETURN                                                            00198500\n      END                                                               00198600\nC  29  80      SUBROUTINE EXPAND( J, WHERE )       2 19 68              00198700\n      SUBROUTINE EXPAND( J, WHERE )                                     00198800\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00198900\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00199000\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00199100\n      DIMENSION ARGS(100)                                               00199200\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00199300\n      DIMENSION WHERE( 1 )                                              00199400\nC                                                                       00199500\nC         THIS ROUTINE EXPANDS STORED COMMANDS FROM WHERE TO A USABLE   00199600\nC         FORM IN ARGS, IARGS AND KIND.                                 00199700\nC                                                                       00199800\n      II = 0                                                            00199900\n      I  = 0                                                            00200000\n      JJJ = J                                                           00200100\nC                                                                       00200200\nC     CONVERT ONLY FIRST ARGUMENT IF COMMAND IS INCREMENT OR RESTORE    00200300\nC                                                                       00200400\n      IF( L1 .NE. 14 ) GO TO 10                                         00200500\n      IF( L2 .GE. 6 .AND. L2 .LE. 8 ) JJJ = 2                           00200600\n   10 II = II + 1                                                       00200700\n   15 I = I + 1                                                         00200800\n      IF( I .GE. JJJ ) GO TO 45                                         00200900\n      T= WHERE( I )                                                     00201000\n      IF( T ) 40, 30, 20                                                00201100\n   20 KIND( II ) = 0                                                    00201200\n      IARGS( II ) = T - 8192.                                           00201300\n      GO TO 10                                                          00201400\n   30 KIND( II ) = 1                                                    00201500\n      I = I + 1                                                         00201600\n      ARGS( II ) = WHERE( I )                                           00201700\n      GO TO 10                                                          00201800\n   40 IF( T .EQ. -1. ) GO TO 100                                        00201900\n      CALL XPND( WHERE( I ), K ,ARGS( II ) , KND )                      00202000\n      IF( K .GE. 0 ) GO TO 50                                           00202100\n      K = - K                                                           00202200\n   42 CALL ERROR( K )                                                   00202300\n   45 RETURN                                                            00202400\n   50 KIND( II ) = KND                                                  00202500\n      IF( KND .EQ. 0 ) IARGS( II ) = ARGS( II )                         00202600\n      I = I + K                                                         00202700\n      GO TO 10                                                          00202800\nC                                                                       00202900\nC     IF STORED VALUE = -1, THEN ARGS (INTEGER) ARE TO BE EXPANDED FROM 00203000\nC     PREVIOUS ARG TO FOLLOWING WITH A MAXIMUM TOTAL OF 50              00203100\nC                                                                       00203200\n  100 I = I + 1                                                         00203300\nC     PICK UP NEXT ARG                                                  00203400\n      IU = WHERE( I )                                                   00203500\n      IF( KIND( II-1 ) .NE. 0 .OR. I .GE. J ) GO TO 200                 00203600\n      IF( IU ) 160, 200, 105                                            00203700\n  105 IU =IU - 8192                                                     00203800\n      K= IU - IARGS( II-1 )                                             00203900\n      NARGS = NARGS + IABS( K ) - 1                                     00204000\n      IF ( NARGS .GT. 50 ) GO TO 250                                    00204100\n      IF ( K ) 110,15,120                                               00204200\n  110 INC = -1                                                          00204300\n      K = -K                                                            00204400\n      GO TO 140                                                         00204500\n  120 INC = 1                                                           00204600\n  140 DO 150 IT = 1, K                                                  00204700\n      KIND( II ) = 0                                                    00204800\n      IARGS( II ) = IARGS( II-1 ) + INC                                 00204900\n  150 II = II + 1                                                       00205000\n      GO TO 15                                                          00205100\nC                                                                       00205200\nC     EXPAND FORM  IARG *** \"\" ARG \"\"                                   00205300\nC                                                                       00205400\n  160 CALL XPND( WHERE( I ) , K , ARGS( II ) , KND )                    00205500\n      IF( K .LT. 0 ) GO TO 42                                           00205600\n      I = I + K                                                         00205700\n      IF( KND .EQ. 0 ) GO TO 170                                        00205800\n      K = 20                                                            00205900\n      GO TO 42                                                          00206000\n  170 IU = ARGS( II )                                                   00206100\n      GO TO 105                                                         00206200\n  200 CALL ERROR( 211 )                                                 00206300\n      GO TO 10                                                          00206400\n  250 K= 10                                                             00206500\n      GO TO 42                                                          00206600\n      END                                                               00206700\nC  30  97      SUBROUTINE EXPCON                   2 19 68              00206800\n      SUBROUTINE EXPCON                                                 00206900\nC**** EXPCON  SUBROUTINE    S PEAVY   9\/12\/67                           00207000\nC**** COMMANDS                                                          00207100\nC****     L2=1\" MVECDIAG,AVECDIAG                                       00207200\nC****         MVECDIAG  A(,, ++) R=,, C=++ STORE IN COL ++              00207300\nC****      OR MVECDIAG  A(,, ++) R=,, C=++ START STORING IN (,, ++)     00207400\nC****     L2=2\" MVECMAT,AVECTARR                                        00207500\nC****         MVECMAT A(,, ++) R=,, C=++ STORE IN COL ++                00207600\nC****      OR MVECMAT A(,, ++) R=,, C=++ START STORING IN (,, ++)       00207700\nC****     THE MATRIX A IS STORED BY ROWS AS A COL VECTOR                00207800\nC****     L2=3\" MMATVEC                                                 00207900\nC****         MMATVEC COL +++    STORE IN A(,, ++) AS R=,, BY C=++ MATRI00208000\nC****      OR MMATVEC STARTING (,, ++) IN A(,, ++) AS R=,, BY C=++ MATRI00208100\nC****     THIS OPERATION IS THE REVERSE OF MVECMAT                      00208200\n      COMMON \/ SCRAT \/ A(10000),NS                                      00208300\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00208400\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00208500\n      DIMENSION ARGS(100)                                               00208600\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00208700\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00208800\n      IF(NARGS.LT.5.OR.NARGS.GT.6)  CALL ERROR (10)                     00208900\n      IF(L2.EQ.3) GO TO 300                                             00209000\n  100 J=NARGS                                                           00209100\n      CALL CKIND(J)                                                     00209200\n      IF(J.NE.0)  CALL ERROR(3)                                         00209300\n      J=1                                                               00209400\n      CALL MTXCHK(J)                                                    00209500\n      IF(J.NE.0) CALL ERROR(17)                                         00209600\n      CALL ADRESS(NARGS,ILL)                                            00209700\n      IF(ILL.LE.0) CALL ERROR(11)                                       00209800\n      IM=IARGS(1)                                                       00209900\n      ILC=ILL                                                           00210000\n      IL=IARGS(3)                                                       00210100\n      IF(L2.GT.1) IL=IL*IARGS(4)                                        00210200\n      IF(NARGS.EQ.6) ILC=ILC+IARGS(5)-1                                 00210300\n      IXX=ILC+IL-1                                                      00210400\n      IF(L2-2)  105,200,310                                             00210500\nC**** VEC DIAG                                                          00210600\n  105 IF(IXX.LE.ILL+NROW-1) GO TO 120                                   00210700\n      IXX=ILL+NROW-1                                                    00210800\n      CALL ERROR( 210 )                                                 00210900\nC**** ERROR 220 \"COLUMN NOT LONG ENOUGH TO STORE ALL OF DIAGONAL.       00211000\nC**** NROW ELEMENTS WILL BE STORED. \"                                   00211100\n  120 IF(NERROR.NE.0) RETURN                                            00211200\n      DO  130  I=ILC,IXX                                                00211300\n      RC(I)=RC(IM)                                                      00211400\n  130 IM=IM+1+NROW                                                      00211500\n      RETURN                                                            00211600\nC**** VECTMAT                                                           00211700\n  200 IF(IXX.LE.ILL+NROW-1) GO TO 220                                   00211800\n      IXX=ILL+NROW-1                                                    00211900\n      CALL ERROR( 210 )                                                 00212000\nC**** ERROR 221\" \"COLUMN NOT LONG ENOUGH TO STORE ALL OF MATRIX (ARRAY).00212100\nC**** NROW ELEMENTS WILL BE STORED.\"                                    00212200\n  220 IF(NERROR.NE.0) RETURN                                            00212300\n      KMX=IARGS(4)                                                      00212400\n      NMX=IARGS(3)                                                      00212500\n      IMM=IM                                                            00212600\n      DO  240  J=1,NMX                                                  00212700\n      IM=IMM                                                            00212800\n      DO  230  I=1,KMX                                                  00212900\n      RC(ILC)=RC(IM)                                                    00213000\n      IM=IM+NROW                                                        00213100\n      IF(ILC.EQ.IXX)  RETURN                                            00213200\n  230 ILC=ILC+1                                                         00213300\n  240 IMM=IMM+1                                                         00213400\n      RETURN                                                            00213500\nC**** RESTORE MATRIX OR ARRAY                                           00213600\n  300 IL=IARGS(1)                                                       00213700\n      IC=2                                                              00213800\n      IF(NARGS.NE.6) GO TO 302                                          00213900\n      IC=3                                                              00214000\n      ILL=IARGS(2)                                                      00214100\n  302 DO 305 I=1,4                                                      00214200\n      IARGS(I)=IARGS(IC)                                                00214300\n  305 IC=IC+1                                                           00214400\n      IARGS( 5)=IL                                                      00214500\n      IARGS(6)=ILL                                                      00214600\n      GO TO 100                                                         00214700\n  310 IF(IXX.LE.ILL+NROW-1) GO TO 320                                   00214800\n      IXX=ILL+NROW-1                                                    00214900\n      CALL ERROR( 210 )                                                 00215000\nC**** ERROR 222\"\"NOT N BY K ELEMENTS IN COLUMN TO RESTORE AS N BY K     00215100\nC**** MATRIX (ARRAY). THEREFORE NROW ELEMENTS WILL BE STORED.\"          00215200\n  320 IF(NERROR.NE.0) RETURN                                            00215300\n      NMX=IARGS(3)                                                      00215400\n      KMX=IARGS(4)                                                      00215500\n      DO 340  I=1,NMX                                                   00215600\n      IMC=IM                                                            00215700\n      DO 330  J=1,KMX                                                   00215800\n      RC(IMC)=RC(ILC)                                                   00215900\n      IF(ILC.EQ.IXX) RETURN                                             00216000\n      IMC=IMC+NROW                                                      00216100\n  330 ILC=ILC+1                                                         00216200\n  340 IM=IM+1                                                           00216300\n      RETURN                                                            00216400\n      END                                                               00216500\nC  31  49      SUBROUTINE EXTREM                   2 19 68              00216600\n      SUBROUTINE EXTREM                                                 00216700\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00216800\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00216900\n      DIMENSION ARGS(100)                                               00217000\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00217100\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00217200\nC                                                                       00217300\nC     L2 = 4,5 MAX     L2 = 6,7 MIN                                     00217400\nC                                                                       00217500\nC     MAX OF ++ TO ++                                                   00217600\nC     MAX OF ++ TO ++, CORRESP ENTRY OF ++ TO ++, ++ TO ++, ETC.        00217700\nC     LIKEWISE FOR MIN.                                                 00217800\nC                                                                       00217900\n      IF( NARGS .GT. 0 .AND. MOD( NARGS, 2 ) .EQ. 0 ) GO TO 30          00218000\n      I=10                                                              00218100\n  10  CALL ERROR( I )                                                   00218200\n  20  RETURN                                                            00218300\n  30  CALL CHKCOL( I )                                                  00218400\n      IF( I .EQ. 0 ) GO TO 40                                           00218500\n      I = 20                                                            00218600\n      GO TO 10                                                          00218700\n  40  IF( NERROR .NE. 0 ) GO TO 20                                      00218800\n      J=0                                                               00218900\n      IF( NRMAX - 1 ) 50, 110, 60                                       00219000\n  50  I=9                                                               00219100\n      GO TO 10                                                          00219200\n  60  J = IARGS( 1 )                                                    00219300\n      K = J + 1                                                         00219400\n      L = K + NRMAX - 2                                                 00219500\n      IF( L2 .GT. 5 ) GO TO 80                                          00219600\nC                                                                       00219700\nC     FIND MAXIMUM                                                      00219800\nC                                                                       00219900\n      DO 70 I = K, L                                                    00220000\n      IF( RC( J ) .LT. RC( I ) ) J = I                                  00220100\n  70  CONTINUE                                                          00220200\n      GO TO 100                                                         00220300\nC                                                                       00220400\nC     FIND MINIMUM                                                      00220500\nC                                                                       00220600\n  80  DO 90 I = K, L                                                    00220700\n      IF( RC( J ) .GT. RC( I ) ) J = I                                  00220800\n  90  CONTINUE                                                          00220900\n 100  J = J - IARGS( 1 )                                                00221000\n 110  DO 120 I = 1, NARGS, 2                                            00221100\n      K = IARGS( I ) + J                                                00221200\n      XY=RC(K)                                                          00221300\n  120 CALL VECTOR (XY,IARGS(I+1))                                       00221400\n      GO TO 20                                                          00221500\n      END                                                               00221600\nC  32   9      FUNCTION FCOS( X )                  2 19 68              00221700\n      FUNCTION FCOS( X )                                                00221800\n      COMMON\/CONSTS\/PI,E,HALFPI,DEG,RAD,XEXP,XTRIG,XALOG,CC( 192 )      00221900\n      IF( ABS( X ) .GT. XTRIG ) GO TO 2                                 00222000\n      FCOS = COS( X )                                                   00222100\n   1  RETURN                                                            00222200\n   2  CALL ERROR( 110 )                                                 00222300\n      FCOS = 0.                                                         00222400\n      GO TO 1                                                           00222500\n      END                                                               00222600\nC  33   9      FUNCTION FEXP( X )                  2 19 68              00222700\n      FUNCTION FEXP( X )                                                00222800\n      COMMON\/CONSTS\/PI,E,HALFPI,DEG,RAD,XEXP,XTRIG,XALOG,CC( 192 )      00222900\n      IF( X .GT. XEXP ) GO TO 2                                         00223000\n      FEXP = EXP( X )                                                   00223100\n   1  RETURN                                                            00223200\n   2  CALL ERROR( 102 )                                                 00223300\n      FEXP = 0.                                                         00223400\n      GO TO 1                                                           00223500\n      END                                                               00223600\nC  34  12      FUNCTION FEXP2( B, E )              2 19 68              00223700\n      FUNCTION FEXP2( B, E )                                            00223800\nC                                                                       00223900\nC     THIS FUNCTION IS INCLUDED TO CATCH EXPONENTIATION ERRORS BEFORE   00224000\nC     THE SYSTEM DOES                                                   00224100\nC                                                                       00224200\n      IE = E                                                            00224300\n      IF( E .EQ. FLOAT( IE ) ) GO TO 2                                  00224400\n      FEXP2 = FEXP( E * FLOG( B ) )                                     00224500\n   1  RETURN                                                            00224600\n   2  FEXP2 = B ** IE                                                   00224700\n      GO TO 1                                                           00224800\n      END                                                               00224900\nC  35   4      SUBROUTINE FFLOAT                   2 19 68              00225000\n      SUBROUTINE FFLOAT                                                 00225100\n      CALL X( \"FFLOAT\" )                                                00225200\n      RETURN                                                            00225300\n      END                                                               00225400\nC  36   4      SUBROUTINE FIXED                    2 19 68              00225500\n      SUBROUTINE FIXED                                                  00225600\n      CALL X( \"FIXED\" )                                                 00225700\n      RETURN                                                            00225800\n      END                                                               00225900\nC  37  40      SUBROUTINE FIXFLO                   2 19 68              00226000\n      SUBROUTINE FIXFLO                                                 00226100\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00226200\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00226300\n      DIMENSION ARGS(100)                                               00226400\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00226500\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00226600\n      COMMON \/ HEADER\/NMCARD(72),ITLE(64,6),IHEAD(4,50),IFMT(17,6),     00226700\n     1 IFMTX(4),LNCNT,IPRINT,NPAGE,IPUNCH                               00226800\n      DIMENSION ITYPE( 2 ), N( 11 )                                     00226900\n      DATA N(1),N(2),N(3),N(4),N(5),N(6),N(7),N(8),N(9),N(10),N(11) \/   00227000\n     1 2H0), 2H1), 2H2), 2H3), 2H4), 2H5), 2H6), 2H7), 2H8), 2H9),3H10)\/00227100\n      DATA ITYPE(1), ITYPE(2) \/ 2H8F, 4H1P8E \/                          00227200\nC                                                                       00227300\nC     L2 = 3 FOR FIXED, L2 = 4 FOR FLOAT                                00227400\nC                                                                       00227500\nC     FORMAT IS 4 WORDS       WHEN FLOAT IS EXECUTED 2. BECOMES 1P8E    00227600\nC     1. C                    WHEN FIXED IS EXECUTED 2. BECOMES 8F      00227700\nC     2. 1P8E                                                           00227800\nC     3. 15.                                                            00227900\nC     4. 6)                                                             00228000\nC                                                                       00228100\nC     THIS ROUTINE ASSUMES THAT AT LEAST FOUR CHARACTERS MAY BE STORED  00228200\nC     IN A WORD, THAT UNUSED SPACE IN A WORD INITIALIZED WITH CHARACTERS00228300\nC     WILL BE FILLED WITH BLANKS, AND THAT BLANKS ARE IGNORED IF FORMAT 00228400\nC     SCANNING (EXCEPT IN HOLLERITH FIELDS).                            00228500\nC                                                                       00228600\n      IF( NARGS .EQ. 1 ) IF( KIND( 1 ) ) 30, 40, 30                     00228700\n      I = 10                                                            00228800\n  10  CALL ERROR( I )                                                   00228900\n  20  RETURN                                                            00229000\n  30  I = 20                                                            00229100\n      GO TO 10                                                          00229200\n  40  I = IARGS( 1 )                                                    00229300\n      IF( I .GE. 0 .AND. I .LE. 10 ) GO TO 50                           00229400\n      I = 3                                                             00229500\n      GO TO 10                                                          00229600\n  50  IFMTX( 4 ) = N( I+1 )                                             00229700\n      IFMTX( 2 ) = ITYPE( L2-2 )                                        00229800\n      GO TO 20                                                          00229900\n      END                                                               00230000\nC  38  41      SUBROUTINE FLIP                     2 19 68              00230100\n      SUBROUTINE FLIP                                                   00230200\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00230300\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00230400\n      DIMENSION ARGS(100)                                               00230500\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00230600\n      EQUIVALENCE  (I,IARGS(100)),(J,IARGS(99)),(K,IARGS(98)),          00230700\n     1 (KK,IARGS(97)),(M,IARGS(96)),(MM,IARGS(95)),(MMM,IARGS(94)),     00230800\n     2 (N,IARGS(93)),(NN,IARGS(92)),(A,ARGS(1))                         00230900\nC                                                                       00231000\nC FLIP COL ++ INTO COL ++, ++ INTO ++, ETC.                             00231100\nC                                                                       00231200\n      IF( NARGS .GT. 0 .AND. MOD( NARGS, 2 ) .GE. 0 ) GO TO 20          00231300\n      I = 10                                                            00231400\n  10  CALL ERROR( I )                                                   00231500\n  15  RETURN                                                            00231600\n  20  CALL CHKCOL( I )                                                  00231700\n      IF( I .EQ. 0 ) GO TO 30                                           00231800\n      I = 20                                                            00231900\n      GO TO 10                                                          00232000\n  30  IF( NERROR .NE. 0 ) GO TO 15                                      00232100\n      IF( NRMAX - 1 ) 35, 15, 40                                        00232200\n  35  I = 9                                                             00232300\n      GO TO 10                                                          00232400\n  40  KK = NRMAX - 1                                                    00232500\n      K = KK \/ 2                                                        00232600\n      DO 60 I = 1, NARGS, 2                                             00232700\n      M = IARGS( I )                                                    00232800\n      N = IARGS( I+1 )                                                  00232900\n      MM = M + KK                                                       00233000\n      NN = N + KK                                                       00233100\n      MMM = M + K                                                       00233200\n      DO 50 J = M, MMM                                                  00233300\n      A = RC( J )                                                       00233400\n      RC( N ) = RC( MM )                                                00233500\n      RC( NN ) = A                                                      00233600\n      N = N + 1                                                         00233700\n      MM = MM - 1                                                       00233800\n  50  NN = NN - 1                                                       00233900\n  60  CONTINUE                                                          00234000\n      GO TO 15                                                          00234100\n      END                                                               00234200\nC  39   8      FUNCTION FLOG( X )                  2 19 68              00234300\n      FUNCTION FLOG( X )                                                00234400\n      IF( X .GT. 0. ) GO TO 1                                           00234500\n      CALL ERROR( 101 )                                                 00234600\n      FLOG = 0.                                                         00234700\n      GO TO 2                                                           00234800\n   1  FLOG = ALOG( X )                                                  00234900\n   2  RETURN                                                            00235000\n      END                                                               00235100\nC  40  59      SUBROUTINE  FPROB                   2 19 68              00235200\n      SUBROUTINE  FPROB                                                 00235300\nC     WRITTEN BY  S PEAVY             10\/13\/67                          00235400\nC     COMMAND IS AS  FOLLOWING                                          00235500\nC        FPROBABILITY V1 $$,V2 $$, F  $$, STORE Q IN COL ++             00235600\n      COMMON \/ SCRAT \/ A(10000),NS                                      00235700\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00235800\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00235900\n      DIMENSION ARGS(100)                                               00236000\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00236100\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00236200\n      IF (NARGS.NE.4) CALL  ERROR(10)                                   00236300\n      IF (KIND(NARGS).NE.0) CALL ERROR (3)                              00236400\n      I1=1                                                              00236500\n      I2=1                                                              00236600\n      I3=1                                                              00236700\n  150 CALL ADRESS (1,IARGS(1))                                          00236800\n      IF(IARGS(1)) 160,170,175                                          00236900\n  160 I1=2                                                              00237000\n      V1=ARGS(1)                                                        00237100\n      GO TO 180                                                         00237200\n  170 CALL ERROR (11)                                                   00237300\n  175 L=IARGS(1)                                                        00237400\n  180 CALL ADRESS (2,IARGS(2))                                          00237500\n      IF(IARGS(2)) 190,200,205                                          00237600\n  190 I2=2                                                              00237700\n      V2=ARGS(2)                                                        00237800\n      GO TO 210                                                         00237900\n  200 CALL ERROR(11)                                                    00238000\n  205 M=IARGS(2)                                                        00238100\n  210 CALL ADRESS(3,IARGS(3))                                           00238200\n      IF(IARGS(3)) 220,230,235                                          00238300\n  220 I3=2                                                              00238400\n      F=ARGS(3)                                                         00238500\n      GO TO 240                                                         00238600\n  230 CALL ERROR(11)                                                    00238700\n  235 N=IARGS(3)                                                        00238800\n  240 CALL ADRESS(NARGS,K)                                              00238900\n      IF(K.LE.0) CALL ERROR (11)                                        00239000\n      IF(NERROR.NE.0) RETURN                                            00239100\n      IF(I1+I2+I3.NE.6) GO TO 260                                       00239200\n      CALL PROB(V1,V2,F,Q)                                              00239300\n      DO  250 I=1,NRMAX                                                 00239400\n      RC(K)=Q                                                           00239500\n  250 K=K+1                                                             00239600\n      RETURN                                                            00239700\n  260 DO 330  I=1,NRMAX                                                 00239800\n      GO TO (270,280),I1                                                00239900\n  270 V1=RC(L)                                                          00240000\n      L=L+1                                                             00240100\n  280 GO TO (290,300),I2                                                00240200\n  290 V2=RC(M)                                                          00240300\n      M=M+1                                                             00240400\n  300 GO TO (310,320),I3                                                00240500\n  310 F=RC(N)                                                           00240600\n      N=N+1                                                             00240700\n  320 CALL PROB(V1,V2,F,RC(K))                                          00240800\n  330 K=K+1                                                             00240900\n      RETURN                                                            00241000\n      END                                                               00241100\nC  41  38      SUBROUTINE FOURIA                   2 19 68              00241200\n      SUBROUTINE FOURIA                                                 00241300\n      COMMON \/BEZON\/Y(200),A,R(199),       N,KAA                        00241400\n      DOUBLE PRECISION  Y,A,R,AA,AB,   AC,BA,BB,AD                      00241500\n      M=N\/2                                                             00241600\n      K=2*M                                                             00241700\n      L=0                                                               00241800\n      IF (N.EQ.K) GO TO 2                                               00241900\n      L=1                                                               00242000\n    2 AB=N                                                              00242100\n      AA=6.28318530717D0\/AB                                             00242200\n      A=0.0                                                             00242300\n      R(M)=.0                                                           00242400\n      AC=1.                                                             00242500\n      DO 3 I=1,N                                                        00242600\n      A=A+Y(I)                                                          00242700\n      R(M)=R(M)+AC*Y(I)                                                 00242800\n    3 AC=-1.*AC                                                         00242900\n      A=A\/AB                                                            00243000\n      R(M)=R(M)\/AB                                                      00243100\n      J=M+L-1                                                           00243200\n      KA=M+1                                                            00243300\n      DO 5 K=1,J                                                        00243400\n      BA=Y(1)                                                           00243500\n      BB=0.0                                                            00243600\n      AC=K                                                              00243700\n      AC=AC*AA                                                          00243800\n      DO 4 I=2,N                                                        00243900\n      AD=I-1                                                            00244000\n      AD=AD*AC                                                          00244100\n      BA=BA+Y(I)*DCOS(AD)                                               00244200\n    4 BB=BB+Y(I)*DSIN(AD)                                               00244300\n      R(K)=2.*BA\/AB                                                     00244400\n      R(KA)=2.*BB\/AB                                                    00244500\n  5   KA=KA+1                                                           00244600\n      IF (L.EQ.1) GO TO 6                                               00244700\n      R(KA)=0.                                                          00244800\n    6 RETURN                                                            00244900\n      END                                                               00245000\nC  42   9      FUNCTION FSIN( X )                  2 19 68              00245100\n      FUNCTION FSIN( X )                                                00245200\n      COMMON\/CONSTS\/PI,E,HALFPI,DEG,RAD,XEXP,XTRIG,XALOG,CC( 192 )      00245300\n      IF( ABS( X ) .GT. XTRIG ) GO TO 2                                 00245400\n      FSIN = SIN( X )                                                   00245500\n   1  RETURN                                                            00245600\n   2  CALL ERROR( 110 )                                                 00245700\n      FSIN = 0.                                                         00245800\n      GO TO 1                                                           00245900\n      END                                                               00246000\nC  43   8      FUNCTION FSQRT( X )                 2 19 68              00246100\n      FUNCTION FSQRT( X )                                               00246200\n      IF( X .LT. 0. ) GO TO 2                                           00246300\n      FSQRT = SQRT( X )                                                 00246400\n   1  RETURN                                                            00246500\n   2  CALL ERROR( 101 )                                                 00246600\n      FSQRT = 0.                                                        00246700\n      GO TO 1                                                           00246800\n      END                                                               00246900\nC  44 207      SUBROUTINE FUNCT                    2 19 68              00247000\n      SUBROUTINE FUNCT                                                  00247100\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00247200\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00247300\n      DIMENSION ARGS(100)                                               00247400\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00247500\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00247600\n      COMMON\/CONSTS\/PI,E,HALFPI,DEG,RAD,XEXP,XTRIG,XALOG,CC( 192 )      00247700\n      DIMENSION II( 2 )                                                 00247800\n      EQUIVALENCE ( I1, II( 1 ) ), ( I2, II( 2 ) )                      00247900\nC                                                                       00248000\nC         THIS SUBROUTINE HANDLES ALL TWO AND THREE ARGUMENT FUNCTIONS. 00248100\nC     IF THE FIRST ARGUMENT IS A CONSTANT, THE FUNCTION IS EVALUATED    00248200\nC         ONLY ONCE.                                                    00248300\nC                                                                       00248400\n      IF( NARGS .EQ. 2 .OR. NARGS .EQ. 3 ) GO TO 10                     00248500\n      CALL ERROR( 10 )                                                  00248600\n      GO TO 200                                                         00248700\n  10  CALL ADRESS( NARGS, IL )                                          00248800\n      IF( IL ) 20, 30, 40                                               00248900\n  20  CALL ERROR( 20 )                                                  00249000\n      GO TO 200                                                         00249100\n  30  CALL ERROR( 11 )                                                  00249200\n      GO TO 200                                                         00249300\n  40  ILZ = IL + NRMAX - 1                                              00249400\n      NARGS = NARGS - 1                                                 00249500\n      DO 50 I = 1, NARGS                                                00249600\n      CALL ADRESS( I, II( I ) )                                         00249700\n      IF( II( I ) ) 45, 30, 50                                          00249800\n  45  II( I ) = -II( I )                                                00249900\n  50  CONTINUE                                                          00250000\n      IF( KIND( 1 ) .EQ. 0 ) GO TO 55                                   00250100\n      X = ARGS( 1 )                                                     00250200\n      LOCRTN = 1                                                        00250300\n      GO TO 250                                                         00250400\n  52  ARGS( 1 ) = X                                                     00250500\n  55  IF( NERROR .NE. 0 ) GO TO 200                                     00250600\n      IF( NRMAX .NE. 0 ) GO TO 60                                       00250700\n      CALL ERROR( 9 )                                                   00250800\n      GO TO 200                                                         00250900\n  60  IF( NARGS .EQ. 2 ) GO TO 90                                       00251000\n      IF( KIND( 1 ) .EQ. 0 ) GO TO 70                                   00251100\nC                                                                       00251200\nC         TWO ARGUMENTS, FIRST IS A CONSTANT                            00251300\nC                                                                       00251400\n      CALL VECTOR( ARGS( 1 ), IL )                                      00251500\n      GO TO 200                                                         00251600\nC                                                                       00251700\nC         TWO ARGUMENTS, FIRST IS A COLUMN NUMBER                       00251800\nC                                                                       00251900\n  70  LOCRTN = 2                                                        00252000\n      I = IL                                                            00252100\n   80 IF ( I .GT.ILZ ) GO TO 200                                        00252200\n      X = RC( I1 )                                                      00252300\n      GO TO 250                                                         00252400\n  75  RC( I ) = X                                                       00252500\n      I1 = I1 + 1                                                       00252600\n      I=I+1                                                             00252700\n      GO TO 80                                                          00252800\n  90  K2 = 1 - KIND( 2 )                                                00252900\n      IF( KIND( 1 ) .EQ. 0 ) GO TO 110                                  00253000\nC                                                                       00253100\nC         THREE ARGUMENTS, FIRST ONE A CONSTANT                         00253200\nC                                                                       00253300\n      DO 100 I = IL, ILZ                                                00253400\n      RC( I ) = RC( I ) + RC( I2 ) * ARGS( 1 )                          00253500\n 100  I2 = I2 + K2                                                      00253600\n      GO TO 200                                                         00253700\nC                                                                       00253800\nC         THREE ARGUMENTS, FIRST A COLUMN NUMBER                        00253900\nC                                                                       00254000\n 110  LOCRTN = 3                                                        00254100\n      I=IL                                                              00254200\n  120 IF ( I .GT.ILZ ) GO TO 200                                        00254300\n      X = RC( I1 )                                                      00254400\n      GO TO 250                                                         00254500\n 115  RC( I ) = RC( I ) + RC( I2 ) * X                                  00254600\n      I1 = I1 + 1                                                       00254700\n      I2 = I2 + K2                                                      00254800\n      I=I+1                                                             00254900\n      GO TO 120                                                         00255000\n 200  RETURN                                                            00255100\n 250  GO TO ( 300,310,320,330,340,350,360,370,380,390,400,410,420,430,  00255200\n     1 440,450,460,460,470,480,480,490,500,500,510,520,530,540,550,560, 00255300\n     2 570,580,590,600,610,620,630 ) , L2                               00255400\n 260  CALL ERROR( L )                                                   00255500\n      X = 0.                                                            00255600\n 275  GO TO ( 52, 75, 115 ), LOCRTN                                     00255700\nC     SIN                                                               00255800\n 300  X = FSIN( X )                                                     00255900\n      GO TO 275                                                         00256000\nC     COS                                                               00256100\n 310  X = FCOS( X )                                                     00256200\n      GO TO 275                                                         00256300\nC     TAN                                                               00256400\n 320  X = FSIN( X ) \/ FCOS( X )                                         00256500\n      GO TO 275                                                         00256600\nC     COT                                                               00256700\n 330  X = FCOS( X ) \/ FSIN( X )                                         00256800\n      GO TO 275                                                         00256900\nC     ASIN                                                              00257000\n 340  IF( ABS( X ) - 1. ) 341, 342, 343                                 00257100\n 341  X = ATAN( X \/ SQRT( 1. - X ** 2 ) )                               00257200\n      GO TO 275                                                         00257300\n 342  X = SIGN( HALFPI, X )                                             00257400\n      GO TO 275                                                         00257500\n 343  L = 103                                                           00257600\n      GO TO 260                                                         00257700\nC     ACOS                                                              00257800\n 350  IF( ABS( X ) - 1. ) 351, 351, 343                                 00257900\n 351  X = ATAN( SQRT( 1. - X ** 2 ) \/ X )                               00258000\n      GO TO 275                                                         00258100\nC     ATAN                                                              00258200\n 360  X = ATAN( X )                                                     00258300\n      GO TO 275                                                         00258400\nC     ACOT                                                              00258500\n 370  X = ATAN( 1. \/ X )                                                00258600\n      GO TO 275                                                         00258700\nC     SIND                                                              00258800\n  380 X = RAD * X                                                       00258900\n      GO TO 300                                                         00259000\nC     COSD                                                              00259100\n  390 X = RAD * X                                                       00259200\n      GO TO 310                                                         00259300\nC     TAND                                                              00259400\n  400 X = RAD * X                                                       00259500\n      GO TO 320                                                         00259600\nC     COTD                                                              00259700\n  410 X = RAD * X                                                       00259800\n      GO TO 330                                                         00259900\nC     ASIND                                                             00260000\n 420  IF( ABS( X ) - 1. ) 421, 422, 343                                 00260100\n  421 X = DEG * ATAN(X\/SQRT(1. - X ** 2 ) )                             00260200\n      GO TO 275                                                         00260300\n 422  X = SIGN( 90., X )                                                00260400\n      GO TO 275                                                         00260500\nC     ACOSD                                                             00260600\n 430  IF( ABS( X ) - 1. ) 431, 431, 343                                 00260700\n  431 X = DEG * ATAN(SQRT( 1. - X ** 2 ) \/ X)                           00260800\n      GO TO 275                                                         00260900\nC     ATAND                                                             00261000\n  440 X = DEG * ATAN(X)                                                 00261100\n      GO TO 275                                                         00261200\nC     ACOTD                                                             00261300\n  450 X = DEG * ATAN( 1. \/ X)                                           00261400\n      GO TO 275                                                         00261500\nC     ABS                                                               00261600\n 460  X = ABS( X )                                                      00261700\n      GO TO 275                                                         00261800\nC     SQRT                                                              00261900\n 470  X = FSQRT( X )                                                    00262000\n      GO TO 275                                                         00262100\nC     EXP                                                               00262200\n 480  X = FEXP( X )                                                     00262300\n      GO TO 275                                                         00262400\nC     NEXP                                                              00262500\n 490  X = FEXP( -X )                                                    00262600\n      GO TO 275                                                         00262700\nC     LOG                                                               00262800\n 500  X = FLOG( X )                                                     00262900\n      GO TO 275                                                         00263000\nC     LOG10                                                             00263100\n 510  IF( X .GT. 0. ) GO TO 511                                         00263200\n      L = 101                                                           00263300\n      GO TO 260                                                         00263400\n 511  X = ALOG10( X )                                                   00263500\n      GO TO 275                                                         00263600\nC     ALOG                                                              00263700\n 520  IF( X .GT. XALOG ) GO TO 522                                      00263800\n      X = 10. ** X                                                      00263900\n      GO TO 275                                                         00264000\n 522  L = 102                                                           00264100\n      GO TO 260                                                         00264200\nC     SINH                                                              00264300\n 530  Y = FEXP( X )                                                     00264400\n      X = .5 * ( Y + 1. \/ Y ) * TANH( X )                               00264500\n      GO TO 275                                                         00264600\nC     COSH                                                              00264700\n 540  Y = FEXP( X )                                                     00264800\n      X = .5 * ( Y + 1. \/ Y )                                           00264900\n      GO TO 275                                                         00265000\nC     TANH                                                              00265100\n 550  X = TANH( X )                                                     00265200\n      GO TO 275                                                         00265300\nC     COTH                                                              00265400\n 560  X = 1. \/ TANH( X )                                                00265500\n      GO TO  275                                                        00265600\nC     ASINH                                                             00265700\n 570  X = SIGN( ALOG( ABS( X ) + SQRT( X ** 2 + 1. ) ), X )             00265800\n      GO TO 275                                                         00265900\nC     ACOTH                                                             00266000\n 580  X = ALOG( ABS( X ) + SQRT( X ** 2 - 1. ) )                        00266100\n      GO TO 275                                                         00266200\nC     ATANH                                                             00266300\n 590  IF( ABS( X ) .LT. 1. ) GO TO 592                                  00266400\n      L = 103                                                           00266500\n      GO TO 260                                                         00266600\n 592  X = .5 * ALOG( ( 1. + X ) \/ ( 1. - X ) )                          00266700\n      GO TO 275                                                         00266800\nC     ACOTH                                                             00266900\n 600  IF( ABS( X ) .LT. 1. ) GO TO 602                                  00267000\n      X = .5 * ALOG( ( X + 1. ) \/ ( X - 1. ) )                          00267100\n      GO TO 275                                                         00267200\n 602  L = 103                                                           00267300\n      GO TO 260                                                         00267400\n  610 X = QNORML( X )                                                   00267500\n      GO TO 275                                                         00267600\nC     INTEGER                                                           00267700\n  620 X = AINT( X)                                                      00267800\n      GO TO 275                                                         00267900\nC     FRACTIONAL                                                        00268000\n  630 X = X - AINT( X )                                                 00268100\n      GO TO 275                                                         00268200\n      END                                                               00268300\nC  45  40      SUBROUTINE GENER                    2 19 68              00268400\n      SUBROUTINE GENER                                                  00268500\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00268600\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00268700\n      DIMENSION ARGS(100)                                               00268800\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00268900\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00269000\nC     GENERATE                                                          00269100\nC         NARGS MUST BE .GE. 4 AND EVEN                                 00269200\n      IF( NARGS .GE. 4 .AND. MOD( NARGS, 2 ) .EQ. 0 ) GO TO 20          00269300\n      CALL ERROR (10)                                                   00269400\n      GO TO 200                                                         00269500\nC     GET STORAGE COLUMN ADDRESS                                        00269600\n  20  CALL ADRESS( NARGS, J )                                           00269700\n      IF( J .GT. 0 ) GO TO 30                                           00269800\n      CALL ERROR(3)                                                     00269900\n      GO TO 200                                                         00270000\n  30  IF( NERROR .NE. 0 ) GO TO 200                                     00270100\nC     CONVERT INTEGERS TO FLOATING POINT                                00270200\n      DO 40 I = 2, NARGS                                                00270300\n      IF( KIND( I-1 ) .EQ. 0 ) ARGS( I-1 ) = IARGS( I-1 )               00270400\n  40  CONTINUE                                                          00270500\n      RC( J ) = ARGS( 1 )                                               00270600\n      NDROW = J + NROW - 1                                              00270700\n      DO 130 I = 4, NARGS, 2                                            00270800\n      S = SIGN( 1., ARGS( I - 2 ) )                                     00270900\n      ENDER = ARGS( I - 1 ) - .01 * ARGS( I - 2 )                       00271000\n 100  J = J + 1                                                         00271100\n      RC( J ) = RC( J - 1 ) + ARGS( I - 2 )                             00271200\n      IF( S * ( RC( J ) - ENDER ) ) 110, 120, 120                       00271300\nC         NOT DONE                                                      00271400\n 110  IF( J .LT. NDROW ) GO TO 100                                      00271500\nC         EXCEEDED COLUMN LENGTH                                        00271600\n      CALL ERROR( 201 )                                                 00271700\n      GO TO 150                                                         00271800\nC         PASSES GENERATE UPPER BOUND, SET IN UPPER BOUND               00271900\n 120  RC( J ) = ARGS( I - 1 )                                           00272000\n 130  CONTINUE                                                          00272100\n 150  NRMAX = MAX0( NRMAX, J - NDROW + NROW )                           00272200\n 200  RETURN                                                            00272300\n      END                                                               00272400\nC  46  61      SUBROUTINE HEADS                    2 19 68              00272500\n      SUBROUTINE HEADS                                                  00272600\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00272700\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00272800\n      DIMENSION ARGS(100),NDIGIT(10)                                    00272900\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00273000\n      COMMON \/ HEADER\/NMCARD(72),ITLE(64,6),IHEAD(4,50),IFMT(17,6),     00273100\n     1 IFMTX(4),LNCNT,IPRINT,NPAGE,IPUNCH                               00273200\n      DIMENSION LHEAD(2,8),K(6)                                         00273300\n      DATA NDIGIT \/ 1H0,1H1,1H2,1H3,1H4,1H5,1H6,1H7,1H8,1H9 \/           00273400\n      DATA KOLUMN \/6HCOLUMN\/                                            00273500\n      DATA IBLANK \/ 1H  \/                                               00273600\nC                                                                       00273700\nC     THIS SUBROUTINE INSERTS THE HEADINGS OVER THE COLUMNS WHEN THE    00273800\nC     STANDARD FORMAT IS CALLED  FOR.                                   00273900\nC                                                                       00274000\nC                                                                       00274100\nC     THIS ROUTINE IS NON-STANDARD. IT HAS BEEN IMPLEMENTED HERE        00274200\nC     ASSUMING B5500 WORD SIZE                                          00274300\nC                                                                       00274400\nC     IN IARGS(51) THRU IARGS(NARGS+50) IS A LIST OF COLUMN NUMBERS.    00274500\nC     IF THE NUMBER IS .LE. 50, A 12-CHARACTER HEADING IS TO BE TAKEN   00274600\nC     FROM ARRAY IHEAD AS SETUP BY SUBROUTINE XHEAD. IF .GT. 50, THE    00274700\nC     HEADING   COLUMN XXXX    IS TO BE USED WHERE XXXX IS THE NUMBER,  00274800\nC     CONVERTED FOR DECIMAL PRINTOUT.  THE HEADINGS ARE TO BE PRINTED   00274900\nC     OVER THE DATA WHICH IS IN FORMAT  1P8E15.6                        00275000\nC     IF HEADING = 0, SETUP  COLUMN XXXX                                00275100\nC                                                                       00275200\n      NARGS = MIN0( NARGS, 8 )                                          00275300\n      DO 100 I = 1, NARGS                                               00275400\n      J = IARGS( I+50 )                                                 00275500\n      IF( J .GT. 50 ) GO TO 30                                          00275600\n      IF( IHEAD( 1, J ) .EQ. 0 ) GO TO 30                               00275700\n      LHEAD( 1, I ) = IHEAD( 1, J )                                     00275800\n      LHEAD( 2, I ) = IHEAD( 2, J )                                     00275900\n      GO TO 100                                                         00276000\nC                                                                       00276100\nC     GENERATE   COLUMN XXXX                                            00276200\nC                                                                       00276300\n   30 LHEAD(1,I)=KOLUMN                                                 00276400\n      LL=J                                                              00276500\n      DO 40 L=1,6                                                       00276600\n      K( L ) = LL \/ (10**(6-L ))                                        00276700\n      LL = LL - K( L ) * ( 10**(6-L) )                                  00276800\n   40 K( L ) = K( L ) + 1                                               00276900\n      KK = 0                                                            00277000\n      DO 45 L =1,6                                                      00277100\n      LL = K( L )                                                       00277200\n      IF ( LL .EQ. 1 .AND. KK .EQ. 0 ) GO TO 44                         00277300\n      KK = 1                                                            00277400\n      K( L ) = NDIGIT( LL )                                             00277500\n      GO TO 45                                                          00277600\n   44 K( L ) = IBLANK                                                   00277700\n   45 CONTINUE                                                          00277800\n      CALL PK5500(6,K,LHEAD(2,I))                                       00277900\n 100  CONTINUE                                                          00278000\n      WRITE( IPRINT, 200 ) ( ( LHEAD(I,J), I = 1,2),J=1,NARGS)          00278100\n  200 FORMAT(8(3X,2A6))                                                 00278200\n      RETURN                                                            00278300\n      END                                                               00278400\nC  47  95      SUBROUTINE IFS                      2 19 68              00278500\n      SUBROUTINE IFS                                                    00278600\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00278700\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00278800\n      DIMENSION ARGS(100)                                               00278900\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00279000\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00279100\n      COMMON \/ BLOCKX \/ INDEX( 6, 8 ), LEVEL                            00279200\n      DIMENSION II( 3 ), K( 3 ), NNN( 6 )                               00279300\n      EQUIVALENCE ( I1, II(1) ), ( I2, II(2) ), ( I3, II(3) )           00279400\nC                                                                       00279500\nC                 THIS COMMAND MAY APPEAR ONLY AS A STORED COMMAND.     00279600\nC                                                                       00279700\nC                                                                       00279800\nC     IFLT, IFEQ, IFGT, IFGE, IFNE, IFLE CORRESPOND TO L2 = 9, 14       00279900\nC                                                                       00280000\nC     COMMANDS MAY HAVE 2 OR 3 ARGUMENTS (ONLY IFEQ AND IFNE MAY HAVE 3)00280100\nC     ANY ARGUMENT MAY BE OF ANY TYPE, COLUMN NUMBER OR CONSTANT.       00280200\nC                                                                       00280300\nC     IN IFEQ AND IFNE THIRD ARG, IF GIVEN, IS TOLERANCE AND TEST GOES  00280400\nC                                                                       00280500\nC          I  ARG1-ARG2  I      I        I                              00280600\nC          I  ---------  I .LT. I  ARG3  I                              00280700\nC          I    ARG2     I      I        I                              00280800\nC                                                                       00280900\nC     IF NO TOLERANCE IS GIVEN, 0. IS ASSUMED                           00281000\nC     A GIVEN TOLERANCE IS IGNORED ON IFLT, IFLE, IFGT, IFGE            00281100\nC     EXAMPLES OF HOW COMMANDS READ.                                    00281200\nC     IFLT  8.32 LT EVERY ENTRY OF COL 34, CONDITION IS TRUE            00281300\nC     IFGE EACH ELEM COL 1 .GE. CORRESP. ELEM. COL 5, COND. IS TRUE     00281400\nC     IFEQ 2. .EQ. 5. CONDITION TRUE (USEFUL WHEN INCREMENTING ARGS. )  00281500\nC                                                                       00281600\nC     IF CONDITION IS FALSE, NO ACTION IS TAKEN.                        00281700\nC     IF CONDITION IS TRUE, THERE ARE TWO POSSIBILITIES..               00281800\nC     1.  IF THE TEST COMMAND IS THE LAST ONE IN THE REPEAT LOOP        00281900\nC         CURRENTLY BEING EXECUTED, THE LOOP IS TERMINATED (DROPPED     00282000\nC         BACK TO THE NEXT OUTER LEVEL IF MORE THAN ONE LEVEL DEEP).    00282100\nC     2.  IF THE TEST COMMAND IS NOT THE LAST ONE, ALL THAT HAPPENS IS  00282200\nC         THAT THE REST OF THE LOOP IS NOT PERFORMED.  THAT IS, IF THE  00282300\nC         LOOP COUNTER HAS NOT REACHED ITS UPPER  LIMIT, IT IS ADVANCED 00282400\nC         ONE AND THE LOOP IS BEGUN FROM THE TOP AGAIN.                 00282500\nC                                                                       00282600\n      IF( LEVEL .GT. 0 ) GO TO 10                                       00282700\n      CALL ERROR( 21 )                                                  00282800\n      GO TO 200                                                         00282900\n  10  IF( NARGS .EQ. 2 ) GO TO 30                                       00283000\n      IF( NARGS .EQ. 3 ) GO TO 25                                       00283100\n      CALL ERROR( 10 )                                                  00283200\n      GO TO 200                                                         00283300\n  20  CALL ERROR( 11 )                                                  00283400\n      GO TO 200                                                         00283500\n  25  IF( L2 .EQ. 10 .OR. L2 .EQ. 13 ) GO TO 30                         00283600\n      CALL ERROR( 212 )                                                 00283700\n      NARGS = 2                                                         00283800\n  30  DO 50 I = 1, NARGS                                                00283900\n      CALL ADRESS( I, II( I ) )                                         00284000\n      IF( II( I ) ) 40, 20, 50                                          00284100\n  40  II( I ) = -II( I )                                                00284200\n  50  K( I ) = 1 - KIND( I )                                            00284300\n      IF( NRMAX.NE.0 .OR. KIND(1)+KIND(2).EQ.2 ) IF( NERROR ) 200,60,20000284400\n      CALL ERROR( 9 )                                                   00284500\n      GO TO 200                                                         00284600\n  60  NNN( 4 ) = 0                                                      00284700\n      NNN( 5 ) = 0                                                      00284800\n      NNN( 6 ) = 0                                                      00284900\n      DO 110 I = 1, NRMAX                                               00285000\n      IF( NARGS .EQ. 2 ) GO TO 65                                       00285100\nC     CHECK EQ,NE WITHIN BOUNDS                                         00285200\n      IF( ABS(RC(I1)\/RC(I2)-1.).LT.ABS(RC(I3)) ) NNN( 5 ) = NNN( 5 ) + 100285300\n      I3 = I3 + K( 3 )                                                  00285400\n      GO TO 100                                                         00285500\nC     CHECK IFS WITHOUT BOUNDS                                          00285600\n  65  IF( RC( I1 ) - RC( I2 ) ) 70, 80, 90                              00285700\n  70  NNN( 4 ) = NNN( 4 ) + 1                                           00285800\n      GO TO 100                                                         00285900\n  80  NNN( 5 ) = NNN( 5 ) + 1                                           00286000\n      GO TO 100                                                         00286100\n  90  NNN( 6 ) = NNN( 6 ) + 1                                           00286200\n 100  I1 = I1 + K( 1 )                                                  00286300\n 110  I2 = I2 + K( 2 )                                                  00286400\n      NNN( 1 ) = NNN( 5 ) + NNN( 6 )                                    00286500\n      NNN( 2 ) = NNN( 4 ) + NNN( 6 )                                    00286600\n      NNN( 3 ) = NNN( 4 ) + NNN( 5 )                                    00286700\n      IF( NARGS .NE. 2 ) NNN( 2 ) = NRMAX - NNN( 5 )                    00286800\n      IF(NNN(L2-8).EQ.0) IF(INDEX(2,LEVEL)-INDEX(3,LEVEL))210,210,220   00286900\n 200  RETURN                                                            00287000\nC                                                                       00287100\nC     IF-COMMAND NOT AT END OF PERFORM LOOP, ADVANCE LOOP COUNT.        00287200\nC                                                                       00287300\n 210  INDEX( 2, LEVEL ) = INDEX( 3, LEVEL ) + 1                         00287400\n      GO TO 200                                                         00287500\nC                                                                       00287600\nC     IF-COMMAND IS AT END OF PERFORM LOOP, TERMINATE LOOP.             00287700\nC                                                                       00287800\n 220  LEVEL = LEVEL - 1                                                 00287900\n      GO TO 200                                                         00288000\n      END                                                               00288100\nC  48  26      SUBROUTINE INPUT                    2 19 68              00288200\n      SUBROUTINE INPUT                                                  00288300\n      COMMON \/ BLOCKA\/MODE,M,KARD(83),KARG,ARG,ARG2,NEWCD(80),KRDEND    00288400\n      COMMON \/BLOCKB\/NSTMT,NSTMTX,NSTMTH,NCOM,LCOM,IOVFL,COM(2000)      00288500\n      COMMON \/BLOCKC\/KIO,INUNIT,ISCRAT,KBDOUT,KRDKNT                    00288600\nC                                                                       00288700\nC     THIS ROUTINE HANDLES THE READING OF INPUT RECORDS.                00288800\nC     IF KIO = 0, INPUT IS CARD IMAGE FROM CARD READER OR TAPE.         00288900\nC     IF KIO = 1, INPUT IS REAL-TIME FROM A KEYBOARD.                   00289000\nC                                                                       00289100\n      KRDKNT=KRDKNT+1                                                   00289200\n      IF(KIO.EQ.0)GO TO 20                                              00289300\n      IF(MODE.EQ.3)GO TO 10                                             00289400\n      WRITE(KBDOUT,5)                                                   00289500\n   5  FORMAT(9H READY   )                                               00289600\n      GO TO 20                                                          00289700\n  10  WRITE(KBDOUT,15)NSTMT                                             00289800\n  15  FORMAT(9H READY   ,I3,3H \/ )                                      00289900\n      GO TO 20                                                          00290000\n  20  READ(INUNIT,25)NEWCD                                              00290100\n  25  FORMAT(80A1)                                                      00290200\n  50  KARD(1)=0                                                         00290300\n      KARD(2)=0                                                         00290400\n      KARD( KRDEND+3 ) = 46                                             00290500\n      CALL OMCONV( NEWCD, KARD(3), KRDEND )                             00290600\n      RETURN                                                            00290700\n      END                                                               00290800\nC  49  79      SUBROUTINE INVCHK(A,M,N,AINV,M1,Y,  2 19 68              00290900\n      SUBROUTINE INVCHK(A,M,N,AINV,M1,Y,L2,ERR,IND)                     00291000\nC     INVCHK FOR OMNITAB  UNIVAC 1108   S. PEAVY  5\/24\/67               00291100\nC     THIS SUBROUTINE INVERTS A MATRIX AND PROVIDES ALL THE CHECKS DESCR00291200\nC     IN PAC-1                                                          00291300\nC                                                                       00291400\nC     A IS THE MATRIX TO BE INVERTED                                    00291500\nC                                                                       00291600\nC     M IS THE SIZE OF A AS DIMENSIONED IN THE CALLING PROGRAM  A(M,M)  00291700\nC                                                                       00291800\nC     N IS THE SIZE OF A TO BE INVERTED                                 00291900\nC       N LESS THAN OR =M-1                                             00292000\nC                                                                       00292100\nC     AINV WILL CONTAIN THE INVERTED MATRIX IF INVERSION IS OBTAINABLE  00292200\nC                                                                       00292300\nC     M1 IS THE SIZE OF AINV AS DIMENSIONED IN THE CALLING PROGRAM      00292400\nC        AINV(M1,2*M1)       M1 MUST BE GREATER OR =N+1                 00292500\nC        AINV MUST HAVE TWICE AS MANY COLUMNS AS ROWS                   00292600\nC        A AND AINV CANNOT BE SAME OR EQUIVALENT                        00292700\nC                                                                       00292800\nC     ERR  WILL CONTAIN THE 3 WAYS OF EVALUATING NORM CHECKS            00292900\nC        ERR IS  A DIMENSIONED AS ERR(3)                                00293000\nC                                                                       00293100\nC     IND IS AN INDICATOR                                               00293200\nC        IND=0  MATRIX INVERTED AND ERROR CHECKS MADE                   00293300\nC        IND=1  MATRIX SINGULAR                                         00293400\nC                                                                       00293500\nC     COLUMN  AINV(N+1,I)   I=1,...,N  WILL CONTAIN THE ERROR BOUND OF  00293600\nC     THE SUM CHECKS+1.                                                 00293700\nC                                                                       00293800\n      DIMENSION A(M,M),AINV(M1,M1),ERR(3),ANORM(2,3)                    00293900\n      DIMENSION Y(N)                                                    00294000\n      DATA ZERO\/0.0\/,ONE\/1.0\/                                           00294100\n    5 NA=N                                                              00294200\n   8  DO  10  I=1,NA                                                    00294300\n      DO  10  J=1,NA                                                    00294400\n  10  AINV(J,I)=A(J,I)                                                  00294500\n      NB=NA                                                             00294600\n      IF (L2.EQ.1) GO TO 11                                             00294700\n      NB=NB+1                                                           00294800\n      DO  3   I=1,NA                                                    00294900\n      AINV(I,NA+1)=Y(I)                                                 00295000\n    3 AINV(NA+1,I)=ZERO                                                 00295100\n      AINV(NA+1,NA+1)=-ONE                                              00295200\n      NA=NA+1                                                           00295300\n  11  DO  13  I=1,NA                                                    00295400\n      SUM=ZERO                                                          00295500\n      AINV(NA+1,I)=ZERO                                                 00295600\n      DO  12  J=1,NA                                                    00295700\n  12  SUM=SUM+AINV(I,J)                                                 00295800\n  13  AINV(I,NA+1)=-SUM                                                 00295900\n      AINV(NA+1,NA+1)=ONE                                               00296000\n      NB=NB+1                                                           00296100\n  15  CALL SPINV(AINV,NB,M1,IND)                                        00296200\n      IF(IND.NE.0) RETURN                                               00296300\n   90 DO 170 K=1,2                                                      00296400\n      DO 100 I=1,3                                                      00296500\n  100 ANORM(K,I)=ZERO                                                   00296600\n      DO 160 I=1,N                                                      00296700\n      SUM=ZERO                                                          00296800\n      DO 150 J=1,N                                                      00296900\n      GO TO (110,120),K                                                 00297000\n  110 TEMP= ABS(AINV(I,J))                                              00297100\n      GO TO 140                                                         00297200\n  120 TEMP=ZERO                                                         00297300\n      DO 130 L=1,N                                                      00297400\n  130 TEMP=TEMP+A(I,L)*AINV(L,J)                                        00297500\n      IF(I.EQ.J) TEMP=ONE-TEMP                                          00297600\n      TEMP= ABS(TEMP)                                                   00297700\n  140 ANORM(K,1)=ANORM(K,1)+TEMP**2                                     00297800\n      IF(ANORM(K,2).LT.TEMP) ANORM(K,2)=TEMP                            00297900\n  150 SUM=SUM+TEMP                                                      00298000\n      IF(ANORM(K,3).LT.SUM) ANORM(K,3)=SUM                              00298100\n  160 CONTINUE                                                          00298200\n      ANORM(K,1)=FSQRT(ANORM(K,1))                                      00298300\n  170 ANORM(K,2)=FLOAT(N)* ANORM(K,2)                                   00298400\n      DO 180 K=1,3                                                      00298500\n  180 ERR(K)=(ANORM(1,K)*ANORM(2,K))\/(1.  -ANORM(2,K))                  00298600\n  190 RETURN                                                            00298700\n      END                                                               00298800\nC  50  90      SUBROUTINE INVERT                   2 19 68              00298900\n      SUBROUTINE INVERT                                                 00299000\nC**** MATRIX INVERSION, SOLUTION OF SYSTEM OF EQUATIONS                 00299100\nC**** S PEAVY   5\/22\/67                                                 00299200\nC**** MINVERT  (+++,+++)  SIZE +++,+++ STORE (+++,+++)                  00299300\nC**** MINVERT  (+++,+++)  SIZE +++  STORE (+++,+++)                     00299400\nC**** SOLVE    (+++,+++,)  SIZE +++,+++  Y VECTOR +++ STORE +++         00299500\nC**** SOLVE    (+++,+++)  SIZE +++  Y VECTOR +++  STORE +++             00299600\nC**** LARGEST MATRIX TO BE INVERTED OR SYSTEM TO BE SOLVED IS 50        00299700\nC****                                                                   00299800\nC**** L2=1   INVERT                                                     00299900\nC**** L2=2   SOLVE                                                      00300000\n      COMMON \/ HEADER\/NMCARD(72),ITLE(64,6),IHEAD(4,50),IFMT(17,6),     00300100\n     1 IFMTX(4),LNCNT,IPRINT,NPAGE,IPUNCH                               00300200\n      COMMON \/ SCRAT \/ A(10000),NS                                      00300300\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00300400\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00300500\n     ONROW,                                                             00300600\n     1NCOL,NARGS,VWXYZ(8),NERROR                                        00300700\n      DIMENSION ARGS(100)                                               00300800\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00300900\n      COMMON \/BLOCKC\/KIO,INUNIT,ISCRAT,KBDOUT,KRDKNT                    00301000\n      DIMENSION IR(4),ERR(3)                                            00301100\n      IF(NARGS.EQ.6.OR.NARGS.EQ.5) GO TO 1200                           00301200\n      CALL ERROR(10)                                                    00301300\n      RETURN                                                            00301400\n 1200 J=NARGS                                                           00301500\n      CALL CKIND (J)                                                    00301600\n      IF(J.NE.0) GO TO 200                                              00301700\n      IF (NARGS.EQ.5) GO TO 90                                          00301800\n      IF (IARGS(3).NE.IARGS(4)) GO TO 210                               00301900\n   90 IR(1)=IARGS(1)                                                    00302000\n      IR(2)=IARGS(2)                                                    00302100\n      IR(3)=IARGS(3)                                                    00302200\n      IR(4)=IARGS(3)                                                    00302300\n      CALL MACHK (IR,J)                                                 00302400\n      IF(J.NE.0) CALL ERROR(17)                                         00302500\n      IF(L2.EQ.2) GO TO 95                                              00302600\n      IR(1)=IARGS(NARGS-1)                                              00302700\n      IR(2)=IARGS(NARGS)                                                00302800\n      CALL MACHK(IR,J)                                                  00302900\n      IF(J.NE.0) CALL ERROR(17)                                         00303000\n   95 IF(2*((IARGS(3)+2)**2).GT.NS ) GO TO 230                          00303100\n      IF(NERROR.NE.0) RETURN                                            00303200\n      CALL ADRESS(2,J)                                                  00303300\n      JA=J+IARGS(1)-1                                                   00303400\n      M1=IARGS(3)+1                                                     00303500\n      IF(L2.EQ.2) M1=M1+1                                               00303600\n      CALL ADRESS(NARGS-1,JC)                                           00303700\n      CALL ADRESS(NARGS  ,JB)                                           00303800\n      CALL INVCHK(RC(JA),NROW,IARGS(3),A,M1,RC(JC),L2,ERR,IND)          00303900\nC**** CHECK TO SEE IF MATRIX WAS INVERTED. YES, IF IND=0                00304000\n      IF(IND.NE.0) GO TO 240                                            00304100\n      IA=IARGS(3)                                                       00304200\n      IF(L2.EQ.2) GO TO 130                                             00304300\nC**** STORE INVERTED MATRIX                                             00304400\n      JB=JB+IARGS(NARGS-1)-1                                            00304500\n      DO 110  I=1,IA                                                    00304600\n      JC=JB                                                             00304700\n      JD=(I-1)*M1+1                                                     00304800\n      DO 100 J=1,IA                                                     00304900\n      RC(JC)=A(JD)                                                      00305000\n      JC=JC+1                                                           00305100\n  100 JD=JD+1                                                           00305200\n  110 JB=JB+NROW                                                        00305300\n      GO TO 150                                                         00305400\nC**** STORE RESULTS OF SOLUTION                                         00305500\n  130 JC=M1*IARGS(3)+1                                                  00305600\n      CALL ADRESS(NARGS,J)                                              00305700\n      DO  140 I=1,IA                                                    00305800\n      RC(J)=A(JC)                                                       00305900\n      JC=JC+1                                                           00306000\n  140 J=J+1                                                             00306100\nC**** DETERMINE SMALLEST ERROR BOUND                                    00306200\n  150 SERR = AMIN1( ERR( 1 ), ERR( 2 ), ERR( 3 ) )                      00306300\n      WRITE(ISCRAT,160) SERR                                            00306400\n  160 FORMAT(6X,20(1H+),43H SMALLEST ERROR BOUND ON INVERTED MATRIX IS, 00306500\n     1E8.1,7H   ++++)                                                   00306600\n      RETURN                                                            00306700\n  200 CALL ERROR(3)                                                     00306800\n      RETURN                                                            00306900\n  210 CALL ERROR(210)                                                   00307000\nC**** PRINT ROW AND COLUMNS DO NOT AGREE,SIZE OF COLUMNS IS SET TO ROW  00307100\n      GO TO 90                                                          00307200\n 230  CALL ERROR( 23 )                                                  00307300\nC**** PRINT MATRIX TOO LARGE TO INVERT                                  00307400\n      RETURN                                                            00307500\n  240 CALL ERROR(22)                                                    00307600\nC**** PRINT MATRIX IS SINGULAR OR NEAR SINGULAR-NO INVERSE              00307700\n      RETURN                                                            00307800\n      END                                                               00307900\nC  51  18      FUNCTION LOCATE( L )                2 19 68              00308000\n      FUNCTION LOCATE( L )                                              00308100\n      COMMON \/BLOCKB\/NSTMT,NSTMTX,NSTMTH,NCOM,LCOM,IOVFL,COM(2000)      00308200\nC                                                                       00308300\nC     THIS FUNCTION SEARCHES THE LIST OF STORED COMMANDS TO SEE IF ONE  00308400\nC     WITH STATEMENT NUMBER L EXISTS.  IF IT DOES, RETURN ITS LOCATION. 00308500\nC     IF IT DOESN\"T EXIST, RETURN NEGATIVE THE LOCATION OF THE NEXT     00308600\nC     HIGHER STATEMENT NUMBER.                                          00308700\nC                                                                       00308800\n      I = 1                                                             00308900\n      AL = L                                                            00309000\n  10  IF( COM( I ) - AL ) 20, 30, 40                                    00309100\n   20 I = I + IFIX( COM( I+1) )                                         00309200\n      GO TO 10                                                          00309300\n   30 LOCATE = I                                                        00309400\n      GO TO 50                                                          00309500\n   40 LOCATE = -I                                                       00309600\n   50 RETURN                                                            00309700\n      END                                                               00309800\nC  52 420      SUBROUTINE LOOKUP                   2 19 68              00309900\n      SUBROUTINE LOOKUP                                                 00310000\n      DIMENSION NOUT(6),NO(4),IG(40),JF(50),IR(16),N(14),IO(28),IS(28), 00310100\n     1 MA(18),MM(10),MB(24),JS(12),JT(10),JZ(34),MZ(20),MJ(28),LB(10),  00310200\n     2 LD(6),MX(3),NX(10)                                               00310300\n      DIMENSION MV(16)                                                  00310400\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00310500\nC                                                                       00310600\n      DATA N(1),N(2),N(3),N(4),N(5),N(6),N(7),N(8),N(9),N(10),N(11),    00310700\n     1 N(12),N(13),N(14)\/10705,2604,16038,16767,17496,18225,18954,1377, 00310800\n     2 15001,5*0\/                                                       00310900\n      DATA NOUT(1),NOUT(2),NOUT(3),NOUT(4),NOUT(5),NOUT(6) \/ 729, 1458, 00311000\n     1 2187,2916, 3645, 4374 \/                                          00311100\nC                                                                       00311200\nC     SUMMARY,LIST                                                      00311300\nC                                                                       00311400\n      DATA NO(1),NO(2),NO(3),NO(4)\/14431,9522,9010,14580\/               00311500\nC                                                                       00311600\nC     SIN,COS,TAN,COT\/ARCSIN,ARCCOS,ARCTAN,ARCCOT\/SIND,COSD,TAND,COSD\/  00311700\nC     ASIND,ACOSD,ATAND,ACOTD\/ASIN,ACOS,ATAN,ACOT\/                      00311800\nC                                                                       00311900\n      DATA IG(1),IG(2),IG(3),IG(4),IG(5),IG(6),IG(7),IG(8)\/14108,0,2611,00312000\n     1 0,14621,0,2612,0\/                                                00312100\n      DATA IG(9),IG(10),IG(11),IG(12),IG(13),IG(14),IG(15),IG(16)\/1218, 00312200\n     1 14108,1218,2611,1218,14621,1218,2612\/                            00312300\n      DATA IG(17),IG(18),IG(19),IG(20),IG(21),IG(22),IG(23),IG(24)\/     00312400\n     1 14108,2916,2611,2916,14621,2916,2612,2916\/                       00312500\n      DATA IG(25),IG(26),IG(27),IG(28),IG(29),IG(30),IG(31),IG(32)\/1251,00312600\n     1 10314,825,13959,1270,10314,825,14688\/                            00312700\n      DATA IG(33),IG(34),IG(35),IG(36),IG(37),IG(38),IG(39),IG(40)\/1251,00312800\n     1 10206,825,13851,1270,10206,825,14580\/                            00312900\nC                                                                       00313000\nC     ABS,ABSOLUTE,SQRT,EXP,EXPONENT,NEGEXP,LOG,LOGE,LOGTEN,ANTILOG\/    00313100\nC                                                                       00313200\n      DATA JF(1),JF(2),JF(3),JF(4),JF(5),JF(6),JF(7),JF(8),JF(9),JF(10),00313300\n     1 JF(11),JF(12),JF(13),JF(14),JF(15),JF(16),JF(17),JF(18),JF(19),  00313400\n     2 JF(20)\/                                                          00313500\n     3 802,0,802,11280,14328,14580,4309,0,4309,11318,10348,4309,9160,0, 00313600\n     4 9160,3645,9160,14729,1127,6900\/                                  00313700\nC                                                                       00313800\nC     SINH,COSH,TANH,COTH \/ASINH,ACOSH,ATANH,ACOTH,DEVNOR,INTEGER,      00313900\nC     FRACTIONAL\/                                                       00314000\nC                                                                       00314100\n      DATA JF(21),JF(22),JF(23),JF(24),JF(25),JF(26),JF(27),JF(28)\/     00314200\n     1 14108,5832,2611,5832,14621,5832,2612,5832\/                       00314300\n      DATA JF(29),JF(30),JF(31),JF(32),JF(33),JF(34),JF(35),JF(36),     00314400\n     * JF(37),JF(38),JF(39),JF(40),JF(41),JF(42) \/                      00314500\n     1 1251,10422,825,14067,1270,10422,825,14796,3073,10629,6959,3839,  00314600\n     2 4861,2736 \/                                                      00314700\nC                                                                       00314800\nC     ADD,SUB,MULT,DIV,RAISE,SUBTRA,MULTIPLY,DIVIDE\/                    00314900\nC                                                                       00315000\n      DATA IR(1),IR(2),IR(3),IR(4),IR(5),IR(6),IR(7),IR(8),IR(9),IR(10),00315100\n     1 IR(11),IR(12),IR(13),IR(14),IR(15),IR(16)\/841,0,14420,0,10056,   00315200\n     2 14580,3181,0,13158,13986,14420,15067,10056,14839,3181,6674\/      00315300\nC                                                                       00315400\nC     GENERATE,SET,  ...  ETC.                                          00315500\nC                                                                       00315600\n      DATA (IO(I),I=1,28)\/ 5252,4132,14006,0,4641,3753,4713,1278,12003, 00315700\n     1 14580,10630,15673,14431,9522,10364,11698,14284,2322,2395,0,9793, 00315800\n     2  729,9793,0,11698,3645,5590,11880\/                               00315900\n                                                                        00316000\n                                                                        00316100\nC                                                                       00316200\nC     BEGIN,SCAN,REPEAT,EXECUTE,PERFORM,INCREMENT,INDEX,RESTORE         00316300\nC     IFLT,IFEQ,IFGT,IFGE,IFNE,IFLE                                     00316400\nC                                                                       00316500\n      DATA IS(1),IS(2),IS(3),IS(4),IS(5),IS(6),IS(7),IS(8),IS(9),IS(10),00316600\n     1 IS(11),IS(12),IS(13),IS(14),IS(15),IS(16),IS(17),IS(18),IS(19),  00316700\n     2 IS(20),IS(21),IS(22),IS(23),IS(24),IS(25),IS(26),IS(27),IS(28) \/ 00316800\n     3 1600,6939,13933,10206,13273,3692,4298,2774,11817,4797,6942,13270,00316900\n     4 6943,4293,13276,15003,6735,14580,6728,12393,6730,14580,6730,3645,00317000\n     5 6737, 3645, 6735, 3645 \/                                         00317100\nC                                                                       00317200\nC     MDEFINE,ADEFINE,AERASE,MIDENT,ADIAG,MDIAG,MZERO,AZERO,MERASE      00317300\nC                                                                       00317400\n      DATA MA(1),MA(2),MA(3),MA(4),MA(5),MA(6),MA(7),MA(8),             00317500\n     1     MA(9),MA(10),MA(11),MA(12),MA(13),MA(14),MA(15),MA(16),      00317600\n     2 MA(17),MA(18) \/ 9590, 4631,                                      00317700\n     3 842, 4631, 882, 1247, 9724, 4043, 846, 918,                      00317800\n     4 9594, 918, 10184, 13527, 1436, 13527, 9630, 1247 \/               00317900\nC                                                                       00318000\nC     MINVERT,LINEAR,INVERT                                             00318100\nC     MMULT,MRAISE                                                      00318200\nC                                                                       00318300\n      DATA MM(1),MM(2),MM(3),MM(4),MM(5),MM(6),MM(7),MM(8),MM(9),MM(10)\/00318400\n     1 9734, 16191, 9005, 3690, 6961, 4151, 9849, 9288, 9964, 7079 \/    00318500\nC                                                                       00318600\nC     MADD,MSUB,MTRANS,AADD,ASUB,AMULT,ADIVIDE,ARAISE,ATRANS,SCALAR,    00318700\nC     ASCALAR,MSCALAR                                                   00318800\nC                                                                       00318900\n      DATA MB(1),MB(2),MB(3),MB(4),MB(5),MB(6),MB(7),MB(8) \/            00319000\n     1 9508, 2916, 10011, 1458, 10035, 1126, 760, 2916 \/                00319100\n      DATA MB(9),MB(10),MB(11),MB(12),MB(13),MB(14),MB(15),MB(16) \/     00319200\n     1 1263, 1458, 1101, 9288, 846, 16285, 1216, 7079 \/                 00319300\n      DATA MB(17), MB(18), MB(19), MB(20), MB(21), MB(22),MB(23),MB(24)\/00319400\n     1 1287, 1126,13933, 8793, 1245, 1054, 9993, 1054 \/                 00319500\nC                                                                       00319600\nC     NLSUB,LSUB,HSUB,USUB,PSUB,TSUB                                    00319700\nC                                                                       00319800\n      DATA JS(1),JS(2),JS(3),JS(4),JS(5),JS(6),JS(7),JS(8),JS(9),JS(10),00319900\n     1 JS(11),JS(12) \/ 10549, 15363, 9282, 1458, 6366, 1458, 15843,     00320000\n     2 1458, 12198, 1458, 15114, 1458 \/                                 00320100\nC                                                                       00320200\nC    PARSUM,PARPROD,RMS,AVERAGE,SUM                                     00320300\nC                                                                       00320400\n      DATA JT(1),JT(2),JT(3),JT(4),JT(5),JT(6),JT(7),JT(8),JT(9),JT(10)\/00320500\n     1 11709, 14431, 11709, 12165, 13492, 0, 1328, 13156, 14431, 0 \/    00320600\nC                                                                       00320700\nC     ROWSUM,PRODUCT,DEFINE,      ,MAX,MAXIMUM,MIN,MINIMUM,SORT,ORDER,  00320800\nC     ERASE,EXCHANGE,FLIP,CHANGE,HIERARCHY  L1=21, L2 = 1, 14           00320900\nC                                                                       00321000\n      DATA JZ( 1),JZ( 2),JZ( 3),JZ( 4),JZ( 5),JZ( 6),JZ( 7),JZ( 8) \/    00321100\n     1 13550, 14431, 12165, 3486, 3057, 6944, 9528, 0 \/                 00321200\n      DATA JZ( 9),JZ(10),JZ(11),JZ(12),JZ(13),JZ(14),JZ(15),JZ(16) \/    00321300\n     1 9528, 6933, 9734, 0, 9734, 6933, 14274, 14580 \/                  00321400\n      DATA JZ(17),JZ(18),JZ(19),JZ(20),JZ(21),JZ(22),JZ(23),JZ(24),     00321500\n     1 JZ(25),JZ(26) \/ 11425, 4131, 4132, 13986, 4296, 5873, 4707,      00321600\n     2 11664, 2404, 10400 \/                                             00321700\n      DATA JZ(27),JZ(28),JZ(29),JZ(30),JZ(31),JZ(32),JZ(33),JZ(34) \/    00321800\n     1 6080, 13167, 9010, 14580, 10623, 7094, 10785, 8748 \/             00321900\nC                                                                       00322000\nC     POLYFIT,SPOLYFIT,FIT,SFIT,SOLVE,SSOLVE                            00322100\nC                                                                       00322200\n      DATA MZ(1),MZ(2),MZ(3),MZ(4),MZ(5),MZ(6),MZ(7),MZ(8),MZ(9),MZ(10),00322300\n     1 MZ(11),MZ(12) \/ 12081,18396,14298,9429,4637,0,14022,14580,14268, 00322400\n     2 16173, 14379, 9347 \/                                             00322500\nC                                                                       00322600\nC     CLOSE,COUNT,SHORTEN,EXPAND,DUPLICATE,MOVE,BLOCKTRANSFER,AMOVE,    00322700\nC     MMOVE,PROMOTE,DEMOTE,DIMENSION,SEPARATE,INSERT                    00322800\nC                                                                       00322900\n      DATA MJ(1),MJ(2),MJ(3),MJ(4),MJ(5),MJ(6),MJ(7),MJ(8),MJ(9),MJ(10),00323000\n     1 MJ(11),MJ(12),MJ(13),MJ(14),MJ(15),MJ(16),MJ(17),MJ(18),MJ(19),  00323100\n     2 MJ(20),MJ(21),MJ(22),MJ(23),MJ(24),MJ(25),MJ(26),MJ(27),MJ(28) \/ 00323200\n     3 2526, 13986, 2613, 10746, 14082,                                 00323300\n     4 13667,4309,1111,3499,8994,9904,3645,1797,2504,                   00323400\n     5 1095,16173,9843,16173,12165,9902,3064,                           00323500\n     6 11480,3172,4042,14002,1216,6958,4151 \/                           00323600\nC                                                                       00323700\nC     STATIS,SSTATIS,FORGIVE,CHECK,FPROB                                00323800\nC                                                                       00323900\n      DATA LB(1),LB(2),LB(3),LB(4),LB(5),LB(6),LB(7),LB(8),LB(9),LB(10)\/00324000\n     1 14392,14842,14384,1278,4797,5368,2408,2484,4824,10989 \/          00324100\nC                                                                       00324200\nC     SELECT,SEARCH,CENSOR                                              00324300\nC                                                                       00324400\n      DATA LD(1),LD(2),LD(3),LD(4),LD(5),LD(6) \/                        00324500\n     1 13998, 3746, 13987, 13211, 2336, 14274 \/                         00324600\nC                                                                       00324700\nC     XX, X, XAX      FOR M(XX\"), M(X\"X), M(XAX\") AND M(X\"AX)           00324800\nC                                                                       00324900\n      DATA MX(1), MX(2), MX(3) \/ 18144, 17496, 17547 \/                  00325000\nC                                                                       00325100\nC      YATES                                                            00325200\nC                                                                       00325300\n      DATA NX(1),NX(2) \/18272,4158\/                                     00325400\nC                                                                       00325500\nC                                                                       00325600\nC     MVECDIAG,AVECDIAG,MVECMAT,AVECMAT,MMATVEC,AARRVEC,MPRINT,APRINT   00325700\nC                                                                       00325800\n      DATA MV(1),MV(2),MV(3),MV(4),MV(5),MV(6),MV(7),MV(8),MV(9),MV(10),00325900\n     1 MV(11),MV(12),MV(13),MV(14),MV(15),MV(16) \/ 10076,2304,1328,2304,00326000\n     2 10076,2539,1328,2232,9829,15179,774,13721,9927,6959,1179,6959 \/  00326100\nC*-.-*-.-*-.-*-.-*-.-*-.-*-.-*-.-*-.-*-.-*-.-*-.-*-.-*-.-*-.-*-.-*-.-*C 00326200\nC                                                                       00326300\nC     CHECK NAMES WITH QUALIFIERS FIRST                                 00326400\nC                                                                       00326500\nC                                                                       00326600\nC     RESET     (NRMAX,COLTOP,V,W,X,Y,Z)  L1=1, L2=1,7                  00326700\nC                                                                       00326800\n      IF(NAME(1).NE.13276.OR.NAME(2).NE.4185)GO TO 110                  00326900\n      DO 104 K=2,7                                                      00327000\n      I=K                                                               00327100\n      IF(NAME(3).EQ.N(I).AND.NAME(4).EQ.N(I+7))GO TO 106                00327200\n 104  CONTINUE                                                          00327300\n      I=1                                                               00327400\n 106  L1=1                                                              00327500\n      L2=I                                                              00327600\n      GO TO 900                                                         00327700\nC                                                                       00327800\nC     PRINT     (A,B,C,D,E,F)     A = STANDARD FORMAT  L1=2, L2=1,6     00327900\nC                                                                       00328000\n 110  IF(NAME(1).NE.12159.OR.NAME(2).NE.10746)GO TO 120                 00328100\n      L1=2                                                              00328200\n      GO TO 122                                                         00328300\nC                                                                       00328400\nC     PUNCH     (A,B,C,D,E,F)     L1=3, L2=1,6                          00328500\nC                                                                       00328600\n 120  IF(NAME(1).NE.12245.OR.NAME(2).NE.2403)GO TO 130                  00328700\n      L1=3                                                              00328800\n 122  DO 124 L9 = 2, 7                                                  00328900\n      L2=L9                                                             00329000\n      IF( NAME( 3 ) .EQ. NOUT( L2-1 ) ) GO TO 900                       00329100\n 124  CONTINUE                                                          00329200\n      L2 = 1                                                            00329300\n      GO TO 900                                                         00329400\nC                                                                       00329500\nC     NO        (SUMMARY,LIST)         L1=4, L2 = 1,2                   00329600\nC                                                                       00329700\n 130  IF(NAME(1).NE.10611)GO TO 140                                     00329800\n      L1=4                                                              00329900\n      DO 134 K=2,4,2                                                    00330000\n      I=K                                                               00330100\n      IF(NAME(3).EQ.NO(I-1).AND.NAME(4).EQ.NO(I))GO TO 136              00330200\n 134  CONTINUE                                                          00330300\n      GO TO 899                                                         00330400\n 136  L2=I\/2                                                            00330500\n      GO TO 900                                                         00330600\nC                                                                       00330700\nC     READ (A,B,C,D,E,F)                           L1 = 5, L2 = 1, 7    00330800\nC                                                                       00330900\n 140  IF(NAME(1).NE.13258.OR.NAME(2).NE.2916) GO TO 150                 00331000\n      L1 = 5                                                            00331100\n      GO TO 122                                                         00331200\nC                                                                       00331300\nC     ABRIDGE (A,B,C,D,E,F)                        L1 = 6, L2 = 1, 7    00331400\nC                                                                       00331500\n 150  IF(NAME(1).NE.801.OR.NAME(2).NE.6676) GO TO 160                   00331600\n      L1 = 6                                                            00331700\n      GO TO 122                                                         00331800\nC                                                                       00331900\nC     DUMMY (A,B,C,D,E,F)                          L1 = 7, L2 = 1, 7    00332000\nC                                                                       00332100\n 160  IF(NAME(1).NE.3496.OR.NAME(2).NE.10152) GO TO 170                 00332200\n      L1 = 7                                                            00332300\n      GO TO 122                                                         00332400\nC                                                                       00332500\nC                                        THESE NAMES ARE TREATED AS     00332600\nC     M(XX\"), M(X\"X), M(XAX\"), M(X\"AX)   SPECIAL CASED BY OMNITAB.      00332700\nC                                        M(X\"X) IS EQUIVALENT TO M X    00332800\nC                                        AND THE \" IS IGNORED, ETC.     00332900\nC                                                                       00333000\n 170  IF( NAME( 1) .NE. 9477 ) GO TO 180                                00333100\n      L1 = 8                                                            00333200\n      DO 174 L9 = 1, 3                                                  00333300\n      L2=L9                                                             00333400\n      IF( NAME(3) .EQ. MX(L2) ) GO TO 900                               00333500\n 174  CONTINUE                                                          00333600\n      GO TO 899                                                         00333700\nC                                                                       00333800\nC     MVECDIAG,AVECDIAG,MVECMAT,AVECMAT,MMATVEC,AARRVEC,MPRINT,APRINT   00333900\nC       APRINT AND MPRINT HAVE OPTIONS A,B,C,D,E,F                      00334000\nC                                                                       00334100\n  180 DO 184 L2 = 2, 9                                                  00334200\n      IF(NAME(1).EQ.MV(2*L2-3).AND.NAME(2).EQ.MV(2*L2-2)) GO TO 186     00334300\n  184 CONTINUE                                                          00334400\n      GO TO 190                                                         00334500\n  186 L2 = L2 \/ 2                                                       00334600\n      L1 = 27                                                           00334700\n      IF(L2 .NE. 4 ) GO TO 900                                          00334800\n      L1 = 9                                                            00334900\n      GO TO 122                                                         00335000\n  190 CONTINUE                                                          00335100\nC                                                                       00335200\nC     ADD,SUB,MULT,DIV,RAISE,SUBTRA,MULTIP,DIVIDE   L1 = 11, L2 = 1, 5  00335300\nC                                                                       00335400\n 200  DO 204 K=2,16,2                                                   00335500\n      I=K                                                               00335600\n      IF(NAME(1).EQ.IR(I-1).AND.NAME(2).EQ.IR(I))GO TO 206              00335700\n 204  CONTINUE                                                          00335800\n      GO TO 210                                                         00335900\n 206  L1 = 11                                                           00336000\n      L2=I\/2                                                            00336100\n      IF(L2.GE.6)L2=L2-4                                                00336200\n      GO TO 900                                                         00336300\nC                                                                       00336400\nC    (SIN,COS,TAN,COT,ARCSIN,ARCCOS,ARCTAN,ARCCOT) DEGREES L1=12,L2=1,1600336500\nC    ((SIND,COSD,ETC..))                                                00336600\n 210  L1 = 12                                                           00336700\n      DO 214 K = 2, 40, 2                                               00336800\n      I=K                                                               00336900\n      IF(NAME(1).EQ.IG(I-1) .AND.NAME(2).EQ.IG(I))GO TO 216             00337000\n 214  CONTINUE                                                          00337100\n      GO TO 220                                                         00337200\n 216  L2 = I \/ 2                                                        00337300\n      IF(L2.GT.16)L2=L2-12                                              00337400\n      IF(L2.LT.8.AND.NAME(3).EQ.3058.AND.NAME(4).EQ.13262)L2=L2+8       00337500\n      GO TO 900                                                         00337600\nC                                                                       00337700\nC     CHECK THE REST OF THE FUNCTIONS   L1 = 12 , L2 = 17,  42          00337800\nC                                                                       00337900\n  220 DO 224 K=2,42,2                                                   00338000\n      I=K                                                               00338100\n      IF(NAME(1).EQ.JF(I-1) .AND.NAME(2).EQ.JF(I))GO TO 226             00338200\n 224  CONTINUE                                                          00338300\n      GO TO 230                                                         00338400\n 226  L2 = I \/ 2 + 16                                                   00338500\n      GO TO 900                                                         00338600\nC                                                                       00338700\nC     GENERATE,SET,FIXED,FLOATING,PLOT,NOSUMM, SUMMARY,NEWPAGE,SPACE    00338800\nC     CGS,MKSA,MKS,PAGE                            L1 = 13, L2 = 1, 13  00338900\nC                                                                       00339000\n  230 DO 234 K= 2, 28, 2                                                00339100\n      I=K                                                               00339200\n      IF( NAME(1).EQ.IO(I-1).AND.NAME(2).EQ.IO(I) ) GO TO 236           00339300\n 234  CONTINUE                                                          00339400\n      GO TO 240                                                         00339500\n 236  L1 = 13                                                           00339600\n      L2 = I \/ 2                                                        00339700\n      GO TO 900                                                         00339800\nC                                                                       00339900\nC     BEGIN,SCAN,REPEAT,EXECUTE,PERFORM,INCREMENT,INDEX,RESTORE         00340000\nC     IFLT,IFEQ,IFI ,JVI,IFLE                                           00340100\nC                                                                       00340200\n 240  DO 244 K = 2, 28, 2                                               00340300\n      I=K                                                               00340400\n      IF( NAME(1) .EQ. IS( I-1 ) .AND. NAME(2) .EQ. IS(I ) ) GO TO 246  00340500\n 244  CONTINUE                                                          00340600\n      GO TO 250                                                         00340700\n 246  L2 = I \/ 2                                                        00340800\n      L1 = 14                                                           00340900\n      GO TO 900                                                         00341000\nC                                                                       00341100\nC     MDEFINE,ADEFINE,AERASE,MIDENT,ADIAG,MDIAG,MZERO,AZERO,MERASE      00341200\nC     L1 = 15, L2 = 1, 4                                                00341300\nC                                                           L2=1, 4     00341400\n 250  DO 254 L9 = 1, 9                                                  00341500\n      L2=L9                                                             00341600\n      IF(NAME(1) .EQ. MA(2*L2-1) .AND. NAME(2) .EQ. MA(2*L2)) GO TO 256 00341700\n 254  CONTINUE                                                          00341800\n      GO TO 260                                                         00341900\n 256  L1 = 15                                                           00342000\n      IF( L2 .GT. 1 ) L2 = L2 - 1                                       00342100\n      IF( L2 - 5 ) 900, 257, 258                                        00342200\n 257  L2 = 4                                                            00342300\n      GO TO 900                                                         00342400\n 258  L2 = 2                                                            00342500\n      GO TO 900                                                         00342600\nC                                                                       00342700\nC     MINVERT,LINEAR,INVERT        L1 = 16, L2 = 1, 2                   00342800\nC     MMULT,MRAISE                     L1 = 17, L2 = 1, 2               00342900\nC                                                                       00343000\n 260  DO 264 L9 = 1, 5                                                  00343100\n      L2=L9                                                             00343200\n      IF(NAME(1) .EQ. MM(2*L2-1) .AND. NAME(2) .EQ. MM(2*L2)) GO TO 266 00343300\n 264  CONTINUE                                                          00343400\n      GO TO 270                                                         00343500\n 266  L1 = 16                                                           00343600\n      IF( L2 - 3 ) 900, 267, 268                                        00343700\n 267  L2 = 1                                                            00343800\n      GO TO 900                                                         00343900\n 268  L1 = 17                                                           00344000\n      L2 = L2 - 3                                                       00344100\n      GO TO 900                                                         00344200\nC                                                                       00344300\nC     MADD,MSUB,MTRANS,AADD,ASUB,AMULT,ADIVIDE,ARAISE,ATRANS,SCALAR,    00344400\nC     ASCALAR,MSCALAR                   L1 = 18, L2 = 1, 8              00344500\nC                                                                       00344600\n 270  DO 274 L9 = 1, 12                                                 00344700\n      L2=L9                                                             00344800\n      IF(NAME(1) .EQ. MB(2*L2-1) .AND. NAME(2) .EQ. MB(2*L2)) GO TO 276 00344900\n 274  CONTINUE                                                          00345000\n      GO TO 280                                                         00345100\n 276  L1 = 18                                                           00345200\n      IF( L2 - 9 ) 900, 277, 278                                        00345300\n 277  L2 = 3                                                            00345400\n      GO TO 900                                                         00345500\n 278  L2 = 6                                                            00345600\n      GO TO 900                                                         00345700\nC                                                                       00345800\nC     NLSUB,LSUB,HSUB,USUB,PSUB,TSUB       L1 = 19, L2 = 1, 6           00345900\nC                                                                       00346000\n 280  L1 = 19                                                           00346100\n      DO 284 L9 = 1, 6                                                  00346200\n      L2=L9                                                             00346300\n      IF(NAME(1) .EQ. JS(2*L2-1) .AND. NAME(2) .EQ. JS(2*L2)) GO TO 900 00346400\n 284  CONTINUE                                                          00346500\nC    PARSUM,PARPROD,RMS,AVERAGE,SUM                                     00346600\nC                L1 = 20,  L2 = 1, 5                                    00346700\n      L1 = 20                                                           00346800\n      DO 294 L9 = 1, 5                                                  00346900\n      L2=L9                                                             00347000\n      IF(NAME(1) .EQ. JT(2*L2-1) .AND. NAME(2) .EQ. JT(2*L2)) GO TO 900 00347100\n 294  CONTINUE                                                          00347200\n      L1 = 21                                                           00347300\nC                                                                       00347400\nC     ROWSUM,PRODUCT,DEFINE,MAX,MAXIMUM,MIN,MINIMUM,SORT,ORDER,         00347500\nC      ERASE,EXCHANGE,FLIP,CHANGE,HEIRARCHY,LIST,NOLIST,NULL            00347600\nC       L1 = 21,        L2 = 1, 17                                      00347700\nC                                                                       00347800\n      DO 304 L2=1,17                                                    00347900\n      IF(NAME(1)  .EQ. JZ(2*L2-1) .AND. NAME(2) .EQ. JZ(2*L2)) GO TO 90000348000\n 304  CONTINUE                                                          00348100\nC                                                                       00348200\nC     POLYFIT,SPOLYFIT,FIT,SFIT,SOLVE,SSOLVE                            00348300\nC                        L1 = 22   L2 = 1, 6                            00348400\n      L1 = 22                                                           00348500\n      DO 314 L9 = 1, 6                                                  00348600\n      L2=L9                                                             00348700\n      IF( NAME(1) .EQ. MZ(2*L2-1) .AND. NAME(2) .EQ. MZ(2*L2)) GO TO 90000348800\n 314  CONTINUE                                                          00348900\nC                                                                       00349000\nC     CLOSE,COUNT,SHORTEN,EXPAND,DUPLICATE,MOVE,BLOCKTRANSFER,AMOVE,    00349100\nC     MMOVE,PROMOTE,DEMOTE,DIMENSION,SEPARATE,INSERT                    00349200\nC                  L1 = 23, L2 = 1, 14                                  00349300\nC                                                                       00349400\n      L1 = 23                                                           00349500\n      DO 324 L9 = 1, 14                                                 00349600\n      L2=L9                                                             00349700\n      IF(NAME(1).EQ.MJ(2*L2-1).AND.NAME(2).EQ.MJ(2*L2)) GO TO 900       00349800\n 324  CONTINUE                                                          00349900\nC                                                                       00350000\nC     STATIS,SSTATIS,FORGIVE,CHECK,FPROB                                00350100\nC                                                                       00350200\n      L1 = 24                                                           00350300\n      DO 334 L9 = 1, 5                                                  00350400\n      L2=L9                                                             00350500\n      IF( NAME(1).EQ.LB(2*L2-1) .AND. NAME(2).EQ.LB(2*L2) ) GO TO 900   00350600\n 334  CONTINUE                                                          00350700\nC                                                                       00350800\nC     SELECT,SEARCH,CENSOR                                              00350900\nC                                                                       00351000\n      L1 = 25                                                           00351100\n      DO 344 L9 = 1, 3                                                  00351200\n      L2=L9                                                             00351300\n      IF( NAME(1).EQ.LD(2*L2-1) .AND. NAME(2).EQ.LD(2*L2) ) GO TO 900   00351400\n 344  CONTINUE                                                          00351500\n      L1 = 26                                                           00351600\n      IF ( NAME(1) .EQ. NX(1) .AND. NAME(2) .EQ. NX(2) ) GO TO 900      00351700\n 899  L1=0                                                              00351800\n      CALL NEWJOB                                                       00351900\n 900  RETURN                                                            00352000\n      END                                                               00352100\nC  53  24      SUBROUTINE MACHK(IR,J)              2 19 68              00352200\n      SUBROUTINE MACHK(IR,J)                                            00352300\nC**** WORK SHEET CHECK FOR MATRIX OR ARRAY                              00352400\nC**** S PEAVY   5\/22\/67                                                 00352500\n      DIMENSION IR(4)                                                   00352600\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00352700\n     ONROW,                                                             00352800\n     1NCOL,NARGS,VWXYZ(8),NERROR                                        00352900\n      DIMENSION ARGS(100)                                               00353000\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00353100\nC**** IF J=0 EVERYTHING IS FINE                                         00353200\nC**** IF J=1 NOT ENOUGH ROWS                                            00353300\nC**** IF J=2 NOT ENOUGH COLUMNS                                         00353400\nC**** IF J=3 NOT ENOUGH ROWS AND COLUMNS                                00353500\nC**** IR(1)  STARTING ROW                                               00353600\nC**** IR(2)  STARTING COLUMN                                            00353700\nC**** IR(3)  NO. OF ROWS                                                00353800\nC**** IR(4)  NO. OF COLUMNS                                             00353900\n      JA=0                                                              00354000\n      JB=0                                                              00354100\n      IF( IR(1) + IR(3) - 1 .GT. NROW ) JA = 1                          00354200\n      IF( IR(2) + IR(4) - 1 .GT. NCOL ) JB = 2                          00354300\n      J=JA+JB                                                           00354400\n      RETURN                                                            00354500\n      END                                                               00354600\nC  54 232      SUBROUTINE MATRIX                   2 19 68              00354700\n      SUBROUTINE MATRIX                                                 00354800\nC  SUBROUTINE MATRIX  R VARNER 8\/24\/67                                  00354900\nC ****                                                                  00355000\nC L2=1  ADD MATRICES A+B  MADD A(,) N,M, TO B(,) N,M AND S ORE IN C(,)  00355100\nC                          MADD A(,) N,M TO B(,)     AND STORE IN C(,)  00355200\nC  L2=2  SUB MATRICES A-B  MSUB A(,) N,M FROM B(,)N,M AND STORE IN C(,) 00355300\nC                          MSUB A(,) N,M FROM B(,)    AND STORE IN C(,) 00355400\nC  L2=3  TRANSPOSE MATRIX MTRANS A(,) N,M AND STORE IN C(,)             00355500\nC        TRANSPOSE ARRAY ATRANS A(,) N,M AND STORE IN C(,)              00355600\nC  L2=4  ARRAY ADD       AADD                                           00355700\nC  L2=5  ARRAY SUBTRACT  ASUB                                           00355800\nC  L2=6  ARRAY MULTIPLY  AMULT                                          00355900\nC  L2=7  ARRAY DIVIDE    ADIV                                           00356000\nC  L2=8  ARRAY RAISE     ARAISE                                         00356100\nC                        GENERAL FORMS FOR ARRAY OPERATIONS             00356200\nC                        A(,) N,M B(,) N,K STORE IN C(,) ARRAY BY ARRAY 00356300\nC                        A(,) N,M B(,)     STORE IN C(,) ARRAY BY ARRAY 00356400\nC                        A(,) N,M  K   STORE IN C(,) ARRAY BY COLUMN    00356500\nC                        A(,) N    K   STORE IN C(,) ARRAY BY COLUMN    00356600\nC                        A(,) N,M  X   STORE IN C(,) ARRAY BY CONSTANT  00356700\nC                        A(,) N    X   STORE IN C(,) ARRAY BY CONSTANT  00356800\nC ****                                                                  00356900\n      COMMON \/ HEADER\/NMCARD(72),ITLE(64,6),IHEAD(4,50),IFMT(17,6),     00357000\n     1 IFMTX(4),LNCNT,IPRINT,NPAGE,IPUNCH                               00357100\n      COMMON \/ SCRAT \/ A(10000),NS                                      00357200\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00357300\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00357400\n      DIMENSION ARGS(100)                                               00357500\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00357600\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00357700\n      DIMENSION IR(4),ISAVE(2)                                          00357800\n      EQUIVALENCE(IR,ISAVE)                                             00357900\nC ****                                                                  00358000\nC   CHECK TO SEE IF WE HAVE CORRECT NUMBER OF ARGUMENTS                 00358100\nC   IF NOT NO FURTHER CHECKING IS DONE                                  00358200\nC ****                                                                  00358300\n      NPA=NARGS                                                         00358400\n      IF(L2-3)100,120,140                                               00358500\n 100  IF(NARGS.NE.8.AND.NARGS.NE.10) GO TO 400                          00358600\n      GO TO 600                                                         00358700\n  120 IF(NARGS.NE.6.AND.NARGS.NE.5) GO TO 400                           00358800\n      GO TO 600                                                         00358900\n 140  IF(NARGS.LT.6.OR.NARGS.GT.10.OR.NARGS.EQ.9) GO TO 400             00359000\n      GO TO 600                                                         00359100\n 400   CALL ERROR(10)                                                   00359200\nC ****                                                                  00359300\nC   CHECK TO SEE IF ALL ARGUMENTS ARE INTEGERS                          00359400\nC   IF NOT NO FURTHER CHECKING IS DONE                                  00359500\nC ****                                                                  00359600\n  600 IF(L2.GT.3) GO TO 640                                             00359700\n  605 J=NARGS                                                           00359800\n      NP=NARGS                                                          00359900\n      CALL CKIND(J)                                                     00360000\n  610 IF(J.EQ.0) GO TO 800                                              00360100\n 620  CALL ERROR(3)                                                     00360200\n  640 IF(NARGS.GT.7) GO TO 605                                          00360300\n      ISAVE(1)=IARGS(NARGS)                                             00360400\n      IARGS(NARGS)=IARGS(NARGS-2)                                       00360500\n      IARGS(NARGS-2)=IARGS(NARGS-1)                                     00360600\n      IARGS(NARGS-1)=ISAVE(1)                                           00360700\n      ISAVE(1)=KIND(NARGS)                                              00360800\n      KIND(NARGS)=KIND(NARGS-2)                                         00360900\n      KIND(NARGS-2)=KIND(NARGS-1)                                       00361000\n      KIND(NARGS-1)=ISAVE(1)                                            00361100\n      NARGS=NARGS-1                                                     00361200\n      GO TO 605                                                         00361300\nC*****                                                                  00361400\nC   CHECK TO SEE IF DIMENSIONS ARE CORRECT IF THEY ARE GIVEN            00361500\nC   IF NOT NO FURTHER CHECKING IS DONE                                  00361600\nC ****                                                                  00361700\n  800 IF(NARGS.NE.10) GO TO 1100                                        00361800\n      IF(IARGS(3).EQ.IARGS(7).AND.IARGS(4).EQ.IARGS(8))GO TO 1100       00361900\n      CALL ERROR(3)                                                     00362000\nC ****                                                                  00362100\nC   CHECK TO SEE IF ARGUMENTS ARE OUT OF RANGE                          00362200\nC   IF YES NO FURTHER CHECKING IS DONE                                  00362300\nC ****                                                                  00362400\n 1100 IF(NARGS.LT.8) GO TO 1140                                         00362500\n 1120 IP=3                                                              00362600\n      GO TO 1160                                                        00362700\n 1140 IP=2                                                              00362800\n      IF(L2.EQ.3.AND.NPA.EQ.6) GO TO 1160                               00362900\n      IF(L2.GT.3.AND.NPA.EQ.7) GO TO 1160                               00363000\n      IR(4)=IARGS(3)                                                    00363100\n      GO TO 1165                                                        00363200\n 1160 IR(4)=IARGS(4)                                                    00363300\n 1165 IR(3)=IARGS(3)                                                    00363400\n      IROW = IR(3)                                                      00363500\n      ICOL = IR(4)                                                      00363600\n      JP=1                                                              00363700\n      DO  1240   I=1,IP                                                 00363800\n      IF(I.EQ.3) GO TO 1180                                             00363900\n      IR(1)=IARGS(JP)                                                   00364000\n      IR(2)=IARGS(JP+1)                                                 00364100\n      IF(L2.EQ.3.AND.NPA.EQ.6.AND.I.EQ.2) GO TO 1170                    00364200\n      GO TO 1200                                                        00364300\n 1170 IR(3)=IARGS(4)                                                    00364400\n      IR(4)=IARGS(3)                                                    00364500\n 1180 IR(1)=IARGS(5)                                                    00364600\n      IR(2)=IARGS(6)                                                    00364700\n 1200 CALL MACHK(IR,J)                                                  00364800\n      JP=NARGS-1                                                        00364900\n      IF(J.EQ.0) GO TO 1240                                             00365000\n      CALL ERROR(17)                                                    00365100\n 1240 CONTINUE                                                          00365200\nC ***$                                                                  00365300\nC   FIND ADRESSES OF COLUMNS                                            00365400\nC *****                                                                 00365500\n      IF(L2-3)1500,1600,1640                                            00365600\n 1500 ISAVE(1)=IARGS(1)                                                 00365700\n      ISAVE(2)=IARGS(3)                                                 00365800\n      IARGS(1)=IARGS(2)                                                 00365900\n      IARGS(2)=IARGS(6)                                                 00366000\n      IARGS(3)=IARGS(NARGS)                                             00366100\n      NARGS=3                                                           00366200\n      CALL CHKCOL(J)                                                    00366300\n      IARGS(1)=IARGS(1)+ISAVE(1)-1                                      00366400\n      IARGS(2)=IARGS(2)+IARGS(5)-1                                      00366500\n      IARGS( 3)=IARGS(3)+IARGS(NP-1)-1                                  00366600\n      GO TO 1800                                                        00366700\n 1600 ISAVE(2)=IARGS(3)                                                 00366800\n 1620 ISAVE(1)=IARGS(1)                                                 00366900\n      IARGS(1)=IARGS(2)                                                 00367000\n      IARGS(2)=IARGS(NP)                                                00367100\n      NARGS=2                                                           00367200\n      CALL CHKCOL(J)                                                    00367300\n      IARGS(1)=IARGS(1)+ISAVE(1)-1                                      00367400\n      IARGS(2)=IARGS(2)+IARGS(NP-1)-1                                   00367500\n      GO TO 1800                                                        00367600\n 1640 IF (NPA.GE.8) GO TO 1500                                          00367700\n      IF(KIND(NPA  ).NE.0) GO TO 1600                                   00367800\n      CALL ADRESS(NPA,J)                                                00367900\n      ISAVE(2)=IARGS(3)                                                 00368000\n      IARGS(3)=J                                                        00368100\n      GO TO 1620                                                        00368200\nC *****                                                                 00368300\nC   CHECK TO SEE IF THERE WERE PREVIOUS ERRORS                          00368400\nC *****                                                                 00368500\n 1800 IF(NERROR.NE.0) RETURN                                            00368600\nC *****                                                                 00368700\nC   SUM ELEMENTS IN SCRATCH AREA                                        00368800\nC   SUBTRACT ELEMENTS IN SCRATCH AREA                                   00368900\nC   PRODUCTS AND QUOTIENTS FORMED USING DOUBLE PRECISION IN SCRATCH AREA00369000\nC   TRANSPOSE IN SCRATCH AREA                                           00369100\nC *****                                                                 00369200\n      NROWPP=NROW                                                       00369300\n      IF(L2-3)2000,1900,2040                                            00369400\n 1900 IIB=ICOL                                                          00369500\n      JJB=IROW                                                          00369600\n      NROWPP=0                                                          00369700\n      K=1                                                               00369800\n      GO TO 2030                                                        00369900\n 2000 NROWP=NROW                                                        00370000\n      IBP=IARGS(2)                                                      00370100\n 2020 IIB=IROW                                                          00370200\n      JJB=ICOL                                                          00370300\n      K=0                                                               00370400\n 2030 IS=1                                                              00370500\n      IAP=IARGS(1)                                                      00370600\n      GO TO 2100                                                        00370700\n 2040 IF(NPA.GE.8) GO TO 2000                                           00370800\n      IF(KIND(NPA  ).EQ.1) GO TO 2065                                   00370900\n 2060 IBP=IARGS(3)                                                      00371000\n 2065 IARGS(3)=IARGS(2)                                                 00371100\n      NROWP=0                                                           00371200\n      GO TO 2020                                                        00371300\n 2100 DO  3560  J=1,JJB                                                 00371400\n      IA=IAP+(J-1)*K                                                    00371500\n      IB=IBP                                                            00371600\n      DO  3540  I=1,IIB                                                 00371700\n      GO TO (2120,2140,2200,2220,2240,2260,2280,2300),L2                00371800\n 2120 A(IS)=RC(IA)+RC(IB)                                               00371900\n      GO TO 3500                                                        00372000\n 2140 A(IS)=RC(IA)-RC(IB)                                               00372100\n      GO TO 3500                                                        00372200\n 2160 A(IS)=RC(IA)*RC(IB)                                               00372300\n      GO TO 3500                                                        00372400\n 2180 A(IS)=RC(IA)\/RC(IB)                                               00372500\n      GO TO 3500                                                        00372600\n 2200 A(IS)=RC(IA)                                                      00372700\n      IA=IA+NROW                                                        00372800\n      GO TO 3530                                                        00372900\n 2220 IF(NPA.GE.8.OR.(KIND(NPA  ).EQ.0.AND.NPA.LT.8)) GO TO 2120        00373000\n      A(IS)=RC(IA)+ARGS(NPA-2)                                          00373100\n      GO TO 3520                                                        00373200\n 2240 IF(NPA.GE.8.OR.(KIND(NPA  ).EQ.0.AND.NPA.LT.8)) GO TO 2140        00373300\n      A(IS)=RC(IA)-ARGS(NPA-2)                                          00373400\n      GO TO 3520                                                        00373500\n 2260 IF(NPA.GE.8.OR.(KIND(NPA  ).EQ.0.AND.NPA.LT.8)) GO TO 2160        00373600\n      A(IS)=RC(IA)*ARGS(NPA-2)                                          00373700\n      GO TO 3500                                                        00373800\n 2280 IF(NPA.GE.8.OR.(NPA.LT.8.AND.KIND(NPA  ).EQ.0)) GO TO 2180        00373900\n      A(IS)=RC(IA)\/ARGS(NPA-2)                                          00374000\n      GO TO 3500                                                        00374100\n 2300 IF(NPA.GE.8.OR.(NPA.LT.8.AND.KIND(NPA  ).EQ.0)) GO TO 2320        00374200\n      A(IS)=FEXP2(RC(IA),ARGS(NPA-2))                                   00374300\n      GO TO 3500                                                        00374400\n 2320 A(IS)=FEXP2(RC(IA),RC(IB))                                        00374500\n      GO TO 3500                                                        00374600\n 3500 IB=IB+1                                                           00374700\n 3520 IA=IA+1                                                           00374800\n3530  IS=IS+1                                                           00374900\n 3540 CONTINUE                                                          00375000\n      IAP=IAP+NROWPP                                                    00375100\n      IBP=IBP+NROWP                                                     00375200\n 3560 CONTINUE                                                          00375300\nC *****                                                                 00375400\nC   MOVE SUMS TO WORKSHEET                                              00375500\nC   MOVE DIFFERENCES TO WORKSHEET                                       00375600\nC   MOVE ARRAY PRODUCT TO WORKSHEET                                     00375700\nC   MOVE ARRAY QUOTIENT TO SORKSHEET                                    00375800\nC   MOVE TRANSPOSE TO WORKSHEET                                         00375900\nC   MOVE RAISED MATRIX TO WORKSHEET                                     00376000\nC *****                                                                 00376100\n      IF(L2.NE.3) GO TO 3820                                            00376200\n 3800 IIB=ICOL                                                          00376300\n      JJB=IROW                                                          00376400\n      ICP=IARGS(2)                                                      00376500\n      GO TO 3840                                                        00376600\n 3820 ICP=IARGS(3)                                                      00376700\n 3840 IS=1                                                              00376800\n 3880 DO  4080  J=1,JJB                                                 00376900\n      IC=ICP                                                            00377000\n      DO 4060 I=1,IIB                                                   00377100\n 4000 RC(IC)=A(IS)                                                      00377200\n      IC=IC+1                                                           00377300\n      IS=IS+1                                                           00377400\n 4060 CONTINUE                                                          00377500\n      ICP=ICP+NROW                                                      00377600\n 4080 CONTINUE                                                          00377700\n      RETURN                                                            00377800\n       END                                                              00377900\nC  55  83      SUBROUTINE MDAMAD                   2 19 68              00378000\n      SUBROUTINE MDAMAD                                                 00378100\nC     SUBROUTINE MDAMAD                    R VARNER  9\/26\/67            00378200\nC *****                                                                 00378300\nC     SUBROUTINE TO PRE OR POST MULTIPLY A MATRIX BY A DIAGONAL STORED  00378400\nC     AS A COLUMN                                                       00378500\nC     L2=1      M(AD)                                                   00378600\nC         MATRIX A IS POSTMULTIPLIED BY THE DIAGONAL D STORED IN COL I  00378700\nC             GENERAL FORM OF COMMAND                                   00378800\nC                 M(AD) A(,) N,K,  D IN COL  I  STORE IN  C(,)          00378900\nC     L2=2      MDA)                                                    00379000\nC         MATRIX A IS PREMULTIPLIED BY THE DIAGONAL D STORED IN COL I   00379100\nC             GENERAL FORM OF COMMAND                                   00379200\nC                 M(DA), A(,) N,K  K IN COL  I  STORE IN  C(,)          00379300\nC *****                                                                 00379400\n      COMMON \/ HEADER\/NMCARD(72),ITLE(64,6),IHEAD(4,50),IFMT(17,6),     00379500\n     1 IFMTX(4),LNCNT,IPRINT,NPAGE,IPUNCH                               00379600\n      COMMON \/ SCRAT \/ A(10000),NS                                      00379700\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00379800\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00379900\n      DIMENSION ARGS(100)                                               00380000\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00380100\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00380200\nC ****                                                                  00380300\nC     CHECK FOR CORRECT NUMBER OF ARGUMENTS                             00380400\nC *****                                                                 00380500\n      IF(NARGS.NE.7)CALL ERROR(10)                                      00380600\nC *****                                                                 00380700\nC     CHECK TO SEE THAT ALL ARGUMENTS ARE INTEGERS                      00380800\nC *****                                                                 00380900\n      J=NARGS                                                           00381000\n      CALL CKIND(J)                                                     00381100\n      IF(J.NE.0)  CALL ERROR(3)                                         00381200\nC *****                                                                 00381300\nC     CHECK TO SEE IF DIMENSIONS ARE OUT OF RANGE                       00381400\nC     COMPUTE ADDRESSES OF COLUMNS                                      00381500\nC *****                                                                 00381600\n      IARGS(12)=IARGS(4)                                                00381700\n      IARGS(11)=IARGS(3)                                                00381800\n      IARGS(10)=IARGS(7)                                                00381900\n      IARGS(9)=IARGS(6)                                                 00382000\n      IARGS(8)= 1                                                       00382100\n      GO TO (100, 120 ),L2                                              00382200\n 100  IARGS(7)=IARGS(4)                                                 00382300\n      GO TO 140                                                         00382400\n 120  IARGS(7)=IARGS(3)                                                 00382500\n 140  IARGS(6)=IARGS(5)                                                 00382600\n      IARGS(5)= 1                                                       00382700\n      J=3                                                               00382800\n      CALL MTXCHK(J)                                                    00382900\n      IF(J-1) 190 , 160  ,180                                           00383000\n 160  CALL ERROR(3)                                                     00383100\n      RETURN                                                            00383200\n 180  CALL ERROR(17)                                                    00383300\n      RETURN                                                            00383400\nC *****                                                                 00383500\nC     CHECK FOR PREVIOUS ERRORS                                         00383600\nC *****                                                                 00383700\n  190 IF(NERROR.NE.0) RETURN                                            00383800\n      IP=IARGS(4)                                                       00383900\n      JP=IARGS(3)                                                       00384000\n      GO TO ( 200, 220 ) ,L2                                            00384100\n 220  I1=0                                                              00384200\n      I2=1                                                              00384300\n      GO TO 260                                                         00384400\n 200  I1=1                                                              00384500\n      I2=0                                                              00384600\n 260  IA=IARGS(1)                                                       00384700\n      IDP=IARGS(5)                                                      00384800\n      IB=IARGS(9)                                                       00384900\n      DO 340  I=1,IP                                                    00385000\n      ID=IDP                                                            00385100\n      DO 300  J=1,JP                                                    00385200\n      RC(IB)=RC(ID)*RC(IA)                                              00385300\n      ID=ID+I2                                                          00385400\n      IA=IA+1                                                           00385500\n      IB=IB+1                                                           00385600\n 300  CONTINUE                                                          00385700\n      IB=IB+NROW-JP                                                     00385800\n      IA=IA+NROW-JP                                                     00385900\n      IDP=IDP+I1                                                        00386000\n 340  CONTINUE                                                          00386100\n      RETURN                                                            00386200\n      END                                                               00386300\nC  56 182      SUBROUTINE MISC2                    2 19 68              00386400\n      SUBROUTINE MISC2                                                  00386500\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00386600\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00386700\n      DIMENSION ARGS(100)                                               00386800\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00386900\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00387000\n      COMMON \/ SCRAT \/ A(10000),NS                                      00387100\nC     SUBROUTINE BY CARLA MESSINA  NSRDS - NBS  JULY 1967               00387200\nC                                                                       00387300\nC TYPE 4 IS   EXPAND $$ TO ,, POWER IN INTERVALS OF ,, START STORE ++   00387400\nC               THE POWERS MAY BE INTEGER OR NOT                        00387500\nC TYPE 1 IS   CLOSE UP ROWS HAVING ** IN ++,++, ETC                     00387600\nC TYPE 2 IS   COUNT LENGTH OF COLUMN ++, STORE IN COLUMN ++             00387700\nC TYPE 3 IS   SHORTEN COL ++ FOR COL ++ = ** STORE IN COL ++ AND COL ++ 00387800\nC TYPE 5 IS   DUPLICATE ,, TIMES THE ARRAY IN ,, ++ R=,, C=,, START     00387900\nC               STORING IN ,, ++                                        00388000\nC                                                                       00388100\n      DIMENSION  IR(4)                                                  00388200\n      J=NARGS                                                           00388300\n      IF (NARGS - 2) 10,40,40                                           00388400\n10    K = 10                                                            00388500\n20    CALL ERROR(K)                                                     00388600\n30    RETURN                                                            00388700\n40    GO TO  (50,75,50 ,400,600) , L2                                   00388800\n50    IF (KIND(L2))   60,60,70                                          00388900\n60    K = 3                                                             00389000\n      GO TO 20                                                          00389100\n70    KIND(L2) = 0                                                      00389200\n      ARG1 = ARGS(L2)                                                   00389300\n      IARGS(L2) = IARGS(L2+1)                                           00389400\n75    CALL CHKCOL(J)                                                    00389500\n      IF (J)    60,80,60                                                00389600\n80    DO  90 I=1,NARGS                                                  00389700\n90    IARGS(I)  = IARGS(I) - 1                                          00389800\n      IF (L2 - 2) 110,110,100                                           00389900\n100   IF (NARGS - 5)   10,110,10                                        00390000\n110   IF (NERROR .NE. 0) GO TO 30                                       00390100\n      IF (NRMAX)  120,120,130                                           00390200\n120   K = 9                                                             00390300\n      GO TO 20                                                          00390400\n130   IF  (L2 - 2) 140,200,300                                          00390500\nC CLOSE UP                                                              00390600\n140   DO 190 J=2,NARGS                                                  00390700\n      K = IARGS(J)                                                      00390800\n      M = 0                                                             00390900\n      DO  160 I=1,NRMAX                                                 00391000\n      J1 = K + I                                                        00391100\n  148 IF ( RC( J1 ) - ARG1 ) 160,150,160                                00391200\n  150 M = M + 1                                                         00391300\n      IF ( (M+I) .EQ. (NRMAX+1) ) GO TO 161                             00391400\n      K1 = J1 +1                                                        00391500\n      K3 = K + NRMAX                                                    00391600\n      DO 155 K2 = K1,K3                                                 00391700\n  155 RC( K2 - 1 ) = RC( K2 )                                           00391800\n      GO TO 148                                                         00391900\n  160 CONTINUE                                                          00392000\n  161 IF ( M .EQ. 0 ) GO TO 190                                         00392100\n      M = NRMAX - M + 1                                                 00392200\n      DO 180 I = M,NRMAX                                                00392300\n      J1 = K + I                                                        00392400\n180   RC(J1) = 0.0                                                      00392500\n190   CONTINUE                                                          00392600\n      GO TO 30                                                          00392700\nC  COUNT                                                                00392800\n200   IF (NRMAX - 2)  260,260,210                                       00392900\n210   DO 250 I=3,NRMAX                                                  00393000\n      J = IARGS(1) + I                                                  00393100\n      IF (RC(J-2))  250,220,250                                         00393200\n220   IF (RC(J-1))  250,230,250                                         00393300\n230   IF (RC(J  ))  250,240,250                                         00393400\n240   ARG1 = I - 3                                                      00393500\n      GO TO 270                                                         00393600\n250   CONTINUE                                                          00393700\n260   ARG1 = NRMAX                                                      00393800\n270   IARGS(2) = IARGS(2) + 1                                           00393900\n      CALL VECTOR (ARG1,IARGS(2))                                       00394000\n      GO TO 30                                                          00394100\nC  SHORTEN                                                              00394200\n300   IF (NRMAX - 2)  30,310,310                                        00394300\n310   DO 360 K=2,NRMAX                                                  00394400\n      J1 = IARGS(2) + K                                                 00394500\n      IF (ARG1 - RC(J1-1))   320,330,340                                00394600\n320   IF (ARG1 - RC(J1  ))   360,350,350                                00394700\n330   NRMAX = K - 1                                                     00394800\n      GO TO 370                                                         00394900\n340   IF (ARG1 - RC(J1))     350,350,360                                00395000\n350   NRMAX = K                                                         00395100\n      GO TO 370                                                         00395200\n360   CONTINUE                                                          00395300\n      K = 203                                                           00395400\n      CALL ERROR(K)                                                     00395500\n370   DO  380 I=1,NRMAX                                                 00395600\n      K = IARGS(1) + I                                                  00395700\n      J = IARGS(4) + I                                                  00395800\n      M = IARGS(5) + I                                                  00395900\n      K1 = IARGS(2) + I                                                 00396000\n      RC(M) = RC(K1)                                                    00396100\n380   RC(J)= RC(K)                                                      00396200\n      GO TO 30                                                          00396300\nC EXPAND                                                                00396400\n400   IF (NARGS - 4)  10,410,10                                         00396500\n410   CALL ADRESS(4,K1)                                                 00396600\n      IF (K1)  60,60,420                                                00396700\n420   IF  (KIND(1))   460,430,460                                       00396800\n430   CALL ADRESS(1,IARGS(1))                                           00396900\n      IF (IARGS(1))   60,60,440                                         00397000\n440   K = IARGS(1) - 1                                                  00397100\n      DO 450  I=1,NRMAX                                                 00397200\n      J = K + I                                                         00397300\n450   A(I) = RC(J)                                                      00397400\n      GO TO 480                                                         00397500\n460   DO 470 I=1,NRMAX                                                  00397600\n470   A(I) = ARGS(1)                                                    00397700\n480   IF (KIND(2))   500,490,500                                        00397800\n490   ARGS(2) = IARGS(2)                                                00397900\n500   IF (KIND(3))   520,510,520                                        00398000\n510   ARGS(3) = IARGS(3)                                                00398100\n520   IF (ARGS(2)*ARGS(3))  530,530,540                                 00398200\n 530  K = 20                                                            00398300\n      GO TO 20                                                          00398400\n540   IF (ABS(ARGS(3)) - ABS(ARGS(2)))  550,550,530                     00398500\n550   IF (NERROR .NE. 0) GO TO 30                                       00398600\n      IF (NRMAX)  120,120,560                                           00398700\n560   CC = ARGS(3)                                                      00398800\n570   DO 580  I=1,NRMAX                                                 00398900\n      K = K1-1 + I                                                      00399000\n580   RC(K) = FEXP2(A(I),CC)                                            00399100\n      IF (ABS(CC) - ABS(ARGS(2)))  590,30,30                            00399200\n590   CC = CC + ARGS(3)                                                 00399300\n      IARGS(4) = IARGS(4) + 1                                           00399400\n      CALL ADRESS(4,K1)                                                 00399500\n      IF  (K1)   60,60,570                                              00399600\nC  DUPLICATE                                                            00399700\n600   IF (NARGS - 7)   10,610,10                                        00399800\n610   CALL CKIND(J)                                                     00399900\n      IF (J)  60,620,60                                                 00400000\n620   DO  630  I=2,5                                                    00400100\n630   IR(I-1) = IARGS(I)                                                00400200\n      CALL MACHK(IR,J)                                                  00400300\n      IF (J)  640,650,640                                               00400400\n640   K = 17                                                            00400500\n      GO TO 20                                                          00400600\n650   IR(1) = IARGS(6)                                                  00400700\n      IR(2) = IARGS(7)                                                  00400800\n      IR(3) = IARGS(1)*IARGS(4)                                         00400900\n      IR(4) = IARGS(5)                                                  00401000\n      CALL MACHK(IR,J)                                                  00401100\n      IF (J)  640,660,640                                               00401200\n660   IF (IARGS(1)-1)  60,670,670                                       00401300\n670   CALL ADRESS(3,IARGS(3))                                           00401400\n      CALL ADRESS(7,IARGS(7))                                           00401500\n      J = IARGS(6) + IARGS(1)*IARGS(4) - 1                              00401600\n      IF (NRMAX - J)  680,690,690                                       00401700\n680   NRMAX = J                                                         00401800\n      IF (NRMAX - NROW) 690,690,640                                     00401900\n690   IF (NERROR .NE. 0) GO TO 30                                       00402000\n      IEND = IARGS(1)                                                   00402100\n      IX = IARGS(2) - 1                                                 00402200\n      IY = IARGS(3) - NROW - 1                                          00402300\n      LONG = IARGS(4)                                                   00402400\n      LWIDE = IARGS(5)                                                  00402500\n      J = 0                                                             00402600\n      DO  700  I=1,LWIDE                                                00402700\n      IY = IY + NROW                                                    00402800\n      DO  700  K=1,LONG                                                 00402900\n      K1 = IX + IY + K                                                  00403000\n      J = J + 1                                                         00403100\n700   A(J) = RC(K1)                                                     00403200\n      IARGS(6) = IARGS(6) - NROW - 1                                    00403300\n      IY   = IARGS(7) -LONG - 1                                         00403400\n      DO 710 JJ = 1, IEND                                               00403500\n      J = 0                                                             00403600\n      IY = IY + LONG                                                    00403700\n      IX = IARGS(6)                                                     00403800\n      DO 710 I=1,LWIDE                                                  00403900\n      IX = IX + NROW                                                    00404000\n      DO 710 K=1,LONG                                                   00404100\n      K1 = IX + IY + K                                                  00404200\n      J = J + 1                                                         00404300\n710   RC(K1) = A(J)                                                     00404400\n      GO TO 30                                                          00404500\n      END                                                               00404600\nC  57  64      SUBROUTINE MKRON                    2 19 68              00404700\n      SUBROUTINE MKRON                                                  00404800\nC     ROUTINE WRITTEN FOR OMNITAB 11\/ 3\/67 BY S PEAVY                   00404900\nC                                                                       00405000\nC     KRONECKER PRODUCT OF TWO MATRICES A(N,C)*B(M,K)=D                 00405100\nC                                                                       00405200\nC     FIRST FOUR ARGUMENTS DEFINE MATRIX A STARTING POS AND SIZE        00405300\nC     NEXT  FOUR ARGUMENTS DEFINE MATRIX B STARTING POS AND SIZE        00405400\nC     LAST TWO ARGUMENTS INDICATE WHERE RESULT IS TO BE STORED  D       00405500\nC     COMMAND IS\"                                                       00405600\nC     MKRON A(,, ++),R=,, C=,,*B(,, ++),R=,, C=,, STORE D(,, ++)        00405700\nC                                                                       00405800\nC                                                                       00405900\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00406000\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00406100\n      DIMENSION ARGS(100)                                               00406200\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00406300\n      COMMON \/ SCRAT \/ A(10000),NS                                      00406400\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00406500\n      COMMON\/CONSTS\/PI,E,HALFPI,DEG,RAD,XEXP,XTRIG,XALOG,CC( 192 )      00406600\n      IF(NARGS.NE.10)CALL ERROR(10)                                     00406700\n      J=NARGS                                                           00406800\n      CALL CKIND(J)                                                     00406900\n      IF(J.NE.0) CALL ERROR(3)                                          00407000\n      IF(NERROR.NE.0)RETURN                                             00407100\n      IARGS(11)=IARGS(3)*IARGS(7)                                       00407200\n      IARGS(12)=IARGS(4)*IARGS(8)                                       00407300\n      J=3                                                               00407400\n      CALL MTXCHK(J)                                                    00407500\n      IF(J.EQ.0) GO TO 150                                              00407600\n      CALL ERROR(17)                                                    00407700\n      RETURN                                                            00407800\n  150 NRA=IARGS(3)                                                      00407900\n      NCA=IARGS(4)                                                      00408000\n      NRB=IARGS(7)                                                      00408100\n      NCB=IARGS(8)                                                      00408200\n      NDS=1                                                             00408300\n      KA=IARGS(1)                                                       00408400\n      DO 300 ICA=1,NCA                                                  00408500\n      LA=IARGS(5)                                                       00408600\n      DO 250 ICB=1,NCB                                                  00408700\n      K=KA                                                              00408800\n      DO 200 IRA=1,NRA                                                  00408900\n      T=RC(K)                                                           00409000\n      K=K+1                                                             00409100\n      L=LA                                                              00409200\n      DO 200 IRB=1,NRB                                                  00409300\n      A(NDS)=T*RC(L)                                                    00409400\n      L=L+1                                                             00409500\n  200 NDS=NDS+1                                                         00409600\n  250 LA=LA+NROW                                                        00409700\n  300 KA=KA+NROW                                                        00409800\n      NRC=IARGS(11)                                                     00409900\n      NCC=IARGS(12)                                                     00410000\n      NDS=1                                                             00410100\n      KA=IARGS(9)                                                       00410200\n      DO 410 I=1,NCC                                                    00410300\n      K=KA                                                              00410400\n      DO 400 J=1,NRC                                                    00410500\n      RC(K)=A(NDS)                                                      00410600\n      NDS=NDS+1                                                         00410700\n  400 K=K+1                                                             00410800\n  410 KA =KA+NROW                                                       00410900\n      RETURN                                                            00411000\n      END                                                               00411100\nC  58 156      SUBROUTINE MMULT                    2 19 68              00411200\n      SUBROUTINE MMULT                                                  00411300\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00411400\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00411500\n      DIMENSION ARGS(100)                                               00411600\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00411700\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00411800\nC *****                                                                 00411900\nC     SUBROUTINE TO MULTIPLY MATRICES                                   00412000\nC                 GENERAL FORMS OF MMULT                                00412100\nC                   MMULT A(,) N,K, BY B(,) K,M AND STORE IN C(,)       00412200\nC                   MMULT A(,) N   BY B(,) N   AND  STORE IN C(,)       00412300\nC                   MMULT A(,) N   BY B(,)     AND  STORE IN C(,)       00412400\nC                   MMULT A(,) N,K, BY B(,) M  AND  STORE IN C(,)       00412500\nC *****                                                                 00412600\n      COMMON\/MULTC\/NS2                                                  00412700\n      COMMON \/ SCRAT \/ X,NS                                             00412800\n      DIMENSION A(10000)                                                00412900\n      DOUBLE PRECISION X(5000), SUM                                     00413000\n      DIMENSION IR(4),ISAVE(2)                                          00413100\n      EQUIVALENCE(IR,ISAVE)                                             00413200\n      NS2=NS\/2                                                          00413300\nC *****                                                                 00413400\nC     CHECK TO SEE IF WE HAVE CORRECT NUMBER OF ARGUMENTS               00413500\nC *****                                                                 00413600\n 100  IF(NARGS.GT.10.OR.NARGS.LT.7) CALL ERROR(10)                      00413700\nC *****                                                                 00413800\nC     CHECK TO SEE IF ALL ARGUMENTS ARE INTEGERS                        00413900\nC *****                                                                 00414000\n  600 J=NARGS                                                           00414100\n      CALL CKIND(J)                                                     00414200\n      IF(J.EQ.0) GO TO 800                                              00414300\n      CALL ERROR(3)                                                     00414400\nC *****                                                                 00414500\nC     CHECK TO SEE IF DIMENSIONS ARE CORRECT                            00414600\nC *****                                                                 00414700\n  800 IF(NARGS.EQ.10) GO TO 840                                         00414800\n      IF(NARGS.EQ.8) GO TO 860                                          00414900\n      GO TO 1100                                                        00415000\n  840 IF(IARGS(4).NE.IARGS(7)) GO TO 880                                00415100\n      GO TO 1100                                                        00415200\n  860 IF(IARGS(3).EQ.IARGS(6)) GO TO 1100                               00415300\n  880 CALL ERROR(3)                                                     00415400\nC *****                                                                 00415500\nC     CHECK TO SEE IF ARGUMENTS ARE OUT OF RANGE                        00415600\nC *****                                                                 00415700\n 1100 IP=3                                                              00415800\n 1160 JERR=0                                                            00415900\n      DO  1320     I=1,IP                                               00416000\n      IF(I.NE.1) GO TO 1200                                             00416100\n      IR(1)=IARGS(1)                                                    00416200\n      IR(2)=IARGS(2)                                                    00416300\n      IR(3)=IARGS(3)                                                    00416400\n      IROWA=IARGS(3)                                                    00416500\n      IF(NARGS.GT.8) GO TO 1180                                         00416600\n      IR(4)=IARGS(3)                                                    00416700\n      ICOLA=IARGS(3)                                                    00416800\n      GO TO 1300                                                        00416900\n 1180 IR(4)=IARGS(4)                                                    00417000\n      ICOLA=IARGS(4)                                                    00417100\n      GO TO 1300                                                        00417200\n 1200 IF(I.EQ.3) GO TO 1240                                             00417300\n      IR(1)=IARGS(NARGS-1)                                              00417400\n      IR(2)=IARGS(NARGS)                                                00417500\n      IR(3)=IARGS(3)                                                    00417600\n      IF(NARGS.GT.8) GO TO 1220                                         00417700\n      IR(4)=IARGS(3)                                                    00417800\n      GO TO 1300                                                        00417900\n 1220 IR(4)=IARGS(NARGS-2)                                              00418000\n      GO TO 1300                                                        00418100\n 1240 IF(NARGS.GT.8) GO TO 1260                                         00418200\n      IR(1)=IARGS(4)                                                    00418300\n      IR(2)=IARGS(5)                                                    00418400\n      IR(3)=IARGS(3)                                                    00418500\n      IR(4)=IARGS(3)                                                    00418600\n      ICOLB=IARGS(3)                                                    00418700\n      GO TO 1300                                                        00418800\n 1260 IR(1)=IARGS(5)                                                    00418900\n      IR(2)=IARGS(6)                                                    00419000\n      IF(NARGS.EQ.10) GO TO 1280                                        00419100\n      IR(3)=IARGS(4)                                                    00419200\n      IR(4)=IARGS(7)                                                    00419300\n      ICOLB=IARGS(7)                                                    00419400\n      GO TO 1300                                                        00419500\n 1280 IR(3)=IARGS(7)                                                    00419600\n      IR(4)=IARGS(8)                                                    00419700\n      ICOLB=IARGS(8)                                                    00419800\n 1300 CALL MACHK(IR,J)                                                  00419900\n      IF(J.EQ.0) GO TO 1320                                             00420000\n      CALL ERROR(17)                                                    00420100\n      JERR=JERR+1                                                       00420200\n 1320 CONTINUE                                                          00420300\nC *****                                                                 00420400\nC     FIND ADDRESSES OF COLUMNS                                         00420500\nC *****                                                                 00420600\n      NP=NARGS                                                          00420700\n      ISAVE(1)=IARGS(1)                                                 00420800\n      IARGS(1)=IARGS(2)                                                 00420900\n      ISAVE(2)=IARGS(3)                                                 00421000\n      IARGS(3)=IARGS(NARGS)                                             00421100\n      NARGS=3                                                           00421200\n      IF(NP.GT.8) GO TO 1540                                            00421300\n      IARGS(2)=IARGS(5)                                                 00421400\n      GO TO 1580                                                        00421500\n 1540 IARGS(2)=IARGS(6)                                                 00421600\n 1580 CALL CHKCOL(J)                                                    00421700\n      IARGS(1)=IARGS(1)+ISAVE(1)-1                                      00421800\n      IARGS(3)=IARGS(3)+IARGS(NP-1)-1                                   00421900\n      IF(NP.GT.8) GO TO 1620                                            00422000\n      IARGS(2)=IARGS(2)+IARGS(4)-1                                      00422100\n      GO TO 1800                                                        00422200\n 1620 IARGS(2)=IARGS(2)+IARGS(5)-1                                      00422300\nC *****                                                                 00422400\nC     CHECK TO SEE IF PREVIOUS ERRORS                                   00422500\nC *****                                                                 00422600\n 1800 IF(NERROR.NE.0) RETURN                                            00422700\nC *****                                                                 00422800\nC     BEGIN MULTIPLICATION                                              00422900\nC *****                                                                 00423000\n      ISP=1                                                             00423100\n      IBP=IARGS(2)                                                      00423200\n      DO 3040  ICB=1,ICOLB                                              00423300\n      IAP=IARGS(1)                                                      00423400\n      DO 3020  IRA=1,IROWA                                              00423500\n      IS=NS2                                                            00423600\n      IA=IAP                                                            00423700\n      IB=IBP                                                            00423800\n      DO 3000 J=1,ICOLA                                                 00423900\n      X(IS)=RC(IA)*RC(IB)                                               00424000\n      IS=IS-1                                                           00424100\n      IA=IA+NROW                                                        00424200\n      IB=IB+1                                                           00424300\n 3000 CONTINUE                                                          00424400\nC *****                                                                 00424500\nC     CALL ROUTINE TO SORT PRODUCTS AND SUM                             00424600\nC *****                                                                 00424700\n      CALL SORTSM (ICOLA,SUM)                                           00424800\n      A(ISP)=SUM                                                        00424900\n      ISP=ISP+1                                                         00425000\n 3020 IAP=IAP+1                                                         00425100\n 3040 IBP=IBP+NROW                                                      00425200\nC *****                                                                 00425300\nC     STORE MATRIX PRODUCT                                              00425400\nC *****                                                                 00425500\n      IS=1                                                              00425600\n      ICP=IARGS(3)                                                      00425700\n      DO 8100   J=1,ICOLB                                               00425800\n      IC=ICP                                                            00425900\n      DO 8080  I=1,IROWA                                                00426000\n      RC(IC)=A(IS)                                                      00426100\n      IS=IS+1                                                           00426200\n      IC=IC+1                                                           00426300\n 8080 CONTINUE                                                          00426400\n 8100 ICP=ICP+NROW                                                      00426500\n      RETURN                                                            00426600\n      END                                                               00426700\nC  59 111      SUBROUTINE MOP                      2 19 68              00426800\n      SUBROUTINE MOP                                                    00426900\nC**** SUBROUTINE TO DO MDEFINE,ADEFINE,MZERO,AZERO,MERASE,AERASE,MEDENT 00427000\nC**** S PEAVY FOR OMNITAB UNIVAC 1108 9\/ 1\/67                           00427100\nC**** COMMANDS ARE AS FOLLOWS                                           00427200\nC****                                                                   00427300\nC**** II    MDEFINE  (+++,+++) N +++ VALUE ***                          00427400\nC**** I     MDEFINE  (+++,++) N ++,K ++ VALUE ***                       00427500\nC**** III   SAME AS I EXCEPT COMMAND IS ADEFINE                         00427600\nC**** IV    SAME AS II EXCEPT COMMAND IS ADEFINE                        00427700\nC**** V     MZERO  (+++,+++)  N +++,K +++                               00427800\nC**** VI    MZERO  (+++,+++)  N +++                                     00427900\nC**** VII   AZERO  (+++,+++)  N +++, K +++                              00428000\nC**** IX    SAME  AS  V   EXCEPT COMMAND IS MERASE                      00428100\nC**** VIII  AZERO  (+++,+++)  N +++                                     00428200\nC**** X     SAME AS VI  EXCEPT COMMAND IS MERASE                        00428300\nC**** XI    SAME AS VII EXCEPT COMMAND IS AERASE                        00428400\nC**** XII   SAME AS VIII EXCEPT COMMAND IS AERASE                       00428500\nC**** XIII  MIDENT  (+++,+++) N +++, N +++                              00428600\nC**** XIV   MIDENT  (+++,+++)  R=+++,C=+++,X=***                        00428700\nC**** XV    MDIAG  (+++,+++) N +++ N +++  COL +++                       00428800\nC**** XVI   MDIAG  (+++,+++) N +++  COL  +++                            00428900\nC**** VII  MDIAG  (+++,+++) N +++ N +++  VALUE ***                      00429000\nC**** VIII MDIAG  (+++,+++) N +++ VALUE ***                             00429100\nC**** XIX   MDIAG  (+++,+++) N +++ N +++  ITH,JTH ELEM\"\"(+++,+++)\"\"     00429200\nC**** XX    MDIAG  (+++,+++) N +++  ITH,JTH,ELEM \"\"(+++,+++)\"\"          00429300\nC**** XXI   SAME AS  XV-XX EXCEPT COMMAND IS ADIAG                      00429400\nC****                                                                   00429500\nC**** L2=1  MDEFINE,ADEFINE                                             00429600\nC**** L2=2  MZERO,AZERO,MERASE,AERASE                                   00429700\nC**** L2=3  MIDENT                                                      00429800\nC**** L2=4  MDIAG,ADIAG                                                 00429900\nC****                                                                   00430000\n      COMMON \/ HEADER\/NMCARD(72),ITLE(64,6),IHEAD(4,50),IFMT(17,6),     00430100\n     1 IFMTX(4),LNCNT,IPRINT,NPAGE,IPUNCH                               00430200\n      COMMON \/ SCRAT \/ A(10000),NS                                      00430300\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00430400\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00430500\n      DIMENSION ARGS(100)                                               00430600\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00430700\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00430800\n      DATA ONE\/1.0\/,ZERO\/0.0\/                                           00430900\n      GO TO (100,150,160,180),L2                                        00431000\n  100 IF(NARGS.NE.4.AND.NARGS.NE.5) CALL ERROR (10)                     00431100\n      IF(KIND(NARGS).NE.1) CALL ERROR (3)                               00431200\n      IF(NARGS.EQ.4) IARGS(4)=IARGS(3)                                  00431300\n      CONST=ARGS(NARGS)                                                 00431400\n      CONSTA=ARGS(NARGS)                                                00431500\n      J=NARGS-1                                                         00431600\n  105 CALL CKIND (J)                                                    00431700\n      IF(J.NE.0) CALL ERROR (3)                                         00431800\n      J=1                                                               00431900\n      CALL MTXCHK(J)                                                    00432000\n      IF(J.NE.0) CALL ERROR (17)                                        00432100\n      IF(NERROR.NE.0) RETURN                                            00432200\n      JB=IARGS(1)                                                       00432300\n      N=IARGS(3)                                                        00432400\n      K=IARGS(4)                                                        00432500\n      JA=JB                                                             00432600\n      IF(L2.EQ.4) GO TO 190                                             00432700\n      DO 120  KA=1,K                                                    00432800\n      JC=JB                                                             00432900\n      DO 110  NA=1,N                                                    00433000\n      RC(JC)=CONST                                                      00433100\n  110 JC=JC+1                                                           00433200\n      RC(JA)=CONSTA                                                     00433300\n      JA=JA+NROW+1                                                      00433400\n  120 JB=JB+NROW                                                        00433500\n      RETURN                                                            00433600\n  150 IF(NARGS.NE.3.AND.NARGS.NE.4) CALL ERROR(10)                      00433700\n      CONST=ZERO                                                        00433800\n      CONSTA=ZERO                                                       00433900\n      J=NARGS                                                           00434000\n      IF(NARGS.EQ.4) GO TO 105                                          00434100\n      IARGS(4)=IARGS(3)                                                 00434200\n      J=NARGS-1                                                         00434300\n      GO TO 105                                                         00434400\n  160 CONST=ZERO                                                        00434500\n      CONSTA=ONE                                                        00434600\n      J=NARGS                                                           00434700\n      IF(NARGS.NE.3) GO TO 170                                          00434800\n      IARGS(4)=IARGS(3)                                                 00434900\n      GO TO 105                                                         00435000\n  170 IF(NARGS.EQ.4.AND.KIND(4).EQ.0) GO TO 105                         00435100\n      CONSTA=ARGS(NARGS)                                                00435200\n      J = J-1                                                           00435300\n      IF(NARGS.EQ.5) GO TO 105                                          00435400\n      IF(NARGS.NE.4)  CALL ERROR (10)                                   00435500\n      IARGS(4)=IARGS(3)                                                 00435600\n      GO TO 105                                                         00435700\n  180 J=NARGS-1                                                         00435800\n      IF(NARGS.NE.4.AND.NARGS.NE.5) CALL ERROR (10)                     00435900\n      IF(NARGS.EQ.5) GO TO 105                                          00436000\n      IARGS(5) = IARGS(4)                                               00436100\n      IARGS(4)=IARGS(3)                                                 00436200\n      GO TO 105                                                         00436300\n  190 IF(KIND(NARGS).EQ.0) GO TO 210                                    00436400\n      DO 200  NA=1,N                                                    00436500\n      RC(JB)=ARGS(NARGS)                                                00436600\n  200 JB=JB+1+NROW                                                      00436700\n      RETURN                                                            00436800\n  210 KIND(5)=0                                                         00436900\n      CALL ADRESS(5,M)                                                  00437000\n      IF(M.GT.0) GO TO 220                                              00437100\n      CALL ERROR (11)                                                   00437200\n      RETURN                                                            00437300\n  220 DO  230 NA=1,N                                                    00437400\n      RC(JB)=RC(M)                                                      00437500\n      M=M+1                                                             00437600\n  230 JB=JB+1+NROW                                                      00437700\n      RETURN                                                            00437800\n      END                                                               00437900\nC  60  55      SUBROUTINE MOVE                     2 19 68              00438000\n      SUBROUTINE MOVE                                                   00438100\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00438200\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00438300\n      DIMENSION ARGS(100)                                               00438400\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00438500\nC     THIS ROUTINE IS ALSO CALLED BLOCKTRANSFER                         00438600\n      IF( NARGS .EQ. 6 ) GO TO 70                                       00438700\n      K = 10                                                            00438800\n  10  CALL ERROR( K )                                                   00438900\n  20  RETURN                                                            00439000\n  40  K = 20                                                            00439100\n      GO TO 20                                                          00439200\n  50  K = 11                                                            00439300\n      GO TO 20                                                          00439400\n  70  IARGS( 9 ) = IARGS( 1 ) + IARGS( 3 ) - 1                          00439500\n      IARGS( 13 ) = IARGS( 5 ) + IARGS( 3 ) - 1                         00439600\n      IF( KIND( 1 ) + KIND( 3 ) + KIND( 4 ) + KIND( 5 ) .NE. 0 )GO TO 4000439700\n      IF( IARGS( 1 ) .GT. 0 .AND. IARGS( 3 ) .GT. 0 .AND. IARGS( 5 )    00439800\n     1 .GT. 0 .AND. IARGS( 9 ) .LE. NROW .AND. IARGS( 13 ) .LE. NROW )  00439900\n     2 GO TO 80                                                         00440000\n      K = 16                                                            00440100\n      GO TO 10                                                          00440200\n  80  IARGS( 10 ) = IARGS( 2 ) + IARGS( 4 ) - 1                         00440300\n      KIND( 10 ) = 0                                                    00440400\n      IARGS( 14 ) = IARGS( 6 ) + IARGS( 4 ) - 1                         00440500\n      KIND( 14 ) = 0                                                    00440600\n      DO 90 I = 2, 14, 4                                                00440700\n      CALL ADRESS( I , IDUMY )                                          00440800\n      IARGS( I ) = IDUMY                                                00440900\n      IF( IARGS( I ) ) 40, 50, 90                                       00441000\n  90  IARGS( I ) = IARGS( I ) - 1                                       00441100\nC                                                                       00441200\nC     IF MOVE IS UP, IR = -1, IF DOWN, IR = +1                          00441300\nC     IF MOVE IS LEFT, IC = -1, IF RIGHT, IC = +1                       00441400\nC     DIRECTION OF MOVE IS SUCH THAT THE TWO AREAS CAN BE OVERLAPPING   00441500\nC     AND IT WILL BE DONE PROPERLY.                                     00441600\nC                                                                       00441700\n      IR = ISIGN( 1, IARGS( 5 ) - IARGS( 1 ) )                          00441800\n      IC = ISIGN( 1, IARGS( 6 ) - IARGS( 2 ) )                          00441900\n      MM = IARGS( 4*IR+5 ) + IARGS( 4*IC+6 )                            00442000\n      NN = IARGS( 4*IR+9 ) + IARGS( 4*IC+10 )                           00442100\n      IC = IC * NROW                                                    00442200\n      MMM = IARGS( 3 )                                                  00442300\n      NNN = IARGS( 4 )                                                  00442400\n      DO 210 J = 1, NNN                                                 00442500\n      M = MM                                                            00442600\n      N = NN                                                            00442700\n      DO 200 I = 1, MMM                                                 00442800\n      RC( N ) = RC ( M )                                                00442900\n      M = M - IR                                                        00443000\n 200  N = N - IR                                                        00443100\n      MM = MM - IC                                                      00443200\n 210  NN = NN - IC                                                      00443300\n      GO TO 20                                                          00443400\n      END                                                               00443500\nC  61 124      SUBROUTINE MRAISE                   2 19 68              00443600\n      SUBROUTINE MRAISE                                                 00443700\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00443800\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00443900\n      DIMENSION ARGS(100)                                               00444000\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00444100\nC *****                                                                 00444200\nC     SUBROUTINE TO RAISE A MATRIX TO A POWER                           00444300\nC           GENERAL FORMS OF MRAISE                                     00444400\nC               MRAISE A(,) N,N TO M POWER AND STORE IN  C(,)           00444500\nC               MRAISE A(,) N   TO M POWER AND STORE IN  C(,)           00444600\nC               M MAY BE INTEGER OR REAL                                00444700\nC *****                                                                 00444800\n      COMMON\/MULTC\/NS2                                                  00444900\n      COMMON \/ SCRAT \/ X,NS                                             00445000\n      DIMENSION A(10000)                                                00445100\n      DOUBLE PRECISION X(5000), SUM                                     00445200\n      DIMENSION IR(4),ISAVE(2)                                          00445300\n      EQUIVALENCE (IR,ISAVE)                                            00445400\n      NS2=NS\/2                                                          00445500\nC *****                                                                 00445600\nC     CHECK NUMBER OF ARGUMENTS                                         00445700\nC *****                                                                 00445800\n      IF(NARGS.NE.7.AND.NARGS.NE.6) CALL ERROR(10)                      00445900\nC *****                                                                 00446000\nC     CHECK TO SEE IF ALL ARGUMENTS ARE INTEGER                         00446100\nC *****                                                                 00446200\n      J=NARGS                                                           00446300\n      CALL CKIND(J)                                                     00446400\n      IF(J.EQ.0) GO TO 800                                              00446500\n      IF(KIND (NARGS-2).NE.0) GO TO 620                                 00446600\n      CALL ERROR (3)                                                    00446700\n      GO TO 800                                                         00446800\n 620  IARGS(NARGS-2)=ARGS(NARGS-2)                                      00446900\nC *****                                                                 00447000\nC     CHECK TO SEE IF DIMENSIONS ARE CORRECT                            00447100\nC *****                                                                 00447200\n  800 IF(NARGS.EQ.6) GO TO 1100                                         00447300\n      IF(IARGS(3).NE.IARGS(4)) CALL ERROR(3)                            00447400\nC *****                                                                 00447500\nC     CHECK TO SEE IF ARGUMENTS ARE OUT OF RANGE                        00447600\nC *****                                                                 00447700\n 1100 IR(3)=IARGS(3)                                                    00447800\n      IR(4)=IARGS(4)                                                    00447900\n      IR(1)=IARGS(1)                                                    00448000\n      IR(2)=IARGS(2)                                                    00448100\n      CALL MACHK(IR,J)                                                  00448200\n      IF(J.NE.0) CALL ERROR(17)                                         00448300\n      IR(1)=IARGS(NARGS-1)                                              00448400\n      IR(2)=IARGS(NARGS)                                                00448500\n      CALL MACHK(IR,J)                                                  00448600\n      IF(J.NE.0) CALL ERROR(17)                                         00448700\nC *****                                                                 00448800\nC     CHECK TO SEE IF PREVIOUS ERRORS                                   00448900\nC *****                                                                 00449000\n      IF(NERROR.NE.0) RETURN                                            00449100\nC *****                                                                 00449200\nC     FIND ADDRESSES OF COLUMNS                                         00449300\nC *****                                                                 00449400\n      NP=NARGS                                                          00449500\n      ISAVE(1)=IARGS(1)                                                 00449600\n      IARGS(1)=IARGS(2)                                                 00449700\n      IARGS(2)=IARGS(NARGS)                                             00449800\n      NARGS=2                                                           00449900\n      CALL CHKCOL(J)                                                    00450000\n      IARGS(1)=IARGS(1)+ISAVE(1)-1                                      00450100\n      IARGS(2)=IARGS(2)+IARGS(NP-1)-1                                   00450200\n      ISIZE=IARGS(3)                                                    00450300\nC *****                                                                 00450400\nC     BEGIN MULTIPLICATION                                              00450500\nC *****                                                                 00450600\nC *****                                                                 00450700\nC     MOVE ORIGINAL MATRIX TO SCRATCH AREA  (COLUMNWISE)                00450800\nC *****                                                                 00450900\n      IP=IARGS(1)                                                       00451000\n      IC=1                                                              00451100\n      DO    4040  J=1,ISIZE                                             00451200\n      DO    4020  I=1,ISIZE                                             00451300\n      A(IC)=RC(IP)                                                      00451400\n      IC=IC+1                                                           00451500\n      IP=IP+1                                                           00451600\n 4020 CONTINUE                                                          00451700\n      IP=IP+NROW-ISIZE                                                  00451800\n 4040 CONTINUE                                                          00451900\n      NPOW=IARGS(NP-2)-1                                                00452000\n      IXP=NS-ISIZE*2                                                    00452100\n      DO  5040     K=1,NPOW                                             00452200\n      ISAVP=IARGS(2)                                                    00452300\n      IMP=NS2                                                           00452400\n      IF(K.GT.1)  GO TO 4060                                            00452500\n      IRP=IARGS(1)                                                      00452600\n      GO TO 4070                                                        00452700\n 4060 IRP=IARGS(2)                                                      00452800\n 4070 DO 5040    I=1,ISIZE                                              00452900\n      ISAV =ISAVP                                                       00453000\n      IC=1                                                              00453100\n      IZ=IRP                                                            00453200\n      IX=IXP                                                            00453300\nC *****                                                                 00453400\nC     SAVE ROW OF MATRIX                                                00453500\nC *****                                                                 00453600\n      DO  4080   J=1,ISIZE                                              00453700\n      A(IX)=RC(IZ)                                                      00453800\n      IX=IX-1                                                           00453900\n      IZ=IZ+NROW                                                        00454000\n 4080 CONTINUE                                                          00454100\n      DO  5020   J=1,ISIZE                                              00454200\n      IX=IXP                                                            00454300\n      IM=IMP                                                            00454400\n      DO 5000    JP=1,ISIZE                                             00454500\n      X(IM)=A(IX)*A(IC)                                                 00454600\n      IM=IM-1                                                           00454700\n      IX=IX-1                                                           00454800\n      IC=IC+1                                                           00454900\n 5000 CONTINUE                                                          00455000\n      CALL SORTSM(ISIZE,SUM)                                            00455100\n      RC(ISAV )=SUM                                                     00455200\n      ISAV =ISAV +NROW                                                  00455300\n 5020 CONTINUE                                                          00455400\n      ISAVP=ISAVP+1                                                     00455500\n      IRP=IRP+1                                                         00455600\n 5040 CONTINUE                                                          00455700\n      RETURN                                                            00455800\n      END                                                               00455900\nC  62  96      SUBROUTINE MSCROW                   2 19 68              00456000\n      SUBROUTINE MSCROW                                                 00456100\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00456200\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00456300\n      DIMENSION ARGS(100)                                               00456400\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00456500\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00456600\nC      SUBROUTINE BY CARLA MESSINA 221.04      JUNE 1967                00456700\nC  TYPE 1 IS       PARSUM OF COL ++ , STORE IN COL ++                   00456800\nC  TYPE 2 IS       PARPRODUCT OF COL ++, STORE IN COL ++                00456900\nC  TYPE 3 IS       ROOT MEAN SQUARE      RMS OF COL ++, STORE IN COL ++ 00457000\nC  TYPE 4 IS       AVERAGE OF COL ++, STORE IN COL ++      (DOWN TO NRMA00457100\nC  TYPE 5 IS       SUM COL ++, STORE IN COL ++   (DOWN TO NRMAX)        00457200\nC                  SUM COL ++ FROM ROW ,, TO ROW ,, STORE IN COL ++     00457300\nC                  SUM COL ++  FROM ROWS NUMBERED ,, ,, ,, ,, ETC STORE 00457400\nC THE THREE TYPES OF SUM ARE IDENTIFIED BY THE NO. OF NARGS =2,3 AND 4 O00457500\n      ELEM = 0.0                                                        00457600\n      IF (NARGS - 2) 10,40,40                                           00457700\n10    K = 10                                                            00457800\n20    CALL ERROR(K)                                                     00457900\n30    RETURN                                                            00458000\n40    CALL ADRESS( 1, J1 )                                              00458100\n      IF (J1) 50,50,60                                                  00458200\n50    K = 3                                                             00458300\n      GO TO 20                                                          00458400\n60    CALL ADRESS( NARGS, J2 )                                          00458500\n      IF (J2) 50,50,70                                                  00458600\n70    IF (NARGS - 3) 200,80,80                                          00458700\n80    IF (L2-5) 10,85,10                                                00458800\n85    NARG1 = NARGS -1                                                  00458900\n      DO 100 I=2,NARG1                                                  00459000\n      IF (KIND(I) .NE. 0) GO TO 120                                     00459100\n      IF (IARGS(I)) 120,120,90                                          00459200\n90    IF (IARGS(I)-NROW) 100,100,120                                    00459300\n100   CONTINUE                                                          00459400\n      IF (NERROR .NE. 0) GO TO 30                                       00459500\n      IF( NARGS - 4 ) 110, 110, 170                                     00459600\nC                                                                       00459700\nC         SUM FROM ROW ,, TO ROW ,,                                     00459800\nC                                                                       00459900\n110   IF (IARGS(2) - IARGS(3)) 130,130,120                              00460000\n120   K = 16                                                            00460100\n      GO TO 20                                                          00460200\n130   IF (NRMAX) 140,140,150                                            00460300\n140   K = 9                                                             00460400\n      GO TO 20                                                          00460500\n150   J = J1 + IARGS( 2 )                                               00460600\n      ELEM = ELEM + RC( J - 1 )                                         00460700\n      IARGS(2) = IARGS(2) + 1                                           00460800\n      IF (IARGS(2) - IARGS(3)) 150,150,160                              00460900\n160   CALL VECTOR (ELEM,J2)                                             00461000\n      GO TO 30                                                          00461100\n170   IF (NRMAX) 140,140,180                                            00461200\nC                                                                       00461300\nC         SUM DISCRETE ROWS                                             00461400\nC                                                                       00461500\n180   DO 190 I = 2, NARG1                                               00461600\n      J = J1 + IARGS( I )                                               00461700\n190   ELEM = ELEM + RC( J - 1 )                                         00461800\n      GO TO 160                                                         00461900\n200   IF (NERROR .NE. 0) GO TO 30                                       00462000\n      IF (NRMAX) 140,140,210                                            00462100\n210   FNRMAX = NRMAX                                                    00462200\nC                                                                       00462300\nC         PARSUM, PARPRODUCT                                            00462400\nC                                                                       00462500\n      IF( L2 - 3 ) 220, 280, 300                                        00462600\n220   J = L2 - 1                                                        00462700\n      RC( J2 ) = RC( J1 )                                               00462800\n      IF( NRMAX .EQ. 1 ) GO TO 30                                       00462900\n      DO 240 I = 2, NRMAX                                               00463000\n      J1 = J1 + 1                                                       00463100\n      J2 = J2 + 1                                                       00463200\n      IF( J .EQ. 0 ) GO TO 230                                          00463300\n      RC( J2 ) = RC( J2 - 1 ) * RC( J1 )                                00463400\n      GO TO 240                                                         00463500\n230   RC( J2 ) = RC( J2 - 1 ) + RC( J1 )                                00463600\n240   CONTINUE                                                          00463700\n      GO TO 30                                                          00463800\nC                                                                       00463900\nC         RMS                                                           00464000\nC                                                                       00464100\n280   DO 290 I = 1,NRMAX                                                00464200\n      J = J1 + I                                                        00464300\n290   ELEM = ELEM + RC( J - 1 ) ** 2                                    00464400\n      ELEM = FSQRT(ELEM\/FNRMAX)                                         00464500\n      GO TO 160                                                         00464600\nC                                                                       00464700\nC         AVERAGE, SUM ENTIRE ROW                                       00464800\nC                                                                       00464900\n300   DO 310 I = 1,NRMAX                                                00465000\n      J = J1 + I                                                        00465100\n310   ELEM = ELEM + RC( J - 1 )                                         00465200\n      IF (L2 - 5) 320,160,160                                           00465300\n320   ELEM = ELEM\/FNRMAX                                                00465400\n      GO TO 160                                                         00465500\n      END                                                               00465600\nC  63 116      SUBROUTINE MXTX                     2 19 68              00465700\n      SUBROUTINE MXTX                                                   00465800\nC *****                                                                 00465900\nC     SUBROUTINE TO MULTIPLY MATRIX A BY ITS TRANSPOSE                  00466000\nC                OR TRANSPOSE OF MATRIX A BY MATRIX A                   00466100\nC        L2=1  MULTIPLY MATRIX BY ITS TRANSPOSE                         00466200\nC           GENERAL FORM OF COMMAND                                     00466300\nC                M(XXT)  A(,) N,K,  STORE IN  C(,)    N,K DEFINE X      00466400\nC                M(XXT)  A(,) N    STORE IN  C(,)                       00466500\nC        L2=2  MULTIPLY TRANSPOSE OF MATRIX BY ITSELF                   00466600\nC           GENERAL FORM OF COMMAD                                      00466700\nC                M(XTX)  A(,) N,K  STORE IN  C(,)    N,K  DEFINE X      00466800\nC                M(XTX)  A(,)N    STORE IN  C(,)                        00466900\nC     L2 = 3 IS M(XAX\")   SET L2 = 1 AND CALL TRANSF                    00467000\nC *****                                                                 00467100\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00467200\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00467300\n      COMMON \/ BLOCKF \/ NCTOP                                           00467400\n      DIMENSION ARGS(100)                                               00467500\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00467600\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00467700\n      COMMON \/ SCRAT \/ X,NS                                             00467800\n      DIMENSION A(10000)                                                00467900\n      DOUBLE PRECISION X(5000), SUM                                     00468000\n      DIMENSION  IR(4),ISAVE(2)                                         00468100\n      EQUIVALENCE (IR,ISAVE)                                            00468200\n      COMMON \/ MULTC \/ NS2                                              00468300\nC *****                                                                 00468400\nC     CHECK FOR CORRECT NUMBER OF AGRUMENTS                             00468500\nC     DECIDE WHETHER COMMAND IS M(XAX\") OR M(X\"AX)                      00468600\nC     L2 = 3 MEANS M(XAX\")   L2 = 2, NARGS .GT. 6 MEANS M(X\"AX)         00468700\nC                                                                       00468800\n      IF( L2-2 ) 100, 10, 20                                            00468900\n   10 IF( NARGS .LE. 6 ) GO TO 100                                      00469000\n   20 L2 = 4 - L2                                                       00469100\n      CALL TRANSF                                                       00469200\n      RETURN                                                            00469300\n  100 IF(NARGS .NE. 5 .AND. NARGS .NE. 6 ) CALL ERROR(10)               00469400\nC *****                                                                 00469500\nC     CHECK TO SEE IF ALL ARGUMENTS ARE INTEGERS                        00469600\nC *****                                                                 00469700\n      J=NARGS                                                           00469800\n      CALL CKIND(J)                                                     00469900\n      IF(J.NE.0)  CALL ERROR(3)                                         00470000\nC *****                                                                 00470100\nC     CHECK TO SEE IF DIMENSIONS ARE OUT OF RANGE                       00470200\nC     COMPUTE ADDRESSES                                                 00470300\nC *****                                                                 00470400\n      IF( NARGS.EQ. 6 ) GO TO 120                                       00470500\n      IARGS(6) = IARGS(NARGS)                                           00470600\n      IARGS(5) = IARGS(NARGS-1)                                         00470700\n      IARGS(4) = IARGS(3)                                               00470800\n  120 GO TO (140,160),L2                                                00470900\n  140 IARGS(8)=IARGS(3)                                                 00471000\n      IARGS(7)=IARGS(3)                                                 00471100\n      GO TO 200                                                         00471200\n  160 IARGS(8)=IARGS(4)                                                 00471300\n      IARGS(7)=IARGS(4)                                                 00471400\n  200 J=2                                                               00471500\n      CALL MTXCHK(J)                                                    00471600\n      IF(J-1) 260, 220, 240                                             00471700\n  220 CALL ERROR(3)                                                     00471800\n      RETURN                                                            00471900\n  240 CALL ERROR(17)                                                    00472000\n      RETURN                                                            00472100\nC *****                                                                 00472200\nC     CHECK FOR PREVIOUS ERRORS                                         00472300\nC *****                                                                 00472400\n  260 IF(NERROR .NE. 0) RETURN                                          00472500\n      GO TO (300,320),L2                                                00472600\n  300 IP=IARGS(3)                                                       00472700\n      JP=IARGS(4)                                                       00472800\n      IADD1=NROW                                                        00472900\n      IADD2=1                                                           00473000\n      GO TO 340                                                         00473100\n  320 IP=IARGS(4)                                                       00473200\n      JP=IARGS(3)                                                       00473300\n      IADD1=1                                                           00473400\n      IADD2=NROW                                                        00473500\n 340  NS2=NS\/2                                                          00473600\n      IC=1                                                              00473700\n      IBP=IARGS(1)                                                      00473800\n      DO  440   K=1,IP                                                  00473900\n      IAP=IARGS(1)                                                      00474000\n      DO   420   I=1,IP                                                 00474100\n      IA=IAP                                                            00474200\n      IB=IBP                                                            00474300\n      IS=NS2                                                            00474400\n      DO   400   J=1,JP                                                 00474500\n      X(IS)=RC(IA)*RC(IB)                                               00474600\n      IS=IS-1                                                           00474700\n      IA=IA+IADD1                                                       00474800\n      IB=IB+IADD1                                                       00474900\n 400  CONTINUE                                                          00475000\n      IAP=IAP+IADD2                                                     00475100\n      CALL SORTSM(JP,SUM)                                               00475200\n      A(IC) = SUM                                                       00475300\n      IC=IC+1                                                           00475400\n 420  CONTINUE                                                          00475500\n      IBP=IBP+IADD2                                                     00475600\n 440  CONTINUE                                                          00475700\nC *****                                                                 00475800\nC     MOVE FROM SCRATCH AREA TO STORAGE                                 00475900\nC *****                                                                 00476000\n      IS=1                                                              00476100\n      IC = IARGS( 5 )                                                   00476200\n      DO   520    I=1,IP                                                00476300\n      DO   500    J=1,IP                                                00476400\n      RC(IC) = A(IS)                                                    00476500\n      IS=IS+1                                                           00476600\n      IC=IC+1                                                           00476700\n 500  CONTINUE                                                          00476800\n      IC = IC + ( NROW+NCTOP-1 ) - IP                                   00476900\n 520  CONTINUE                                                          00477000\n      RETURN                                                            00477100\n      END                                                               00477200\nC  64  40      SUBROUTINE MTXCHK(J)                2 19 68              00477300\n      SUBROUTINE MTXCHK(J)                                              00477400\nC     S PEAVY FOR OMNITAB   9\/5\/67                                      00477500\nC     J AS INPUT = NO OF MATRICES TO BE CHECKED                         00477600\nC       IARGS(1), IARGS(5),...,IARGS(4*(J-1)+1) STARTING ROW    OF  MAT 00477700\nC       IARGS(2), IARGS(6),...,IARGS(4*(J-1)+2) STARTING COLUMN OF  MAT 00477800\nC       IARGS(3), IARGS(7),...,IARGS(4*(J-1)+3) NO. OF ROWS             00477900\nC       IARGS(4), IARGS(8),...,IARGS(4*(J-1)+4)  NO OF COLUMNS          00478000\nC                                                                       00478100\nC     UPON RETURN                                                       00478200\nC     J=0  IF  ALL MATRICES ARE IN WORK SHEET                           00478300\nC     AND                                                               00478400\nC       IARGS(1),IARGS(5),...,IARGS(4*(J-1)+1) WILL CONTAIN STARTING    00478500\nC       ADDRESS OF MATRIX                                               00478600\nC     J GT  ZERO  IF  MATRIX IS NOT IN WORK SHEET                       00478700\nC     J=1 SOME IARGS ARE NEGATIVE,  J=2 MATRIX TO BIG FOR WORK SHEET    00478800\n      COMMON \/ HEADER\/NMCARD(72),ITLE(64,6),IHEAD(4,50),IFMT(17,6),     00478900\n     1 IFMTX(4),LNCNT,IPRINT,NPAGE,IPUNCH                               00479000\n      COMMON \/ SCRAT \/ A(10000),NS                                      00479100\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00479200\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00479300\n      DIMENSION ARGS(100)                                               00479400\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00479500\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00479600\n      JA=J                                                              00479700\n      JB=4*J                                                            00479800\n      J = 0                                                             00479900\n      DO  100  I=1,JB                                                   00480000\n      IF(IARGS(I).GT.0) GO TO 100                                       00480100\n      J=1                                                               00480200\n      RETURN                                                            00480300\n  100 CONTINUE                                                          00480400\n      DO  120  I=1,JB,4                                                 00480500\n      IF(IARGS(I)+IARGS(I+2)-1.GT.NROW) GO TO 130                       00480600\n      IF(IARGS(I+1)+IARGS(I+3)-1.GT.NCOL) GO TO 130                     00480700\n      CALL ADRESS(I+1,JC)                                               00480800\n 120  IARGS(I)=JC+IARGS(I)-1                                            00480900\n      RETURN                                                            00481000\n 130  J=2                                                               00481100\n      RETURN                                                            00481200\n      END                                                               00481300\nC  65  75      SUBROUTINE NNAME(NAME)              2 19 68              00481400\n      SUBROUTINE NNAME(NAME)                                            00481500\n      COMMON \/ BLOCKA\/MODE,M,KARD(83),KARG,ARG,ARG2,NEWCD(80),KRDEND    00481600\n      DIMENSION NAME(2),MISC(6)                                         00481700\nC                                                                       00481800\nC THIS SUBROUTINE ASSEMBLES A NAME UP TO THE FIRST NON-LETTER OR UP TO  00481900\nC SIX LETTER, WHICHEVER IS FIRST. THE INDEX, M, IS INITIALLY POINTING AT00482000\nC THE FIRST LETTER, IT IS LEFT POINTING AT THE FIRST NON-LETTER.        00482100\nC                                                                       00482200\nC                                                                       00482300\nC                                                                       00482400\nC                                                                       00482500\nC                                                                       00482600\nC                                                                       00482700\nC                                                                       00482800\nC             SPACE OUT SO THAT TABLE LIES  ALL ON ONE PAGE             00482900\nC                                                                       00483000\nC                                                                       00483100\nC                                                                       00483200\nC                                                                       00483300\nC                                                                       00483400\nC                                                                       00483500\nC                                                                       00483600\nC                                                                       00483700\nC                                                                       00483800\nC                                                                       00483900\nC                                                                       00484000\nC                                                                       00484100\nC        CONVERSION TABLE FOR ALPHABETIC TO NUMERIC AS USED BY OMNITAB. 00484200\nC                                                                       00484300\nC                  A       729        27         1                      00484400\nC                  B      1458        54         2                      00484500\nC                  C      2187        81         3                      00484600\nC                  D      2916       108         4                      00484700\nC                  E      3645       135         5                      00484800\nC                  F      4374       162         6                      00484900\nC                  G      5103       189         7                      00485000\nC                  H      5832       216         8                      00485100\nC                  I      6561       243         9                      00485200\nC                  J      7290       270        10                      00485300\nC                  K      8019       297        11                      00485400\nC                  L      8748       324        12                      00485500\nC                  M      9477       351        13                      00485600\nC                  N     10206       378        14                      00485700\nC                  O     10935       405        15                      00485800\nC                  P     11664       432        16                      00485900\nC                  Q     12393       459        17                      00486000\nC                  R     13122       486        18                      00486100\nC                  S     13851       513        19                      00486200\nC                  T     14580       540        20                      00486300\nC                  U     15309       567        21                      00486400\nC                  V     16038       594        22                      00486500\nC                  W     16767       621        23                      00486600\nC                  X     17496       648        24                      00486700\nC                  Y     18225       675        25                      00486800\nC                  Z     18954       702        26                      00486900\nC                                                                       00487000\nC                                                                       00487100\nC     THE FIRST THREE CHARACTERS GO INTO THE FIRST WORD OF NAME         00487200\nC     THE SECOND THREE CHARACTERS GO INTO THE SECOND WORD OF NAME       00487300\nC                                                                       00487400\nC                                                                       00487500\n      DO 10 I=1,6                                                       00487600\n 10   MISC(I)=0                                                         00487700\n      DO 20 I=1,6                                                       00487800\n      L=KARD(M)-9                                                       00487900\n      IF(L.LT.1.OR.L.GE.27)GO TO 40                                     00488000\n      MISC(I)=L                                                         00488100\n 20   M=M+1                                                             00488200\n 30   IF(KARD(M).LT.10.OR.KARD(M).GE.36)GO TO 40                        00488300\n      M=M+1                                                             00488400\n      GO TO 30                                                          00488500\n 40   NAME(1)=MISC(3)+27*(MISC(2)+27*MISC(1))                           00488600\n      NAME(2)=MISC(6)+27*(MISC(5)+27*MISC(4))                           00488700\n      RETURN                                                            00488800\n      END                                                               00488900\nC  66  13      FUNCTION NONBLA(I)                  2 19 68              00489000\n      FUNCTION NONBLA(I)                                                00489100\n      COMMON \/ BLOCKA\/MODE,M,KARD(83),KARG,ARG,ARG2,NEWCD(80),KRDEND    00489200\nC                                                                       00489300\nC     SCAN KARD STARTING AT KARD(I) UNTIL A NON-BLANK CHARACTER IS      00489400\nC     FOUND.  POINT M AT IT AND ALSO RETURN IT AS FUNCTION VALUE.       00489500\nC                                                                       00489600\n      M=I                                                               00489700\n   1  IF(KARD(M).NE.44)GO TO 2                                          00489800\n      M=M+1                                                             00489900\n      GO TO 1                                                           00490000\n   2  NONBLA=KARD(M)                                                    00490100\n      RETURN                                                            00490200\n      END                                                               00490300\nC  67  38      SUBROUTINE OMCONV( NWCD, KRD, KRDE  2 19 68              00490400\n      SUBROUTINE OMCONV( NWCD, KRD, KRDEND )                            00490500\n      COMMON \/ ABCDEF \/ L(48)                                           00490600\nC                                                                       00490700\nC     ARRAY L CONTAINS THE ALPHABET FORMATTED  1H                       00490800\nC                                                                       00490900\nC     THIS ROUTINE CONVERTS INPUT CARD IMAGES TO A STANDARD CODE SO     00491000\nC     THAT OMNITAB CAN DEAL WITH THE CHARACTERS AS INTEGERS.            00491100\nC                                                                       00491200\nC                                                                       00491300\nC     THIS ROUTINE IS INCLUDED ONLY FOR COMPLETENESS.  IT SHOULD BE     00491400\nC     REWRITTEN IN ASSEMBLY LANGUAGE FOR EACH COMPUTER.  ALSO, IT       00491500\nC     CANNOT MEET ASA STANDARDS BECAUSE ASA DOES NOT REQUIRE THAT DATA  00491600\nC     READ WITH FORMAT  A1  BE STORED THE SAME AS HOLLERITH DATA  SETUP 00491700\nC     WITH  1H    ALTHOUGH THEY WILL BE THE SAME ON MOST COMPUTERS.     00491800\nC                                                                       00491900\nC     ALSO, ASA DOESNT RECOGNIZE THE CHARACTER  \"  APOSTROPHE  WHICH    00492000\nC     OMNITAB EQUATES TO THE  *  ASTERISK.                              00492100\nC     THIS LAST ITEM IS NOT IMPORTANT TO THE EXECUTION OF OMNITAB, IT   00492200\nC     IS ONLY A CONVENIENCE.                                            00492300\nC                                                                       00492400\n      DIMENSION NWCD( 1 ), KRD( 1 )                                     00492500\n      DO 30 I = 1, KRDEND                                               00492600\n      IJK = I                                                           00492700\n      K=NWCD(I)                                                         00492800\n      IF(K.NE.L(45))GO TO 10                                            00492900\n      J=45                                                              00493000\n      GO TO 30                                                          00493100\n  10  DO 20 M=1,46                                                      00493200\n      J=M                                                               00493300\n      IF(K.EQ.L(J))GO TO 30                                             00493400\n  20  CONTINUE                                                          00493500\n      IF(K.NE.L(47))GO TO 25                                            00493600\n      J=41                                                              00493700\n  30  KRD(I)=J-1                                                        00493800\n      RETURN                                                            00493900\n   25 KRD( IJK ) = 46                                                   00494000\n      RETURN                                                            00494100\n      END                                                               00494200\nC  68 311      SUBROUTINE OMNIT                    2 19 68              00494300\n      SUBROUTINE OMNIT                                                  00494400\nC     *************** THIS IS THE MAIN OMNITAB ROUTINE *****************00494500\n      COMMON \/ BLOCKA\/MODE,M,KARD(83),KARG,ARG,ARG2,NEWCD(80),KRDEND    00494600\n      COMMON \/BLOCKB\/NSTMT,NSTMTX,NSTMTH,NCOM,LCOM,IOVFL,COM(2000)      00494700\n      COMMON \/BLOCKC\/KIO,INUNIT,ISCRAT,KBDOUT,KRDKNT                    00494800\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00494900\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00495000\n      DIMENSION ARGS(100)                                               00495100\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00495200\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00495300\n      COMMON \/ HEADER\/NMCARD(72),ITLE(64,6),IHEAD(4,50),IFMT(17,6),     00495400\n     1 IFMTX(4),LNCNT,IPRINT,NPAGE,IPUNCH                               00495500\n      DATA IBLANK\/1H \/,LETSGO\/-1\/                                       00495600\nC                                                                       00495700\nC     THIS IS THE MAIN OMNITAB PROGRAM                                  00495800\nC                                                                       00495900\nC                                                                       00496000\nC     SUBROUTINES CALLED BY THIS PROGRAM..                              00496100\nC     SETUP,INPUT,ERROR,STMT,NNAME,AARGS,ASTER,SETQ,READQ,STORE,XECUTE  00496200\nC     AERR,XOMNIT,XFORMT,LOOKUP                                         00496300\nC                                                                       00496400\nC                                                                       00496500\nC     MOD = 1  INTERPRETIVE MODE                                        00496600\nC          = 2  DATA MODE (READ  SET)                                   00496700\nC          = 3  STORAGE MODE (BETWEEN BEGIN AND FINISH)                 00496800\nC          =4  IMPLIED STORAGE MODE (STATEMENT NUMBER GIVEN)            00496900\nC                                                                       00497000\nC                                                                       00497100\nC     0 =  0,  1 =  1, ETC., 9 =  9, A = 10, B = 11, ETC, Z= 35, \/ = 36 00497200\nC     . = 37, - = 38, + = 39, * = 40, ( = 41, ) = 42, , = 43            00497300\nC     BLANK = 44, = = 45, $ AND OTHERS = 46                             00497400\nC                                                                       00497500\nC-----------------------------------------------------------------------00497600\nC                                                                       00497700\nC     THIS IS A CALL TO   SYSTEM TO ESTABLISH THE PRINTER PAGE TO BE    00497800\nC     62 LINES LONG STARTING ON LINE 3. UNIQUE TO NBS 1108 INSTALLATION.00497900\nC                                                                       00498000\nC     CALL PGSIZE( 3, 62 )                                              00498100\nC                                                                       00498200\nC-----------------------------------------------------------------------00498300\n      CALL SETUP                                                        00498400\n  50  IF(MODE.EQ.3)NSTMT=NSTMT+10                                       00498500\n      IF(MODE.EQ.4)MODE=1                                               00498600\n      NAME(1)=0                                                         00498700\n      NAME(2)=0                                                         00498800\n      NAME(3)=0                                                         00498900\n      NAME(4)=0                                                         00499000\n      NARGS=0                                                           00499100\n      J=0                                                               00499200\nC                                                                       00499300\nC     CHECK FOR ACCUMULATED ERRORS DURING LAST EXECUTED COMMAND         00499400\nC                                                                       00499500\n      CALL AERR(0)                                                      00499600\n  52  CALL INPUT                                                        00499700\nC                                                                       00499800\nC     SCANNING BEGINS WITH THE THIRD CHARACTER. THE FIRST TWO ARE DUMMY 00499900\nC     TO KEEP THE PROGRAM OUT OF TROUBLE.  SCANNING TERMINATES WITH A $ 00500000\nC     A $ HAS BEEN PLANTED IN THE (KRDEND+1)-TH POSITION.               00500100\nC                                                                       00500200\n      M=2                                                               00500300\n  55  M=M+1                                                             00500400\n      K=KARD(M)                                                         00500500\n      IF(K.GE.36)IF(K-46)55,58,55                                       00500600\n      IF(K.GE.10)GO TO 70                                               00500700\nC                                                                       00500800\nC     A NUMBER IS THE FIRST ALPHANUMERIC CHARACTER ENCOUNTERED, ERROR IF00500900\nC     IN MODE 3                                                         00501000\nC                                                                       00501100\n      CALL OUTPUT                                                       00501200\n      IF(MODE.NE.3)GO TO 60                                             00501300\n  57  CALL ERROR(2)                                                     00501400\n      GO TO 52                                                          00501500\n  58  IF( MODE .NE. 4 ) CALL OUTPUT                                     00501600\n      GO TO 50                                                          00501700\n  60  CALL STMT(NSTMT)                                                  00501800\n      IF(KARG.NE.0)IF(MODE-2)57,98,57                                   00501900\nC                                                                       00502000\nC     IF AN ILLEGAL STATEMENT NUMBER WAS FOUND, KARG = 1 (KARG = 0 IF   00502100\nC     LEGAL)                                                            00502200\nC                                                                       00502300\n      MODE=4                                                            00502400\nC                                                                       00502500\nC     M IS POINTING AT THE FIRST LETTER ON THE CARD, ASSEMBLE NAME.     00502600\nC                                                                       00502700\n  70  CALL NNAME(NAME(1))                                               00502800\nC                                                                       00502900\nC                                                                       00503000\nC     CHECK THE FIRST NAME FOR SPECIAL NAMES...                         00503100\nC     OMNITAB, FORMAT, NOTE, FOOTNOTE, HEAD,TITLE                       00503200\nC                                                                       00503300\nC     OMNITAB                                                           00503400\nC                                                                       00503500\n      IF(NAME(1).NE.11300.OR.NAME(2).NE.7102)IF(LETSGO)80,81,81         00503600\nC                                                                       00503700\nC     IF NOT THE FIRST OMNITAB CARD, WRITE EOF RECORD.                  00503800\nC                                                                       00503900\n      IF (LETSGO .NE. -1 ) WRITE( ISCRAT, 75 )                          00504000\n  75  FORMAT(1HZ,83X)                                                   00504100\n      LETSGO=LETSGO+1                                                   00504200\n  80  CALL XOMNIT(LETSGO)                                               00504300\n      IF( LETSGO .NE. -1 ) GO TO 50                                     00504400\n      LETSGO=0                                                          00504500\nC                                                                       00504600\nC     FINISH                                                            00504700\nC                                                                       00504800\n  81  IF(NAME(1).NE.4631.OR.NAME(2).NE.7082) GO TO 811                  00504900\n      MODE = 1                                                          00505000\n      GO TO 58                                                          00505100\nC                                                                       00505200\nC     FORMAT                                                            00505300\nC                                                                       00505400\n  811 IF( MODE .NE. 4 ) CALL OUTPUT                                     00505500\n      IF(NAME(1).NE.4797.OR.NAME(2).NE.9524) GO TO 82                   00505600\n      CALL XFORMT                                                       00505700\n  812 IF(MODE.GE.3)CALL ERROR(202)                                      00505800\n      IF(MODE.NE.3)MODE=1                                               00505900\n      GO TO 50                                                          00506000\nC                                                                       00506100\nC     NOTE                                                              00506200\nC                                                                       00506300\n  82  IF(NAME(1).NE.10631.OR.NAME(2).NE.3645)GO TO 83                   00506400\n  822 WRITE(IPRINT,825)(NEWCD(I-2),I=M,74)                              00506500\n  825 FORMAT(10X,72A1)                                                  00506600\n      LNCNT=LNCNT+1                                                     00506700\n      GO TO 812                                                         00506800\nC                                                                       00506900\nC     FOOTNOTE                                                          00507000\nC                                                                       00507100\n  83  IF(NAME(1).NE.4794.OR.NAME(2).NE.14973)GO TO 84                   00507200\n      IF(LNCNT.GE.61)GO TO 822                                          00507300\n      DO 831 LNCNX=LNCNT,61                                             00507400\n  831 WRITE(IPRINT,832)                                                 00507500\n  832 FORMAT(1H )                                                       00507600\n      LNCNT=61                                                          00507700\n      GO TO 822                                                         00507800\nC                                                                       00507900\nC     HEAD                                                              00508000\nC                                                                       00508100\n  84  IF(NAME(1).NE.5968.OR.NAME(2).NE.2916)GO TO 85                    00508200\n      CALL XHEAD                                                        00508300\n      GO TO 812                                                         00508400\nC                                                                       00508500\nC     TITLES.     TITLEX=TITLE5 , TITLEY = TITLE6                       00508600\nC                                                                       00508700\n   85 IF ( NAME(1) .NE. 14843 ) GO TO 87                                00508800\nC     CHECK NAME  TITLE                                                 00508900\n      IF ( NAME(2) .EQ. 8883 ) GO TO 852                                00509000\nC     CHECK TITLEX AND TITLEY                                           00509100\n      K = 5                                                             00509200\n      IF ( NAME(2) .NE. 8908 ) IF ( NAME(2) - 8907 ) 87,854,87          00509300\n      K = 6                                                             00509400\n      GO TO 854                                                         00509500\n  852 K = KARD( M )                                                     00509600\n      IF ( K .GE. 1 .AND. K .LE. 6 ) GO TO 854                          00509700\n      CALL ERROR(209)                                                   00509800\n      K = 1                                                             00509900\n  854 MM = MIN0( M+59 , 81 )                                            00510000\n      DO 856 I=1,60                                                     00510100\n  856 ITLE(I,K) = IBLANK                                                00510200\n      I = 1                                                             00510300\n      DO 858 MX=M,MM                                                    00510400\n      ITLE(I,K) = NEWCD( MX-1 )                                         00510500\n  858 I = I + 1                                                         00510600\n      GO TO 812                                                         00510700\nC                                                                       00510800\nC         STOP                                                          00510900\nC                                                                       00511000\n  87  IF(NAME(1).NE.14406.OR.NAME(2).NE.11664)GO TO 89                  00511100\n      WRITE( ISCRAT, 75 )                                               00511200\n      CALL XSTOP                                                        00511300\n      STOP                                                              00511400\nC                                                                       00511500\nC     M IS POINTING AT THE FIRST NON-LETTER AFTER NAME. LOOK FOR        00511600\nC     POSSIBLE NAME QUALIFIER OR ARGUMENTS OR END OF CARD.              00511700\nC                                                                       00511800\n  89  K=KARD(M)                                                         00511900\n      IF(K.LT.36)IF(K-10)100,90,90                                      00512000\n      IF(K.EQ.40)GO TO 100                                              00512100\n      IF(K.EQ.46)GO TO 200                                              00512200\n      M=M+1                                                             00512300\n      GO TO 89                                                          00512400\nC                                                                       00512500\nC     A LETTER FOUND, ASSEMBLE SECOND NAME (COMMAND QUALIFIER).         00512600\nC                                                                       00512700\n  90  CALL NNAME(NAME(3))                                               00512800\nC                                                                       00512900\nC     CHECK SPECIAL CASE OF NAMES M(XAX\"), M(X\"AX), M(XX\"), M(X\"X)      00513000\nC                                                                       00513100\nC     SKIP ONE CHARACTER (\") IF FIRST NAME =(M  )                       00513200\n      IF( NAME(1) .EQ. 9477 ) M = M + 1                                 00513300\n      GO TO 100                                                         00513400\nC                                                                       00513500\nC     SCAN FOR ARGUMENTS AND END OF CARD                                00513600\nC                                                                       00513700\n  98  M=3                                                               00513800\n 100  J=J+1                                                             00513900\n      GO TO 102                                                         00514000\n 101  M=M+1                                                             00514100\n 102  K=KARD(M)                                                         00514200\n      IF(K.GE.10)IF(K-40)101,120,199                                    00514300\nC                                                                       00514400\nC     NUMBER FOUND, CONVERT ARGUMENT. IF KARG RETURNED = 0, NUMBER IS   00514500\nC     INTEGER,IF KARG = 1, NUMBER IS FLOATING POINT, IF KARG = -1, ERROR00514600\nC                                                                       00514700\n      CALL AARGS                                                        00514800\n      IF(KARG)50,105,103                                                00514900\n 103  ARGTAB(J)=0.                                                      00515000\n      J=J+1                                                             00515100\n      GO TO 110                                                         00515200\nC                                                                       00515300\nC     ARGUMENT IS AN INTEGER. ADD A BIAS OF 8192 THEN CHECK THAT IT IS  00515400\nC     .GT. 0                                                            00515500\nC                                                                       00515600\n 105  ARG=ARG+8192.                                                     00515700\n      IF(ARG.GT.0.)GO TO 110                                            00515800\n      CALL ERROR(18)                                                    00515900\n      GO TO 50                                                          00516000\n 110  ARGTAB(J)=ARG                                                     00516100\n  115 NARGS = NARGS + 1                                                 00516200\n      GO TO 100                                                         00516300\nC                                                                       00516400\nC     ASTERISK FOUND, CONVERT                                           00516500\nC                                                                       00516600\nC     IF BRACKETED BY SINGLE ASTERISKS, QUANTITY IS TO BE USED AS A     00516700\nC     FLOATING POINT ARGUMENT.IF BRACKETED BY DOUBLE ASTERISKS, QUANTITY00516800\nC     IS TO BE TRUNCATED AND USED AS AN INTEGER ARGUMENT.               00516900\nC                                                                       00517000\n 120  KARG=1                                                            00517100\n      M=M+1                                                             00517200\n      IF(KARD(M).NE.40)GO TO 125                                        00517300\n      KARG=0                                                            00517400\n      M=M+1                                                             00517500\n 125  CALL ASTER                                                        00517600\nC                                                                       00517700\nC     THE TERMINAL ASTERISK(S) HAVE BEEN CHECKED TO BE THE SAME AS THE  00517800\nC     INTITAL SET (IF NO ERROR) AND M IS POINTING AT THE FIRST CHARACTER00517900\nC     AFTER THE LAST ASTERISK.                                          00518000\nC                                                                       00518100\nC     KARG RETURNED AS 1 = ERROR FOUND                                  00518200\nC                      2 = FLOATING POINT CONSTANT, Z.B.  *PI*          00518300\nC                      3 = INTEGER NAMED VARIABLE,  Z.B. **NRMAX**      00518400\nC                      4 = FL. PT. NAMED VARIABLE,  Z.B.  *NRMAX*       00518500\nC                      5 = INTEGER ROW-COLUMN,      Z.B. **3,40**       00518600\nC                      6 = FL. PT. ROW-COLUMN,      Z.B.  *1,2*         00518700\nC                      7 = STRING OF ASTERISKS      Z.B. ***            00518800\nC                                                                       00518900\nC     A STRING OF THREE OR MORE ASTERISKS IMPLIES -THRU-                00519000\nC     EXAMPLE..                                                         00519100\nC     ERASE 1 2 3 4 12 13 14 15 16 20     IS EQUIVALENT TO              00519200\nC     ERASE 1 *** 4, 12 *** 16, 20                                      00519300\nC                                                                       00519400\nC     PRINT 1 20 19 18 17 16 15 14          IS EQUIVALENT TO            00519500\nC     PRINT 1, 20 *** 14                                                00519600\nC                                                                       00519700\nC                                                                       00519800\n      GO TO ( 50, 103, 135, 135, 140, 140, 150 ), KARG                  00519900\n 135  ARGTAB(J)=-2.*ARG-FLOAT(KARG-3)                                   00520000\n      GO TO 115                                                         00520100\n 140  ARGTAB(J)=-(ARG+8208.)                                            00520200\n      ARG2=ARG2+8192.                                                   00520300\n      IF(KARG.EQ.6)ARG2=-ARG2                                           00520400\n      J=J+1                                                             00520500\n      ARGTAB(J)=ARG2                                                    00520600\n      GO TO 115                                                         00520700\n 150  IF( J .GT. 0 ) GO TO 155                                          00520800\n      CALL ERROR( 211 )                                                 00520900\n      GO TO 102                                                         00521000\n 155  ARGTAB( J ) = -1.                                                 00521100\n      GO TO 100                                                         00521200\nC                                                                       00521300\nC                                                                       00521400\nC                            ARGTAB SETUP                               00521500\nC                                                                       00521600\nC     IF ENTRY .GT. 0, IT IS AN INTEGER CONSTANT (Z.B. COLUMN NUMBER)   00521700\nC     TO WHICH A BIAS OF 8192 HAS BEEN ADDED.  THIS IS TO SAY THAT A    00521800\nC     NEGATIVE INTEGER ARGUMENT MAY NOT BE EXPLICITLY GIVEN OR MODIFIED 00521900\nC     TO BE LESS THAT -8191.                                            00522000\nC                                                                       00522100\nC     IF ENTRY .EQ.0, THE NEXT ENTRY IS A FLOATING POINT CONSTANT.      00522200\nC                                                                       00522300\nC     IF ENTRY .LT. 0, ARGUMENT IS A VARIABLE. SET SIGN POSITIVE AND..  00522400\nC                                                                       00522500\nC         IF ENTRY .LT. 16, IT IS A NAMED VARIABLE REFERENCE NUMBER     00522600\nC                                                                       00522700\nC             2,3  NRMAX      6,7    V       10,11    X                 00522800\nC         IF  4,5  COLTOP     8,9    W       12,13    Y                 00522900\nC                                            14,15    Z                 00523000\nC                                                                       00523100\nC                                                                       00523200\nC             V,W,X,Y,Z, ARE FOR PROGRAMMING CONVENIENCE ONLY AND DO NOT00523300\nC             AFFECT THE OPERATION OF OMNITAB                           00523400\nC                                                                       00523500\nC             IF ENTRY IS EVEN, CURRENT VALUE TO BE TRUNCATED AND USED  00523600\nC             AS AN INTEGER ARGUMENT.                                   00523700\nC             IF ENTRY IS ODD. THE CURRENT VALUE IS TO BE USED AS A     00523800\nC             FLOATING POINT ARGUMENT.                                  00523900\nC                                                                       00524000\nC         IF ENTRY .GT. 16, IT IS A WORKSHEET REFERENCE (ROW,COLUMN) TO 00524100\nC                  WHICH A BIAS OF 8192. HAS BEEN ADDED.                00524200\nC             ENTRY - 8208 = ROW NUMBER                                 00524300\nC             ABS(NEXT ENTRY) = COLUMN NUMBER TO WHICH A BIAS OF 8192.  00524400\nC                  HAS BEEN ADDED.                                      00524500\nC                                                                       00524600\nC             IF NEXT ENTRY IS NEGATIVE, WORKSHEET CONTENTS ARE TO BE   00524700\nC             USED AS A FLOATING POINT CONSTANT.  IF +, WORKSHEET VALUE 00524800\nC             TO BE TRUNCATED AND USED AS AN INTEGER ARGUMENT.          00524900\nC                                                                       00525000\nC                                                                       00525100\n 199  IF(K.NE.46)GO TO 101                                              00525200\nC                                                                       00525300\nC     END OF CARD FOUND ( $ ENCOUNTERED)                                00525400\nC  69  32C                                         2 19 68              00525500\nC                                                                       00525600\n 200  IF(J.EQ.0)J=1                                                     00525700\n      IF(MODE.NE.2.OR.NAME(1).NE.0)GO TO 210                            00525800\nC                                                                       00525900\nC     IN INPUT MODE AND NO POSSIBLE NAME, RETURN TO SET OR READ ROUTINE 00526000\nC                                                                       00526100\n 202  CALL EXPAND( J, ARGTAB )                                          00526200\n      IF( ISRFLG .EQ. 0 ) GO TO 204                                     00526300\n      CALL SETQ                                                         00526400\n      GO TO 50                                                          00526500\n 204  CALL READQ                                                        00526600\n      GO TO 50                                                          00526700\nC                                                                       00526800\nC     LOOK UP NAME (AND POSSIBLE QUALIFIER) IN DICTIONARY. RETURN       00526900\nC     COORDINATES OF ENTRY. IF L1 = 0, NAME NOT FOUND                   00527000\nC                                                                       00527100\n 210  CALL LOOKUP                                                       00527200\n      IF(L1.NE.0)GO TO 220                                              00527300\n      IF(MODE.EQ.2)GO TO 202                                            00527400\n      CALL ERROR(1)                                                     00527500\n      GO TO 50                                                          00527600\nC                                                                       00527700\nC     NAME FOUND                                                        00527800\nC                                                                       00527900\n 220  IF(MODE.EQ.2)MODE=1                                               00528000\n      IF(MODE.EQ.1)GO TO 222                                            00528100\n      CALL STORE(J)                                                     00528200\n      GO TO 50                                                          00528300\n 222  CALL EXPAND( J, ARGTAB )                                          00528400\n      CALL XECUTE                                                       00528500\n      GO TO 50                                                          00528600\n      END                                                               00528700\nC  70 477      SUBROUTINE ORTHO                    2 19 68              00528800\n      SUBROUTINE ORTHO                                                  00528900\nC                                                                       00529000\n      COMMON \/ HEADER\/NMCARD(72),ITLE(64,6),IHEAD(4,50),IFMT(17,6),     00529100\n     1 IFMTX(4),LNCNT,IPRINT,NPAGE,IPUNCH                               00529200\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00529300\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00529400\n      DIMENSION ARGS(100)                                               00529500\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00529600\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00529700\n      COMMON \/ SCRAT \/ SCRA(10000),NS                                   00529800\nC *******       *******       *******                                   00529900\nC   ORTHONORMALIZATION PROGRAM  BY PHILIP J. WALSH  JULY 1, 1967        00530000\nC   LEAST SQUARES PROGRAM USING GRAM SCHMIDT PROCESS                    00530100\nC                                                                       00530200\nC   POLYFIT  Y IN ++, WEIGHTS IN ++,  X IN ++,  DEGREE ++, STORE COEF.IN00530300\nC                 ++  AND DEVIATIONS IN ++                              00530400\nC                                                                       00530500\nC   FIT  Y IN ++,  WEIGHTS IN ++, X IN ++, X IN ++, ..., STORE COEF. IN 00530600\nC                 ++  AND DEVIATIONS IN ++                              00530700\nC                                                                       00530800\nC   SOLVE  B IN ++, USING COEF. MATRIX IN ++, ++, ..., ++, STORE COEF IN00530900\nC                 ++ AND  DEVIATIONS IN ++                              00531000\nC                                                                       00531100\nC                                                                       00531200\nC                                                                       00531300\nC                                                                       00531400\n      IX1 (I,J,IN) = IN + I * (I-1)\/2 + J                               00531500\n      IX2 (I,J,IP) = IP + I * (I-1)\/2 + J                               00531600\nC     PRECHECKING SECTION                                               00531700\n      IF(NARGS .GT. 0 ) GO TO 10000                                     00531800\n      K = 10                                                            00531900\n      GO TO 10001                                                       00532000\n10000 NRBAR = 1                                                         00532100\n      N = NRMAX                                                         00532200\n      FN = N                                                            00532300\nC     GET Y COLUMN (OR B COLUMN IF SOLVE)                               00532400\n      CALL ADRESS( 1,L11)                                               00532500\n      IF ( L11 ) 9000, 9000, 9010                                       00532600\n 9000 K = 11                                                            00532700\n10001 CALL ERROR( K )                                                   00532800\n      RETURN                                                            00532900\n 9010 CALL ADRESS(NARGS,L66)                                            00533000\n      CALL ADRESS(NARGS-1,L55)                                          00533100\n      IF (L66) 9000,9000, 8000                                          00533200\n 8000 IF (L55) 9000,9000, 8010                                          00533300\n 8010 L66 = L66 - 1                                                     00533400\n      L55 = L55 -1                                                      00533500\n      GO TO ( 9020, 9020, 9020, 9020, 9030, 9030) , L2                  00533600\nC     GET WEIGHTS (IF NOT SOLVE )                                       00533700\n 9020 CALL ADRESS( 2, L22)                                              00533800\n      IF ( L22)  9000, 9000, 9040                                       00533900\n 9040 NMUI = 2                                                          00534000\n      L22 = L22 - 1                                                     00534100\n      SU = 0.                                                           00534200\n      DO 9100 I = 1, NRMAX                                              00534300\n      IF (RC( I + L22 ) ) 9110,9100, 9110                               00534400\n 9110 SU = SU + 1.0                                                     00534500\n 9100 CONTINUE                                                          00534600\n      GO TO (9050,9050,9060,9060), L2                                   00534700\nC     THIS IS POLYFIT                                                   00534800\n 9050 IF( NARGS .NE. 6) GO TO 9000                                      00534900\n      M = IARGS(4) + 1                                                  00535000\n      GO TO 9120                                                        00535100\nC     THIS IS FIT                                                       00535200\n 9060 M = NARGS - 4                                                     00535300\n      IF (NARGS - 5) 9000, 9120, 9120                                   00535400\nC     THIS IS SOLVE                                                     00535500\n 9030 M = NARGS - 3                                                     00535600\n      DENOM = 1.0                                                       00535700\n      NMUI = 1                                                          00535800\n      IF ( NARGS - 4) 9000, 9070, 9070                                  00535900\nC     Y IN L11 W IN L22  AND WEIGHT SWITCH SET AT THIS POINT            00536000\nC                                                                       00536100\nC     CALCULATE SCRATCH AREA REQUIREMENTS ...                           00536200\n 9120 FM = M                                                            00536300\n      IF (FN - SU ) 9000, 9140, 9150                                    00536400\n 9150 IF (SU - FM ) 9000, 9160, 9140                                    00536500\n 9140 DENOM = FSQRT( SU - FM )                                          00536600\n      GO TO 9070                                                        00536700\n 9160 DENOM = 1.0                                                       00536800\n 9070 NPM = N + M                                                       00536900\n      M1 = M - 1                                                        00537000\n      M2 = M + 1                                                        00537100\n      N1 = N - 1                                                        00537200\n      N2 = N + 1                                                        00537300\n      MD1 = ( M * (M2)) \/ 2                                             00537400\nC                                                                       00537500\nC                                                                       00537600\n      ND1 = M2 * NPM                                                    00537700\nC                                                                       00537800\nC     X REQUIRES ND1 CELLS                                              00537900\nC     GET SCRA (ND1 + 1) FOR START OF PK                                00538000\n      ND2 = M*NPM                                                       00538100\n      MD3 = ND2 + N                                                     00538200\n      ND3 = ND1                                                         00538300\nC     ADD NPM TO REACH XP                                               00538400\n      ND4 = ND3 + NPM                                                   00538500\nC     ADD NPM TO REACH QK                                               00538600\n      ND5 = ND4 + NPM                                                   00538700\nC     ADD (M+1) TO REACH CV                                             00538800\n      ND6 = ND5 + M2                                                    00538900\nC     ADD (M*(M+1))\/2 + M  TO REACH VCV                                 00539000\n      ND66 = MD1 + M                                                    00539100\n      ND7  = ND6 + ND66                                                 00539200\nC   ADD THE SAME AMOUNT TO REACH Q                                      00539300\n      ND8 = ND7 + ND66                                                  00539400\nC     Q IS (M+1) CELLS LONG  THEN COMES Q2                              00539500\n      ND9 = ND8 + M2                                                    00539600\nC Q2 E AND EP ARE EACH M CELLS LONG                                     00539700\n      ND10 = ND9 + M                                                    00539800\n      ND11 = ND10 + M                                                   00539900\n      ND12 = ND11 + M                                                   00540000\nC THE A MATRIX IS NEXT                                                  00540100\n      ND13 = ND12 + MD1                                                 00540200\nC GRAM FACTOR STORAGE                                                   00540300\n      ND14 = ND13 + M2                                                  00540400\nC  ENF                                                                  00540500\nC CV DIAGONALS                                                          00540600\n      ND16 = ND14 + M                                                   00540700\nC VCV DIAGONALS                                                         00540800\n      ND17 = ND16 + M                                                   00540900\n      ND18 = ND17 + M                                                   00541000\n      IF( ND18 - 10000 ) 9090,9090,9000                                 00541100\nC                                                                       00541200\n 9090 IF( NERROR .NE. 0 ) RETURN                                        00541300\n      GO TO ( 1, 1, 2, 2, 3, 3 ), L2                                    00541400\nC    THIS IS POLYFIT                                                    00541500\n    1 CALL ADRESS(3,L33)                                                00541600\n      IF (L33) 9000, 9000, 11                                           00541700\n   11 L33 = L33 - 1                                                     00541800\n      DO 21 I = 1, N                                                    00541900\n      K = I + NPM                                                       00542000\n      SCRA( I) = 1.0                                                    00542100\n   21 SCRA(K) = RC(I + L33)                                             00542200\n      IF ( M .EQ. 2 ) GO TO 100                                         00542300\n      DO 41 K = 2, M1                                                   00542400\n      K2 = K* NPM                                                       00542500\n      K1 = K2 - NPM                                                     00542600\n      DO 31 I = 1, N                                                    00542700\n      I2 = I + K2                                                       00542800\n      I1 = I + K1                                                       00542900\n   31 SCRA(I2) = SCRA(I1) * RC(I + L33)                                 00543000\n   41 CONTINUE                                                          00543100\n      GO TO 100                                                         00543200\n    2 I = 3                                                             00543300\n      GO TO 14                                                          00543400\n    3 I = 2                                                             00543500\n   14 L44 = NARGS - 2                                                   00543600\n      J = 0                                                             00543700\n      DO 44 I1 = I,L44                                                  00543800\n      K1 = J * NPM                                                      00543900\n      CALL ADRESS(I1, L33)                                              00544000\n      IF (L33) 9000, 9000, 24                                           00544100\n   24 L33 = L33 - 1                                                     00544200\n      DO 54 I2 = 1, N                                                   00544300\n      K2 = K1 + I2                                                      00544400\n   54 SCRA(K2) = RC(I2 + L33)                                           00544500\n   44 J = J + 1                                                         00544600\nC     GENERATE IDENTITY MATRIX AUGMENTATION                             00544700\n  100 DO 120  K = 1, M                                                  00544800\n      K1 = (K - 1) * NPM + N                                            00544900\n      DO 110  I = 1, M                                                  00545000\n      K2  = K1 + I                                                      00545100\n  110 SCRA( K2) = 0.0                                                   00545200\n      K2 = K1 + K                                                       00545300\n  120 SCRA(K2) = 1.0                                                    00545400\nC     BEGIN THE G.S. PROCESS                                            00545500\n  200 NBEI = 1                                                          00545600\n      NRHI = 1                                                          00545700\n      I18  = 1                                                          00545800\n  210 NGAI = 2                                                          00545900\n      NSII = 2                                                          00546000\n  230 NDEI = 1                                                          00546100\n      NNUI = 1                                                          00546200\n      LZ1  = 1                                                          00546300\n      LZ2  = 1                                                          00546400\nC  K CONTROLS WHOLE  LOOP                                               00546500\n      K = 1                                                             00546600\n  240 NTHI = 1                                                          00546700\n  250 NALI = 1                                                          00546800\n      NOMI = 1                                                          00546900\n  260 DO  270  J = 1, M                                                 00547000\n      NJ = ND3 + N + J                                                  00547100\n  270 SCRA (NJ) = 0.0                                                   00547200\nC****    BOX 6.                                                         00547300\n  390 KD1 =(K-1)* NPM                                                   00547400\n      DO  300  I = 1, N                                                 00547500\n      I1 = ND3 + I                                                      00547600\n      I2 = KD1 + I                                                      00547700\n      GO TO ( 280, 290), NMUI                                           00547800\nC****    PK(I)                                                          00547900\n  280 SCRA( I1) =  SCRA (I2)                                            00548000\n      GO  TO 300                                                        00548100\n  290 SCRA (I1) =  SCRA (I2) * RC ( I + L22)                            00548200\n  300 CONTINUE                                                          00548300\n  310 GO TO ( 320, 330), NOMI                                           00548400\n  320 DO  340 I = 1, K                                                  00548500\n      I1 = (I-1)*NPM                                                    00548600\n      SUM = 0.0                                                         00548700\n      DO  350 J = 1, NPM                                                00548800\n      I2 = I1 + J                                                       00548900\n      J2 = J + ND3                                                      00549000\n  350 SUM = SUM + SCRA(J2) * SCRA(I2)                                   00549100\n      I2 = I + ND5                                                      00549200\nC****     QK(I)                                                         00549300\n  340 SCRA(I2) = SUM                                                    00549400\n      GO TO 360                                                         00549500\n  330 DK2 = 0.                                                          00549600\n      I1 =(K-1) * NPM                                                   00549700\n      DO  370 I = 1, NPM                                                00549800\n  370 DK2 = DK2 +  SCRA ( I + ND3) * SCRA (I + I1)                      00549900\n      DK = FSQRT( DK2 )                                                 00550000\nC****    GRAM FACTORS                                                   00550100\n      SCRA ( I18 + ND13) = DK                                           00550200\n      I18 = I18 + 1                                                     00550300\n      K1 = (K-1)* NPM                                                   00550400\n      DO  380  I = 1, NPM                                               00550500\n  380 SCRA  (I + K1) = SCRA (I + K1) \/ DK                               00550600\n      NOMI  = 1                                                         00550700\n      GO TO 390                                                         00550800\nC****    BOX8                                                           00550900\n  360 GO TO ( 400, 410), NDEI                                           00551000\n  400 LZ1 = -LZ1                                                        00551100\n      IF (LZ1)  420, 430, 430                                           00551200\nC****    BOX8A                                                          00551300\n  430 K1 = K- 1                                                         00551400\n      DO  440  I = 1, K1                                                00551500\n  440 SCRA (I+ND5) =  - SCRA(I +ND5)                                    00551600\n      SCRA (K+ND5) = 1.0                                                00551700\n      DO  450  I = 1, NPM                                               00551800\n      SUM = 0.0                                                         00551900\n      DO  460  J = 1, K                                                 00552000\n      J1 = (J-1)* NPM                                                   00552100\n  460 SUM = SUM +  SCRA (I +J1) * SCRA (J+ND5 )                         00552200\nC****    XP(I)                                                          00552300\n  450 SCRA (I + ND4 ) = SUM                                             00552400\n      GO TO  470                                                        00552500\nC****    BOX8B    GET QK(I18)                                           00552600\n  420 SCRA(ND14+I18)=FSQRT(SCRA(ND5+K))                                 00552700\n      GO TO 430                                                         00552800\nC****    NDE1                                                           00552900\n  410 LZ2 = -LZ2                                                        00553000\n      IF (LZ2) 480, 430, 430                                            00553100\nC****    GET E AMD OTHER VECTORS                                        00553200\n  480 DO  490 I = 1, M                                                  00553300\n      SCRA (I + ND8) = SCRA( I + ND5)                                   00553400\n  490 SCRA (I + ND9) = SCRA( I + ND5) * SCRA (I + ND5)                  00553500\n      SCRA ( ND8 + M2) = SCRA (ND5 + M2)                                00553600\n      SCRA ( ND10 + 1) = SCRA ( ND8 +M2) -  SCRA(ND9 + 1)               00553700\n      DO  500  J = 2, M                                                 00553800\n      J1 = J - 1                                                        00553900\n  500 SCRA (ND10 + J) =  SCRA (ND10 + J1) - SCRA( ND9 + J)              00554000\n      FI = 1.0                                                          00554100\n      DO  510  I = 1, M                                                 00554200\n      IF (FN - FI)   520,520, 530                                       00554300\n  530 IF ( SCRA ( ND10 +I)) 540,550,550                                 00554400\n  540 SCRA (ND11 + I)  = - SQRT ( ABS ( SCRA ( I+ND10))\/(FN-FI))        00554500\n      GO TO 510                                                         00554600\n  550 SCRA(I + ND11) = SQRT(SCRA(I + ND10)\/(FN-FI))                     00554700\n      GO TO 510                                                         00554800\n  520 SCRA (I+ND10) = -1.0                                              00554900\n  510 FI = FI + 1.0                                                     00555000\n      GO TO 430                                                         00555100\nC****    BOX9                                                           00555200\n  470 GO TO (610,620,630), NTHI                                         00555300\n  610 K1 = (K-1)* NPM                                                   00555400\n      DO  640 I= 1, NPM                                                 00555500\n  640 SCRA ( I + K1) =  SCRA (I + ND4)                                  00555600\n      GO TO 800                                                         00555700\n  620 DO  650 I = 1, N                                                  00555800\n  650 RC( I + L66) =  SCRA ( I + ND4)                                   00555900\n      DO  660 I = 1, M                                                  00556000\n      NI = N+I                                                          00556100\n      KK1= I+1                                                          00556200\n  660 RC(L55+KK1) =  - SCRA( NI + ND4)                                  00556300\n      NTHI = 3                                                          00556400\n      GO TO 610                                                         00556500\n  630 GO TO 900                                                         00556600\nC****    BOX10                                                          00556700\n  800 GO TO (810, 830), NALI                                            00556800\n  810 NOMI = 2                                                          00556900\n      NALI = 2                                                          00557000\n      GO TO 390                                                         00557100\n  830 IF  (K - M) 820, 1000, 1000                                       00557200\n  820 K= K+1                                                            00557300\n      GO TO 240                                                         00557400\n  900 GO TO (910,920), NNUI                                             00557500\n  910 NNUI = 2                                                          00557600\n      GO TO  1200                                                       00557700\n  920 SS =  DK \/ DENOM                                                  00557800\n      SSQ = SS*SS                                                       00557900\n  930 RC ( L55 +1) = SS                                                 00558000\n      GO TO 1200                                                        00558100\n 1000 GO TO (1010,1020), NBEI                                           00558200\nC**  ******    ***** ****** ***** ****** *****                          00558300\nC GET THE A MATRIX                                                      00558400\n 1010 K1 = 1                                                            00558500\n      DO 1060 I = 1, M                                                  00558600\n      I1 = I*N + (I-1)*M                                                00558700\n      DO 1070 J = 1, I                                                  00558800\n      I2 = J + I1                                                       00558900\n      K2 = K1 + ND12                                                    00559000\n      SCRA(K2) = SCRA (I2)                                              00559100\n 1070 K1 = K1+ 1                                                        00559200\n 1060 CONTINUE                                                          00559300\n      GMDT = 1.0                                                        00559400\n      DO 1080 I = 1, M                                                  00559500\n 1080 GMDT = GMDT *(SCRA (I + ND13)\/ SCRA(I +ND14)   )                  00559600\n      GMDT = GMDT * GMDT                                                00559700\nC                                                                       00559800\n      NDEI = 2                                                          00559900\n      NBEI = 2                                                          00560000\n      NTHI = 2                                                          00560100\n      K = K + 1                                                         00560200\n      GO TO 1030                                                        00560300\n 1020 GO TO 900                                                         00560400\n 1030 GO TO (1040,1050),NGAI                                            00560500\n 1040 GO TO 900                                                         00560600\nC GET CV MATRIC                                                         00560700\n 1050 CONTINUE                                                          00560800\n      DO  111  IH = 1, M                                                00560900\n      LOC = IX2 (IH,0, ND6)                                             00561000\n      DO  111  J = 1, IH                                                00561100\n      SUM = 0.                                                          00561200\n      DO  112  KK = IH, M                                               00561300\n      LOC1 = IX1( KK, IH, ND12)                                         00561400\n      LOC2 = IX1( KK, J, ND12)                                          00561500\n 112  SUM = SUM + SCRA (LOC1)* SCRA(LOC2)                               00561600\n 111  SCRA ( LOC + J) = SUM                                             00561700\n      J = 1                                                             00561800\n      SCRA(J+ND16)=FSQRT(SCRA(J+ND6))                                   00561900\n      DO 2050 I = 2, M                                                  00562000\n      J1 = I + J + ND6                                                  00562100\nC**           THE ARGUMENT IN THE FOLLOWING SQRT OCCASIONALLY IS NEGATIV00562200\n      SCRA(I+ND16)=FSQRT(SCRA(J1))                                      00562300\n 2050 J = J + I                                                         00562400\n      NGAI = 1                                                          00562500\n      GO TO 900                                                         00562600\n 1200 GO TO (1210,1220),NRHI                                            00562700\n 1210 IF(NRBAR) 1230,1500,1230                                          00562800\n 1230 NRBAR = NRBAR - 1                                                 00562900\n      NTHI = 2                                                          00563000\n      NRHI = 2                                                          00563100\n      L11 = L11 - 1                                                     00563200\n      DO 1240 I = 1,N                                                   00563300\n      I1 = I + ND2                                                      00563400\n 1240 SCRA(I1) = RC(I+L11)                                              00563500\n      DO 1250 I = 1, M                                                  00563600\n      I1 = I + MD3                                                      00563700\n 1250 SCRA(I1) = 0.                                                     00563800\n      GO TO 250                                                         00563900\n 1220 GO TO (1410,1420), NSII                                           00564000\n 1410 GO TO 1210                                                        00564100\nC GET VCV AND DEV AND COEF                                              00564200\n 1420 DO 1421 I = 1,MD1                                                 00564300\n 1421 SCRA(I + ND7) = SSQ* SCRA(I + ND6)                                00564400\n      DO 2070 I = 1,M                                                   00564500\n      J1 = I + L55 + M2                                                 00564600\n      SCRA(I+ND17)= SS*SCRA(I+ND16)                                     00564700\n 2070 RC(J1) = SCRA(I+ND17)                                             00564800\n      GO TO 1210                                                        00564900\nC THE CALCULATIONS ARE COMPLETED. NOW OUTPUT THE RESULTS                00565000\n 1500 GO TO ( 2000, 5000, 2000, 5000, 2000, 5000), L2                   00565100\n 5000 RETURN                                                            00565200\n 2000 CALL PAGE (4)                                                     00565300\nC GET POLYFIT INFORMATION                                               00565400\n      IF ( L2 - 3 )  2010,2020,2100                                     00565500\nC THIS IS POLYFIT                                                       00565600\n 2010 WRITE(IPRINT,2001) IARGS(4),IARGS(1),IARGS(3)                     00565700\n      KL1 = IARGS( 4 ) + 1                                              00565800\n      DO 2700 I=1,KL1                                                   00565900\n 2700 IARGS(I+2) = I-1                                                  00566000\n      GO TO 2030                                                        00566100\nC THIS IS FIT                                                           00566200\n 2020 J=NARGS-2                                                         00566300\n      WRITE(IPRINT,2021) (IARGS(I),I=1,J)                               00566400\n 2030 I = SU                                                            00566500\n      WRITE(IPRINT,2031) I,IARGS(2)                                     00566600\n      IF ( L2 .NE. 3 ) GO TO 2701                                       00566700\n      WRITE(IPRINT,2032)                                                00566800\n      GO TO 2702                                                        00566900\n 2701 WRITE(IPRINT,2732)                                                00567000\n 2702 L55 = L55+1                                                       00567100\n      DO 2038 I = 1,M                                                   00567200\n      J = I + M + L55                                                   00567300\n      WRITE(IPRINT,2235) IARGS(I+2),RC(I+L55),RC(J)                     00567400\n 2038 CONTINUE                                                          00567500\n      WRITE(IPRINT,2033) SS                                             00567600\n      WRITE(IPRINT,2034)                                                00567700\n      DO2040 I = 1, M                                                   00567800\n      LOC = IX2(I,0,ND6)                                                00567900\n 2040 WRITE(IPRINT,2035) (SCRA(J+LOC),J=1,I)                            00568000\n      WRITE(IPRINT,2036)                                                00568100\n      WRITE(IPRINT,2035) (SCRA(I+ND16),I=1,M)                           00568200\nC REPEAT THIS FOR  VARIANCE COVARIANCE MATRIX                           00568300\n      WRITE(IPRINT,2037)                                                00568400\n      DO 2060  I = 1, M                                                 00568500\n      LOC = IX2(I,0,ND7)                                                00568600\n 2060 WRITE(IPRINT,2035) (SCRA(J+LOC),J=1,I)                            00568700\n      WRITE(IPRINT,2071)                                                00568800\n      WRITE(IPRINT,2035) (SCRA(I+ND17),I=1,M)                           00568900\n      WRITE(IPRINT,2082)                                                00569000\n      DO 2083 I = 1,M                                                   00569100\n      LOC = IX2(I,0,ND12)                                               00569200\n 2083 WRITE(IPRINT,2035) (SCRA(J+LOC),J=1,I)                            00569300\n      CALL PAGE (4)                                                     00569400\n      WRITE(IPRINT,2081) GMDT                                           00569500\n      WRITE(IPRINT,2080)                                                00569600\n      DO  2090  I =  1,  M                                              00569700\n 2090 WRITE(IPRINT,2035) SCRA(I+ND13),SCRA(I+ND8),SCRA(I+ND9)           00569800\n     1 , SCRA (I + ND10), SCRA (I + ND11), SCRA (I + ND14)              00569900\n      WRITE(IPRINT,2035)SCRA(ND14),SCRA(ND9)                            00570000\n      WRITE(IPRINT,2133)                                                00570100\n      IDF=SU                                                            00570200\n      XSQR=SCRA(ND9)\/SU                                                 00570300\n      JGO = 2                                                           00570400\n      IF ( L2 .EQ. 1 ) JGO = 1                                          00570500\n      WRITE(IPRINT,2134) SCRA(ND9),IDF,XSQR                             00570600\n      DO 2091 I=1,M                                                     00570700\n      IDF = SU-FLOAT(I)                                                 00570800\n      XSQR=SCRA(I+ND9)                                                  00570900\n      XSQE=SCRA(I+ND10)\/FLOAT(IDF)                                      00571000\n      FCALC=XSQR\/XSQE                                                   00571100\n      JONE=1                                                            00571200\n      GO TO (2781,2782),JGO                                             00571300\n 2782 WRITE(IPRINT,2135) IARGS(I+2),SCRA(I+ND9),JONE,XSQR,FCALC,SCRA(I +00571400\n     1 ND10),IDF,     XSQE,SCRA(I+ND11)                                 00571500\n      GO TO 2091                                                        00571600\n 2781 WRITE(IPRINT,2735) IARGS(I+2),SCRA(I+ND9),JONE,XSQR,FCALC,SCRA(I +00571700\n     1 ND10),IDF,     XSQE,SCRA(I+ND11)                                 00571800\n 2091 CONTINUE                                                          00571900\n      XSQ=SCRA(ND9)-SCRA(ND10+M)                                        00572000\n      XSQE=XSQ\/FLOAT(M)                                                 00572100\n      FCALC=XSQE\/(SCRA(M+ND10)\/(SU-FLOAT(M)))                           00572200\n      WRITE(IPRINT,2136)XSQ,M,XSQE,FCALC                                00572300\n      GO TO 5000                                                        00572400\n 2100 J = NARGS - 2                                                     00572500\n      WRITE(IPRINT,2110) (IARGS(I),I=1,J)                               00572600\n      WRITE(IPRINT,2115)                                                00572700\n      L55 = L55 + 1                                                     00572800\n      DO 2120 I = 1,M                                                   00572900\n      J = I + M + L55                                                   00573000\n      WRITE(IPRINT,2035) RC(I+L55),RC(J)                                00573100\n 2120 CONTINUE                                                          00573200\n      GO TO 5000                                                        00573300\n 2001 FORMAT(25H0POLYNOMIAL FIT OF DEGREE I3,19H TO THE FUNCTION IN I4, 00573400\n     1                  1H.\/\/42H THE INDEPENDENT VARIABLE (X) IS IN COLU00573500\n     1MN  I4,1H.)                                                       00573600\n 2021 FORMAT(34H0REGRESSION FIT OF THE FUNCTION IN I4,11H,WEIGHTS IN I4,00573700\n     127H,USING VARIABLES IN COLUMNS\/\/ (14I5) )                         00573800\n 2032 FORMAT(62H0VARIABLE IN COLUMN     COEFFICIENT AND ITS STANDARD DEV00573900\n     1IATION,\/)                                                         00574000\n 2732 FORMAT(62H0TERM OF DEGREE         COEFFICIENT AND ITS STANDARD DEV00574100\n     1IATION,\/)                                                         00574200\n 2031 FORMAT(1H0,I4,34H NON-ZERO WEIGHTS APPEAR IN COLUMN I4,1H.)       00574300\n 2033 FORMAT(20H0STANDARD DEVIATION 1P1E15.7)                           00574400\n 2035 FORMAT(1P8E15.7)                                                  00574500\n 2034 FORMAT(54H0THE INVERSE OF THE X\"X MATRIX OF THE NORMAL EQUATIONS\/)00574600\n 2036 FORMAT(53H0THE SQUARE ROOT OF THE DIAGONALS OF THE ABOVE MATRIX\/) 00574700\n 2037 FORMAT(50H0THE VARIANCE-COVARIANCE MATRIX OF THE REGRESSION ,     00574800\n     112HCOEFFICIENTS\/)                                                 00574900\n 2071 FORMAT(67H0THE SQUARE ROOT OF THE DIAGONALS IN THE VARIANCE-COVARI00575000\n     1ANCE MATRIX \/ )                                                   00575100\n 2080 FORMAT( 1H0,5X,2HGF,14X,2HFC,13X,3HSFC,13X,3HSSR,13X,1HR,         00575200\n     1     13X,2HVN \/)                                                  00575300\n 2081 FORMAT(20H0GRAM DETERMINANT   1P1E15.7)                           00575400\n 2082 FORMAT(20H0THE A(I,J) MATRIX   \/)                                 00575500\n 2110  FORMAT(36H0SOLUTION OBTAINED BY FIT TO COLUMN   I3,\/30H USING COE00575600\n     1FFICIENTS IN COLUMNS   \/(14I5))                                   00575700\n 2115 FORMAT(28H0SOLUTION AND UNCERTAINTIES    \/)                       00575800\n 2133 FORMAT(\/\/30X,21H ANALYSIS OF VARIANCE,\/  7H0SOURCE,17X,15HSUM OF S00575900\n     1QUARES , 7H   D.F.,6X,11HMEAN SQUARE,10X,1HF,12X,4HS.D.)          00576000\n 2134 FORMAT( 6H0TOTAL,18X,1PE15.7,I6,4X,1PE15.7  )                     00576100\n 2135 FORMAT(19H0VARIABLE IN COLUMN,I5,1PE15.7,I6,4X,1PE15.7,0PF11.2,\/  00576200\n     1  9H RESIDUAL,15X,1PE15.7,I6,4X,1PE15.7,19X,1PE15.7  )            00576300\n 2735 FORMAT(19H0TERM OF DEGREE    ,I5,1PE15.7,I6,4X,1PE15.7,0PF11.2,\/  00576400\n     1  9H RESIDUAL,15X,1PE15.7,I6,4X,1PE15.7,19X,1PE15.7  )            00576500\n 2136 FORMAT(16H0TOTAL REDUCTION,8X,1PE15.7,I6,4X,1PE15.7,F11.2 )       00576600\n 2235 FORMAT(14X,I4,7X,2(1PE15.7)  )                                    00576700\n      END                                                               00576800\nC  71  22      SUBROUTINE OUTPUT                   2 19 68              00576900\n      SUBROUTINE OUTPUT                                                 00577000\n      COMMON \/ BLOCKA\/MODE,M,KARD(83),KARG,ARG,ARG2,NEWCD(80),KRDEND    00577100\n      COMMON \/BLOCKB\/NSTMT,NSTMTX,NSTMTH,NCOM,LCOM,IOVFL,COM(2000)      00577200\n      COMMON \/BLOCKC\/KIO,INUNIT,ISCRAT,KBDOUT,KRDKNT                    00577300\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00577400\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00577500\n      DIMENSION ARGS(100)                                               00577600\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00577700\n      COMMON \/ FLAGS \/ NSUMRY, LLIST                                    00577800\nC                                                                       00577900\nC     WRITE RECORD ON SCRATCH UNIT                                      00578000\nC                                                                       00578100\n      IF( NERROR .EQ. 0 .AND. LLIST .EQ. 0 ) GO TO 15                   00578200\n      IF( MODE .EQ. 3 ) GO TO 20                                        00578300\n      WRITE( ISCRAT, 10 ) NEWCD                                         00578400\n  10  FORMAT(4X,80A1)                                                   00578500\n  15  RETURN                                                            00578600\n  20  I = NSTMT \/ 10                                                    00578700\n      WRITE( ISCRAT, 25 ) I, NEWCD                                      00578800\n  25  FORMAT(1H+,I3,80A1)                                               00578900\n      GO TO 15                                                          00579000\n      END                                                               00579100\nC  72  18      SUBROUTINE PAGE( J )                2 19 68              00579200\n      SUBROUTINE PAGE( J )                                              00579300\n      COMMON \/ HEADER\/NMCARD(72),ITLE(64,6),IHEAD(4,50),IFMT(17,6),     00579400\n     1 IFMTX(4),LNCNT,IPRINT,NPAGE,IPUNCH                               00579500\nC                                                                       00579600\nC         BRING UP A NEW PAGE AND PRINT OMNITAB CARD AND PAGE NUMBER    00579700\nC         THEN, IF J = 0, DONE                                          00579800\nC                 J = 1, PRINT TITLE1                                   00579900\nC                  J = 2, PRINT TITLE1, 2                               00580000\nC                    ETC. FOR J = 3, 4                                  00580100\nC                                                                       00580200\n      NPAGE = NPAGE + 1                                                 00580300\n      WRITE( IPRINT, 100 ) NMCARD, NPAGE                                00580400\n      IF( J .LE. 0 .OR. J .GT. 4 ) GO TO 10                             00580500\n      WRITE( IPRINT, 101 ) ( ( ITLE( I, II ), I = 1, 60 ), II = 1, J )  00580600\n  10  RETURN                                                            00580700\n 100  FORMAT(1H1,19X,72A1,10X,4HPAGE,I4)                                00580800\n 101  FORMAT(1X,120A1\/1X,120A1)                                         00580900\n      END                                                               00581000\nC  73   4      SUBROUTINE PAGEX                    2 19 68              00581100\n      SUBROUTINE PAGEX                                                  00581200\n      CALL X( \"PAGEX\" )                                                 00581300\n      RETURN                                                            00581400\n      END                                                               00581500\nC  74  93      SUBROUTINE PDMOTE                   2 19 68              00581600\n      SUBROUTINE PDMOTE                                                 00581700\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00581800\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00581900\n      DIMENSION ARGS(100)                                               00582000\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00582100\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00582200\n      L2 = L2 - 10                                                      00582300\nC                                                                       00582400\nC     L2 \" 0 FOR PROMOTE,   1 FOR DEMOTE    ( L2 ORIGINALLY 10, 11 )    00582500\nC                                                                       00582600\n      IF( MOD( NARGS, 2 ) .NE. 0 ) GO TO 30                             00582700\n      I = 10                                                            00582800\n  10  CALL ERROR( I )                                                   00582900\n  20  RETURN                                                            00583000\n  30  NR = IARGS( 1 )                                                   00583100\n      IARGS( 1 ) = 1                                                    00583200\n      CALL CHKCOL( I )                                                  00583300\n      IF( I .EQ. 0 ) GO TO 40                                           00583400\n      I = 20                                                            00583500\n      GO TO 10                                                          00583600\nC                                                                       00583700\nC     IF NUMBER OF ROWS TO BE MOVED IS NEGATIVE, FLIP INSTRUCTIONS.     00583800\nC     I.E.  PROMOTE -6  IS THE SAME AS   DEMOTE  6   .                  00583900\n  40  IF( NR ) 50, 20, 60                                               00584000\n  50  L2 = 1 - L2                                                       00584100\n      NR = -NR                                                          00584200\n  60  NARGS = NARGS - 1                                                 00584300\nC                                                                       00584400\nC     CHECK DISTANCE OF MOVE                                            00584500\nC                                                                       00584600\n      IF( L2 .EQ. 0 ) GO TO 80                                          00584700\n      IF( NR + NRMAX .LE. NROW ) GO TO 100                              00584800\n      CALL ERROR(213)                                                   00584900\n      NRMAX = NROW - NR                                                 00585000\n      GO TO 100                                                         00585100\n  70  I = 205                                                           00585200\n      GO TO 10                                                          00585300\n  80  IF( NR - NRMAX ) 100, 90, 70                                      00585400\nC                                                                       00585500\nC     PROMOTE \"NRMAX\"  ...                                              00585600\nC                                                                       00585700\n  90  IF( NARGS .NE. 0 ) GO TO 20                                       00585800\n      IF( NRMAX .EQ. 0 ) GO TO 70                                       00585900\n      J = IARGS( 1 )                                                    00586000\n      DO 95 I = 1, NCOL                                                 00586100\n      CALL VECTOR( 0., J )                                              00586200\n  95  J = J + NROW                                                      00586300\n      GO TO 20                                                          00586400\n 100  LIMIT = NARGS                                                     00586500\n      IF( LIMIT .EQ. 0 ) LIMIT = 2 * NCOL                               00586600\n      IF( NERROR .NE. 0 ) GO TO 20                                      00586700\n      IF( NRMAX .NE. 0 ) GO TO 110                                      00586800\n      GO TO 10                                                          00586900\nC                                                                       00587000\nC     START PROMOTING OR DEMOTING                                       00587100\nC                                                                       00587200\n 110  DO 200 I = 1, LIMIT, 2                                            00587300\n      IF( NARGS .NE. 0 ) GO TO 120                                      00587400\n      K1 = IARGS( 1 )                                                   00587500\n      K2 = K1                                                           00587600\n      IARGS( 1 ) = IARGS( 1 ) + NROW                                    00587700\n      GO TO 130                                                         00587800\n 120  K1 = IARGS (I+1 )                                                 00587900\n      K2 = IARGS( I+2 )                                                 00588000\n 130  IF( L2 .EQ. 0 ) GO TO 150                                         00588100\nC                                                                       00588200\nC     DEMOTE COL AT K1 TO COL AT K2                                     00588300\nC                                                                       00588400\n      K1 = K1 + NRMAX                                                   00588500\n      K2 = K2 + NRMAX + NR                                              00588600\n      DO 140 J = 1, NRMAX                                               00588700\n      K1 = K1 - 1                                                       00588800\n      K2 = K2 - 1                                                       00588900\n 140  RC ( K2 ) = RC( K1 )                                              00589000\n      GO TO 200                                                         00589100\nC                                                                       00589200\nC     PROMOTE COL AT K1 TO COL AT K2                                    00589300\nC                                                                       00589400\n 150  JJ = NRMAX - NR                                                   00589500\n      K1 = K1 + NR                                                      00589600\n      DO 160 J = 1, JJ                                                  00589700\n      RC( K2 ) = RC( K1 )                                               00589800\n      K1 = K1 + 1                                                       00589900\n 160  K2 = K2 + 1                                                       00590000\nC                                                                       00590100\nC     IF PROMOTE ARRAY, FILL REST OF COLUMN WITH ZEROES.                00590200\nC                                                                       00590300\n      IF( NARGS .NE. 0 ) GO TO 200                                      00590400\n      JJ = JJ + 1                                                       00590500\n      DO 170 J = JJ, NRMAX                                              00590600\n      RC( K2 ) = 0.                                                     00590700\n 170  K2 = K2 + 1                                                       00590800\n 200  CONTINUE                                                          00590900\n      IF( L2 .NE. 0 ) NRMAX = NRMAX + NR                                00591000\n      GO TO 20                                                          00591100\n      END                                                               00591200\nC  75  47      SUBROUTINE PHYCON(NAME)             2 19 68              00591300\n      SUBROUTINE PHYCON(NAME)                                           00591400\n      COMMON \/ BLOCKA\/MODE,M,KARD(83),KARG,ARG,ARG2,NEWCD(80),KRDEND    00591500\n      COMMON \/ PCONST \/ P( 40 ), N( 40 )                                00591600\n      DATA J\/-1\/                                                        00591700\nC                                                                       00591800\nC     PHYSICAL CONSTANT LIST                                            00591900\nC                                                                       00592000\nC     ENTRIES ARE IN PAIRS, FIRST MKS VALUE, THEN CGS (ELECTROMAGNETIC) 00592100\nC                                                                       00592200\nC                                                                       00592300\nC        PI        PI                                                   00592400\nC        E         BASE OF NATURAL LOGS                                 00592500\nC        C         SPEED OF LIGHT IN VACUUM                             00592600\nC        Q         ELEMENTARY CHARGE                                    00592700\nC        N         AVOGADRO CONSTANT                                    00592800\nC        ME        ELECTRON REST MASS                                   00592900\nC        MP        PROTON REST MASS                                     00593000\nC        F         FARADAY CONSTANT                                     00593100\nC        H         PLANCK CONSTANT                                      00593200\nC        ALPHA     FINE STRUCTURE CONSTANT                              00593300\nC        QME       CHARGE TO MASS RATIO FOR ELECTRON                    00593400\nC        RINF      RYDBERG CONSTANT                                     00593500\nC        GAMMA     GYROMAGNETIC RATIO OF PROTON (CORRECTED FOR H2O)     00593600\nC        MUB       BOHR MAGNETON                                        00593700\nC        R         GAS CONSTANT                                         00593800\nC        K         BOLTZMANN CONSTANT                                   00593900\nC        CONE      FIRST RADIATION CONSTANT                             00594000\nC        CTWO      SECOND RADIATION CONSTANT                            00594100\nC        SIGMA     STEPHAN-BOLTZMANN CONSTANT                           00594200\nC        G         GRAVITATIONAL CONSTANT                               00594300\nC                                                                       00594400\nC                                                                       00594500\nC     IF NAME .LE. 0, NAME = INDEX FROM MKS,CGS  0 = CGS, -1 = MKS      00594600\nC                                                                       00594700\n      IF(NAME.GT.0)GO TO 10                                             00594800\n      J=NAME                                                            00594900\n      RETURN                                                            00595000\n   10 DO 20 IM=1,20                                                     00595100\n      I = IM                                                            00595200\n      IF(NAME.EQ.N(I))GO TO 30                                          00595300\n  20  CONTINUE                                                          00595400\n      ARG=0.                                                            00595500\n      RETURN                                                            00595600\n  30  I=I+I+J                                                           00595700\n      ARG=P(I)                                                          00595800\n      RETURN                                                            00595900\n      END                                                               00596000\nC  76 348      SUBROUTINE PLOT                     2 19 68              00596100\n      SUBROUTINE PLOT                                                   00596200\nC**** WRITTEN BY  S. PEAVY   11\/ 8\/67                                   00596300\nC**** WRITTEN BY  S. PEAVY   10\/26\/67                                   00596400\nC**** THIS ROUTINE PLOTS MAX. OF 5 CURVES. IF MORE THEN ONE POINT FALLS 00596500\nC**** ON THE SAME POSITION A TALLY IS KEPT AND THE NUMBER IS PRINTED.   00596600\nC**** THE USER MAY PROVIDE THE BOUNDS ON THE X,Y COORDINATES.           00596700\nC**** IF BOUNDS ARE PROVIDED,THEY MUST APPEAR IN PAIRS AS READ NOS. IF A00596800\nC**** PAIR OF REAL NOS ARE EQUAL THE PROGRAM ASSUMES THERE ARE NO BOUNDS00596900\nC**** COMMANDS FOR USING THIS PLOT ARE AS FOLLOWS                       00597000\nC**** FOR THE AXIS THAT PAIR REPRESENTS AND THE BOUNDS WILL BE CALCULAT-00597100\nC**** ED.                                                               00597200\nC**** COMMANDS FOR USING PLOT ARE AS FOLLOWS                            00597300\nC**** I     PLOT Y +++,+++,... X +++                                    00597400\nC**** II    PLOT Y +++,+++,....,(YMIN,YMAX) X +++ (XMIN,XMAX)           00597500\nC**** III   PLOT Y +++,+++,....,(YMIN,YMAX) X ++1                       00597600\nC**** IV    PLOT Y +++,+++,.... V +++ (XMIN,XMAX)                       00597700\nC**** V     PLOT Y +++,+++,.... X (XMIN,XMAX) (YMIN,YMAX)               00597800\nC****                                                                   00597900\nC**** ERRORS                                                            00598000\nC**** I  WHEN TYPE II COMMAND IS USED THERE MUST BE TWO PAIRS OF REAL   00598100\nC****    NOS. OTHERWISE THE FOLLOWING MESSAGE IS PRINTED                00598200\nC****       \" Y BOUNDS ARE NOT SET UP CORRECTLY\"                        00598300\nC****  I  IF BOUNDS ARE PROVIDED, THEN THERE MUST BE FOUR REAL NOS.     00598400\nC**** II  IF A SINGLE REAL NO. APPEARS AHEAD OF COLUMN NOS., THE FOLLOW-00598500\nC****     ING MESSAGE WILL BE PRINTED AND NO PLOTTING WILL TAKE PLACE   00598600\nC****       \" Y BOUNDS ARE NOT SET UP CORRECTLY\"                        00598700\nC**** III IF A PLOT COMMAND ENDS WITH ONE REAL NO, THE FOLLOWING MESSAGE00598800\nC****     WILL BE PRINTED AND PLOTTING WILL BE TERMINATED               00598900\nC****       \" X BOUNDS ARE NOT SET UP CORRECTLY\"                        00599000\nC**** IV  IF MORE THEN 5 PLOTS ARE REQUESTED PER GRAPH, NO GRAPH WILL BE00599100\nC****     PRODUCED AND FOLLOWING MESSAGE WILL BE PRINTED.               00599200\nC****       \" MORE THEN 5 PLOTS WERE REQUISTED PER GRAPH\"               00599300\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00599400\n      COMMON \/ HEADER\/NMCARD(72),ITLE(64,6),IHEAD(4,50),IFMT(17,6),     00599500\n     1 IFMTX(4),LNCNT,IPRINT,NPAGE,IPUNCH                               00599600\n      COMMON \/ SCRAT \/ A(10000),NS                                      00599700\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00599800\n     ONROW,                                                             00599900\n     1NCOL,NARGS,VWXYZ(8),NERROR                                        00600000\n      DIMENSION ARGS(100)                                               00600100\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00600200\n      DIMENSION TIT(60),TITX(60)                                        00600300\n      EQUIVALENCE(TIT,ITLE(1,6)),(TITX,ITLE(1,5))                       00600400\n      DIMENSION X(1),KCCL(6),PRINT(101),XP(6),BOOL(5),IDGT(9)           00600500\n      EQUIVALENCE (RC(1),X(1) )                                         00600600\n      INTEGER PRINT,BLANK                                               00600700\n      EQUIVALENCE (X0,XMIN),(X1,XMAX),(Y0,YMIN),(Y1,YMAX)               00600800\n      DIMENSION IHD(3,6),IPR(101)                                       00600900\n      INTEGER BOOL,COL1,COL2                                            00601000\n      DATA BOOL(1),BOOL(2),BOOL(3),BOOL(4),BOOL(5)\/1H.,1H*,1H+,1H,,1H-\/,00601100\n     1COL1,COL2\/3HCOL ,3HUMN \/,BLANK\/ 1H  \/                             00601200\n      DATA IDGT(1),IDGT(2),IDGT(3),IDGT(4),IDGT(5),IDGT(6),IDGT(7),     00601300\n     1 IDGT(8),IDGT(9)\/1H2,1H3,1H4,1H5,1H6,1H7,1H8,1H9,1HX \/            00601400\nC**** INITIAL  SWITCHES                                                 00601500\n      DATA IXPR\/1HX\/                                                    00601600\n      IF( L2 .EQ. 5) KLIM=101                                           00601700\n      IF( L2 .EQ. 14) KLIM=61                                           00601800\n      KLIM1=KLIM-1                                                      00601900\n      IF(L2 .EQ. 5) KIM=5                                               00602000\n      IF(L2 .EQ. 14) KIM=3                                              00602100\n      ISWT=1                                                            00602200\n      ISWT1=0                                                           00602300\n      XUP=1.E+35                                                        00602400\n      XDOWN=-1.E+35                                                     00602500\n      YUP=1.E+35                                                        00602600\n      YDOWN=-1.E+35                                                     00602700\n      NCN=0                                                             00602800\n      IF(NARGS.EQ.2) GO TO 115                                          00602900\n      IF(KIND(NARGS).EQ.0)  GO TO 110                                   00603000\n      IF(KIND(NARGS)-KIND(NARGS-1).NE.0) GO TO 710                      00603100\nC**** X OR Y BOUNDS ARE PROVIDED                                        00603200\n      IF(KIND(NARGS-2).EQ.0)  GO TO 100                                 00603300\n      IF(KIND(NARGS-3).EQ.0) GO TO 710                                  00603400\n      ISWT=5                                                            00603500\n      YUP=ARGS(NARGS)                                                   00603600\n      YDOWN=ARGS(NARGS-1)                                               00603700\n      XUP=ARGS(NARGS-2)                                                 00603800\n      XDOWN=ARGS(NARGS-3)                                               00603900\n      NARGS=NARGS-4                                                     00604000\n      GO TO 115                                                         00604100\nC**** X BOUNDS ARE PROVIDED                                             00604200\n  100 ISWT=3                                                            00604300\n      XUP=ARGS(NARGS)                                                   00604400\n      XDOWN=ARGS(NARGS-1)                                               00604500\n      NARGS=NARGS-2                                                     00604600\nC**** CHECK TO SEE IF THERE ARE Y BOUNDS                                00604700\n  110 IF(KIND(NARGS-1)-KIND(NARGS-2).NE.0) GO TO 700                    00604800\n      IF(KIND(NARGS-1).EQ.0) GO TO 115                                  00604900\nC**** Y LIMITS ARE PROVIDED                                             00605000\n      ISWT=ISWT+1                                                       00605100\n      YUP=ARGS(NARGS-1)                                                 00605200\n      YDOWN=ARGS(NARGS-2)                                               00605300\n      IARGS(NARGS-2)=IARGS(NARGS)                                       00605400\n      KIND(NARGS-2)=0                                                   00605500\n      NARGS=NARGS-2                                                     00605600\n  115 DO 120 I=1,NARGS                                                  00605700\n  120 KCCL(I)=IARGS(I)                                                  00605800\n      M=NARGS-1                                                         00605900\n      IF(NARGS.GT.6) GO TO 720                                          00606000\n      CALL CHKCOL(J)                                                    00606100\n      IF(J.GT.0) GO TO 730                                              00606200\nC**** NO ERROR FOUND IN COLUMN NOS.                                     00606300\n      IF(NERROR.GE.1) RETURN                                            00606400\nC**** SEARCH FOR MAX AND MIN ON AXIS,  IF BOUNDS ARE NOT PROVIDED,      00606500\nC**** OTHERWISE TALLY NO OF POINTS THAT FALL OUTSIDE OF BOUNDS .        00606600\n      IF(XUP.GE.XDOWN) GO TO 122                                        00606700\n      XAP=XDOWN                                                         00606800\n      XAN=XUP                                                           00606900\n      GO TO 124                                                         00607000\n  122 XAP=XUP                                                           00607100\n      XAN=XDOWN                                                         00607200\n  124 IF(YUP.GE.YDOWN) GO TO 125                                        00607300\n      YAP=YDOWN                                                         00607400\n      YAN=YUP                                                           00607500\n      GO TO 126                                                         00607600\n  125 YAP=YUP                                                           00607700\n      YAN=YDOWN                                                         00607800\n  126 K1=IARGS(NARGS)                                                   00607900\n      K2=K1-1+NRMAX                                                     00608000\n      IF(ISWT-2)127,1000,135                                            00608100\n  127 X1=X(K1)                                                          00608200\n      X0=X1                                                             00608300\n      DO  130 I=K1,K2                                                   00608400\n      IF(X1.GE.X(I)) GO TO 128                                          00608500\n      X1=X(I)                                                           00608600\n      GO TO 130                                                         00608700\n  128 IF(X0.LE.X(I)) GO TO 130                                          00608800\n      X0=X(I)                                                           00608900\n  130 CONTINUE                                                          00609000\n  133 XAP=X1                                                            00609100\n      XAN=X0                                                            00609200\n  135 GO TO(138,170 ,136,170, 170 ),ISWT                                00609300\n  136 KEY=2                                                             00609400\n      GO TO 140                                                         00609500\n  138 KEY=1                                                             00609600\n  140 DO  167 J=1,M                                                     00609700\n      K1=IARGS(NARGS)                                                   00609800\n      K3=IARGS(J)                                                       00609900\n      K4=K3-1+NRMAX                                                     00610000\n      IF(J.GT.1) GO TO 145                                              00610100\n      Y1=X(K3)                                                          00610200\n      Y0=Y1                                                             00610300\n      KY=1                                                              00610400\n  145 GO TO( 147,155  ),KEY                                             00610500\n  147 DO 150  I=K3 ,K4                                                  00610600\n      IF(Y1.LT.X(I)) Y1=X(I)                                            00610700\n      IF(Y0.GT.X(I)) Y0=X(I)                                            00610800\n  150 CONTINUE                                                          00610900\n      GO TO  167                                                        00611000\n  155 DO 165  I=K3,K4                                                   00611100\n      IF(X(K1).GE.XAN.AND.X(K1).LE.XAP) GO TO (160,162),KY              00611200\n      GO  TO 165                                                        00611300\n  160 Y1=X(I)                                                           00611400\n      Y0=X(I)                                                           00611500\n      KY=2                                                              00611600\n      GO TO 165                                                         00611700\n  162 IF(Y1.LT.X(I))  Y1=X(I)                                           00611800\n      IF(Y0.GT.X(I))  Y0=X(I)                                           00611900\n  165 K1=K1+1                                                           00612000\n  167 CONTINUE                                                          00612100\n      YAP=Y1                                                            00612200\n      YAN=Y0                                                            00612300\n      IF(ISWT.EQ.1) GO TO 1990                                          00612400\n      GO TO 180                                                         00612500\n  170 Y1=YUP                                                            00612600\n      Y0=YDOWN                                                          00612700\n      ISWT1=1                                                           00612800\n      IF(ISWT.EQ.2) GO TO 1100                                          00612900\n  180 X1=XUP                                                            00613000\n      X0=XDOWN                                                          00613100\n      GO TO 1100                                                        00613200\nC**** DETERMINE X AND Y INCREMENTS FOR PLOT                             00613300\n  195 YDELTA=(YMAX-YMIN)\/50.                                            00613400\n      K1=IARGS(NARGS)                                                   00613500\n      IF( L2 .EQ. 5) XDELTA=(XMAX-XMIN)\/100.                            00613600\n      IF( L2 .EQ. 14) XDELTA=(XMAX-XMIN)\/60.                            00613700\n      YL  =YMAX-YDELTA\/2.                                               00613800\n      YT=YMAX                                                           00613900\n      IF(ISWT.GT.1) WRITE(IPRINT,610) NTOT,NCN                          00614000\n      GO TO 2300                                                        00614100\n  198 KYTL=1                                                            00614200\n      IF(YMAX.LT.YMIN)  KYTL=2                                          00614300\n      KXTL=1                                                            00614400\n      IF(XMAX.LT.XMIN)  KXTL=2                                          00614500\n      ITB=1                                                             00614600\nC**** THE I LOOP CONTROLS THE 5 DIVISIONS OF THE Y ORDINATE             00614700\n      DO 350  I=1,6                                                     00614800\n      L=1                                                               00614900\nC**** THE J LOOP IS FOR EACH LINE OF PRINT WITHIN THE DIVISIONS         00615000\n      DO 350  J=1,10                                                    00615100\nC**** BLANK OUT PRINT BUFFER LINE.                                      00615200\n      DO 200 K=1,KLIM                                                   00615300\n  200 PRINT(K)=BLANK                                                    00615400\nC**** THE KK INDEX IS FOR EACH CURVE.  KK LESS THAN 6.                  00615500\n      DO 270 KK=1,M                                                     00615600\n      K3=IARGS(KK)                                                      00615700\n      K4=K3-1+NRMAX                                                     00615800\n      K5=K1                                                             00615900\nC**** THIS DETERMINES IF Y(K) VALUE IS ON THE PRESENT PRINT LINE        00616000\n      DO 260 K=K3,K4                                                    00616100\n      GO TO (202,201), KYTL                                             00616200\n  202 IF(X(K)-YT )205,205,260                                           00616300\n  205 IF(X(K)-YL )260,260,210                                           00616400\n  201 IF(X(K)-YL) 203,203,260                                           00616500\n  203 IF(X(K)-YT) 260,260,210                                           00616600\nC**** YES. Y(K) BELONGS ON THIS PRINT LINE                              00616700\nC**** THEREFORE DETERMIND  WHERE ALL THE X(K5) FALL ON THE X-AXIS       00616800\n  210 XL=XMIN                                                           00616900\n      XT=XMIN+XDELTA\/2.                                                 00617000\n      DO 255 KA=1,KLIM                                                  00617100\n      GO TO (212,211) , KXTL                                            00617200\n  211 IF(X(K5)-XT) 250,250,213                                          00617300\n  213 IF(X(K5) -XL)  220,220,250                                        00617400\n  212 IF(X(K5)-XL ) 250,215,215                                         00617500\n  215 IF(X(K5)-XT ) 220,250,250                                         00617600\n  220 IF(PRINT(KA)-BLANK)240,230,240                                    00617700\n  230 PRINT(KA)=BOOL(KK)                                                00617800\n      GO TO 260                                                         00617900\nC**** IF MORE THEN ONE POINT FALLS ON THE PRINT POSITION, TALLY THE NO. 00618000\nC**** OF POINTS.                                                        00618100\n  240 DO 242 KKK=1,9                                                    00618200\n      IF(PRINT(KA)-IDGT(KKK)) 242,244,242                               00618300\n  242 CONTINUE                                                          00618400\n      PRINT(KA)=IDGT(1)                                                 00618500\n      GO TO 260                                                         00618600\n  244 IF(PRINT(KA).NE.IDGT(9)) PRINT(KA)=IDGT(KKK+1)                    00618700\n      GO TO 260                                                         00618800\n  250 XL=XT                                                             00618900\n  255 XT=XT+XDELTA                                                      00619000\n  260 K5=K5+1                                                           00619100\n  270 CONTINUE                                                          00619200\n      YP=YT*YL                                                          00619300\n      YT=YL                                                             00619400\n      YL=YL-YDELTA                                                      00619500\n      GO TO (280,300),L                                                 00619600\n  280 IF(I-5) 285,285,400                                               00619700\n  285 L=2                                                               00619800\n      YS = YT + YDELTA \/ 2.                                             00619900\nC**** THIS PATH IS EXECUTED ONCE IN EVERY DIVISION OF THE Y-AXIS. EVERY 00620000\nC**** TENTH LINE, STARTING WITH ZERO LINE                               00620100\n      IF(YP   ) 286,286,295                                             00620200\n  286 IF(L2 .EQ. 5)WRITE(IPRINT,299) TIT(ITB),YS, PRINT                 00620300\n      IF(L2 .EQ.  14) WRITE(IPRINT,298) TIT(ITB),YS,(PRINT(IB),IB=1,61) 00620400\n      GO TO 350                                                         00620500\n  290 FORMAT(1X,A1,1PE11.4,1H+,101A1,1H+)                               00620600\n  291 FORMAT(1X,A1,1PE11.4,1H+,61A1,1H+)                                00620700\n  295 IF(L2 .EQ. 5) WRITE(IPRINT,290) TIT(ITB),YS, PRINT                00620800\n      IF(L2 .EQ.14) WRITE(IPRINT,291) TIT(ITB),YS,(PRINT(IB),IB=1,61)   00620900\n      GO TO 350                                                         00621000\n  298 FORMAT(1X,A1,1PE11.4,1HX,61A1,1HX)                                00621100\n  299 FORMAT(1X,A1,1PE11.4,1HX,101A1,1HX)                               00621200\n  300 IF(YP   ) 302,302,306                                             00621300\nC**** PRINTS LINE                                                       00621400\n  302 IF( L2 .EQ. 5) WRITE(IPRINT,304) TIT(ITB), PRINT                  00621500\n      IF( L2 .EQ. 14) WRITE(IPRINT,303) TIT(ITB),(PRINT(IB),IB=1,61)    00621600\n  303 FORMAT(1X,A1,11X,1HX,61A1,1HX)                                    00621700\n  304 FORMAT(1X,A1,11X,1HX,101A1,1HX)                                   00621800\n      GO TO 350                                                         00621900\n  306 IF( L2 .EQ. 5) WRITE(IPRINT,310) TIT(ITB), PRINT                  00622000\n      IF( L2 .EQ. 14) WRITE(IPRINT,309) TIT(ITB),(PRINT(IB),IB=1,61)    00622100\n  309 FORMAT(1X,A1,11X,1H-,61A1,1H-)                                    00622200\n  310 FORMAT(1X,A1,11X,1H-,101A1,1H-)                                   00622300\n  350 ITB=ITB+1                                                         00622400\n  400 IF(YP      ) 402,402,406                                          00622500\n  402 IF( L2 .EQ. 5) WRITE(IPRINT,299) TIT(51),YMIN,PRINT               00622600\n      IF( L2 .EQ. 14) WRITE(IPRINT,298) TIT(51),YMIN,(PRINT(IB),IB=1,61)00622700\n      GO  TO 408                                                        00622800\n  406 IF( L2 .EQ. 5) WRITE(IPRINT,290) TIT(51),YMIN,PRINT               00622900\n      IF( L2 .EQ. 14) WRITE(IPRINT,291) TIT(51),YMIN,(PRINT(IB),IB=1,61)00623000\nC**** LAST LINE OF PRINT OUT PLUS X VALUES ALONG X-AXIS.                00623100\n  408 IF( L2 .EQ. 14) GO TO 430                                         00623200\n      WRITE(IPRINT,620)IPR                                              00623300\n      WRITE(IPRINT,420) XP                                              00623400\n  409 WRITE(IPRINT,630) TITX                                            00623500\n  420 FORMAT(6(7X,1PE13.4))                                             00623600\n      RETURN                                                            00623700\n  430 WRITE(IPRINT,620) (IPR(I),I=1,61)                                 00623800\n      WRITE(IPRINT,420) (XP(I),I=1,4)                                   00623900\n      GO TO 409                                                         00624000\n  600 FORMAT(12H ABS- COLUMN,I6, 7H; ORD- ,5(2A3,I5,2H (,A1,4H),  ))    00624100\n  605 FORMAT( 6H ABS- ,2A6,6H;ORD- ,5(2A6,2H (,A1,3H), ))               00624200\n  610 FORMAT(29H TOTAL NO. OF PTS. PLOTTED IS,I5,60H AND NO. NOT PLOTTED00624300\n     1  BECAUSE THEY FALL OUTSIDE OF BOUNDS IS,I5  )                    00624400\n  620 FORMAT(14X,101A1)                                                 00624500\n  630 FORMAT(34X,60A1)                                                  00624600\nC**** THIS PRINTS OUT THAT \"Y BOUNDS ARE NOT SET UP CORRECTLY\".         00624700\n 700  CONTINUE                                                          00624800\nC**** THIS PRINTS OUT THAT \"X BOUNDS ARE NOT SET UP CORRECTLY\".         00624900\n 710  CONTINUE                                                          00625000\nC**** THIS PRINT \"COL. NOS. APPEAR AS ARGUMENTS\".                       00625100\n 730  CALL ERROR(20)                                                    00625200\n 725  NERROR = NERROR - 1                                               00625300\n      RETURN                                                            00625400\nC**** THIS PRINTS THAT \"MORE THEN 5 PLOTS WERE REQUISTED PER GRAPH\".    00625500\n 720  CALL ERROR(10)                                                    00625600\n      GO TO 725                                                         00625700\n 1000 KEY=1                                                             00625800\n 1010 DO  1050 IK=1,M                                                   00625900\n      IKK=IARGS(IK)                                                     00626000\n      DO  1045 I=K1,K2                                                  00626100\n      IF(X(IKK).GE.YAN.AND.X(IKK).LE.YAP) GO TO (1030,1040),KEY         00626200\n      GO  TO 1045                                                       00626300\n 1030 X1=X(I)                                                           00626400\n      X0=X1                                                             00626500\n      KEY=2                                                             00626600\n      GO TO 1045                                                        00626700\n 1040 IF(X1.LT.X(I)) X1=X(I)                                            00626800\n      IF(X0.GT.X(I)) X0=X(I)                                            00626900\n 1045 IKK=IKK+1                                                         00627000\n 1050 CONTINUE                                                          00627100\n      IF(KEY.EQ.2)  GO TO 133                                           00627200\n      X0=XDOWN                                                          00627300\n      X1=XUP                                                            00627400\n      GO TO 133                                                         00627500\n 1100 DO 1120  J=1,M                                                    00627600\n      K1=IARGS(NARGS)                                                   00627700\n      K3=IARGS(J)                                                       00627800\n      K4=K3-1+NRMAX                                                     00627900\n      DO 1120  I=K3,K4                                                  00628000\n      IF(X(I).GT.YAP.OR.X(I).LT.YAN) GO TO 1110                         00628100\n      IF(X(K1).LE.XAP.AND.X(K1).GE.XAN) GO TO 1120                      00628200\n 1110 NCN=NCN+1                                                         00628300\n 1120 K1=K1+1                                                           00628400\n      NTOT=M*NRMAX-NCN                                                  00628500\nC**** DETERMINE TYPE OF HEADINGS TO BE PRINTED                          00628600\n 1990 KTLE=0                                                            00628700\n      DO 2000  I=1,NARGS                                                00628800\n      J=KCCL(I)                                                         00628900\n      IF(J.GT.50.OR.IHEAD(1,J).EQ.0) GO TO 2005                         00629000\n      IHD(1,I)=IHEAD(1,J)                                               00629100\n      IHD(2,I)=IHEAD(2,J)                                               00629200\n      IHD(3,I) = IHEAD(3,J)                                             00629300\n      KTLE=KTLE+1                                                       00629400\n 2000 CONTINUE                                                          00629500\nC**** STARTS A NEW PAGE AND PRINTS TITLE 1 AND 2                        00629600\n 2005 CALL PAGE(2)                                                      00629700\n      IF(KTLE.EQ.NARGS)  GO TO 2010                                     00629800\n      WRITE(IPRINT,600) KCCL(NARGS),(COL1,COL2,KCCL(I),BOOL(I),I=1,M)   00629900\n      GO TO 195                                                         00630000\n 2010 WRITE (IPRINT,605)  (IHD(I,NARGS),I=1,2),  ((IHD(I,J),I=1,2),     00630100\n     1 BOOL(J  ),J=1,M)                                                 00630200\n      GO TO 195                                                         00630300\n 2300 XP(1)=XMIN                                                        00630400\n      IF( L2 .EQ. 5) XP(6)=XMAX                                         00630500\n      IF( L2 .EQ. 14) XP(4)=XMAX                                        00630600\n      XR=20.*XDELTA                                                     00630700\n      DO 2310 I=2,KIM                                                   00630800\n 2310 XP(I)=XP(I-1)+XR                                                  00630900\n      DO 2320 J=1,KLIM1                                                 00631000\n 2320 IPR(J)=BOOL(5)                                                    00631100\n      DO 2330 I=1,KLIM,10                                               00631200\n 2330 IPR(I)=BOOL(3)                                                    00631300\n      IF(XMIN*XMAX.GE.0) GO  TO 2370                                    00631400\n      J=0                                                               00631500\n      DO 2340 I=2,KIM                                                   00631600\n      IF(XP(I-1)*XP(I))2345,2360,2340                                   00631700\n 2340 CONTINUE                                                          00631800\n      I=KIM                                                             00631900\n      GO TO 2360                                                        00632000\n 2345  XXP=XP(I-1)+XDELTA                                               00632100\n      DO 2350   J=1,20                                                  00632200\n      IF(XP(I-1)*XXP            .LE.0.0) GO TO 2360                     00632300\n 2350 XXP=XXP+XDELTA                                                    00632400\n      J=20                                                              00632500\n 2360 N=(I-2)*20+J                                                      00632600\n      IPR(N)=IXPR                                                       00632700\n      IPR(N)=IXPR                                                       00632800\n 2370 IF( L2 .EQ. 5) WRITE(IPRINT,620) IPR                              00632900\n      IF(L2 .EQ. 14) WRITE(IPRINT,620) (IPR(I),I=1,61)                  00633000\n      GO TO 198                                                         00633100\n      END                                                               00633200\nC  77  13      SUBROUTINE PNT(ND15)                2 19 68              00633300\n      SUBROUTINE PNT(ND15)                                              00633400\n      COMMON \/BLOCKD\/R(10100),IA(100),KI(100),ART(100),NR,NRO,NC,NARGS, 00633500\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00633600\n      DIMENSION ARGS(100)                                               00633700\n      EQUIVALENCE( ARGS(1), R(10001) )                                  00633800\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00633900\n      COMMON \/ SCRAT \/ SCRA(10000),NS                                   00634000\n                                                                        00634100\n                                                                        00634200\n    1 PRINT 40, (SCRA(I), I = 1,ND15)                                   00634300\n      RETURN                                                            00634400\n   40 FORMAT(8E16.8)                                                    00634500\n      END                                                               00634600\nC  78  71      SUBROUTINE PRINTX                   2 19 68              00634700\n      SUBROUTINE PRINTX                                                 00634800\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00634900\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00635000\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00635100\n      DIMENSION ARGS(100)                                               00635200\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00635300\n      COMMON \/ HEADER\/NMCARD(72),ITLE(64,6),IHEAD(4,50),IFMT(17,6),     00635400\n     1 IFMTX(4),LNCNT,IPRINT,NPAGE,IPUNCH                               00635500\n      DIMENSION KFMT( 17 )                                              00635600\n      IF ( L1 .EQ. 2 .OR. L1 .EQ. 3 ) IF( NARGS ) 20,20,45              00635700\n      IF( NARGS .GT. 1 ) GO TO 40                                       00635800\nC                                                                       00635900\nC     L1 = 2 FOR PRINT, L1 = 6 FOR ABRIDGE                              00636000\nC     L1 = 3 FOR PUNCH                                                  00636100\nC                                                                       00636200\n  20  CALL ERROR( 205 )                                                 00636300\n  30  RETURN                                                            00636400\n  40  LL = IARGS( 1 )                                                   00636500\n      IARGS( 1 ) = 1                                                    00636600\n      IF( LL .LE. 0 .OR. LL .GT. NROW ) GO TO 20                        00636700\n  45  DO 46 I = 1, NARGS                                                00636800\n  46  IARGS( I+50 ) = IARGS( I )                                        00636900\n  50  CALL CHKCOL( I )                                                  00637000\n      IF( I .NE. 0 ) GO TO 20                                           00637100\n  60  IF( NERROR .NE. 0 ) GO TO 30                                      00637200\n      CALL SETFMT( KFMT )                                               00637300\n      IF( L1 .EQ. 2 ) GO TO 80                                          00637400\n      IF ( L1 .EQ. 3 ) GO TO 150                                        00637500\nC                                                                       00637600\nC     ABRIDGE                                                           00637700\nC                                                                       00637800\n      DO 70 I = 2, NARGS                                                00637900\n      J = IARGS( I ) + LL                                               00638000\n  70  ARGS( I ) = RC( J-1 )                                             00638100\n      WRITE( IPRINT, KFMT ) ( ARGS( I ), I = 2, NARGS )                 00638200\n      GO TO 30                                                          00638300\nC                                                                       00638400\nC     PRINT                                                             00638500\nC                                                                       00638600\n  80  LL = NRMAX                                                        00638700\n  90  IF( LL .GT. 51 ) GO TO 100                                        00638800\n      J = LL                                                            00638900\n      LL = 0                                                            00639000\n      GO TO 110                                                         00639100\n 100  LL = LL - 50                                                      00639200\n      J = 50                                                            00639300\n 110  CALL PAGE( 4 )                                                    00639400\n      IF( L2 .EQ. 1 ) CALL HEADS                                        00639500\n      WRITE( IPRINT, 130 )                                              00639600\n      DO 140 M = 1, J                                                   00639700\n      DO 120 I = 1, NARGS                                               00639800\n      K = IARGS( I )                                                    00639900\n      IARGS( I ) = IARGS( I ) + 1                                       00640000\n 120  ARGS( I ) = RC( K )                                               00640100\n      WRITE( IPRINT, KFMT ) ( ARGS( I ), I = 1, NARGS )                 00640200\n      IF( MOD( M, 10 ) .EQ. 0 ) WRITE( IPRINT, 130 )                    00640300\n 130  FORMAT(1X)                                                        00640400\n 140  CONTINUE                                                          00640500\n      IF( LL ) 30, 30, 90                                               00640600\nC                                                                       00640700\nC     PUNCH                                                             00640800\nC                                                                       00640900\n  150 DO 170 M=1,NRMAX                                                  00641000\n      DO 160 I=1,NARGS                                                  00641100\n      K = IARGS( I )                                                    00641200\n      IARGS( I ) = IARGS( I ) + 1                                       00641300\n  160 ARGS( I ) = RC( K )                                               00641400\n      WRITE(IPUNCH, KFMT ) ( ARGS( I ) , I=1,NARGS )                    00641500\n  170 CONTINUE                                                          00641600\n      RETURN                                                            00641700\n      END                                                               00641800\nC  79  89      SUBROUTINE PROB (VNU1,VNU2,F,Q)     2 19 68              00641900\n      SUBROUTINE PROB (VNU1,VNU2,F,Q)                                   00642000\n      DOUBLE PRECISION C,A,X,W,ONE,B,TA,TB,G                            00642100\n      DATA C\/.6366197723675814D0\/,EP\/1.E-5\/,ONE\/1.D0\/,TWO\/2.0\/,ONEP\/1.\/,00642200\n     1 P5\/.5\/                                                           00642300\n      NU1=VNU1+EP                                                       00642400\n      NU2=VNU2+EP                                                       00642500\n      V1=NU1                                                            00642600\n      V2=NU2                                                            00642700\n      IF (ABS(V1-VNU1).GT.EP) GO TO 310                                 00642800\n      IF( ABS(V2-VNU2).GT.EP) GO TO 310                                 00642900\n      IF(F.GE.0.) GO TO 80                                              00643000\n      F=0.                                                              00643100\nC**** ERROR \" SET F=0  SINCE  F LESS THEN 0\"                            00643200\n      CALL ERROR (206)                                                  00643300\n   80 IF(NU1.LT.0.OR.NU2.LT.0) GO TO 300                                00643400\n  105 MNU1=MOD(NU1,2)                                                   00643500\n      MNU2=MOD(NU2,2)                                                   00643600\n      IF(MNU2.NE.0) GO TO 120                                           00643700\n      I1=NU2\/2-1                                                        00643800\n      X=V2\/(V2+V1*F)                                                    00643900\n      V4=V1\/TWO                                                         00644000\n      I4=NU1                                                            00644100\n   90 A=ONE                                                             00644200\n      IF(I1.EQ.0) GO TO 110                                             00644300\n      W=A                                                               00644400\n      DO  100 I=1,I1                                                    00644500\n      T=I                                                               00644600\n      W=((V4+T-ONEP)\/T)*X*W                                             00644700\n  100 A=A+W                                                             00644800\n  110 Q=A*(ONE-X)**V4                                                   00644900\n      IF(  I4.EQ.NU1) Q=ONEP-Q                                          00645000\n  115 IF(Q.LT.0.) Q=0                                                   00645100\n      IF(Q.GT.ONEP)  Q=ONEP                                             00645200\n      RETURN                                                            00645300\n  120 IF(MNU1.NE.0) GO TO 130                                           00645400\n      I1=NU1\/2-1                                                        00645500\n      X=ONEP-V2\/(V2+V1*F)                                               00645600\n      V4=V2\/TWO                                                         00645700\n      I4=NU2                                                            00645800\n      GO TO 90                                                          00645900\n  130 IF(NU2.NE.1) GO TO 170                                            00646000\n      IF(NU1.NE.1) GO TO 140                                            00646100\n      Q=C*ATAN(ONEP\/FSQRT(F))                                           00646200\n      GO TO 115                                                         00646300\n  140 X=ATAN(FSQRT(V2\/(V1*F)))                                          00646400\n      I1= (NU1-3)\/2                                                     00646500\n      IS=1                                                              00646600\n  145 TB=DSIN(X)                                                        00646700\n      A=DCOS(X)                                                         00646800\n      IF(I1.EQ.0) GO TO 160                                             00646900\n      TA=A**2                                                           00647000\n      W=A                                                               00647100\n      DO  150 I=1,I1                                                    00647200\n      V3=I                                                              00647300\n      W= V3\/(V3+P5)*TA*W                                                00647400\n  150 A=A+W                                                             00647500\n  160 A=C*(X+TB*A)                                                      00647600\n      Q=A                                                               00647700\n      GO TO (115,180),IS                                                00647800\n  170 X=ATAN(FSQRT(V1*F\/V2))                                            00647900\n      I1= (NU2-3)\/2                                                     00648000\n      IS=2                                                              00648100\n      GO TO 145                                                         00648200\n  180 IF(NU1.NE.1) GO TO 190                                            00648300\n      Q=ONE-A                                                           00648400\n      GO TO 115                                                         00648500\n  190 I1=(NU1-3)\/2                                                      00648600\n      B=ONE                                                             00648700\n      IF(I1.EQ.0) GO TO 210                                             00648800\n      W=B                                                               00648900\n      DO  200  I=1,I1                                                   00649000\n      V3=I                                                              00649100\n      W= (V2+TWO*V3-ONEP)\/(TWO*V3+ONEP)*TB**2*W                         00649200\n  200 B=B+W                                                             00649300\n  210 G=C                                                               00649400\n      I1=(NU2-1)\/2                                                      00649500\n      DO 220 I=1,I1                                                     00649600\n      V3=I                                                              00649700\n  220 G=(TWO*V3)\/(TWO*V3-ONEP)*G                                        00649800\n      Q=ONE-A+G*TB*DCOS(X)**NU2*B                                       00649900\n      GO TO 115                                                         00650000\nC**** PRINT \" EITHER NU1 OR NU2 IS LESS THEN 1 \"                        00650100\n  300 CALL ERROR (207)                                                  00650200\n      RETURN                                                            00650300\nC**** PRINT \" EITHER NU1 OR NU2 IS NOT A INTEGER  PROGRAM USES LARGEST  00650400\nC**** INTEGER CONTAINED \"                                               00650500\n  310 CALL ERROR(208)                                                   00650600\n      GO TO 105                                                         00650700\n      END                                                               00650800\nC  80  55      SUBROUTINE PROROW                   2 19 68              00650900\n      SUBROUTINE PROROW                                                 00651000\nC     PROGRAMMED BY CARLA MESSINA  MAY,1967                             00651100\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00651200\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00651300\n      DIMENSION ARGS(100)                                               00651400\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00651500\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00651600\n      COMMON \/ SCRAT \/ A(10000),NS                                      00651700\n      IF (NARGS - 3)  10,40,40                                          00651800\n10    K = 10                                                            00651900\n20    CALL ERROR(K)                                                     00652000\n30    RETURN                                                            00652100\n40    CALL CHKCOL(J)                                                    00652200\n      IF (J) 50,60,50                                                   00652300\n50    K = 3                                                             00652400\n      GO TO 20                                                          00652500\n60    IF (NRMAX) 70,70,80                                               00652600\n70    K = 9                                                             00652700\n      GO TO 20                                                          00652800\n80    IF (NERROR .NE. 0) RETURN                                         00652900\n      DO  100  I=1,NRMAX                                                00653000\n      A(I) = 0.0                                                        00653100\n      GO TO (100,90), L2                                                00653200\n90    A(I) = 1.0                                                        00653300\n100   CONTINUE                                                          00653400\n      IF( NARGS - 4 ) 110, 200, 200                                     00653500\n110   IF (IARGS(1) - IARGS(2)) 120,120,50                               00653600\n120   K = IARGS(1)                                                      00653700\n      DO  150  I=1,NRMAX                                                00653800\n      J = K + I - 1                                                     00653900\n      GO TO (130,140), L2                                               00654000\n130   A(I) = A(I) + RC(J)                                               00654100\n      GO TO 150                                                         00654200\n140   A(I) = A(I)*RC(J)                                                 00654300\n150   CONTINUE                                                          00654400\n      IF (IARGS(1) + NROW - IARGS(2))  160,160,170                      00654500\n160   IARGS(1) = IARGS(1) + NROW                                        00654600\n      GO TO 120                                                         00654700\n170   K = IARGS(NARGS)                                                  00654800\n      DO 180  I=1,NRMAX                                                 00654900\n      J = K + I - 1                                                     00655000\n180   RC(J) = A(I)                                                      00655100\n      GO TO 30                                                          00655200\n200   II = NARGS - 1                                                    00655300\n      DO  250  L=1,II                                                   00655400\n      K = IARGS(L)                                                      00655500\n      DO  250  I=1,NRMAX                                                00655600\n      J = K + I - 1                                                     00655700\n      GO TO (230,240), L2                                               00655800\n230   A(I) = A(I)+RC(J)                                                 00655900\n      GO TO 250                                                         00656000\n240   A(I) = A(I)*RC(J)                                                 00656100\n250   CONTINUE                                                          00656200\n      GO TO 170                                                         00656300\n      END                                                               00656400\nC  81  19      FUNCTION QNORML(X)                  2 19 68              00656500\n      FUNCTION QNORML(X)                                                00656600\nC                                                                       00656700\nC     A FUNCTION FROM AMS 55 CHAPTER 26 TO COMPUTE THE INVERSE NORMAL   00656800\nC     INTEGRAL FOR THE PROBABILITY  X                                   00656900\nC                                                                       00657000\n      IF ( X .LE. 0.0 .OR. X .GE. 1.0 ) GO TO 10                        00657100\n      IF (X .EQ. 0.5) GO TO 1                                           00657200\n      GO TO 2                                                           00657300\n   10 CALL AERR( 3 )                                                    00657400\n    1 QNORML=0.0                                                        00657500\n      RETURN                                                            00657600\n    2 P=X                                                               00657700\n      IF (X .GT. 0.5) P=1.0-X                                           00657800\n      T=SQRT(ALOG(1.0\/(P**2)) )                                         00657900\n      QNORML=T-(2.515517+.802853*T+.010328*T**2)\/(1.0+1.432788*T+.18926900658000\n     1*T**2+.001308*T**3)                                               00658100\n      IF ( X .LT. 0.5 ) QNORML = -1.0 * QNORML                          00658200\n      RETURN                                                            00658300\n      END                                                               00658400\nC  82  25      SUBROUTINE READQ                    2 19 68              00658500\n      SUBROUTINE READQ                                                  00658600\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00658700\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00658800\n      DIMENSION ARGS(100)                                               00658900\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00659000\n      COMMON \/ QRS \/ NDROW, IFLAG, J, NNARG                             00659100\n      IF( IFLAG .NE. 0 ) GO TO 99                                       00659200\n      IF( J .LT. NROW ) GO TO 10                                        00659300\n      IFLAG = 1                                                         00659400\n      CALL ERROR( 201 )                                                 00659500\n      GO TO 99                                                          00659600\nC     NNARG CONTAINS NARGS OF READ COMMAND                              00659700\nC     IARGS(51) THRU IARGS(NNARG+50) CONTAINS ADDRESSES OF COLUMN TOPS  00659800\n  10  DO 30 I = 1, NNARG                                                00659900\n      K = IARGS( I + 50 ) + J                                           00660000\n      IF( KIND( I ) .EQ. 0 ) GO TO 20                                   00660100\n      RC( K ) = ARGS( I )                                               00660200\n      GO TO 30                                                          00660300\n  20  RC( K ) = IARGS( I )                                              00660400\n  30  CONTINUE                                                          00660500\nC     J IS CARD COUNT. IT COUNTS FROM ZERO.                             00660600\n      J = J + 1                                                         00660700\n      NRMAX = J                                                         00660800\n  99  RETURN                                                            00660900\n      END                                                               00661000\nC  83  77      SUBROUTINE READX                    2 19 68              00661100\n      SUBROUTINE READX                                                  00661200\n      COMMON \/ BLOCKA\/MODE,M,KARD(83),KARG,ARG,ARG2,NEWCD(80),KRDEND    00661300\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00661400\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00661500\n      DIMENSION ARGS(100)                                               00661600\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00661700\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00661800\n      COMMON \/ QRS \/ NDROW, IFLAG, J, NNARG                             00661900\n      COMMON \/BLOCKC\/KIO,INUNIT,ISCRAT,KBDOUT,KRDKNT                    00662000\n      COMMON \/ HEADER\/NMCARD(72),ITLE(64,6),IHEAD(4,50),IFMT(17,6),     00662100\n     1 IFMTX(4),LNCNT,IPRINT,NPAGE,IPUNCH                               00662200\n      DIMENSION KFMT(17)                                                00662300\n      IF( L2 .NE. 1 ) GO TO 200                                         00662400\n      ISRFLG = 0                                                        00662500\n      IF( NARGS .GT. 0 ) GO TO 10                                       00662600\n   5  CALL ERROR( 10 )                                                  00662700\n      GO TO 99                                                          00662800\n  10  MODE = 2                                                          00662900\n      CALL CHKCOL( I )                                                  00663000\n      IF( I .EQ. 0 ) GO TO 20                                           00663100\n  15  CALL ERROR( 3 )                                                   00663200\n      GO TO 99                                                          00663300\n  20  IF( NERROR .NE. 0 ) GO TO 99                                      00663400\n      DO 30 I = 1, NARGS                                                00663500\n      IARGS( I + 50 ) = IARGS( I )                                      00663600\n      IARGS( I ) = 0                                                    00663700\n  30  ARGS( I ) = 0.                                                    00663800\n      IFLAG = 0                                                         00663900\n      J = 0                                                             00664000\n      NNARG = NARGS                                                     00664100\n      GO TO 100                                                         00664200\n  99  IFLAG = 1                                                         00664300\n 100  RETURN                                                            00664400\nC                                                                       00664500\nC                  FORMATTED READ                                       00664600\nC                  READ X  N  C C C C                                   00664700\nC                                                                       00664800\nC                  N = NUMBER OF CARDS TO READ. IF N = 0, READ UNTIL A  00664900\nC                  BLANK CARD IS FOUND                                  00665000\nC                  X IS THE FORMAT IDENTIFIER, A,B,C,D,E,F              00665100\nC                                                                       00665200\n 200  IF( NARGS .LE. 1 ) GO TO 5                                        00665300\nC                  SETUP FORMAT                                         00665400\n      CALL SETFMT( KFMT )                                               00665500\nC                  CHECK AND CONVERT ARGUMENTS                          00665600\n      DO 210 I = 2, NARGS                                               00665700\n      CALL ADRESS( I, IARGS( I ) )                                      00665800\n 210  IF( IARGS( I ) .LE. 0 ) GO TO 311                                 00665900\n      IF( IARGS( 1 ) ) 15, 220, 230                                     00666000\n 220  N = 10000                                                         00666100\n      GO TO 240                                                         00666200\n 230  N = IARGS( 1 )                                                    00666300\n 240  DO 280 I = 1, N                                                   00666400\n      READ( INUNIT, KFMT ) ( ARGS( J ), J = 2, NARGS )                  00666500\nC                  CHECK IF LOOKING FOR BLANK CARD                      00666600\n      IF( IARGS( 1 ) .NE. 0 ) GO TO 260                                 00666700\n      DO 250 J = 2, NARGS                                               00666800\n 250  IF( ARGS( J ) .NE. 0. ) GO TO 260                                 00666900\nC                  BLANK CARD FOUND, TERMINATE READ.                    00667000\n      GO TO 290                                                         00667100\nC                  IF THERE IS TOO MUCH DATA, DO NOT ENTER EXCESS       00667200\n 260  IF( I .GT. NROW ) GO TO 280                                       00667300\n      DO 270 J = 2, NARGS                                               00667400\n      K = IARGS( J )                                                    00667500\n      IARGS( J ) = K + 1                                                00667600\n 270  RC( K ) = ARGS( J )                                               00667700\n 280  CONTINUE                                                          00667800\n      I = N + 1                                                         00667900\n 290  I = I - 1                                                         00668000\n      NRMAX = MAX0( NRMAX, MIN0( I, NROW ) )                            00668100\n      WRITE( ISCRAT, 300 ) I                                            00668200\n 300  FORMAT(5X,I4,31H DATA CARDS READ BUT NOT LISTED,44X)              00668300\n      IF( I .GT. NROW ) CALL ERROR( 201 )                               00668400\n      GO TO 100                                                         00668500\n 311  CALL ERROR( 11 )                                                  00668600\n      GO TO 100                                                         00668700\n      END                                                               00668800\nC  84  33      SUBROUTINE RESET                    2 19 68              00668900\n      SUBROUTINE RESET                                                  00669000\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00669100\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00669200\n      COMMON \/ BLOCKF \/ NCTOP                                           00669300\n      DIMENSION ARGS(100)                                               00669400\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00669500\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00669600\n      IF ( NARGS .EQ. 1 ) IF ( L2 - 2 )30,110,100                       00669700\n      K = 10                                                            00669800\n  10  CALL ERROR( K )                                                   00669900\n  20  RETURN                                                            00670000\nC         RESET NRMAX                                                   00670100\n  30  IF( KIND(1) .NE. 0 ) IARGS(1) = ARGS(1)                           00670200\n  40  IF( IARGS( 1 ) .GE. 0 .AND. IARGS( 1 ) .LE. NROW ) GO TO 50       00670300\n      K = 3                                                             00670400\n      GO TO 10                                                          00670500\n  50  NRMAX = IARGS( 1 )                                                00670600\n      GO TO 20                                                          00670700\nC         RESET V,W,X,Y,Z                                               00670800\n 100  IF( KIND(1) .EQ. 0 ) ARGS(1) = IARGS(1)                           00670900\n      VWXYZ( L2-2 ) = ARGS( 1 )                                         00671000\n      GO TO 20                                                          00671100\nC         RESET COLTOP                                                  00671200\n  110 IF ( KIND( 1 ) .NE. 0 ) IARGS(1) = ARGS(1)                        00671300\n      IF ( IARGS ( 1 ) .GE. 0 .AND. IARGS( 1 ) .LE. (NROW+NCTOP-1))     00671400\n     1 GO TO 120                                                        00671500\n      K = 3                                                             00671600\n      GO TO 10                                                          00671700\n  120 J = NCTOP                                                         00671800\n      NCTOP = IARGS( 1 )                                                00671900\n      NROW  = NROW + ( J - NCTOP )                                      00672000\n      GO TO 20                                                          00672100\n      END                                                               00672200\nC  85  23      SUBROUTINE RNDOWN                   2 19 68              00672300\n      SUBROUTINE RNDOWN                                                 00672400\n      COMMON \/BLOCKC\/KIO,INUNIT,ISCRAT,KBDOUT,KRDKNT                    00672500\n      COMMON \/ BLOCKX \/ INDEX( 6, 8 ), LEVEL                            00672600\nC                                                                       00672700\nC     IF AN ERROR IS MADE IN A STORED STATEMENT, THIS ROUTINE PRINTS    00672800\nC     OUT EXACTLY WHEN AND WHERE IT OCCURRED.                           00672900\nC                                                                       00673000\n      A = FLOAT( INDEX( 6, LEVEL ) ) \/ 10.                              00673100\n      WRITE( ISCRAT, 10 ) A                                             00673200\n  10  FORMAT(31H IN COMMAND AT STATEMENT NUMBER,F6.1,47X)               00673300\n      N = LEVEL - 1                                                     00673400\n  20  IF( N ) 70, 50, 30                                                00673500\n  30  A = FLOAT( INDEX( 6, N ) ) \/ 10.                                  00673600\n      WRITE( ISCRAT, 40 ) INDEX( 5, N + 1 ), INDEX( 4, N + 1 ), A       00673700\n  40  FORMAT(10H CYCLE NO.,I4,3H OF,I4,24H OF PERFORM AT STATEMENT,F6.1,00673800\n     1 33X)                                                             00673900\n      N = N - 1                                                         00674000\n      GO TO 20                                                          00674100\n  50  WRITE( ISCRAT, 60 ) INDEX( 5, 1 ), INDEX( 4, 1 )                  00674200\n  60  FORMAT(10H CYCLE NO.,I4,3H OF,I4,31H OF EXTERNAL PERFORM STATEMENT00674300\n     1.,32X)                                                            00674400\n  70  RETURN                                                            00674500\n      END                                                               00674600\nC  86 177      SUBROUTINE SELECT                   2 19 68              00674700\n      SUBROUTINE SELECT                                                 00674800\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00674900\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00675000\n      DIMENSION ARGS(100)                                               00675100\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00675200\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00675300\n      COMMON \/ SCRAT \/ A(10000),NS                                      00675400\nC                                                                       00675500\nC ITYPE=1     SELECT IN COL ++ VALUES APPROX COL ++ TO WITHIN **,       00675600\nC                  STORE IN COL ++                                      00675700\nC ITYPE=1     SELECT IN COL ++ VALUES APPROX COL ++ TO WITHIN **,       00675800\nC                  STORE IN COL ++ TO COL ++                            00675900\nC ITYPE=1     SELECT IN COL ++ VALUES APPROX COL ++ TO WITHIN **,       00676000\nC                  STORE ++ TO ++, STORE NUMBER FALLING WITHIN TOL IN CO00676100\nC                                                                       00676200\nC ITYPE=2     SEARCH IN COL ++ FOR NUMBERS IN ++, TRANSFER CORRESP VALUE00676300\nC                  FROM ++ INTO ++, ++ INTO ++,  ETC                    00676400\nC                                                                       00676500\nC ITYPE=3     CENSOR COL ++ FOR $$, REPLACING BY $$, STORE IN COL ++    00676600\nC                                                                       00676700\nC  BY CARLA G. MESSINA  NSRDS     NBS                                   00676800\nC                                                                       00676900\n      GO TO (10,90,120) ,L2                                             00677000\n10    IF (KIND(3)) 40,20,40                                             00677100\n20    K=3                                                               00677200\n30    CALL ERROR(K)                                                     00677300\n35    RETURN                                                            00677400\n40    IARGS(3)= IARGS(2)                                                00677500\n      KIND(3)=0                                                         00677600\n      IF (NARGS - 4) 50,60,70                                           00677700\n50    K=10                                                              00677800\n      GO TO 30                                                          00677900\n60    IARGS(5)=IARGS(4)                                                 00678000\n      NARGS = NARGS+ 1                                                  00678100\n      KIND(5) = KIND(4)                                                 00678200\n70    IF (NARGS - 6) 80,80,50                                           00678300\n80    IF (IARGS(4) - IARGS(5)) 220,220,20                               00678400\n90    IF (NARGS - 4) 50,100,100                                         00678500\n100   IF (2*(NARGS\/2) - NARGS) 50,110,50                                00678600\n110   CALL CHKCOL(J)                                                    00678700\n      IF (J) 20,190,20                                                  00678800\n120   IF (NARGS-4) 50,130,50                                            00678900\n130   DO 140 I=1,4                                                      00679000\n140   CALL ADRESS(I,IARGS(I))                                           00679100\n      IF (IARGS(1)) 20,20,150                                           00679200\n150   IF (IARGS(4)) 20,20,160                                           00679300\n160   DO 180 I=2,3                                                      00679400\n      IF (KIND(I)) 180,170,180                                          00679500\n170   IF (IARGS(I)) 20,20,180                                           00679600\n180   CONTINUE                                                          00679700\n190   IF (NERROR .NE. 0) GO TO 35                                       00679800\n      IF (NRMAX) 200,200,210                                            00679900\n200   K=9                                                               00680000\n      GO TO 30                                                          00680100\n210   GO TO (300,500,600) , L2                                          00680200\n220   IF (IARGS(5) - IARGS(4) - NRMAX + 1) 110,110,230                  00680300\n230   IARGS(5) =IARGS(4) + NRMAX - 1                                    00680400\n      GO TO 110                                                         00680500\nC   SELECT                                                              00680600\n300   DO 330 I=1,NRMAX                                                  00680700\n      L = IARGS( 1 ) + I - 1                                            00680800\n      K = IARGS( 2 ) + I - 1                                            00680900\n      J = IARGS(4) + I -1                                               00681000\n      M = NRMAX + I                                                     00681100\n      A(I) = RC(K)                                                      00681200\n      A(M) = RC(L)                                                      00681300\n310   RC(J) = 0.0                                                       00681400\n      IF (J - I - IARGS(5) + 1)  320,330,330                            00681500\n320   J = NROW + J                                                      00681600\n      GO TO 310                                                         00681700\n330   CONTINUE                                                          00681800\n      ARG3= ARGS(3)                                                     00681900\n      DO 480 I=1,NRMAX                                                  00682000\n      I9 = 2*NRMAX + 1                                                  00682100\n      I11 = 5*NRMAX                                                     00682200\n      DO 335 I10 = I9, I11                                              00682300\n  335 A( I10 ) = 0.0                                                    00682400\n      K= NRMAX + 1                                                      00682500\n      L = 2*NRMAX                                                       00682600\n      M= 3*NRMAX                                                        00682700\n      N = 4*NRMAX                                                       00682800\n      I1 = IARGS(4) + I - 1                                             00682900\n      J1 = IARGS(6) + I - 1                                             00683000\n      DO 350 J=K,L                                                      00683100\n      AT =  ABS(A(I) - A(J))                                            00683200\n      IF ( ABS(ARG3) - AT) 350,340,340                                  00683300\n340   M = M + 1                                                         00683400\n      A(M) = AT                                                         00683500\n      N = N + 1                                                         00683600\n      A(N) = A(J)                                                       00683700\n350   CONTINUE                                                          00683800\n      IF (M - 3*NRMAX + 1) 360,380,400                                  00683900\n360   IF (NARGS-5) 480,480,370                                          00684000\n370   RC(J1)=0.0                                                        00684100\n      GO TO 480                                                         00684200\n380   RC(I1) =A(N)                                                      00684300\n      IF (NARGS - 5) 480,480,390                                        00684400\n390   RC(J1) = 1.0                                                      00684500\n      GO TO 480                                                         00684600\n400   M1 = 3*NRMAX + 2                                                  00684700\n410   K2 = 0                                                            00684800\n      DO 430 J=M1,M                                                     00684900\n      IF (A(J) - A(J-1)) 420,430,430                                    00685000\n420   AT = A(J)                                                         00685100\n      A(J) = A(J-1)                                                     00685200\n      A(J-1) =AT                                                        00685300\n      N = J + NRMAX                                                     00685400\n      AT = A(N)                                                         00685500\n      A(N) = A(N-1)                                                     00685600\n      A(N-1) = AT                                                       00685700\n      K2 = K2 +1                                                        00685800\n430   CONTINUE                                                          00685900\n      IF (K2) 440,440,410                                               00686000\n440   N = 4*NRMAX + 1                                                   00686100\n450   RC(I1) = A(N)                                                     00686200\n      I1= I1 + NROW                                                     00686300\n      N = N +1                                                          00686400\n      IF (I1 - I - IARGS(5) + 1) 450,450,460                            00686500\n460   IF (NARGS - 5) 480,480,470                                        00686600\n470   RC(J1) = M - 3*NRMAX                                              00686700\n480   CONTINUE                                                          00686800\n      GO TO 35                                                          00686900\nC  SEARCH                                                               00687000\n500   I1 = NARGS - 1                                                    00687100\n      DO 520 I =1,NRMAX                                                 00687200\n      K = IARGS(1) + I - 1                                              00687300\n      L = IARGS(2) + I - 1                                              00687400\n      M = NRMAX + I                                                     00687500\n      A(I) = RC(L)                                                      00687600\n      A(M) = RC(K)                                                      00687700\n      J1 = 2                                                            00687800\n      DO 510 N=3,I1,2                                                   00687900\n      L= J1*NRMAX + I                                                   00688000\n      M = IARGS(N) + I - 1                                              00688100\n      A(L) = RC(M)                                                      00688200\n510   J1 = J1 + 1                                                       00688300\n      DO 520 N =4,NARGS,2                                               00688400\n      M = IARGS(N) + I - 1                                              00688500\n520   RC(M) = 0.0                                                       00688600\n      K = NRMAX + 1                                                     00688700\n      L = 2*NRMAX                                                       00688800\n      DO 560 I=1,NRMAX                                                  00688900\n      AT =  ABS(A(I)\/1.E8)                                              00689000\n      DO 550 J=K,L                                                      00689100\n      IF ( ABS(A(I) - A(J)) - AT) 530,550,550                           00689200\n530   J1=1                                                              00689300\n      DO 540  N=4,NARGS,2                                               00689400\n      M= IARGS(N) + I - 1                                               00689500\n      I1= J1*NRMAX + J                                                  00689600\n      RC(M) = A(I1)                                                     00689700\n540   J1 =J1 + 1                                                        00689800\n      GO TO 560                                                         00689900\n550   CONTINUE                                                          00690000\n560   CONTINUE                                                          00690100\n      GO TO 35                                                          00690200\nC  CENSOR                                                               00690300\n600   DO 610 I=1,NRMAX                                                  00690400\n      J = IARGS(1) + I -1                                               00690500\n610   A(I) = RC(J)                                                      00690600\n      DO 660 J=2,3                                                      00690700\n      K = (J-1)*NRMAX                                                   00690800\n      IF (KIND(J)) 640,620,640                                          00690900\n620   DO 630 I=1,NRMAX                                                  00691000\n      I1 = IARGS(J) + I - 1                                             00691100\n      K = K + 1                                                         00691200\n630   A(K) = RC(I1)                                                     00691300\n      GO TO 660                                                         00691400\n640   ARG3 = ARGS(J)                                                    00691500\n      DO 650 I =1,NRMAX                                                 00691600\n      K = K +1                                                          00691700\n650   A(K) = ARG3                                                       00691800\n660   CONTINUE                                                          00691900\n      DO 680 I=1,NRMAX                                                  00692000\n      J=   NRMAX + I                                                    00692100\n      K= 2*NRMAX + I                                                    00692200\n      L = IARGS(4) + I - 1                                              00692300\n      IF (A(I) -  A(J)) 670,670,680                                     00692400\n670   A(I) = A(K)                                                       00692500\n680   RC(L) = A(I)                                                      00692600\n      GO TO 35                                                          00692700\n       END                                                              00692800\nC  87   4      SUBROUTINE SEPINS                   2 19 68              00692900\n      SUBROUTINE SEPINS                                                 00693000\n      CALL X( \"SEPINS\" )                                                00693100\n      RETURN                                                            00693200\n      END                                                               00693300\nC  88  52      SUBROUTINE SET                      2 19 68              00693400\n      SUBROUTINE SET                                                    00693500\n      COMMON \/BLOCKC\/KIO,INUNIT,ISCRAT,KBDOUT,KRDKNT                    00693600\n      COMMON \/ BLOCKA\/MODE,M,KARD(83),KARG,ARG,ARG2,NEWCD(80),KRDEND    00693700\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00693800\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00693900\n      DIMENSION KFMT(17)                                                00694000\n      DIMENSION NOUT(6)                                                 00694100\n      DATA NOUT(1),NOUT(2),NOUT(3),NOUT(4),NOUT(5),NOUT(6) \/ 729, 1458, 00694200\n     1 2187,2916, 3645, 4374 \/                                          00694300\n      DIMENSION ARGS(100)                                               00694400\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00694500\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00694600\n      COMMON \/ QRS \/ NDROW, IFLAG, J, NNARG                             00694700\n      ISRFLG = 1                                                        00694800\n      IF ( NARGS .GE. 1 .AND. NARGS .LE. 3 ) GO TO 10                   00694900\n      CALL ERROR( 10 )                                                  00695000\n      GO TO 99                                                          00695100\n  10  MODE = 2                                                          00695200\n      DO 12 I=1,6                                                       00695300\n      L2 = I+1                                                          00695400\n      IF ( NAME(3) .EQ. NOUT(L2-1) ) GO TO 14                           00695500\n   12 CONTINUE                                                          00695600\n      GO TO 16                                                          00695700\n   14 L1 = 0                                                            00695800\n      CALL SETFMT( KFMT )                                               00695900\n   16 CALL ADRESS( NARGS , J )                                          00696000\n      IF( J ) 15, 17, 20                                                00696100\n  15  CALL ERROR( 3 )                                                   00696200\n      GO TO 99                                                          00696300\n  17  CALL ERROR( 11 )                                                  00696400\n      GO TO 99                                                          00696500\n  20  NDROW = J + NROW - 1                                              00696600\n      IF( NARGS .EQ. 1 ) GO TO 30                                       00696700\n      IF ( L1 .EQ. 0 ) GO TO 200                                        00696800\n      IF( KIND( 1 ) .NE. 0 ) GO TO 15                                   00696900\n      IF( IARGS( 1 ) .LE. NROW .AND. IARGS( 1 ) .GT. 0 ) GO TO 25       00697000\n      CALL ERROR( 16 )                                                  00697100\n      GO TO 99                                                          00697200\n  25  J = J + IARGS( 1 ) - 1                                            00697300\n  30  IFLAG = 0                                                         00697400\n      MODE = 2                                                          00697500\n      GO TO 100                                                         00697600\n  99  IFLAG = 1                                                         00697700\n 100  RETURN                                                            00697800\n  200 KROW = 1                                                          00697900\n      IF ( NARGS .EQ. 3 ) KROW = IARGS(2)                               00698000\n      J = J + KROW - 1                                                  00698100\n      JEND = IARGS(1) + J - 1                                           00698200\n      READ ( INUNIT , KFMT ) ( RC( I ),I=J,JEND)                        00698300\n      NRMAX =MAX0(NRMAX, IARGS(1) + KROW - 1 )                          00698400\n      GO TO 100                                                         00698500\n      END                                                               00698600\nC  89  24      SUBROUTINE SETFMT( KFMT )           2 19 68              00698700\n      SUBROUTINE SETFMT( KFMT )                                         00698800\n      DIMENSION KFMT( 17 )                                              00698900\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00699000\n      COMMON \/ HEADER\/NMCARD(72),ITLE(64,6),IHEAD(4,50),IFMT(17,6),     00699100\n     1 IFMTX(4),LNCNT,IPRINT,NPAGE,IPUNCH                               00699200\nC                                                                       00699300\nC    SETUP FORMAT STATEMENT                                             00699400\nC                                                                       00699500\nC                                                                       00699600\nC     USE STANDARD FORMAT IF L2 = 1 OR IF REQUESTED FORMAT HAS NOT BEEN 00699700\nC     SUPPLIED YET.                                                     00699800\nC                                                                       00699900\n      IF( L2 .NE. 1 .AND. IFMT( 1, L2-1 ) .NE. 0 ) GO TO 30             00700000\nC     USE STANDARD FORMAT IF L2 = 1 OR IF REQUESTED FORMAT HAS NOT BEEN 00700100\nC     SUPPLIED YET.                                                     00700200\nC                                                                       00700300\n      IF( L2 .NE. 1 .AND. IFMT( 1, L2-1 ) .NE. 0 ) GO TO 30             00700400\n      DO 10 I = 1, 4                                                    00700500\n  10  KFMT( I ) = IFMTX( I )                                            00700600\n  20  RETURN                                                            00700700\n  30  DO 40 I = 1, 17                                                   00700800\n  40  KFMT( I ) = IFMT( I, L2-1 )                                       00700900\n      GO TO 20                                                          00701000\n      END                                                               00701100\nC  90  28      SUBROUTINE SETQ                     2 19 68              00701200\n      SUBROUTINE SETQ                                                   00701300\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00701400\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00701500\n      DIMENSION ARGS(100)                                               00701600\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00701700\n      COMMON \/ QRS \/ NDROW, IFLAG, J, NNARG                             00701800\nC     CHECK IF END OF ROW HAS BEEN EXCEEDED PREVIOUSLY IN THIS SET.     00701900\n      IF( IFLAG .NE. 0 .OR. NARGS .EQ. 0 ) GO TO 99                     00702000\nC     J IS WHERE NEXT DATA ITEM IS TO GO IN COLUMN                      00702100\nC     JJ IS WHERE LAST DATA ITEM OF THIS SET IS TO GO                   00702200\nC     NDROW IS ADDRESS OF LAST ELEMENT OF ROW.                          00702300\n      JJ = J + NARGS - 1                                                00702400\n      IF( JJ .LE. NDROW ) GO TO 10                                      00702500\n      CALL ERROR( 201 )                                                 00702600\n      IFLAG = 1                                                         00702700\n      IF( J .GT. NDROW ) GO TO 99                                       00702800\n      JJ = NDROW                                                        00702900\n  10  K = 1                                                             00703000\n      DO 30 I = J, JJ                                                   00703100\n      IF( KIND( K ) .EQ. 0 ) GO TO 20                                   00703200\n      RC( I ) = ARGS( K )                                               00703300\n      GO TO 30                                                          00703400\n  20  RC( I ) = IARGS( K )                                              00703500\n  30  K = K + 1                                                         00703600\n      J = JJ + 1                                                        00703700\n      NRMAX = MAX0( NRMAX, JJ - NDROW + NROW )                          00703800\n  99  RETURN                                                            00703900\n      END                                                               00704000\nC  91  94      SUBROUTINE SORDER                   2 19 68              00704100\n      SUBROUTINE SORDER                                                 00704200\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00704300\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00704400\n      DIMENSION ARGS(100)                                               00704500\n      EQUIVALENCE( ARGS(1), RC(10101) )                                 00704600\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00704700\n      COMMON \/ SCRAT \/ A(10000),NS                                      00704800\nC           SUBROUTINE BY CARLA MESSINA 221.04  JUNE 1967               00704900\nC     L2=8 FOR SORT, L2=9 FOR ORDER, L2=14 FOR HEIRARCHY                00705000\nC                                                                       00705100\nC TYPE 1 IS      HEIRARCHY OF COL  ++, STORE IN COL ++                  00705200\nC           HEIRARCHY GIVES THE ROW LOCATION OF THE SMALLEST NO. OF THE 00705300\nC     THE FIRST COLUMN IN THE FIRST ROW OF THE SECOND COLUMN            00705400\nC     THE ROW NO. OF THE SECOND LOWEST NO. OF THE FIRST COLUMN IS STORED00705500\nC     IN THE SECOND ROW OF THE SECOND COLUMN, ..... THE ROW NO. OF THE  00705600\nC     LARGEST NO. OF THE FIRST COL IS STORED IN THE NRMAX ROW OF THE 2ND00705700\nC     COLUMN.  THE FIRST COLUMN IS UNCHANGED BY THIS COMMAND.           00705800\nC TYPE 2 IS   ORDER COLUMNS ++,++,++, ETC                               00705900\nC        ORDER PLACES EACH ONE OF THE GIVEN COLUMNS IN NUMERICALLY      00706000\nC     INCREASING ORDER.                                                 00706100\nC TYPE 3 IS   SORT COL ++ CARRY ALONG COLUMNS ++,++, ETC                00706200\nC        SORT PLACES THE FIRST COLUMN IN NUMERICALLY INCREASING ORDER   00706300\nC     WHILE PRESERVING THE ROW RELATIONSHIPS AMONG THE GIVEN COLUMNS    00706400\nC                                                                       00706500\nC        THESE INSTRUCTIONS CAN BE DONE FASTER IF A MACHINE LANGUAGE    00706600\nC     PROGRAM IS SUBSTITUTED FOR THIS ONE.                              00706700\nC                                                                       00706800\n      IF (NARGS) 10,10,40                                               00706900\n10    K=10                                                              00707000\n20    CALL ERROR(K)                                                     00707100\n30    RETURN                                                            00707200\n40    CALL CHKCOL(J)                                                    00707300\n      IF (J) 50,60,50                                                   00707400\n50    K=3                                                               00707500\n      GO TO 20                                                          00707600\n  60  IF( L2 - 9 ) 80, 80, 70                                           00707700\n70    IF (NARGS-2) 10,80,10                                             00707800\n80    IF (NERROR) 30,90,30                                              00707900\n90    IF (NRMAX-1) 100,110,120                                          00708000\n100   K=9                                                               00708100\n      GO TO 20                                                          00708200\n 110  IF( L2 - 9 ) 30, 30, 215                                          00708300\n120   K3=1                                                              00708400\n      K = IARGS(1) -1                                                   00708500\n130   DO 140 I =1,NRMAX                                                 00708600\n      J=K+I                                                             00708700\n      L = NRMAX + I                                                     00708800\n      A(I) = RC(J)                                                      00708900\n140   A(L) = I                                                          00709000\n150   K1 = NRMAX                                                        00709100\n160   K1 = K1 -1                                                        00709200\n      K2=0                                                              00709300\n      IF (K1-1) 170,170,180                                             00709400\n170   K1 = 2                                                            00709500\n180   DO 200 I=1,K1                                                     00709600\n      IF (A(I)-A(I+1)) 200,200,190                                      00709700\n190   CC = A(I)                                                         00709800\n      A(I) = A(I+1)                                                     00709900\n      A(I+1) = CC                                                       00710000\n      L=NRMAX + I                                                       00710100\n      CC = A(L)                                                         00710200\n      A(L) = A(L+1)                                                     00710300\n      A(L+1) = CC                                                       00710400\n      K2=1                                                              00710500\n200   CONTINUE                                                          00710600\n      IF (K2) 160,210,160                                               00710700\n 210  IF( L2 - 9 ) 240, 240, 220                                        00710800\n215   A(NRMAX+1)=1.0                                                    00710900\n220   K= IARGS(2) - 1                                                   00711000\n      DO 230 I=1,NRMAX                                                  00711100\n      J= K+ I                                                           00711200\n      L=NRMAX + I                                                       00711300\n230   RC(J) = A(L)                                                      00711400\n      GO TO 30                                                          00711500\n240   DO 250 I=1,NRMAX                                                  00711600\n      J= K+ I                                                           00711700\n250   RC(J) = A(I)                                                      00711800\n      IF (NARGS-2) 30,260,260                                           00711900\n 260  IF( L2 - 9 ) 290, 270, 270                                        00712000\n270   IF (NARGS-K3) 30,30,280                                           00712100\n280   K3 = K3 + 1                                                       00712200\n      K = IARGS(K3) - 1                                                 00712300\n      GO TO 130                                                         00712400\n290   DO 310 I =2,NARGS                                                 00712500\n      K = IARGS(I) - 1                                                  00712600\n      DO 300 J=1,NRMAX                                                  00712700\n      L = NRMAX + J                                                     00712800\n      J1 = A(L) + K                                                     00712900\n300   A(J) = RC(J1)                                                     00713000\n      DO 310 J=1,NRMAX                                                  00713100\n      J1= K + J                                                         00713200\n310   RC(J1) = A(J)                                                     00713300\n      GO TO 30                                                          00713400\n      END                                                               00713500\nC  92  40      SUBROUTINE SORTSM(N,SUM)            2 19 68              00713600\n      SUBROUTINE SORTSM(N,SUM)                                          00713700\nC *****                                                                 00713800\nC     SORT COLUMN OF PRODUCTS FOR MATRIX MULTIPLICATION                 00713900\nC     AFTER SORTING START SUMMING BEGIN IN MIDDLE OF SORTED COLUMN      00714000\nC *****                                                                 00714100\n      COMMON\/MULTC\/NS2                                                  00714200\n      COMMON \/ SCRAT \/ X,NS                                             00714300\n      DIMENSION A(10000)                                                00714400\n      DOUBLE PRECISION X(5000), SUM, SAVE                               00714500\n                                                                        00714600\n      IF ( N .NE. 1 ) GO TO 80                                          00714700\n      SUM = X( NS2 )                                                    00714800\n      RETURN                                                            00714900\n   80 SUM = X(NS2)                                                      00715000\n      IS = NS2 - 1                                                      00715100\n      DO 120  I=2,N                                                     00715200\n      SUM = SUM + X(IS)                                                 00715300\n 120  IS=IS-1                                                           00715400\n      RETURN                                                            00715500\n      END                                                               00715600\nC  93  24      SUBROUTINE SPACE                    2 19 68              00715700\n      SUBROUTINE SPACE                                                  00715800\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00715900\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00716000\n      DIMENSION ARGS(100)                                               00716100\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00716200\n      COMMON \/ HEADER\/NMCARD(72),ITLE(64,6),IHEAD(4,50),IFMT(17,6),     00716300\n     1 IFMTX(4),LNCNT,IPRINT,NPAGE,IPUNCH                               00716400\n      IF( NARGS - 1 ) 60, 40, 10                                        00716500\n  10  I = 10                                                            00716600\n  20  CALL ERROR( I )                                                   00716700\n  30  RETURN                                                            00716800\n  40  IF ( KIND(1) .EQ. 0 ) IF ( IARGS(1) ) 50,30,70                    00716900\n      I = 20                                                            00717000\n      GO TO 20                                                          00717100\n  50  I = 3                                                             00717200\n      GO TO 20                                                          00717300\n  60  IARGS( 1 ) = 1                                                    00717400\n  70  J = MIN0( 60, IARGS( 1 ) )                                        00717500\n      IF( NERROR .NE. 0 ) GO TO 30                                      00717600\n      DO 80 I = 1, J                                                    00717700\n  80  WRITE( IPRINT, 90 )                                               00717800\n  90  FORMAT(1X)                                                        00717900\n      GO TO 30                                                          00718000\n      END                                                               00718100\nC  94  84      SUBROUTINE SPINV(A,M,KK,ISIG)       2 19 68              00718200\n      SUBROUTINE SPINV(A,M,KK,ISIG)                                     00718300\nC7058MI  MATRIX INVERSION WITH MINIMUM ROUNDOFF ERROR ACCUMULATION. PREC00718400\n      DATA ONE\/1.0\/,ZERO\/0.0\/,ER\/1.E-8\/                                 00718500\n      DIMENSION A(1)                                                    00718600\n      ISIG = 0                                                          00718700\n      N = M                                                             00718800\n      NN = KK                                                           00718900\n      N2 = N + N                                                        00719000\n      DO 10 J=1,N                                                       00719100\n      NJCOL = (N + J - 1) * NN                                          00719200\n      DO 10 I=1,N                                                       00719300\n      KINJ = NJCOL + I                                                  00719400\n      IF(I-J)4,6,4                                                      00719500\n    4 A(KINJ)=ZERO                                                      00719600\n      GO TO 10                                                          00719700\n    6 A(KINJ) = ONE                                                     00719800\n   10 CONTINUE                                                          00719900\nC  DETERMINE MAXIMUM ABS OF VARIABLE BEING ELIMINATED.  THIS BECOMES PIV00720000\n      L = 0                                                             00720100\n   12 L = L + 1                                                         00720200\n      LCOL = NN*L-NN                                                    00720300\n      KLL = LCOL + L                                                    00720400\n      IF(L - N)13,30,1000                                               00720500\nC  FIND THE LARGEST ELEMENT IN THE LTH COLUMN.                          00720600\n   13 J1 = L                                                            00720700\n      C = ABS ( A(KLL) )                                                00720800\n      L1 = L + 1                                                        00720900\n      DO 20 I = L1,N                                                    00721000\n      KIL = LCOL + I                                                    00721100\n      X = ABS (A(KIL))                                                  00721200\n      IF(C - X)14,20,20                                                 00721300\nC  RECORD THE NUMBER OF THE ROW HAVING THE GREATER ELEMENT.             00721400\n   14 J1 = I                                                            00721500\nC  C BECOMES THE GREATER.                                               00721600\n      C  = X                                                            00721700\n   20 CONTINUE                                                          00721800\nC  INTERCHANGE ROW J1 WITH ROW L. J1 IS THE ROW WITH THE LARGEST ELEMENT00721900\nC  TEST TO SEE IF INTERCHANGING IS NECESSARY.                           00722000\n      IF(J1 - L)22,30,22                                                00722100\n   22 DO 24 J = L,N2                                                    00722200\n      JCOL = NN*J-NN                                                    00722300\n      KJIJ = JCOL + J1                                                  00722400\n      HOLD = A(KJIJ)                                                    00722500\n      KLJ = JCOL + L                                                    00722600\n      A(KJIJ) = A(KLJ)                                                  00722700\n      A(KLJ) = HOLD                                                     00722800\n   24 CONTINUE                                                          00722900\nC  IF  THE LARGEST ABSOLUTE ELEMENT IN A COLUMN IS ZERO WE HAVE A SINGUL00723000\n  30  IF(ABS(A(KLL))-ER)33,33,32                                        00723100\n  33  ISIG = 4                                                          00723200\n      GO TO 1000                                                        00723300\nC   ZERO ALL THE ELEMENTS IN THE LTH COLUMN BUT THE PIVOTAL ELEMENT.    00723400\n   32 L1 = 1                                                            00723500\n      L2 = L - 1                                                        00723600\n      IF(L2)321,321,323                                                 00723700\n  321 IF(L-N)322,46,322                                                 00723800\n  322 L1 = L + 1                                                        00723900\n      L2 = N                                                            00724000\n  323 DO 324 I = L1,L2                                                  00724100\n      KIL = LCOL + I                                                    00724200\n      Z = -A(KIL)\/A(KLL)                                                00724300\n      DO 324 J = L,N2                                                   00724400\n      JCOL = NN*J - NN                                                  00724500\n      KIJ = JCOL + I                                                    00724600\n      KLJ = JCOL + L                                                    00724700\n  324 A(KIJ) = A(KIJ) + Z*A(KLJ)                                        00724800\n      IF(N - L2)12,12,321                                               00724900\nC  DIVIDE BY DIAGONAL ELEMENTS.                                         00725000\n   46 DO 48 I = 1,N                                                     00725100\n      KKK = NN*I - NN + I                                               00725200\n      ZZ = A(KKK)                                                       00725300\n      DO 48 J = 1,N2                                                    00725400\n      KKI = NN*J - NN + I                                               00725500\n   48 A(KKI) = A(KKI)\/ZZ                                                00725600\nC   RETURN AFTER PUTTING A INVERSE INTO B                               00725700\n   49 DO 50 J = 1,N                                                     00725800\n      JCOL = NN*J - NN                                                  00725900\n      NJCOL = NN * N + JCOL                                             00726000\n      DO 50 I = 1,N                                                     00726100\n      KIJ = JCOL + I                                                    00726200\n      KINJ = NJCOL + I                                                  00726300\n  50  A(KIJ) = A(KINJ)                                                  00726400\n 1000 RETURN                                                            00726500\n       END                                                              00726600\nC  95 449      SUBROUTINE  STATIS                  2 19 68              00726700\n      SUBROUTINE  STATIS                                                00726800\nC     PROGRAM WRITTEN BY S. PEAVY   8\/31\/67                             00726900\nC**** OMNITAB COMMAN IS AS FOLLOWS                                      00727000\nC**** I  WITH WEIGHTS                                                   00727100\nC****  A. STATIS  COL +++  WEIGHTS +++  START STORING RESULTS +++       00727200\nC****      (RESULTS WILL BE STORED IN THE NEXT 4 COL)                   00727300\nC****  B. STATIS  COL +++ WHTS +++ RESULTS +++,+++,+++,+++              00727400\nC**** II WITHOUT WHTS                                                   00727500\nC****  A. SAME AS I. A.  EXCEPT WHTS COL OMITTED                        00727600\nC****  B. SAME AS I. B.  EXCEPT WHTS COL OMITTED                        00727700\n      COMMON \/ HEADER\/NMCARD(72),ITLE(64,6),IHEAD(4,50),IFMT(17,6),     00727800\n     1 IFMTX(4),LNCNT,IPRINT,NPAGE,IPUNCH                               00727900\n      COMMON \/ SCRAT \/ A(10000),NS                                      00728000\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00728100\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00728200\n      DIMENSION ARGS(100)                                               00728300\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00728400\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00728500\n      DIMENSION  SA(1250,3),ISA(1250)                                   00728600\n      DIMENSION IB(10)                                                  00728700\n      EQUIVALENCE (A(101),ISA),(A(1351),SA),(NRMAX,NARMAX)              00728800\n      DIMENSION  BCON(4),BKCON(4),AKCON(4),AT5(6),CK1(6),DK2(6),XK1(7), 00728900\n     1 YK2(7)                                                           00729000\n      DATA BCON\/3.6948,-1.6561,.406,2.7764\/,BKCON\/7.45894,-.89082,      00729100\n     1 .61522,2.56706\/,AKCON\/-.51732,-.61863,-.04122,.55897\/,AT5\/       00729200\n     2 1.9599640,2.3722712,2.8224986,2.5558497,1.5895341,.7328982\/,CK1\/ 00729300\n     3 -.70285,-.02006,-.01687,-.01447,-.01263,.67839\/,DK2\/-1.49016,    00729400\n     4 .13384,.09764,.07476,.05931,1.68641\/,XK1\/-40.343875,14.1365,     00729500\n     5 -2.743342,.84143957,.001066,-6.3701507E-6,1.749484E-8\/,YK2\/      00729600\n     6 50.298233,-11.395210,6.0537922,1.1542370,-9.8051279E-4,5.5609437E00729700\n     7 -6,1.4584433E-8\/,CONK\/1.959964\/                                  00729800\n      DATA ZERO\/0.0\/,ONE\/1.0\/,TWO\/2.0\/                                  00729900\n      NXCOL=IARGS(1)                                                    00730000\n      NXWT= IARGS(2)                                                    00730100\n      ISTORE=1                                                          00730200\n      NAR=NARGS                                                         00730300\n      IWT=1                                                             00730400\n      IF(NARGS.EQ.1) GO TO 80                                           00730500\n      IF(NARGS.EQ.3.AND.IARGS(NARGS).LT.0) GO TO 70                     00730600\n      GO TO 90                                                          00730700\n   70 NARGS=NARGS-1                                                     00730800\n      IWT=2                                                             00730900\n   80 ISTORE=2                                                          00731000\n      GO TO  95                                                         00731100\n   90 IF(NARGS.NE.2.AND.NARGS.NE.3.AND.NARGS.NE .5.AND.NARGS.NE.6)      00731200\n     1CALL ERROR (10)                                                   00731300\n  95  J=NARGS                                                           00731400\n      CALL CKIND(J)                                                     00731500\n      IF(J    .NE.0) CALL ERROR (3)                                     00731600\n      CALL CHKCOL(J)                                                    00731700\n      IF(J.NE.0) CALL ERROR(11)                                         00731800\n      IF(NARMAX*4.GT.NS  ) CALL ERROR (225)                             00731900\n      IF(NERROR.NE.0) RETURN                                            00732000\n      IXN=NRMAX                                                         00732100\n      A(1)=NRMAX                                                        00732200\n      K=IARGS(1)                                                        00732300\n      M=1                                                               00732400\n      IF(NAR  .EQ.3.OR.NAR  .EQ.6) GO TO  120                           00732500\n      NZW=NRMAX                                                         00732600\n      SUM=0.0                                                           00732700\n      S2=0.                                                             00732800\n      WT=0.0                                                            00732900\n      DO  100 I=1,IXN                                                   00733000\n      SA(I,2)=RC(K)                                                     00733100\n      SA(I,3)=1.0                                                       00733200\n      ISA(I)=M                                                          00733300\n      SA(I,1)=RC(K)                                                     00733400\n      K=K+1                                                             00733500\n      M=M+1                                                             00733600\n      WT=WT+1.                                                          00733700\n      SUM=SUM+SA(I,2)                                                   00733800\n  100 S2=S2+SA(I,2)**2                                                  00733900\n      SUMWT=SUM                                                         00734000\n      GO TO 150                                                         00734100\n  120 SUM=0.                                                            00734200\n      WT=0.                                                             00734300\n      SUMWT=0.0                                                         00734400\n      MA=IARGS(2)                                                       00734500\n      S2=0.0                                                            00734600\n      IWT=2                                                             00734700\n      DO  130 I=1,IXN                                                   00734800\n      IF(RC(MA).EQ.0.)GO TO 125                                         00734900\n      SA(M,2)=RC(K)                                                     00735000\n      SA(M,3)=RC(MA)                                                    00735100\n      ISA(M)=M                                                          00735200\n      SA(M,1)=RC(K)                                                     00735300\n      S2=S2+SA(M,2)**2*RC(MA)                                           00735400\n      SUM=SUM+RC(K)                                                     00735500\n      WT=WT+RC(MA)                                                      00735600\n      SUMWT=SA(M,2)*RC(MA)+SUMWT                                        00735700\n      M=M+1                                                             00735800\n  125 K=K+1                                                             00735900\n  130 MA=MA+1                                                           00736000\n      NZW=M-1                                                           00736100\n  150 A(2)=NZW                                                          00736200\n      A(3)=SUM\/A(2)                                                     00736300\n      A(4)=SUMWT\/WT                                                     00736400\n      A(24)=(2*A(2)-1.)\/3.                                              00736500\n      A(25)=FSQRT((16.*A(2)-29.)\/90.)                                   00736600\n      A(39)=S2                                                          00736700\n      IXN=NZW                                                           00736800\n      IXNM1=IXN-1                                                       00736900\n  405 IST=0                                                             00737000\n      DO 410 I=2,IXN                                                    00737100\n      IF(SA(I-1,1).LE.SA(I,1)) GO TO 410                                00737200\n      K=ISA(I-1)                                                        00737300\n      ISA(I-1)=ISA(I)                                                   00737400\n      ISA(I)=K                                                          00737500\n      T=SA(I-1,1)                                                       00737600\n      SA(I-1,1)=SA(I,1)                                                 00737700\n      SA(I,1)=T                                                         00737800\n      IST=1                                                             00737900\n  410 CONTINUE                                                          00738000\n      IF(IST.NE.0) GO TO 405                                            00738100\n      NALPHA=.05*A(2)                                                   00738200\n      IXA=NALPHA+1                                                      00738300\n      IXNA=IXN-NALPHA                                                   00738400\n      TSUM=0.                                                           00738500\n      TWSUM=0                                                           00738600\n      TWT=0                                                             00738700\n      DO 660  I=IXA,IXNA                                                00738800\n      M=ISA(I)                                                          00738900\n      TWSUM=TWSUM+SA(I,1)*SA(M,3)                                       00739000\n      TWT=TWT+SA(M,3)                                                   00739100\n  660 TSUM=TSUM+SA(I,1)                                                 00739200\n      A(7)=TSUM\/(A(2)-2.*FLOAT(NALPHA))                                 00739300\n      A(8)=TWSUM\/TWT                                                    00739400\n      N2=(NZW+1)\/2                                                      00739500\n      A(5)=SA(N2,1)                                                     00739600\n      IF(MOD(NZW,2).EQ.0) A(5)=(A(5)+SA(N2+1,1))\/TWO                    00739700\n      A(6)=(SA(1,1)+SA(IXN,1))\/TWO                                      00739800\n      A(11)=SA(IXN,1)-SA(1,1)                                           00739900\n      A(34)=SA(1,1)                                                     00740000\n      A(35)=SA(IXN,1)                                                   00740100\n      DELX=A(11)\/10.                                                    00740200\n      XB=SA(1,1)                                                        00740300\n      XT=XB+DELX                                                        00740400\n      L=1                                                               00740500\n      DO 520  I=1,10                                                    00740600\n      IC=0                                                              00740700\n  500 IF(SA(L,1).GE.XT) GO TO 510                                       00740800\n      IC=IC+1                                                           00740900\n      L=L+1                                                             00741000\n      IF(L.NE.IXN) GO TO 500                                            00741100\n  510 A(I+50)=IC                                                        00741200\n  520 XT=XT+DELX                                                        00741300\n      IF(L.GT.IXN) GO TO 527                                            00741400\n      DO 524 I=L,IXN                                                    00741500\n      IF(SA(I  ,1).GE.XT-DELX)  A(60)=A(60)+1.                          00741600\n  524 CONTINUE                                                          00741700\n  527 DO  530 I=1,IXNM1                                                 00741800\n  530 SA(I,3)=SA(I+1,1)-SA(I,1)                                         00741900\n      LA=1                                                              00742000\n      DO 420 I=1,IXN                                                    00742100\n      K=ISA(I)                                                          00742200\n      SA(K,1)=LA                                                        00742300\n  420 LA=LA+1                                                           00742400\n      K=0                                                               00742500\n      RNS=0.                                                            00742600\n      RNSS=ONE                                                          00742700\n      LR=0                                                              00742800\n      DO 470 I=1,IXNM1                                                  00742900\n      IF(SA(I,3).NE.0.AND.K.EQ.0) GO TO 460                             00743000\n      IF(SA(I,3).NE.0) GO TO 430                                        00743100\n      RNS=RNS+RNSS                                                      00743200\n      K=K+1                                                             00743300\n      GO TO 470                                                         00743400\n  430 K=K+1                                                             00743500\n      RNS=RNS+RNSS                                                      00743600\n      RNS=RNS\/FLOAT(K)                                                  00743700\n      DO 450 L=1,K                                                      00743800\n      LR=LR+1                                                           00743900\n      LRR=ISA(LR)                                                       00744000\n  450 SA(LRR,1)=RNS                                                     00744100\n      LR=LR-1                                                           00744200\n      RNS=0.                                                            00744300\n      K=0                                                               00744400\n  460 LR=LR+1                                                           00744500\n  470 RNSS=RNSS+ONE                                                     00744600\n      ICI=0                                                             00744700\n      IPLUS=0                                                           00744800\n      IMINUS=0                                                          00744900\n      IDRUNS=0                                                          00745000\n      IC=0                                                              00745100\n      ADEV=0.0                                                          00745200\n      DEV3=0.0                                                          00745300\n      DEV2=0.0                                                          00745400\n      DEV=0.0                                                           00745500\n      DEVI=0.0                                                          00745600\n      DEVWT=0.                                                          00745700\n      DEV4=0.0                                                          00745800\n      AK=1.                                                             00745900\n      KWT=IARGS(2)                                                      00746000\n      NRXX=KWT+NRMAX-1                                                  00746100\n      TA=1.0                                                            00746200\n      DO  250 I=1,IXN                                                   00746300\n      T=SA(I,2)-A(4)                                                    00746400\n      SA(I,3)=T                                                         00746500\n      DEV=T+DEV                                                         00746600\n      ADEV=ADEV+ABS(T)                                                  00746700\n      DEV2=DEV2+T**2                                                    00746800\n      DEV3=DEV3+T**3                                                    00746900\n      DEV4=DEV4+T**4                                                    00747000\n      DEVI=AK*T+DEVI                                                    00747100\n      AK=AK+1.0                                                         00747200\n      IF(IWT.EQ.1) GO TO 210                                            00747300\n  203 IF(RC(KWT).NE.0.)GO TO 204                                        00747400\n      IF(KWT.GE.NRXX ) GO TO 200                                        00747500\n      KWT=KWT+1                                                         00747600\n      GO TO 203                                                         00747700\n  204 TA=RC(KWT)                                                        00747800\n  210 DEVWT=DEVWT+TA*T**2                                               00747900\n  200 IF(T.LT.0) GO TO 230                                              00748000\n      IPLUS=IPLUS+1                                                     00748100\n      ICI=+1                                                            00748200\n      GO TO  240                                                        00748300\n  230 IMINUS=IMINUS+1                                                   00748400\n      ICI=-1                                                            00748500\n  240 IF(IC.EQ.ICI) GO TO 250                                           00748600\n      IC=ICI                                                            00748700\n      IDRUNS=IDRUNS+1                                                   00748800\n  250 KWT=KWT+1                                                         00748900\n      A(13)=DEVWT\/(A(2)-1.)                                             00749000\n      A(9)=FSQRT(A(13))                                                 00749100\n      A(10)=A(9)\/FSQRT(WT)                                              00749200\n      A(14)=100.*A(9)\/A(4)                                              00749300\n      A(28)=IPLUS                                                       00749400\n      A(29)=IMINUS                                                      00749500\n      A(31)=1.+(2.*A(28)*A(29)\/A(2))                                    00749600\n      A(32)=FSQRT((2.*A(28)*A(29)*(2.*A(28)*A(29)-A(28)-A(29))) \/       00749700\n     1( (A(28)+A(29))**2*(A(2)-1.)))                                    00749800\n      A(36)=(DEV3\/A(2))**2\/( (A(2)-1.)\/A(2)*A(13))**3                   00749900\n      A(37)=(DEV4\/A(2))\/( (A(2)-1.) \/A(2)*A(13))**2                     00750000\n      A(38)=SUMWT                                                       00750100\n      A(40)=DEVWT                                                       00750200\n      A(30)=IDRUNS                                                      00750300\n      A(33)=(A(30)-A(31))\/A(32)                                         00750400\n      A(19)=12.*DEVI\/(A(2)*(A(2)**2-1.))                                00750500\n      A(20)=FSQRT((1.\/(A(2)-2.))*(12.*DEV2\/(A(2)*(A(2)**2-1.))-A(19)**2)00750600\n     1)                                                                 00750700\n      A(21)=A(19)\/A(20)                                                 00750800\n      CALL PROB(ONE,A(2)-ONE ,A(21)*A(21),A(22))                        00750900\n      DIF=0                                                             00751000\n      IRUN=1                                                            00751100\n      TA=SA(2,2)-SA(1,2)                                                00751200\n      DO 300 I=2,IXN                                                    00751300\n      T=SA(I,2)-SA(I-1,2)                                               00751400\n      DIF=DIF+T**2                                                      00751500\n      IF (TA*T.GE.0) GO TO 300                                          00751600\n      TA=T                                                              00751700\n      IRUN=IRUN+1                                                       00751800\n  300 CONTINUE                                                          00751900\n      A(23)=IRUN                                                        00752000\n      A(26)=DIF\/(A(2)-1.)                                               00752100\n      A(27)=A(26)\/A(13)                                                 00752200\n      A(41)=A(4)*FSQRT(WT)\/A(9)                                         00752300\n      A(12)=ADEV \/A(2)                                                  00752400\n      NU=NZW-1                                                          00752500\n      VNU=NU                                                            00752600\n      T=ZERO                                                            00752700\n      TK1=ZERO                                                          00752800\n      TK2=ZERO                                                          00752900\n      IF(NU.GE.5)  GO TO 1210                                           00753000\n      DO  1200 I=1,4                                                    00753100\n      V=I\/NU                                                            00753200\n      T=T+BCON(I)*V                                                     00753300\n      TK2=BKCON(I)*V+TK2                                                00753400\n 1200 TK1=TK1+AKCON(I)*V                                                00753500\n      GO TO 1260                                                        00753600\n 1210 T= (((( AT5(6)\/VNU+AT5(5))\/VNU+AT5(4))\/VNU+AT5(3))\/VNU+AT5(2))\/VNU00753700\n     1 +AT5(1)                                                          00753800\n      IF (NU.GT. 10 ) GO TO 1230                                        00753900\n      DO  1220  I=1,6                                                   00754000\n      V=(I+4)\/NU                                                        00754100\n      TK1=TK1+CK1(I)*V                                                  00754200\n 1220 TK2=TK2+DK2(I)*V                                                  00754300\n      GO TO 1260                                                        00754400\n 1230 IF(NU.GT.100) GO TO 1250                                          00754500\n      DO  1240 I=1,7                                                    00754600\n      V=VNU**(I-4)                                                      00754700\n      TK1=TK1+XK1(I)*V                                                  00754800\n 1240 TK2=TK2+YK2(I)*V                                                  00754900\n      GO TO 1260                                                        00755000\n 1250 V2=FSQRT(TWO*VNU)                                                 00755100\n      V2M1=FSQRT(TWO*VNU-ONE)                                           00755200\n      TK1=V2\/(CONK  +V2M1)                                              00755300\n      TK2=V2\/(-CONK+V2M1)                                               00755400\n 1260 A(15)=A(4)-T*A(10)                                                00755500\n      A(16)=A(4)+T*A(10)                                                00755600\n      A(17)=TK1*A(9)                                                    00755700\n      A(18)=TK2*A(9)                                                    00755800\nC**** START PRINT OUT                                                   00755900\n      IF(L2.EQ.2) GO TO 930                                             00756000\n      CALL PAGE (4)                                                     00756100\n      IF(IWT.EQ.2) GO TO 760                                            00756200\n      WRITE(IPRINT,1000)NXCOL,NZW                                       00756300\n      GO TO 785                                                         00756400\n  760 IF(NZW.NE.NRMAX) GO TO 770                                        00756500\n      WRITE(IPRINT,1010)  NXCOL,NXWT,NZW                                00756600\n      GO TO 780                                                         00756700\n  770 WRITE(IPRINT,1020) NXCOL,NXWT,NZW,NRMAX                           00756800\n  780 WRITE (IPRINT,1030)                                               00756900\n  785 DO  790  I=1,10                                                   00757000\n  790 IB(I)=A(I+50)                                                     00757100\n      WRITE(IPRINT,1040) (IB(I),I=1,10)                                 00757200\n      WRITE(IPRINT,1050)                                                00757300\n      WRITE(IPRINT,1060)  ( A(I+2),A(I+8),I=1,6)                        00757400\n      WRITE(IPRINT,1070)  (A(I),I=15,18)                                00757500\n      WRITE(IPRINT,1080)  (A(I),A(I+15),I=19,22),(A(I),I=38,41)         00757600\n      IB(1)=A(23)                                                       00757700\n      IB(2)=A(28)                                                       00757800\n      IB(3)=A(29)                                                       00757900\n      IB(4)=A(30)                                                       00758000\n      WRITE(IPRINT,1090) IB(1),(A(I),I=24,27),(IB(I),I=2,4),            00758100\n     1(A(I),I=31,33)                                                    00758200\n      WRITE(IPRINT,1100)                                                00758300\n      KB=ISA(1)                                                         00758400\n      T=SA(KB,2)                                                        00758500\n      LINEP=40                                                          00758600\n      LINE=0                                                            00758700\n      LW=IARGS(2)                                                       00758800\n      DO  870 I=1,IXNM1                                                 00758900\n      IF(LINEP.LT.40) GO TO 810                                         00759000\n      LINEP=0                                                           00759100\n      CALL PAGE (4)                                                     00759200\n      WRITE(IPRINT,1110)                                                00759300\n      IF(IWT.EQ.1) GO TO 800                                            00759400\n      WRITE(IPRINT,1120)                                                00759500\n      GO TO 810                                                         00759600\n  800 WRITE(IPRINT,1130)                                                00759700\n  810 K=ISA(I+1)                                                        00759800\n      TA=SA(K,2)-T                                                      00759900\n      GO TO (850,840),IWT                                               00760000\n  840 IF(RC(LW).NE.0) GO TO 845                                         00760100\n      LW=LW+1                                                           00760200\n      GO TO 840                                                         00760300\n  845 WRITE(IPRINT,1150) I,SA(I,2),SA(I,1),SA(I,3),RC(LW),ISA(I),T,TA   00760400\n      LW=LW+1                                                           00760500\n      GO TO 860                                                         00760600\n  850 WRITE(IPRINT,1140)I,SA(I,2),SA(I,1),SA(I,3),ISA(I),T,TA           00760700\n  860 T=SA(K,2)                                                         00760800\n      LINE=LINE+1                                                       00760900\n      IF(LINE.NE.10) GO TO 870                                          00761000\n      LINE=0                                                            00761100\n      LINEP=LINEP+10                                                    00761200\n      WRITE(IPRINT,1160)                                                00761300\n  870 CONTINUE                                                          00761400\n      IF(IWT.EQ.1) GO TO 920                                            00761500\n  900 IF(RC(LW).NE.0) GO TO 910                                         00761600\n      LW=LW+1                                                           00761700\n      GO TO 900                                                         00761800\n  910 WRITE (IPRINT,1150) NZW,SA(NZW,2),SA(NZW,1),SA(NZW,3),RC(LW),     00761900\n     1 ISA(NZW),T                                                       00762000\n      GO TO 930                                                         00762100\n  920 WRITE(IPRINT,1140) NZW,SA(NZW,2),SA(NZW,1),SA(NZW,3),ISA(NZW),T   00762200\n  930 IF(ISTORE.EQ.2) RETURN                                            00762300\n      IF(NARGS.EQ.2.OR.NARGS.EQ.3) GO TO 940                            00762400\n      L=IARGS(NARGS-3)                                                  00762500\n      M=IARGS(NARGS-2)                                                  00762600\n      K=IARGS(NARGS-1)                                                  00762700\n      J=IARGS(NARGS)                                                    00762800\n      GO TO 950                                                         00762900\n  940 L=IARGS(NARGS)                                                    00763000\n      M=L+NROW                                                          00763100\n      K=M+NROW                                                          00763200\n      J=K+NROW                                                          00763300\n  950 DO  960 I=1,NZW                                                   00763400\n      MB=ISA(I)                                                         00763500\n      RC(K)=SA(MB,2)                                                    00763600\n      RC(M)=SA(I,1)                                                     00763700\n      RC(J)=SA(I,3)                                                     00763800\n      M=M+1                                                             00763900\n      K=K+1                                                             00764000\n  960 J=J+1                                                             00764100\n      IF(NZW.EQ.NRMAX) GO TO 975                                        00764200\n      NZW1=NZW+1                                                        00764300\n      DO 970  I=NZW1,NRMAX                                              00764400\n      RC(M)=0.                                                          00764500\n      RC(K)=0.                                                          00764600\n      RC(J)=0.                                                          00764700\n      M=M+1                                                             00764800\n      K=K+1                                                             00764900\n  970 J=J+1                                                             00765000\n 975  NTOP=60                                                           00765100\n      IF ( NROW .LT. NTOP ) NTOP = NROW                                 00765200\n      DO   980  I=1,NTOP                                                00765300\n      RC(L)=A(I)                                                        00765400\n  980 L=L+1                                                             00765500\n      IF(NRMAX.LT.60) RETURN                                            00765600\n      DO 990  I=61,NRMAX                                                00765700\n      RC(L)=0.                                                          00765800\n  990 L=L+1                                                             00765900\n      RETURN                                                            00766000\n 1000 FORMAT(1H0,4X,28HSTATISTICAL ANALYSIS OF COL ,I4,33X,4HN = ,I4)   00766100\n 1010 FORMAT(1H0,4X,28HSTATISTICAL ANALYSIS OF COL ,I4,8X,15HWEIGHTS IN 00766200\n     1COL ,I4,6X,4HN = ,I4)                                             00766300\n 1020 FORMAT(1H0,4X,28HSTATISTICAL ANALYSIS OF COL ,I4,8X,15HWEIGHTS IN 00766400\n     1COL ,I4,6X,4HN = ,I4,33H(NO OF NON-ZERO WTS) COL LENGTH =,I4)     00766500\n 1030 FORMAT(1H0,24X,64HALL COMPUTATIONS ARE BASED ON OBSERVATIONS WITH 00766600\n     1NON-ZERO WEIGHTS )                                                00766700\n 1040 FORMAT(1H0\/15X,28HFREQUENCY DISTRIBUTION (1-6),7X,10I6)           00766800\n 1050 FORMAT(1H0\/5X, 26HMEASURES OF LOCATION (2-2),34X,28HMEASURES OF DI00766900\n     1SPERSION (2-6))                                                   00767000\n 1060 FORMAT(1H0,                                                       00767100\n     1 9X,26HUNWEIGHTED MEAN          =,   1PE15.7,20X,                 00767200\n     2    26HSTANDARD DEVIATION       =,     E15.7    \/                 00767300\n     310X,26HWEIGHTED MEAN            =,     E15.7,20X,                 00767400\n     4    26HS.D. OF MEAN             =,     E15.7    \/                 00767500\n     510X,26HMEDIAN                   =,     E15.7,20X                  00767600\n     6    26HRANGE                    =,     E15.7    \/                 00767700\n     710X,26HMID-RANGE                =,     E15.7,20X,                 00767800\n     8    26HMEAN DEVIATION           =,     E15.7    \/                 00767900\n     910X,26H5 PCT UNWTD TRIMMED MEAN =,     E15.7,20X                  00768000\n     A    26HVARIANCE                 =,     E15.7    \/                 00768100\n     B10X,26H5 PCT WTD TRIMMED MEAN   =,      E15.7,20X                 00768200\n     C    26HCOEFFICIENT OF VARIATION =,     E15.7    )                 00768300\n 1070 FORMAT (1H0\/\/                                                     00768400\n     120X,50HA TWO-SIDED 95 PCT CONFIDENCE INTERVAL FOR MEAN IS 1PE11.4,00768500\n     2 3H TO,E11.4, 6H (2-2)\/                                           00768600\n     320X,50HA TWO-SIDED 95 PCT CONFIDENCE INTERVAL FOR S.D. IS, E11.4, 00768700\n     4 3H TO,E11.4, 6H (2-7))                                           00768800\n 1080 FORMAT                                                            00768900\n     1(1H0\/\/5X,30HLINEAR TREND STATISTICS (5-1) ,30X,16HOTHER STATISTICS00769000\n     2\/\/10X,5HSLOPE,20X,1H=,1PE15.7,20X,7HMINIMUM,18X,1H=,E15.7\/        00769100\n     3  10X,13HS.D. OF SLOPE,12X,1H=,E15.7,20X,7HMAXIMUM,18X,1H=,E15.7\/ 00769200\n     4 10X,26HSLOPE\/S.D. OF SLOPE = T  =,E15.7,20X,8HBETA ONE,17X,1H=,  00769300\n     5 E15.7\/10X,35HPROB EXCEEDING ABS VALUE OF OBS T =,0PF6.3,20X,     00769400\n     6 8HBETA TWO,17X,1H=,1PE15.7\/71X,17HWTD SUM OF VALUES,8X,1H=,E15.7\/00769500\n     7  71X,18HWTD SUM OF SQUARES,7X,1H=,E15.7\/5X,24HTESTS FOR NON-RANDO00769600\n     8MNESS,42X,26HWTD SUM OF DEVS SQUARED  =,E15.7\/71X,11HSTUDENT\"S T, 00769700\n     9 14X,1H=,E15.7)                                                   00769800\n 1090 FORMAT( 10X, 26HNO OF RUNS UP AND DOWN   =,I5\/10X,26HEXPECTED NO O00769900\n     1F RUNS      = ,F7.1\/10X,26HS.D. OF NO OF RUNS       =,F8.2\/10X    00770000\n     2  26HMEAN SQ SUCCESSIVE DIFF  =,1PE16.7\/10X,26HMEAN SQ SUCC DIFF\/V00770100\n     3AR    =,0PF9.3\/\/\/10X,24HDEVIATIONS FROM WTD MEAN\/\/15X,21HNO OF + S00770200\n     4IGNS       =,I5\/15X,21HNO OF - SIGNS       =I5\/15X,10HNO OF RUNS, 00770300\n     5 10X,1H=,I5\/15X,21HEXPECTED NO OF RUNS =,F7.1\/15X,12HS.D. OF RUNS,00770400\n     6 8X,1H=,F8.2\/15X,21HDIFF.\/S.D. OF RUNS  =F9.3)                    00770500\n 1100 FORMAT(\/\/\/\/\/68H NOTE - ITEMS IN PARENTHESES REFER TO PAGE NUMBER I00770600\n     1N NBS HANDBOOK 91)                                                00770700\n 1110 FORMAT(\/\/   27X,12HOBSERVATIONS,47X,20HORDERED OBSERVATIONS)      00770800\n 1120 FORMAT(1H0,8X,1HI,9X, 4HX(I),9X,4HRANK,7X,  9HX(I)-MEAN,7X,4HW(I) 00770900\n     1, 16X, 3HNO.,8X,4HX(J), 10X, 11HX(J+1)-X(J))                      00771000\n 1130 FORMAT(1H0,8X,1HI, 9X, 4HX(I),9X,4HRANK,7X,  9HX(I)-MEAN,27X,     00771100\n     1  3HNO.,8X, 4HX(J), 10X, 11HX(J+1)-X(J))                          00771200\n 1140 FORMAT(I10,1PE17.7,0PF9.1,1PE17.7,22X,I6,1P2E17.7)                00771300\n 1150 FORMAT(I10,1PE17.7,0PF9.1,1PE17.7,1PE12.3,10X,I6,1P2E17.7)        00771400\n 1160 FORMAT(1H )                                                       00771500\n      END                                                               00771600\nC  96  54      SUBROUTINE STMT( NSTMT )            2 19 68              00771700\n      SUBROUTINE STMT( NSTMT )                                          00771800\n      COMMON \/ BLOCKA\/MODE,M,KARD(83),KARG,ARG,ARG2,NEWCD(80),KRDEND    00771900\nC                                                                       00772000\nC     THIS SUBROUTINE ASSEMBLES AND CHECKS A STATEMENT NUMBER.          00772100\nC                                                                       00772200\nC     CALLED BY..  .MAIN.                                               00772300\nC                                                                       00772400\n      MISC=10*KARD(M)                                                   00772500\n  10  M=M+1                                                             00772600\n      K=KARD(M)                                                         00772700\n      IF(K.GE.10)GO TO 30                                               00772800\n      MISC=10*(MISC+K)                                                  00772900\n      IF(MISC.LT.10000)GO TO 10                                         00773000\nC                                                                       00773100\nC     ILLEGAL STATEMENT NUMBER EXIT                                     00773200\nC                                                                       00773300\n  20  KARG=1                                                            00773400\n      RETURN                                                            00773500\nC                                                                       00773600\nC     NON-NUMERIC FOUND, IS IT A .                                      00773700\nC                                                                       00773800\n  30  IF(K.EQ.37)GO TO 50                                               00773900\nC                                                                       00774000\nC     IS IT A \/                                                         00774100\nC                                                                       00774200\n  40  IF(K.EQ.36)GO TO 70                                               00774300\nC                                                                       00774400\nC     IS IT A SPACE                                                     00774500\nC                                                                       00774600\n      IF(K-44)20,60,20                                                  00774700\nC                                                                       00774800\nC     . FOUND, MUST BE FOLLOWED BY ONE AND ONLY ONE NUMERAL             00774900\nC                                                                       00775000\n  50  M=M+1                                                             00775100\n      K=KARD(M)                                                         00775200\n      IF(K.GE.10)GO TO 20                                               00775300\n      MISC=MISC+K                                                       00775400\n  60  M=M+1                                                             00775500\n      K=KARD(M)                                                         00775600\n      GO TO 40                                                          00775700\n  70  M=M+1                                                             00775800\n      K=KARD(M)                                                         00775900\nC                                                                       00776000\nC     \/ FOUND, MUST BE FOLLOWED BY BLANKS THEN\/OR A LETTER              00776100\nC                                                                       00776200\n      IF(K.EQ.44)GO TO 70                                               00776300\n      IF(K.GE.36.OR.K.LT.10)GO TO 20                                    00776400\nC                                                                       00776500\nC     LEGAL STATEMENT NUMBER FOUND                                      00776600\nC                                                                       00776700\n      NSTMT=MISC                                                        00776800\n      KARG=0                                                            00776900\n      RETURN                                                            00777000\n      END                                                               00777100\nC  97  78      SUBROUTINE STORE( J )               2 19 68              00777200\n      SUBROUTINE STORE( J )                                             00777300\n      COMMON \/ BLOCKA\/MODE,M,KARD(83),KARG,ARG,ARG2,NEWCD(80),KRDEND    00777400\n      COMMON \/BLOCKB\/NSTMT,NSTMTX,NSTMTH,NCOM,LCOM,IOVFL,COM(2000)      00777500\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00777600\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00777700\n      DIMENSION ARGS(100)                                               00777800\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00777900\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00778000\nC         STORAGE LAYOUT..          STATEMENT NUMBER                    00778100\nC                                   NUMBER OF WORDS IN ENTRY            00778200\nC                                   NARGS+64*(L1+64*L2)                 00778300\nC     ALL ITEMS ARE STORED IN       (   ENTRY 1    )                    00778400\nC     FLOATING POINT TO ALLOW       (         2    )                    00778500\nC     CONVERSION TO DOUBLE-              .....                          00778600\nC     PRECISION.                    ( LAST WORD    )                    00778700\nC                                                                       00778800\n      IF(IOVFL .NE. 0 ) RETURN                                          00778900\n      IZE = J + 2                                                       00779000\n      IF( NSTMT .GT. NSTMTH ) GO TO 80                                  00779100\nC                                                                       00779200\nC         STATEMENT IS AN INSERTION OR A REPLACEMENT                    00779300\nC                                                                       00779400\n      L = NSTMT                                                         00779500\n      L = LOCATE( L )                                                   00779600\n      IF( L .GT. 0 ) GO TO 30                                           00779700\nC                                                                       00779800\n      L = -L                                                            00779900\n      IDIF = IZE                                                        00780000\n   10 LL = NCOM                                                         00780100\nC         STATEMENT IS AN INSERTION, OPEN GAP                           00780200\n      II = LL + IDIF                                                    00780300\n      IF( II .GE. LCOM ) GO TO 90                                       00780400\n      DO 20 I = L, NCOM                                                 00780500\n      COM( II ) = COM( LL )                                             00780600\n      II = II - 1                                                       00780700\n   20 LL = LL - 1                                                       00780800\n      GO TO 60                                                          00780900\nC                                                                       00781000\nC         STATEMENT IS REPLACEMENT                                      00781100\nC                                                                       00781200\n   30 IDIF = IZE - IFIX( COM( L+1 ) )                                   00781300\n      IF( IDIF ) 40, 60, 10                                             00781400\nC                                                                       00781500\nC         NEW STATEMENT SMALLER THAN OLD, CLOSE UP GAP.                 00781600\nC                                                                       00781700\n   40 I = L - IDIF                                                      00781800\n      II = L                                                            00781900\n      DO 50 JJ= I, NCOM                                                 00782000\n      COM( II ) = COM( JJ)                                              00782100\n   50 II = II + 1                                                       00782200\nC                                                                       00782300\nC         INSERT STATEMENT                                              00782400\nC                                                                       00782500\n   60 COM( L ) = NSTMT                                                  00782600\n      COM( L+1 ) = IZE                                                  00782700\n      COM( L+2 ) = NARGS + 64 * ( L1 + 64 * L2 )                        00782800\n      NCOM = NCOM + IDIF                                                00782900\n      IF( IZE .EQ. 3 ) GO TO 75                                         00783000\n      DO 70 I = 4, IZE                                                  00783100\n      COM( L+3 ) = ARGTAB( I-3 )                                        00783200\n   70 L = L + 1                                                         00783300\n   75 CONTINUE                                                          00783400\n      RETURN                                                            00783500\nC                                                                       00783600\nC         PUT STATEMENT ON END                                          00783700\nC                                                                       00783800\n   80 L = NCOM                                                          00783900\n      IDIF = IZE                                                        00784000\n      NSTMTX = NSTMTH                                                   00784100\n      NSTMTH = NSTMT                                                    00784200\n      IF( NCOM + IDIF .LT. LCOM ) GO TO 60                              00784300\nC                                                                       00784400\nC         COM STORAGE OVERFLOW                                          00784500\nC                                                                       00784600\n   90 IOVFL = 1                                                         00784700\n      CALL ERROR( 12 )                                                  00784800\n      RETURN                                                            00784900\n      END                                                               00785000\nC  98  26      SUBROUTINE STRUVE                   2 19 68              00785100\n      SUBROUTINE STRUVE (Z,A,B)                                         00785200\n      DOUBLE PRECISION Z,A,B,C,X,P,Q,R,S                                00785300\n      COMMON \/RJN\/C(100),X                                              00785400\n      X=DABS(Z)                                                         00785500\n      IF (X.GT.70.) GO TO 2                                             00785600\n      CALL BEJN                                                         00785700\n      P=.0D0                                                            00785800\n      Q=.0D0                                                            00785900\n      DO 1 N=1,49                                                       00786000\n      J=2*N                                                             00786100\n      K=J+1                                                             00786200\n      R=J-1                                                             00786300\n      S=4*N**2-1                                                        00786400\n      P=P+C(J)\/R                                                        00786500\n    1 Q=Q+C(K)\/S                                                        00786600\n      A=P\/.78539816339D0                                                00786700\n      B=(2.D0*Q+1.D0-C(1))\/1.5707963268D0                               00786800\n      GO TO 3                                                           00786900\n    2 S=1.D0\/X**2                                                       00787000\n      P=1.D0-S*(1.D0-9.D0*S*(1.D0-25.D0*S*(1.D0-49.D0*S)))              00787100\n      A=DBEY(X,0)+P\/(X*1.5707963268D0)                                  00787200\n      Q=1.D0+S*(1.D0-3.D0*S*(1.D0-15.D0*S*(1.D0-35.D0*S)))              00787300\n      B=DBEY(X,1)+Q\/(  1.5707963268D0)                                  00787400\n    3 RETURN                                                            00787500\n      END                                                               00787600\nC  99 172      SUBROUTINE TRANSF                   2 19 68              00787700\n      SUBROUTINE TRANSF                                                 00787800\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00787900\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00788000\n      DIMENSION ARGS(100)                                               00788100\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00788200\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00788300\nC *****                                                                 00788400\nC     SUBROUTINE TO PROVIDE TRANSFORMATIONS  B=UAU(T) AND  C=U(I)AU     00788500\nC     L2=1    TRANSFORMATION  B=UAU(T)                                  00788600\nC             GENERAL FORMS OF  TRANSFORM                               00788700\nC                TRANSFORM   A(,) R=N   R=M ROWS OF U (,) STORE IN C(,) 00788800\nC                M(XAXT)     A(,) K,K   U(,)  N,K         STORE IN C(,) 00788900\nC                M(XAXT)     A(,) K     U(,)  N,K         STORE IN C(,) 00789000\nC     L2=2    BACK TRANSFORMATION  C=U(T)ALL                            00789100\nC             GENERAL FORMS OF BACKTRANS                                00789200\nC                BACKTRANS   A(,) R=N  R=M ROWS OF U(T)(,) STORE IN C(,)00789300\nC                M(XTAX)     A(,) N,N   U(,)  N,K          STORE IN C(,)00789400\nC                M(XTAX)     A(,) N     U(,)  N,K          STORE IN C(,)00789500\nC *****                                                                 00789600\n      COMMON \/ SCRAT \/ X,NS                                             00789700\n      DIMENSION A(10000)                                                00789800\n      DOUBLE PRECISION X(5000), SUM                                     00789900\n      DIMENSION  IR(4),ISAVE(2)                                         00790000\n      EQUIVALENCE (IR,ISAVE)                                            00790100\n      COMMON \/MULTC\/NS2                                                 00790200\nC *****                                                                 00790300\nC     CHECK TO SEE IF WE HAVE CORRECT NUMBER OF ARGUMENTS               00790400\nC *****                                                                 00790500\n      IF(NARGS.GT.10.OR.NARGS.LT.8) CALL ERROR(10)                      00790600\nC *****                                                                 00790700\nC     CHECK TO SEE IF ALL ARGUMENTS ARE INTEGERS                        00790800\nC *****                                                                 00790900\n      J=NARGS                                                           00791000\n      CALL CKIND(J)                                                     00791100\n      IF(J.NE.0) CALL  ERROR(3)                                         00791200\nC *****                                                                 00791300\nC     CHECK TO SEE IF DIMENSIONS ARE CORRECT                            00791400\nC *****                                                                 00791500\n      IF(NARGS.EQ.8) GO TO 230                                          00791600\n      IF(NARGS.EQ.10) GO TO (200,  220  ),L2                            00791700\n      GO TO (160,180),L2                                                00791800\n 160  IF(IARGS(3).NE.IARGS(7)) CALL ERROR(3)                            00791900\n      GO TO 230                                                         00792000\n 180  IF(IARGS(3).NE.IARGS(6)) CALL ERROR(3)                            00792100\n      GO TO 230                                                         00792200\n 200  IF(IARGS(3).NE.IARGS(4).OR.IARGS(3).NE.IARGS(8)) CALL ERROR(3)    00792300\n      GO TO 230                                                         00792400\n  220 IF(IARGS(3).NE.IARGS(4).OR.IARGS(3).NE.IARGS(7)) CALL ERROR(3)    00792500\nC *****                                                                 00792600\nC     CHECK TO SEE IF DIMENSIONS ARE OUT OF RANGE                       00792700\nC *****                                                                 00792800\n  230 IR(1)=IARGS(1)                                                    00792900\n      IR(2)=IARGS(2)                                                    00793000\n      IR(3)=IARGS(3)                                                    00793100\n      IR(4)=IARGS(3)                                                    00793200\n      CALL MACHK(IR,J)                                                  00793300\n      IF(J.NE.0) CALL ERROR(17)                                         00793400\n      IF(NARGS.EQ.9) GO TO 300                                          00793500\n      IR(1)=IARGS(5)                                                    00793600\n      IR(2)=IARGS(6)                                                    00793700\n      IF(NARGS.EQ.10) GO TO 280                                         00793800\n      GO TO (240 , 260 ),L2                                             00793900\n 240  IR(3)=IARGS(4)                                                    00794000\n      IR(4)=IARGS(3)                                                    00794100\n      GO TO 340                                                         00794200\n 260  IR(3)=IARGS(3)                                                    00794300\n      IR(4)=IARGS(4)                                                    00794400\n      GO TO 340                                                         00794500\n 280  IR(3)=IARGS(7)                                                    00794600\n      IR(4)=IARGS(8)                                                    00794700\n      GO TO 340                                                         00794800\n 300  DO 320    I=1,4                                                   00794900\n 320  IR(I)=IARGS(I+3)                                                  00795000\n 340  CALL MACHK(IR,J)                                                  00795100\n      IF(J.NE.0) CALL ERROR(17)                                         00795200\n      IR(1)=IARGS(NARGS-1)                                              00795300\n      IR(2)=IARGS(NARGS)                                                00795400\n      IF(NARGS.EQ.8) GO TO 420                                          00795500\n      GO TO (360, 380),L2                                               00795600\n 360  IJ=7                                                              00795700\n      GO TO 400                                                         00795800\n 380  IJ=8                                                              00795900\n  400 IF(NARGS.EQ.9) GO TO 410                                          00796000\n      IR(3)=IARGS(IJ)                                                   00796100\n      IR(4)=IARGS(IJ)                                                   00796200\n      GO TO 440                                                         00796300\n  410 IR(3)=IARGS(IJ-1)                                                 00796400\n      IR(4)=IARGS(IJ-1)                                                 00796500\n      GO TO 440                                                         00796600\n 420  IR(3)=IARGS(4)                                                    00796700\n      IR(4)=IARGS(4)                                                    00796800\n 440  CALL MACHK(IR,J)                                                  00796900\n      IF(J.NE.0)  CALL ERROR(17)                                        00797000\nC *****                                                                 00797100\nC     CHECK FOR PREVIOUS ERRORS                                         00797200\nC *****                                                                 00797300\n      IF(NERROR.NE.0) RETURN                                            00797400\nC *****                                                                 00797500\nC     FIND ADDRESSES OF COLUMNS                                         00797600\nC *****                                                                 00797700\n      NP=NARGS                                                          00797800\n      ISAVE(1)=IARGS(1)                                                 00797900\n      ISAVE(2)=IARGS(3)                                                 00798000\n      IARGS(1)=IARGS(2)                                                 00798100\n      IF(NARGS.EQ.9) GO TO 460                                          00798200\n      IARGS(2)=IARGS(6)                                                 00798300\n      GO TO 480                                                         00798400\n 460  IARGS(2)=IARGS(5)                                                 00798500\n 480  IARGS(3)=IARGS(NARGS)                                             00798600\n      NARGS=3                                                           00798700\n      CALL CHKCOL(J)                                                    00798800\n      IARGS(1)=IARGS(1)+ISAVE(1)-1                                      00798900\n      IF(NP.EQ.9) GO TO 500                                             00799000\n      IARGS(2)=IARGS(2)+IARGS(5)-1                                      00799100\n      GO TO 520                                                         00799200\n 500  IARGS(2)=IARGS(2)+IARGS(4)-1                                      00799300\n 520  IARGS(3)=IARGS(3)+IARGS(NP-1)-1                                   00799400\n      NS2=NS\/2                                                          00799500\n      IROWA=ISAVE(2)                                                    00799600\n      ISP=1                                                             00799700\n      IF(NP.EQ.8) GO TO 560                                             00799800\n      IF(NP.EQ.10) GO TO 540                                            00799900\n      IROWU=IARGS(L2+5)                                                 00800000\n      GO TO 580                                                         00800100\n 540  IROWU=IARGS(L2+6)                                                 00800200\n      GO TO 580                                                         00800300\n 560  IROWU=IARGS(4)                                                    00800400\n 580  GO TO (600 ,620),L2                                               00800500\n 600  IADD1=1                                                           00800600\n      IADD2=NROW                                                        00800700\n      GO TO 640                                                         00800800\n 620  IADD1=NROW                                                        00800900\n      IADD2=1                                                           00801000\n 640  DO  720     J=1,IROWU                                             00801100\n      DO  700     I=1,IROWU                                             00801200\n      IUP=IARGS(2)+(I-1)*IADD1                                          00801300\n      IA=IARGS(1)                                                       00801400\n      IUT=IARGS(2)+(J-1)*IADD1                                          00801500\n      ISX=NS2                                                           00801600\n      DO   680    L=1,IROWA                                             00801700\n      IU=IUP                                                            00801800\n      DO   660    K=1,IROWA                                             00801900\n      X(ISX)=RC(IU)*RC(IA)*RC(IUT)                                      00802000\n      ISX=ISX-1                                                         00802100\n      IU=IU+IADD2                                                       00802200\n      IA=IA+1                                                           00802300\n 660  CONTINUE                                                          00802400\n      IA=IA+NROW-IROWA                                                  00802500\n      IUT=IUT+IADD2                                                     00802600\n 680  CONTINUE                                                          00802700\n      CALL SORTSM (IROWA*IROWA,SUM)                                     00802800\n      A(ISP)=SUM                                                        00802900\n      ISP=ISP+1                                                         00803000\n  700 CONTINUE                                                          00803100\n      IC=IC+NROW-IROWU                                                  00803200\n  720 CONTINUE                                                          00803300\nC *****                                                                 00803400\nC     STORE RESULTS IN WORKSHEET                                        00803500\nC *****                                                                 00803600\n      IS=1                                                              00803700\n      IC=IARGS(3)                                                       00803800\n      DO 820 J=1,IROWU                                                  00803900\n      DO 800 I=1,IROWU                                                  00804000\n      RC(IC)=A(IS)                                                      00804100\n      IS=IS+1                                                           00804200\n      IC=IC+1                                                           00804300\n  800 CONTINUE                                                          00804400\n      IC=IC+NROW-IROWU                                                  00804500\n  820 CONTINUE                                                          00804600\n      RETURN                                                            00804700\n      END                                                               00804800\nC 100  21      SUBROUTINE VARCON(NAME)             2 19 68              00804900\n      SUBROUTINE VARCON(NAME)                                           00805000\n      COMMON \/ BLOCKA\/MODE,M,KARD(83),KARG,ARG,ARG2,NEWCD(80),KRDEND    00805100\n      DIMENSION NAME(2),N(14)                                           00805200\n      DATA N(1),N(2),N(3),N(4),N(5),N(6),N(7),N(8),N(9),N(10),N(11),    00805300\n     1 N(12),N(13),N(14)\/10705,2604,16038,16767,17496,18225,18954,1377, 00805400\n     2 15001,5*0\/                                                       00805500\nC                                                                       00805600\nC      LOOKUP NAME IN VARIABLE-NAME TABLE                               00805700\nC                                                                       00805800\nC        NAMES IN TABLE                                                 00805900\nC                                                                       00806000\nC             NRMAX,COLTOP,V,W,X,Y,Z                                    00806100\nC                                                                       00806200\n      DO 10 IM=1,7                                                      00806300\n      I = IM                                                            00806400\n      IF(NAME(1).EQ.N(I).AND.NAME(2).EQ.N(I+7))GO TO 20                 00806500\n  10  CONTINUE                                                          00806600\n      I=0                                                               00806700\n  20  ARG=I                                                             00806800\n      RETURN                                                            00806900\n      END                                                               00807000\nC 101  14      SUBROUTINE VECTOR( A, J )           2 19 68              00807100\n      SUBROUTINE VECTOR( A, J )                                         00807200\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00807300\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00807400\n      DIMENSION ARGS(100)                                               00807500\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00807600\nC                                                                       00807700\nC        VECTORIZE A IN TO COLUMN STARTING AT J                         00807800\nC                                                                       00807900\n      IF( NRMAX .EQ. 0 ) GO TO 20                                       00808000\n      K = J + NRMAX - 1                                                 00808100\n      DO 10 I = J, K                                                    00808200\n  10  RC( I ) = A                                                       00808300\n  20  RETURN                                                            00808400\n      END                                                               00808500\nC 102   6      SUBROUTINE X(S)                     2 19 68              00808600\n      SUBROUTINE X(S)                                                   00808700\n      PRINT 10, S                                                       00808800\n   10 FORMAT(A6)                                                        00808900\n      RETURN                                                            00809000\n      END                                                               00809100\nC 103 346      SUBROUTINE XECUTE                   2 19 68              00809200\n      SUBROUTINE XECUTE                                                 00809300\n      COMMON \/ FLAGS \/ NSUMRY, LLIST                                    00809400\n      COMMON \/ BLOCKA\/MODE,M,KARD(83),KARG,ARG,ARG2,NEWCD(80),KRDEND    00809500\n      COMMON \/BLOCKB\/NSTMT,NSTMTX,NSTMTH,NCOM,LCOM,IOVFL,COM(2000)      00809600\n      COMMON \/BLOCKC\/KIO,INUNIT,ISCRAT,KBDOUT,KRDKNT                    00809700\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00809800\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00809900\n      DIMENSION ARGS(100)                                               00810000\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00810100\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00810200\n      COMMON \/ BLOCKX \/ INDEX( 6, 8 ), LEVEL                            00810300\n   90 IF ( L1 .LE. 30 ) GO TO                                           00810400\n     1(100, 200, 200, 400, 500, 200, 700, 800, 900, 1000, 1100,         00810500\n     2 1200, 1300, 1400, 1500, 1600, 1700, 1800, 1900, 2000, 2100, 2200,00810600\n     3 2300, 2400, 2500, 2600, 2700, 2800, 2900, 3000 ), L1             00810700\n      CALL GOJOB                                                        00810800\n      GO TO 9000                                                        00810900\n  100 CALL RESET                                                        00811000\n      GO TO 9000                                                        00811100\n  200 CALL PRINTX                                                       00811200\n      GO TO 9000                                                        00811300\n  400 IF( L2 .NE. 1 ) GO TO 402                                         00811400\n  401 NSUMRY = 0                                                        00811500\n      GO TO 9000                                                        00811600\nC                                                                       00811700\nC      NO LIST   OR  NOLIST                                             00811800\nC                                                                       00811900\nC      LIST  (WITH NO ARGUMENT)  = LIST 3                               00812000\nC      LIST 0 = NO LISTING          LIST 1 = LIST ONLY INFORMATIVE DIAGS00812100\nC      LIST 2 = LIST ONLY ARITH ERR LIST 3 = LIST BOTH TYPES OF ERRORS  00812200\nC                                                                       00812300\nC      IF A FATAL ERROR OCCURS, LLIST IS SET TO AND KEPT AT 3           00812400\nC                                                                       00812500\n  402 IARGS(1) = 0                                                      00812600\n  404 IF( NERROR .EQ. 0 ) LLIST = IARGS( 1 )                            00812700\n      WRITE( ISCRAT, 406 ) IARGS( 1 )                                   00812800\n  406 FORMAT(1H,,I1,82X)                                                00812900\n      GO TO 9000                                                        00813000\nC                                                                       00813100\nC      LIST                                                             00813200\nC                                                                       00813300\n  410 IF( NARGS .EQ. 0 .OR. IARGS(1) .LT. 0 .OR. IARGS(1).GT.3)         00813400\n     1 IARGS(1) = 3                                                     00813500\n      GO TO 404                                                         00813600\n  500 CALL READX                                                        00813700\n      GO TO 9000                                                        00813800\n  700 CALL DUMMY                                                        00813900\n      GO TO 9000                                                        00814000\n  800 CALL MXTX                                                         00814100\n      GO TO 9000                                                        00814200\n  900 CALL APRINT                                                       00814300\n      GO TO 9000                                                        00814400\n 1000 GO TO 9000                                                        00814500\n 1100 CALL ARITH                                                        00814600\n      GO TO 9000                                                        00814700\n1200  CALL FUNCT                                                        00814800\n      GO TO 9000                                                        00814900\n 1300 GO TO ( 1301,1302,1303,1304,1305, 401,1307,1308,1309,1310,1312,   00815000\n     1 1312,1313,1305), L2                                              00815100\n 1301 CALL GENER                                                        00815200\n      GO TO 9000                                                        00815300\n 1302 CALL SET                                                          00815400\n      GO TO 9000                                                        00815500\n 1303 CONTINUE                                                          00815600\n 1304 CALL FIXFLO                                                       00815700\n      GO TO 9000                                                        00815800\n 1305 CALL PLOT                                                         00815900\n      GO TO 9000                                                        00816000\n 1307 NSUMRY = 1                                                        00816100\n      GO TO 9000                                                        00816200\n 1308 CALL PAGE( 4 )                                                    00816300\n      GO TO 9000                                                        00816400\n 1309 CALL SPACE                                                        00816500\n      GO TO 9000                                                        00816600\n 1310 CALL PHYCON( 0 )                                                  00816700\n      GO TO 9000                                                        00816800\n 1312 CALL PHYCON( -1 )                                                 00816900\n      GO TO 9000                                                        00817000\n 1313 CALL PAGEX                                                        00817100\n      GO TO 9000                                                        00817200\n 1400 IF( L2 .GT. 2 ) GO TO 1410                                        00817300\n      CALL BEGIN                                                        00817400\n      GO TO 9000                                                        00817500\n 1410 IF( L2 .LE. 5 ) GO TO 13000                                       00817600\n      IF( L2 .LE. 8 ) GO TO 14000                                       00817700\n      CALL IFS                                                          00817800\n      GO TO 9000                                                        00817900\n 1500 CALL MOP                                                          00818000\n      GO TO 9000                                                        00818100\n 1600 CALL INVERT                                                       00818200\n      GO TO 9000                                                        00818300\n 1700 IF( L2 .EQ. 2 ) GO TO 1720                                        00818400\n      CALL MMULT                                                        00818500\n      GO TO 9000                                                        00818600\n 1720 CALL MRAISE                                                       00818700\n      GO TO 9000                                                        00818800\n 1800 CALL MATRIX                                                       00818900\n      GO TO 9000                                                        00819000\n 1900 CALL ALLSUB                                                       00819100\n      GO TO 9000                                                        00819200\n 2000 CALL MSCROW                                                       00819300\n      GO TO 9000                                                        00819400\n 2100 GO TO ( 2101, 2101, 2103, 2104, 2104, 2104, 2104, 2108, 2108,     00819500\n     1 2110, 2111, 2112, 2113,2108,410 , 402, 9000), L2                 00819600\n 2101 CALL PROROW                                                       00819700\n      GO TO 9000                                                        00819800\n 2103 CALL DEFINE                                                       00819900\n      GO TO 9000                                                        00820000\n 2104 CALL EXTREM                                                       00820100\n      GO TO 9000                                                        00820200\n 2108 CALL SORDER                                                       00820300\n      GO TO 9000                                                        00820400\n 2110 CALL ERASE                                                        00820500\n      GO TO 9000                                                        00820600\n 2111 CALL EXCHNG                                                       00820700\n      GO TO 9000                                                        00820800\n 2112 CALL FLIP                                                         00820900\n      GO TO 9000                                                        00821000\n 2113 CALL CHANGE                                                       00821100\n      GO TO 9000                                                        00821200\n 2200 CALL ORTHO                                                        00821300\n      GO TO 9000                                                        00821400\n2300  GO TO ( 2310, 2310, 2310, 2310, 2310, 2320, 2320,2320, 2320, 2330,00821500\n     1 2330, 2340, 2350, 2350 ), L2                                     00821600\n2310  CALL MISC2                                                        00821700\n      GO TO 9000                                                        00821800\n2320  CALL MOVE                                                         00821900\n      GO TO 9000                                                        00822000\n2330  CALL PDMOTE                                                       00822100\n      GO TO 9000                                                        00822200\n2340  CALL DIMENS                                                       00822300\n      GO TO 9000                                                        00822400\n2350  CALL SEPINS                                                       00822500\n      GO TO 9000                                                        00822600\n 2400 GO TO ( 2410, 2410, 2430, 2440, 2450 ), L2                        00822700\n 2410 CALL STATIS                                                       00822800\n      GO TO 9000                                                        00822900\n 2430 CALL ERROR( 0 )                                                   00823000\n      GO TO 9000                                                        00823100\n 2440 CALL ERROR( -1 )                                                  00823200\n      GO TO 9000                                                        00823300\n 2450 CALL FPROB                                                        00823400\n      GO TO 9000                                                        00823500\n 2500 CALL SELECT                                                       00823600\n      GO TO 9000                                                        00823700\n 2600 CONTINUE                                                          00823800\n      CALL YATES                                                        00823900\n      GO TO 9000                                                        00824000\n 2700 CONTINUE                                                          00824100\n      CALL EXPCON                                                       00824200\n 2800 CONTINUE                                                          00824300\n 2900 CONTINUE                                                          00824400\n 3000 CONTINUE                                                          00824500\n 9000 CALL AERR( 0 )                                                    00824600\n 9009 IF( LEVEL .GT. 0 ) GO TO 13130                                    00824700\n      RETURN                                                            00824800\nC         THIS IS WHERE THE REPEAT = EXECUTE = PERFORM COMMAND IS       00824900\nC         EXECUTED.  NESTED PERFORMS UP TO EIGHT LEVELS ARE ALLOWED.    00825000\nC         CURRENT LEVEL IS STORED IN  -LEVEL- .                         00825100\nC                                                                       00825200\nC     INDEX( 1, LEVEL ) CONTAINS LOCATION OF COMMAND AT ARG1 (FIRST)    00825300\nC     INDEX( 2, LEVEL ) CONTAINS RUNNING INDEX FROM ARG 1 TO ARG 2      00825400\nC     INDEX( 3, LEVEL ) CONTAINS LOCATION OF COMMAND AT ARG2 (LAST)     00825500\nC     INDEX( 4, LEVEL ) CONTAINS THIRD ARG ( REPEAT COUNT )             00825600\nC     INDEX( 5, LEVEL ) CONTAINS CURRENT LEVEL COUNTER (1 TO ARG 3)     00825700\nC     INDEX( 6, LEVEL ) CONTAINS STATEMENT NUMBER OF STATEMENT CURRENTLY00825800\nC                  BEING EXECUTED.                                      00825900\nC                                                                       00826000\n13000 IF( NARGS - 3 ) 13002, 13010, 13008                               00826100\n13002 IF( NARGS - 1 ) 13008, 13004, 13006                               00826200\nC                                                                       00826300\nC     SECOND ARG MISSING, MAKE SAME AS FIRST ARG                        00826400\nC                                                                       00826500\n13004 IARGS( 2 ) = IARGS( 1 )                                           00826600\n      KIND( 2 ) = KIND( 1 )                                             00826700\nC                                                                       00826800\nC     THIRD ARG MISSING, SET TO INTEGER 1                               00826900\nC                                                                       00827000\n13006 IARGS( 3 ) = 1                                                    00827100\n      KIND( 3 ) = 0                                                     00827200\n      GO TO 13020                                                       00827300\n13008 CALL ERROR( 10 )                                                  00827400\n      GO TO 9000                                                        00827500\n13010 IF( KIND( 3 ) .EQ. 0 .AND. IARGS( 3 ) .GT. 0 ) GO TO 13020        00827600\n13015 CALL ERROR( 3 )                                                   00827700\n      GO TO 9000                                                        00827800\n13020 DO 13040 I = 1, 2                                                 00827900\n      IF( KIND( I ) .EQ. 0 ) GO TO 13030                                00828000\n      IARGS( I ) = 10. * ARGS( I ) + .5                                 00828100\n      GO TO 13035                                                       00828200\n13030 IARGS( I ) = 10 * IARGS( I )                                      00828300\n13035 IF( IARGS( I ) .GT. NSTMTH ) GO TO 13038                          00828400\n      IARGS( I ) = LOCATE( IARGS( I ))                                  00828500\n      IF( IARGS( I ) .GT. 0 ) GO TO 13040                               00828600\n13038 CALL ERROR ( 13 )                                                 00828700\n      GO TO 9000                                                        00828800\n13040 CONTINUE                                                          00828900\n13045 IF( LEVEL .LT. 8 ) GO TO 13050                                    00829000\n      CALL ERROR( 19 )                                                  00829100\n      GO TO 9000                                                        00829200\n13050 IF( NERROR .NE. 0 ) GO TO 9000                                    00829300\n      LEVEL = LEVEL + 1                                                 00829400\n      INDEX( 1, LEVEL ) = IARGS( 1 )                                    00829500\n      INDEX( 3, LEVEL ) = IARGS( 2 )                                    00829600\n      INDEX( 4, LEVEL ) = IARGS( 3 )                                    00829700\n      INDEX( 5, LEVEL ) = 0                                             00829800\nC         OUTER LOOP                                                    00829900\n13100 INDEX( 5, LEVEL ) = INDEX( 5, LEVEL ) + 1                         00830000\n      IF( INDEX( 5, LEVEL ) .LE. INDEX( 4, LEVEL ) ) GO TO 13110        00830100\nC         END OF OUTER LOOP, REDUCE LEVEL BY 1                          00830200\n      LEVEL = LEVEL - 1                                                 00830300\n      GO TO 9009                                                        00830400\nC         INNER LOOP                                                    00830500\n13110 INDEX( 2, LEVEL ) = INDEX( 1, LEVEL )                             00830600\n13130 I2 = INDEX( 2, LEVEL )                                            00830700\n      IF( I2 .GT. INDEX( 3, LEVEL ) ) GO TO 13100                       00830800\n      INDEX( 6, LEVEL ) = COM( I2)                                      00830900\n      K = COM( I2 + 1 )                                                 00831000\n      INDEX( 2, LEVEL ) = INDEX( 2, LEVEL ) + K                         00831100\n      L2 = COM( I2 + 2 )                                                00831200\n      L1 = L2 \/ 64                                                      00831300\n      NARGS = L2 - 64 * L1                                              00831400\n      L2 = L1 \/ 64                                                      00831500\n      L1 = L1 - 64 * L2                                                 00831600\n      CALL EXPAND( K - 2, COM( I2 + 3 ) )                               00831700\n      GO TO 90                                                          00831800\nC                                                                       00831900\nC     L2 = 6,7,8  INCREMENT, INDEX, RESTORE                             00832000\nC                                                                       00832100\n14000 IF( L2 - 7 ) 14010, 14500, 14020                                  00832200\nC                                                                       00832300\nC     INCREMENT, T = 1.    RESTORE, T = 0.                              00832400\nC                                                                       00832500\n14010 T = 1.                                                            00832600\n      GO TO 14030                                                       00832700\n14020 T = 0.                                                            00832800\n14030 IF( NARGS .GE. 2 ) GO TO 14040                                    00832900\n14035 K = 10                                                            00833000\n      GO TO 14410                                                       00833100\n14040 IF( KIND( 1 ) .EQ. 0 ) GO TO 14050                                00833200\n      J = 10. * ARGS( 1 ) + .5                                          00833300\n      GO TO 14053                                                       00833400\n14050 J = 10 * IARGS ( 1 )                                              00833500\n14053 IF( J .GT. NSTMTH ) GO TO 14056                                   00833600\n      J = LOCATE( J )                                                   00833700\nC     J HAS LOCATION OF COMMAND TO BE MODIFIED                          00833800\n      IF( J .GT. 0 ) GO TO 14060                                        00833900\n14056 K = 13                                                            00834000\n      GO TO 14410                                                       00834100\n14060 JJ = J + IFIX( COM( J+1 ) )                                       00834200\nC                                                                       00834300\nC     CHECK THAT COMMAND HAS THE PROPER NUMBER OF ARGUMENTS             00834400\nC                                                                       00834500\n      IF( NARGS - 1 .NE. MOD( IFIX( COM( J+2) ), 64 ))GO TO 14035       00834600\n      J = J + 3                                                         00834700\nC     SKIP OVER HEADER                                                  00834800\nC                                                                       00834900\nC     CHECK IF THIS COMMAND IS STORED. IF SO, PULL OUT INTO ARGTAB.     00835000\nC                                                                       00835100\n      IF (LEVEL .EQ. 0 ) GO TO 14100                                    00835200\n      K = 2 * NARGS                                                     00835300\n      DO 14070 I = 2, K                                                 00835400\n      ARGTAB( I ) = COM( I2+4 )                                         00835500\n14070 I2 = I2 + 1                                                       00835600\nC     I2 HAS LOCATION OF THIS COMMAND                                   00835700\n14100 I = 2 + KIND( 1 )                                                 00835800\n14200 IF( COM ( J ) ) 14280, 14210, 14260                               00835900\nC                                                                       00836000\nC     FLOATING POINT CONST.                                             00836100\nC                                                                       00836200\n14210 IF( ARGTAB( I ) ) 14212, 14220, 14400                             00836300\nC     INCR. FLT. PT. CONSTANT BY \"STATEMENT\"                            00836400\n14212 IF( ARGTAB( I ) .EQ. -1. ) GO TO 14400                            00836500\n      CALL XPND( ARGTAB(I) , K , Y , KND )                              00836600\n      IF( K .LT. 0 ) GO TO 14264                                        00836700\n      IF( KND .EQ. 0 ) GO TO 14400                                      00836800\n      COM( J+1 ) = T * COM( J+1 ) + Y                                   00836900\n14214 J = J + 2                                                         00837000\n14216 I = I + K + 1                                                     00837100\n      GO TO 14250                                                       00837200\n14220 COM( J+1 ) = T * COM( J+1 ) + ARGTAB( I+1 )                       00837300\n14230 J = J + 2                                                         00837400\n14240 I = I + 2                                                         00837500\n14250 IF( J - JJ ) 14200, 14420, 14420                                  00837600\nC                                                                       00837700\nC     COLUMN NUMBER                                                     00837800\nC                                                                       00837900\n14260 IF ( ARGTAB( I ) ) 14262,14400,14268                              00838000\nC                                                                       00838100\nC     INTEGER CONSTANT MODIFIED BY \"\" STATEMANT\"\"                       00838200\n14262 IF ( ARGTAB( I ) .EQ. -1. ) GO TO 14400                           00838300\n      CALL XPND( ARGTAB( I ) , K , Y,KND)                               00838400\n      IF ( K .GE. 0 ) IF ( KND ) 14400,14266,14400                      00838500\n14264 K = -K                                                            00838600\n      GO TO 14410                                                       00838700\n14266 COM( J ) = T * COM( J ) + Y                                       00838800\n      J=J+1                                                             00838900\n      GO TO 14216                                                       00839000\n14268 COM( J ) = T * ( COM( J ) - 8192. ) + ARGTAB( I )                 00839100\n      IF( COM( J ) ) 14390, 14390, 14270                                00839200\n14270 J = J + 1                                                         00839300\n      I = I + 1                                                         00839400\n      GO TO 14250                                                       00839500\nC                                                                       00839600\nC     VARIABLE *REFERENCE*                                              00839700\nC                                                                       00839800\nC     NRMAX, V, W, X, Y, Z CAN ONLY INCREMENT BY 0 OR 0.                00839900\nC     WHETHER 0 OR 0. INCREMENTS \"\"X\"\" OR\"X\" IS IMMATERIAL              00840000\nC                                                                       00840100\n14280 IF (COM( J ) .LT. -16. ) GO TO 14290                              00840200\n      IF ( COM( J ) .EQ. -1. ) GO TO 14430                              00840300\nC                                                                       00840400\nC                                                                       00840500\n      IF ( ABS( ARGTAB(  I ) ) + ABS( ARGTAB( I+1 ) ) .NE. 0. )         00840600\n     1       IF ( ARGTAB( I ) - 8192. ) 14400,14270,14400               00840700\n      J = J + 1                                                         00840800\n      GO TO 14240                                                       00840900\nC                                                                       00841000\nC     *ROW,COL*REFERENCE.                                               00841100\nC                                                                       00841200\n14290 IF( ARGTAB( I ) + 16. ) 14295, 14400, 14400                       00841300\n14295 COM( J ) = T * ( COM( J ) + 8208. ) + ARGTAB( I )                 00841400\n      IF( COM( J ) .GT. -16. ) GO TO 14400                              00841500\n      IF( COM( J+1 ) * ARGTAB( I+1 ) ) 14400, 14400, 14300              00841600\n14300 Y = T * ( ABS( COM( J+1 ) ) - 8192. ) + ABS( ARGTAB( I+1 ) )      00841700\n      IF ( Y ) 14400, 14400, 14310                                      00841800\n14310 COM( J+1 ) = SIGN( Y, COM( J+1 ) )                                00841900\n      GO TO 14230                                                       00842000\n14390 K = 18                                                            00842100\n      GO TO 14410                                                       00842200\n14400 K = 20                                                            00842300\n14410 CALL ERROR( K )                                                   00842400\n14420 GO TO 9000                                                        00842500\nC                                                                       00842600\nC     *** (=THRU) IGNORE. INCREM. OR RESTORE MAY OR MAY NOT             00842700\nC     HAVE CORRESPONDING ***                                            00842800\nC                                                                       00842900\n14430 IF ( ARGTAB( I ) .EQ. -1. ) I = I + 1                             00843000\n      J = J + 1                                                         00843100\n      GO TO 14250                                                       00843200\nC                                                                       00843300\nC     INDEX                                                             00843400\nC                                                                       00843500\n14500 CALL X( \"INDEX\" )                                                 00843600\n      GO TO 9000                                                        00843700\n      END                                                               00843800\nC 104  25      SUBROUTINE XFORMT                   2 19 68              00843900\n      SUBROUTINE XFORMT                                                 00844000\n      COMMON \/ BLOCKA\/MODE,M,KARD(83),KARG,ARG,ARG2,NEWCD(80),KRDEND    00844100\n      COMMON \/ HEADER\/NMCARD(72),ITLE(64,6),IHEAD(4,50),IFMT(17,6),     00844200\n     1 IFMTX(4),LNCNT,IPRINT,NPAGE,IPUNCH                               00844300\nC                                                                       00844400\nC     LOOK FOR LETTER A-F FOLLOWED BY NON-ALPHANUMERIC CHARACTER        00844500\nC     A $ = 46 STOPS THE SCAN                                           00844600\nC                                                                       00844700\n  10  M = M + 1                                                         00844800\n      IF( KARD(M).LT.10 .OR. KARD(M).GT.15 ) IF(KARD(M)-46) 10,90,10    00844900\n      IF( KARD( M+1 ) .LE. 35 ) GO TO 90                                00845000\n      L2 = KARD( M )                                                    00845100\nC                                                                       00845200\nC     LOOK FOR (                                                        00845300\nC                                                                       00845400\n  20  M = M + 1                                                         00845500\n      IF( KARD(M) .NE. 41 ) IF( KARD(M)-46 ) 20, 90, 20                 00845600\nC                                                                       00845700\nC     PACK UP FORMAT TO END OF CARD ($)                                 00845800\nC                                                                       00845900\n      CALL PK5500(KRDEND+3-M , NEWCD(M-2),IFMT( 1, L2-9 ))              00846000\n  30  RETURN                                                            00846100\n  90  CALL ERROR( 205 )                                                 00846200\n      GO TO 30                                                          00846300\n      END                                                               00846400\nC 105  22      SUBROUTINE XHEAD                    2 19 68              00846500\n      SUBROUTINE XHEAD                                                  00846600\n      COMMON \/ BLOCKA\/MODE,M,KARD(83),KARG,ARG,ARG2,NEWCD(80),KRDEND    00846700\n      COMMON \/ HEADER\/NMCARD(72),ITLE(64,6),IHEAD(4,50),IFMT(17,6),     00846800\n     1 IFMTX(4),LNCNT,IPRINT,NPAGE,IPUNCH                               00846900\n      GO TO 50                                                          00847000\n  40  M = M + 1                                                         00847100\n  50  IF( KARD( M) .GE. 10 ) IF( KARD( M ) - 46 ) 40, 70 , 40           00847200\n      CALL AARGS                                                        00847300\n      I = ARG                                                           00847400\n      IF( KARG .EQ. 0 .AND. I .GT. 0 .AND. I .LT. 50 ) GO TO 100        00847500\n  70  CALL ERROR( 204 )                                                 00847600\n  80  RETURN                                                            00847700\n  90  M = M + 1                                                         00847800\n 100  IF( KARD( M ) .NE. 36 ) IF( KARD( M ) - 46 ) 90, 70, 90           00847900\nC                                                                       00848000\nC     SLASH FOUND. PICK UP NEXT 12 CHARACTERS  IN  FORMAT A1 AND PACK   00848100\nC     INTO FORMAT A6. THIS PORTION OF THIS IS NON-STANDARD AND WILL     00848200\nC     HAVE TO BE REWRITTEN FOR MACHINES OTHER THAN B5500                00848300\nC                                                                       00848400\n      CALL PK5500(12,NEWCD(M-1),IHEAD(1,I))                             00848500\n      RETURN                                                            00848600\n      END                                                               00848700\nC 106  47      SUBROUTINE XPND( T , K , Y , KND )  2 19 68              00848800\n      SUBROUTINE XPND( T , K , Y , KND )                                00848900\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00849000\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00849100\n      DIMENSION ARGS(100)                                               00849200\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00849300\n      DIMENSION T( 2 )                                                  00849400\nC                                                                       00849500\nC     THIS SUBROUTINE TAKES A \"\"STATEMENT\"\" REFERENCE AS STORED         00849600\nC     AND EXPANDS IT INTO THE PROPER ARGUMENT WITH CHECKING.            00849700\nC                                                                       00849800\nC     K IS RETURNED 0 IF ARG IN STATEMENT IS ONE WORD LONG              00849900\nC     K IS RETURNED 1 IF ARG IN STATEMENT IS TWO WORDS LONG             00850000\nC     K IS RETURNED -( ERROR NUMBER ) IF ERROR OCCURS.                  00850100\nC                                                                       00850200\n      IT = -T( 1 )                                                      00850300\n      IF( IT .LT. 16 ) GO TO 60                                         00850400\nC                                                                       00850500\nC     \"\"ROW,COL\"\" ENTRY                                                 00850600\nC                                                                       00850700\n      IT =IT - 8208                                                     00850800\n      IF( IT .GT. 0 .AND. IT .LE. NROW ) GO TO 41                       00850900\n      K = -16                                                           00851000\n      GO TO 44                                                          00851100\n   41 IARGS( 100 ) = ABS( T(2) ) - 8192                                 00851200\n      KIND( 100 ) = 0                                                   00851300\n      CALL ADRESS( 100 , J )                                            00851400\n      IF( J .NE. 0 ) GO TO 46                                           00851500\n      K = -11                                                           00851600\n   44 RETURN                                                            00851700\n   46 J = J + IT                                                        00851800\n      KND= 0                                                            00851900\n      IF( T(2) .LT. 0 ) KND = 1                                         00852000\n      Y = RC( J - 1 )                                                   00852100\n      K=1                                                               00852200\n      GO TO 44                                                          00852300\nC                                                                       00852400\nC     NRMAX , V , W , X , Y , Z , REFERENCE.                            00852500\nC                                                                       00852600\n   60 IU = IT \/ 2                                                       00852700\n      KND = IT - 2 * IU                                                 00852800\n      K = 0                                                             00852900\n      IF( IU .LE. 1 ) GO TO 70                                          00853000\n      Y = VWXYZ( IU-2 )                                                 00853100\n      GO TO 44                                                          00853200\n   70 Y= NRMAX                                                          00853300\n      GO TO 44                                                          00853400\n      END                                                               00853500\nC 107  55      SUBROUTINE XSTOP                    2 19 68              00853600\n      SUBROUTINE XSTOP                                                  00853700\n      COMMON \/BLOCKC\/KIO,INUNIT,ISCRAT,KBDOUT,KRDKNT                    00853800\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00853900\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00854000\n      DIMENSION ARGS(100)                                               00854100\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00854200\n      COMMON \/ HEADER\/NMCARD(72),ITLE(64,6),IHEAD(4,50),IFMT(17,6),     00854300\n     1 IFMTX(4),LNCNT,IPRINT,NPAGE,IPUNCH                               00854400\n      COMMON \/ SCRAT \/ A(10000),NS                                      00854500\n      DIMENSION ITEMP( 84 )                                             00854600\n      EQUIVALENCE ( ITEMP( 1 ), A( 1 ) )                                00854700\n      COMMON \/ FLAGS \/ NSUMRY, LLIST                                    00854800\n      DATA IZ, IP \/ 1HZ, 1H+ \/                                          00854900\n      DATA N0, KOMMA \/ 1H0,1H,  \/                                       00855000\nC                                                                       00855100\nC     THIS ROUTINE REWINDS THE SCRATCH UNIT AND PRINTS IT.              00855200\nC                                                                       00855300\n      REWIND ISCRAT                                                     00855400\n       LLIST = 0                                                        00855500\n      IF ( NERROR .EQ. 0 ) LLIST = 3                                    00855600\n  30  CALL PAGE( 0 )                                                    00855700\n      WRITE( IPRINT, 35 )                                               00855800\n  35  FORMAT(\/\/)                                                        00855900\n      DO 80 J = 1, 50                                                   00856000\n      READ( ISCRAT, 40 ) ITEMP                                          00856100\n  40  FORMAT( 84A1 )                                                    00856200\n      IF( ITEMP( 1 ) . EQ. IZ ) GO TO 100                               00856300\n      IF( ITEMP( 1 ) . EQ.IP ) GO TO 60                                 00856400\n      IF ( ITEMP( 1 ) .EQ. KOMMA ) GO TO 55                             00856500\n      WRITE( IPRINT, 50 ) ITEMP                                         00856600\n  50  FORMAT(20X,84A1)                                                  00856700\n      GO TO 80                                                          00856800\n   55 LLIST = 3                                                         00856900\n      IF ( ITEMP( 2 ) .EQ. N0 . AND . NERROR .EQ. 0 ) LLIST = 0         00857000\n      GO TO 80                                                          00857100\n  60  WRITE( IPRINT, 70 ) ( ITEMP( I ), I = 2, 84 )                     00857200\n  70  FORMAT(18X,3A1,3X,80A1)                                           00857300\n  80  CONTINUE                                                          00857400\n      GO TO 30                                                          00857500\n 100  REWIND ISCRAT                                                     00857600\n      IF( NERROR - 1 ) 110,130,150                                      00857700\n 110  WRITE( IPRINT, 120 )                                              00857800\n 120  FORMAT(\/\/\/40X,32HCONGRATULATIONS, NO FATAL ERRORS)                00857900\n      GO TO 200                                                         00858000\n 130  WRITE( IPRINT, 140 )                                              00858100\n 140  FORMAT(\/\/\/40X,20HONLY ONE FATAL ERROR)                            00858200\n      GO TO 200                                                         00858300\n 150  WRITE( IPRINT, 160 ) NERROR                                       00858400\n 160  FORMAT(\/\/\/40X,I4,7H ERRORS)                                       00858500\n  200 WRITE( IPRINT , 180 )                                             00858600\n  180 FORMAT(\/\/\/80X,\"CSD OMNITAB VERSION OF AUG.16,1968\"\/1H1)           00858700\n      KRDKNT = 0                                                        00858800\n      LLIST = 3                                                         00858900\n      RETURN                                                            00859000\n      END                                                               00859100\nC 108  53      SUBROUTINE YATES                    2 19 68              00859200\n      SUBROUTINE YATES                                                  00859300\nC                                                                       00859400\nC     YATES ALGORITHM                                                   00859500\nC                                                                       00859600\nC     STATEMENT IS                                                      00859700\nC                                                                       00859800\nC        YATES ALGORITHM FOR ++ FACTORS,OBS IN COL ++,STORE CONTRASTS IN00859900\nC                                                                       00860000\nC                                                                       00860100\nC     ALL 3 ARGUMENTS MUST BE INTEGERS                                  00860200\nC                                                                       00860300\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00860400\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00860500\n      COMMON \/ SCRAT \/ A(10000),NS                                      00860600\nC                                                                       00860700\nC     CHECK ARGS                                                        00860800\nC                                                                       00860900\n      J=0                                                               00861000\n      IF ( NARGS .EQ. 3 ) GO TO 10                                      00861100\n      CALL ERROR(10)                                                    00861200\n      J=1                                                               00861300\n   10 DO 20 K=1,3                                                       00861400\n      IF ( KIND( K ) .NE. 0 ) GO TO 30                                  00861500\n   20 CONTINUE                                                          00861600\n      IF ( J .EQ. 1 ) RETURN                                            00861700\n      GO TO 40                                                          00861800\n   30 CALL ERROR(3)                                                     00861900\n      RETURN                                                            00862000\n   40 NFACT= IARGS(1)                                                   00862100\n      CALL ADRESS( 2 , NYOBS )                                          00862200\n      CALL ADRESS( 3 , NYCONT )                                         00862300\n      IF ( 2**NFACT .GT. NROW ) GO TO 30                                00862400\n      IF ( NYOBS .EQ. 0 .OR. NYCONT .EQ. 0 ) GO TO 30                   00862500\n      LL=NFACT*2**NFACT                                                 00862600\n      IF ( NERROR .NE. 0 ) RETURN                                       00862700\n      DO 50 I=1,LL                                                      00862800\n   50 A(I)=0.0                                                          00862900\n      L=2**NFACT                                                        00863000\n      NY=NYOBS-1                                                        00863100\n      DO 55 I=1,L                                                       00863200\n   55 A(I)=RC(NY+I)                                                     00863300\n      NYATES=L \/ 2                                                      00863400\n      DO 60 I1=1,NFACT                                                  00863500\n      DO 60 I2=1,NYATES                                                 00863600\n      A(I1*L+I2)=A((I1-1)*L+2*I2)+ A( (I1-1)*L+2*I2-1)                  00863700\n      A(I1*L+NYATES+I2) = A( (I1-1)*L+2*I2) - A( (I1-1)*L+2*I2-1)       00863800\n   60 CONTINUE                                                          00863900\n      L1 = NFACT * L                                                    00864000\n      DO 70 I=1,L                                                       00864100\n      RC(NYCONT)= A(L1+I)                                               00864200\n   70 NYCONT=NYCONT+1                                                   00864300\n      RETURN                                                            00864400\n      END                                                               00864500\nC 109 208C      MAIN AND CROSS REFERENCE TABLE     2 19 68              00864600\nC      MAIN AND CROSS REFERENCE TABLE                                   00864700\nC                                                                       00864800\nC                                                                       00864900\nC     THIS IS A CROSS-REFERENCE TABLE SHOWING WUICH SUBPROGRAMS         00865000\nC     REFERENCE PARTICULAR BLOCKS OF COMMON OR PARTICULAR SUBPROGRAMS.  00865100\nC     THIS LIST DOES NOT INCLUDE THOSE MANY SUBROUTINES CALLED ONLY BY  00865200\nC     THE SUBROUTINE \"XECUTE\".                                          00865300\nC                                                                       00865400\nC     OMNITAB USES NO UNLABELLED COMMON.                                00865500\nC                                                                       00865600\nC                                                                       00865700\nC                                                                       00865800\nC                                                                       00865900\nC******************** LABELLED COMMON **********************************00866000\nC                                                                       00866100\nC                                                                       00866200\nC     ABCDEF                                                            00866300\nC            BLOCK  OMCONV                                              00866400\nC     BLOCKA                                                            00866500\nC            AARGS  ASTER  BEGIN  INPUT  NNAME  NONBLA OMNIT  OUTPUT    00866600\nC            PHYCON READX  SET    SETUP  STMT   STORE  VALUES XFORMT    00866700\nC            XECUTE XHEAD  XOMNIT                                       00866800\nC     BLOCKB                                                            00866900\nC            BEGIN  INPUT  LOCATE OMNIT  OUTPUT STORE  XOMNIT XECUTE    00867000\nC     BLOCKC                                                            00867100\nC            AERR   ERROR  INPUT  INVERT OMNIT  OUTPUT RNDOWN SETUP     00867200\nC            XOMNIT XSTOP  XECUTE                                       00867300\nC     BLOCKD                                                            00867400\nC            ADRESS ALLSUB APRINT ARITH  BEGIN  CHANGE CHKCOL CKIND     00867500\nC            DEFINE DIMENS ERASE  ERROR  EXCHNG EXPAND EXPCON EXTREM    00867600\nC            FIXFLO FLIP   FPROB  FUNCT  GENER  HEADS  IFS    INVERT    00867700\nC            MACHK  MATRIX MISC2  MMULT  MOP    MOVE   MRAISE MSCROW    00867800\nC            MTXCHK MXTX   OMNIT  ORTHO  OUTPUT PDMOTE PLOT   PRINTX    00867900\nC            PROROW READQ  READX  RESET  SELECT SET    SETQ   SETUP     00868000\nC            SORDER SPACE  STATIS STORE  TRANSF VECTOR XOMNIT XPND      00868100\nC            XECUTE XSTOP                                               00868200\nC     BLOCKE                                                            00868300\nC            ALLSUB APRINT ARITH  BEGIN  EXPAND EXPCON EXTREM FIXFLO    00868400\nC            FPROB  FUNCT  IFS    INVERT LOOKUP MATRIX MISC2  MMULT     00868500\nC            MOP    MRAISE MSCROW MXTX   OMNIT  ORTHO  PDMOTE PRINTX    00868600\nC            PROROW READX  RESET  SELECT SET    SETFMT SORDER STATIS    00868700\nC            STORE  TRANSF XECUTE                                       00868800\nC     BLOCKX                                                            00868900\nC            AERR   ERROR  IFS    RNDOWN SETUP  XECUTE                  00869000\nC     CONSTS                                                            00869100\nC            AARGS  FUNCT  FSIN   FCOS   FEXP   SETUP  VALUES           00869200\nC     FLAGS                                                             00869300\nC            AERR   ERROR  OUTPUT XOMNIT XSTOP  XECUTE                  00869400\nC     HEADER                                                            00869500\nC            FIXFLO HEADS  OMNIT  PAGE   PLOT   PRINTX SETFMT SETUP     00869600\nC            SPACE  VALUES XFORMT XHEAD  XOMNIT XSTOP                   00869700\nC     MULTC                                                             00869800\nC            MMULT  MRAISE MXTX   SORTSM TRANSF                         00869900\nC     PCONST                                                            00870000\nC            BLOCK  PHYCON SETUP                                        00870100\nC     QRS                                                               00870200\nC            READQ  READX  SET    SETQ                                  00870300\nC     SCRAT                                                             00870400\nC            EXPCON FPROB  INVERT MATRIX MISC2  MMULT  MOP    MRAISE    00870500\nC            MXTX   ORTHO  PLOT   PROROW SELECT SETUP  SORDER SORTSM    00870600\nC            STATIS TRANSF XSTOP                                        00870700\nC     SPRV                                                              00870800\nC            ERROR  SETUP  XOMNIT                                       00870900\nC                                                                       00871000\nC                                                                       00871100\nC                                                                       00871200\nC                                                                       00871300\nC******************** SUBROUTINES AND FUNCTIONS ************************00871400\nC                                                                       00871500\nC                                                                       00871600\nC     AARGS                                                             00871700\nC            ASTER  OMNIT  XHEAD                                        00871800\nC     ADRESS                                                            00871900\nC            ALLSUB ARITH  CHANGE CHKCOL DEFINE EXCHNG EXPCON FPROB     00872000\nC            FUNCT  GENER  IFS    INVERT MISC2  MOP    MOVE   MSCROW    00872100\nC            ORTHO  SELECT SET    XPND                                  00872200\nC     AERR                                                              00872300\nC            ERROR  OMNIT  SETUP  XECUTE                                00872400\nC     ASTER                                                             00872500\nC            OMNIT                                                      00872600\nC     CHKCOL                                                            00872700\nC            ERASE  EXTREM FLIP   MISC2  PDMOTE PLOT   PRINTX PROROW    00872800\nC            READX  SELECT SORDER STATIS                                00872900\nC     CKIND                                                             00873000\nC            APRINT EXPCON INVERT MATRIX MISC2  MMULT  MOP    MRAISE    00873100\nC            MXTX   STATIS TRANSF                                       00873200\nC     ERROR                                                             00873300\nC            AARGS  ALLSUB APRINT ARITH  ASTER  BEGIN  CHANGE DEFINE    00873400\nC            DIMENS ERASE  EXCHNG EXPAND EXPCON EXTREM FIXFLO FLIP      00873500\nC            FPROB  FUNCT  FSIN   FCOS   FSQRT  FEXP   FLOG   GENER     00873600\nC            IFS    INVERT MATRIX MISC2  MMULT  MOP    MOVE   MRAISE    00873700\nC            MSCROW MXTX   OMNIT  ORTHO  PDMOTE PAGE   PRINTX PROROW    00873800\nC            READQ  READX  RESET  SELECT SET    SETQ   SORDER   SPACE   00873900\nC            STATIS STORE  TRANSF XFORMT XOMNIT XECUTE                  00874000\nC     EXPAND                                                            00874100\nC            OMNIT  XECUTE                                              00874200\nC     FCOS                                                              00874300\nC            FUNCT                                                      00874400\nC     FEXP                                                              00874500\nC            FUNCT  FEXP2                                               00874600\nC     FEXP2                                                             00874700\nC            ARITH  MATRIX MISC2                                        00874800\nC     FEXP3                                                             00874900\nC            MATRIX                                                     00875000\nC     FLOG                                                              00875100\nC            FUNCT  FEXP2                                               00875200\nC     FLOG10                                                            00875300\nC            FUNCT                                                      00875400\nC     FSIN                                                              00875500\nC            FUNCT                                                      00875600\nC     FSQRT                                                             00875700\nC            FUNCT  INVCHK MSCROW ORTHO  STATIS                         00875800\nC     HEADS                                                             00875900\nC            PRINTX                                                     00876000\nC     INPUT                                                             00876100\nC            OMNIT                                                      00876200\nC     INVCHK                                                            00876300\nC            INVERT                                                     00876400\nC     LOCATE                                                            00876500\nC            STORE  XECUTE                                              00876600\nC     LOOKUP                                                            00876700\nC            OMNIT                                                      00876800\nC     MACHK                                                             00876900\nC            INVERT                                                     00877000\nC     MOVE                                                              00877100\nC            MISC2  XECUTE                                              00877200\nC     MTXCHK                                                            00877300\nC            APRINT EXPCON MATRIX MMULT  MOP    MRAISE MXTX   TRANSF    00877400\nC     NNAME                                                             00877500\nC            ASTER  OMNIT                                               00877600\nC     NONBLA                                                            00877700\nC            ASTER                                                      00877800\nC     OMCONV                                                            00877900\nC            INPUT                                                      00878000\nC     OMNIT                                                             00878100\nC            OMNSYM OMNREL OMNITA MNITAB                                00878200\nC     OUTPUT                                                            00878300\nC            OMNIT                                                      00878400\nC     PAGE                                                              00878500\nC            ORTHO  PLOT   PRINTX STATIS XSTOP  XECUTE                  00878600\nC     PGSIZE                                                            00878700\nC            OMNIT                                                      00878800\nC     PHYCON                                                            00878900\nC            ASTER  XECUTE                                              00879000\nC    PK5500                                                             00879100\nC           XFORMT XHEAD HEADS                                          00879200\nC     PRINTX                                                            00879300\nC            APRINT XECUTE                                              00879400\nC     PROB                                                              00879500\nC            FPROB  STATIS                                              00879600\nC     READQ                                                             00879700\nC            OMNIT                                                      00879800\nC     RNDOWN                                                            00879900\nC            AERR   ERROR                                               00880000\nC     SETFMT                                                            00880100\nC            PRINTX                                                     00880200\nC     SETQ                                                              00880300\nC            OMNIT                                                      00880400\nC     SETUP                                                             00880500\nC            OMNIT                                                      00880600\nC     SORTSM                                                            00880700\nC            MMULT  MRAISE MXTX   TRANSF                                00880800\nC     SPINV                                                             00880900\nC            INVCHK                                                     00881000\nC     STMT                                                              00881100\nC            OMNIT                                                      00881200\nC     STORE                                                             00881300\nC            OMNIT                                                      00881400\nC     TRANSF                                                            00881500\nC            MXTX                                                       00881600\nC     VARCON                                                            00881700\nC            ASTER                                                      00881800\nC     VECTOR                                                            00881900\nC            DEFINE ERASE  EXTREM FUNCT  MISC2  MSCROW PDMOTE           00882000\nC     XECUTE                                                            00882100\nC            OMNIT                                                      00882200\nC     XFORMT                                                            00882300\nC            OMNIT                                                      00882400\nC     XHEAD                                                             00882500\nC            OMNIT                                                      00882600\nC     XOMNIT                                                            00882700\nC            OMNIT                                                      00882800\nC     XPND                                                              00882900\nC            EXPAND XECUTE                                              00883000\nC     XSTOP                                                             00883100\nC            OMNIT  XOMNIT                                              00883200\nC                                                                       00883300\nC******************** SYSTEM FUNCTIONS *********************************00883400\nC                                                                       00883500\nC     *ALOG                                                             00883600\nC            FUNCT  FLOG                                                00883700\nC     *ALOG10                                                           00883800\nC            FUNCT                                                      00883900\nC     *ATAN                                                             00884000\nC            FUNCT                                                      00884100\nC     *COS                                                              00884200\nC            FCOS                                                       00884300\nC     *EXP                                                              00884400\nC            FEXP                                                       00884500\nC     *SIN                                                              00884600\nC            FSIN                                                       00884700\nC     *SQRT                                                             00884800\nC            FUNCT  FSQRT  ORTHO                                        00884900\nC     *TANH                                                             00885000\nC            FUNCT                                                      00885100\n      CALL OMNIT                                                        00885200\n      STOP                                                              00885300\n      END                                                               00885400\nC 110  60      SUBROUTINE XOMNIT(LG)               2 19 68              00885500\n      SUBROUTINE XOMNIT(LG)                                             00885600\n      COMMON \/ BLOCKF \/ NCTOP                                           00885700\n      COMMON \/ BLOCKA\/MODE,M,KARD(83),KARG,ARG,ARG2,NEWCD(80),KRDEND    00885800\n      COMMON \/BLOCKB\/NSTMT,NSTMTX,NSTMTH,NCOM,LCOM,IOVFL,COM(2000)      00885900\n      COMMON \/BLOCKC\/KIO,INUNIT,ISCRAT,KBDOUT,KRDKNT                    00886000\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00886100\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00886200\n      DIMENSION ARGS(100)                                               00886300\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00886400\n      COMMON \/ HEADER\/NMCARD(72),ITLE(64,6),IHEAD(4,50),IFMT(17,6),     00886500\n     1 IFMTX(4),LNCNT,IPRINT,NPAGE,IPUNCH                               00886600\n      COMMON \/ FLAGS \/ NSUMRY, LLIST                                    00886700\n      COMMON \/ SPRV \/ NERCON,NERR                                       00886800\n      DATA LBLANK\/1H \/                                                  00886900\n      DIMENSION IH( 4 )                                                 00887000\n      DATA IH(1),IH(2),IH(3),IH(4) \/ 1H(, 4H1P8E, 3H15., 2H6) \/         00887100\nC                                                                       00887200\nC     IF LG IS NEG, FIRST CARD WAS NOT \"OMNITAB\" CARD. IF LG= 0, FIRST  00887300\nC     CARD = \"OMNITAB\", ELSE SUBSEQUENT \"OMNITAB\" CARD FOUND.           00887400\nC                                                                       00887500\n      IF(LG)300,200,100                                                 00887600\nC                                                                       00887700\nC     GO THROUGH \"STOP\" SEQUENCE AND RETURN                             00887800\n 100  CALL XSTOP                                                        00887900\n 200  DO 210 I=1,72                                                     00888000\n 210  NMCARD(I)=NEWCD(I)                                                00888100\nC                                                                       00888200\nC     INITIALIZE SYSTEM                                                 00888300\nC                                                                       00888400\n 300  DO 310 I = 1, 64                                                  00888500\n      DO 310 J = 1, 6                                                   00888600\n 310  ITLE( I, J ) = LBLANK                                             00888700\n      DO 315 I = 1, 50                                                  00888800\n      IHEAD( 1, I ) = 0                                                 00888900\n      IHEAD( 3 , I) = 0                                                 00889000\n      IHEAD( 4 , I) = 0                                                 00889100\n 315  IHEAD( 2, I ) = 0                                                 00889200\n      DO 320 J = 1, 6                                                   00889300\n 320  IFMT( 1, J ) = 0                                                  00889400\n      DO 325 I = 1, 4                                                   00889500\n 325  IFMTX( I ) = IH( I )                                              00889600\n      MODE=1                                                            00889700\n      NRMAX=0                                                           00889800\n      NROW=101                                                          00889900\n      NCOL= 99                                                          00890000\n      NCTOP = 1                                                         00890100\n      NERR = 0                                                          00890200\n      LLIST = 3                                                         00890300\n      NSUMRY = 0                                                        00890400\n      NERROR = 0                                                        00890500\n      NSTMT=0                                                           00890600\n      NSTMTH=0                                                          00890700\n      NCOM=1                                                            00890800\n      CALL RANDM(0)                                                     00890900\n      LCOM=2000                                                         00891000\n      IOVFL=0                                                           00891100\n      NPAGE = 0                                                         00891200\n      DO 330 I=1,10100                                                  00891300\n 330  RC(I)=0.                                                          00891400\n      RETURN                                                            00891500\n      END                                                               00891600\nC 111  33      SUBROUTINE SETUP                    2 19 68              00891700\n      SUBROUTINE SETUP                                                  00891800\n      COMMON \/ BLOCKA\/MODE,M,KARD(83),KARG,ARG,ARG2,NEWCD(80),KRDEND    00891900\n      COMMON \/ SPRV \/ NERCON,NERR                                       00892000\n      COMMON \/BLOCKC\/KIO,INUNIT,ISCRAT,KBDOUT,KRDKNT                    00892100\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00892200\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00892300\n      DIMENSION ARGS(100)                                               00892400\n      EQUIVALENCE( ARGS(1), RC(10001) )                                 00892500\n      COMMON \/ SCRAT \/ A(10000),NS                                      00892600\n      COMMON \/ HEADER\/NMCARD(72),ITLE(64,6),IHEAD(4,50),IFMT(17,6),     00892700\n     1 IFMTX(4),LNCNT,IPRINT,NPAGE,IPUNCH                               00892800\n      COMMON \/ BLOCKX \/ INDEX( 6, 8 ), LEVEL                            00892900\n      COMMON \/ PCONST \/ P( 40 ), N( 40 )                                00893000\n      COMMON\/CONSTS\/PI,E,HALFPI,DEG,RAD,XEXP,XTRIG,XALOG,CC( 192 )      00893100\n      NERCON = 100                                                      00893200\n      P( 1 ) = PI                                                       00893300\n      P( 2 ) = PI                                                       00893400\n      P( 3 ) = E                                                        00893500\n      P( 4 ) = E                                                        00893600\n      KRDKNT = 0                                                        00893700\n      KRDEND = 80                                                       00893800\n      NERROR = 0                                                        00893900\n      LEVEL = 0                                                         00894000\n      MODE=1                                                            00894100\n      INUNIT=1                                                          00894200\n      IPRINT=3                                                          00894300\n      IPUNCH=2                                                          00894400\n      ISCRAT=4                                                          00894500\n      NS = 10000                                                        00894600\n      KIO = 0                                                           00894700\n      CALL AERR(-1)                                                     00894800\n      RETURN                                                            00894900\n      END                                                               00895000\nC 112  27      SUBROUTINE NEWJOB                   2 19 68              00895100\n      SUBROUTINE NEWJOB                                                 00895200\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00895300\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00895400\n      DIMENSION ARGS(100)                                               00895500\n      EQUIVALENCE( ARGS(1), RC(10101) )                                 00895600\n      COMMON \/ BLOCKE \/ NAME( 4 ), L1, L2, ISR                          00895700\n      DIMENSION K( 4 )                                                  00895800\nC                  AD, DA, AV, V                                        00895900\n      DATA K \/ 837, 2943, 1323, 16038 \/                                 00896000\nC              CHECK  AURANDOM OR ANRANDOM                              00896100\n      IF (NAME(1).NE. 1314 .OR. NAME(2) .NE. 1111) GO TO 10             00896200\n      L1 = 40                                                           00896300\n      L2=1                                                              00896400\n      GO TO 2                                                           00896500\n   10 IF (NAME(1).NE. 1125 .OR. NAME(2) .NE. 1111) GO TO 40             00896600\n      L1=40                                                             00896700\n      L2=2                                                              00896800\n   2  RETURN                                                            00896900\nC                  L1 = 41 MDAMAD                                       00897000\nC                  L1 = 42  ARYVEC                                      00897100\n  40  IF( NAME(1) .NE. 9477 ) GO TO 200                                 00897200\n      DO 50 I = 1, 4                                                    00897300\n  50  IF( NAME( 3 ) .EQ. K( I ) ) GO TO 70                              00897400\n      GO TO 2                                                           00897500\n  70  L1 = I\/3 + 41                                                     00897600\n      L2 = 2 - MOD( I, 2 )                                              00897700\n      GO TO 2                                                           00897800\nC                  MKRON                                                00897900\n  200 IF( NAME(1) .NE. 9792 .OR. NAME(2) .NE. 11313 ) GO TO 90          00898000\n      L1 = 43                                                           00898100\n      GO TO 2                                                           00898200\nC     DUMP SCRATCH AREA                                                 00898300\n   90 IF( NAME(1) .NE. 3496 .OR. NAME(2) .NE. 11664 ) GO TO 100         00898400\n      L1 = 45                                                           00898500\n      GO TO 2                                                           00898600\n  100 CONTINUE                                                          00898700\n      GO TO 2                                                           00898800\n      END                                                               00898900\nC 113   8      SUBROUTINE GOJOB                    2 19 68              00899000\n      SUBROUTINE GOJOB                                                  00899100\n      COMMON \/ BLOCKE \/ NAME(4), L1, L2, ISR                            00899200\n      IF (L1.EQ.40)CALL RANDM(1)                                        00899300\n      IF( L1 .EQ. 41 ) CALL MDAMAD                                      00899400\n      IF( L1 .EQ. 42 ) CALL ARYVEC                                      00899500\n      IF( L1 .EQ. 43 ) CALL MKRON                                       00899600\n      IF( L1 .EQ. 45 ) CALL XDUMP                                       00899700\n      RETURN                                                            00899800\n      END                                                               00899900\nC  114 52  SUBROUTINE AERR(I)                                           00900000\n      SUBROUTINE AERR(I)                                                00900100\n      COMMON \/BLOCKC\/ KIO,INUNIT,ISCRAT,KBDOUT,KRDKNT                   00900200\n      COMMON \/BLOCKX\/ INDEX(6,8),LEVEL                                  00900300\n      COMMON \/FLAGS\/ NSUMRY,LLIST                                       00900400\nC*****                                                                  00900500\nC WHEN ARITHMETIC TROUBLES DEVELOP, THIS ROUTINE TALLIES THEM AND THEN  00900600\nC PRINTS THE RESULT WHEN THE COMMAND IS DONE                            00900700\nC*****                                                                  00900800\n      DIMENSION MESS(6)                                                 00900900\n      IF(I)80,60,50                                                     00901000\nC*****                                                                  00901100\nC DATA COMING IN                                                        00901200\nC*****                                                                  00901300\n   50 J = MIN0(I,6)                                                     00901400\n      MESS(J) = MESS(J) + 1                                             00901500\n   55 RETURN                                                            00901600\nC*****                                                                  00901700\nC DUMP RESULTS, END OF COMMAND                                          00901800\nC*****                                                                  00901900\n   60 IF(LLIST.LT.2) GO TO 80                                           00902000\n      DO 70 J = 1,6                                                     00902100\n      IF(MESS(J).EQ.0) GO TO 70                                         00902200\n      WRITE(ISCRAT,601)                                                 00902300\n      WRITE(ISCRAT,291) MESS(J)                                         00902400\n  291 FORMAT(34H** ARITHMETIC FAULT,ZERO RETURNED,I4,6H TIMES,40X)      00902500\n      GO TO (201,202,203,204,205,206),J                                 00902600\n  201 WRITE(ISCRAT,701)                                                 00902700\n  701 FORMAT(35H** NEGATIVE ARGUMENT TO SQRT OR LOG,49X)                00902800\n      GO TO 600                                                         00902900\n  202 WRITE(ISCRAT,702)                                                 00903000\n  702 FORMAT(43H** EVALUATION OF EXPONENT PRODUCES OVERFLOW,41X)        00903100\n      GO TO 600                                                         00903200\n  203 WRITE(ISCRAT,703)                                                 00903300\n  703 FORMAT(45H** ARGUMENT OUT OF BOUNDS TO INVERSE FUNCTION,39X)      00903400\n      GO TO 600                                                         00903500\n  204 CONTINUE                                                          00903600\n  205 CONTINUE                                                          00903700\n  206 WRITE(ISCRAT,706) J                                               00903800\n  706 FORMAT(16H** ERROR MESSAGE,I2,66X)                                00903900\n  600 IF(LEVEL .NE. 0) CALL RNDOWN                                      00904000\n      WRITE(ISCRAT,601)                                                 00904100\n  601 FORMAT(84X)                                                       00904200\n      MESS(J)=0                                                         00904300\n   70 CONTINUE                                                          00904400\n      GO TO 55                                                          00904500\nC*****                                                                  00904600\nC INITIALIZATION SECTION                                                00904700\nC*****                                                                  00904800\n   80 DO 85 J=1,6                                                       00904900\n   85 MESS(J)=0                                                         00905000\n      GO TO 55                                                          00905100\n      END                                                               00905200\nC  115  26 SUBROUTINE PK5500 (N,IALPH,JALPH)                            00905300\n      SUBROUTINE PK5500 (N,IALPH,JALPH)                                 00905400\nC*****                                                                  00905500\nC     THIS ROUTINE PICKS UP CHARACTERS IN FORMAT A1 AND PACKS INTO      00905600\nC     FORMAT A6. THIS ROUTINE IS NON-STANDARD AND WILL HAVE TO BE       00905700\nC     REWRITTEN FOR MACHINES OTHER THAN BURROUGHS B-5500                00905800\nC*****                                                                  00905900\n      DIMENSION IALPH(1),JALPH(1,1)                                     00906000\n      J=N\/6                                                             00906100\n      K=MOD(N,6)                                                        00906200\n      L=1                                                               00906300\n      DO 15 I=1,J                                                       00906400\n      M=L+5                                                             00906500\n      IS=12                                                             00906600\n      DO 10 I1=L,M                                                      00906700\n      JALPH(1,I)=CONCAT(JALPH(1,I),IALPH(I1),IS,12,6)                   00906800\n   10 IS=IS+6                                                           00906900\n   15 L=L+6                                                             00907000\n      IF(K.EQ.0)RETURN                                                  00907100\n      I=J+1                                                             00907200\n      M=L+K                                                             00907300\n      IS=12                                                             00907400\n      DO 20 I1=L,M                                                      00907500\n      JALPH(1,I)=CONCAT(JALPH(1,I),IALPH(I1),IS,12,6)                   00907600\n   20 IS=IS+6                                                           00907700\n      RETURN                                                            00907800\n      END                                                               00907900\nC 116    SUBROUTINE RANDM(IST)                                          00908000\n      SUBROUTINE RANDM( IST )                                           00908100\nC                                                                       00908200\nC      THIS ROUTINE GENERATES RANDOM NUMBER. IT IS WRITTEN FOR          00908300\nC      THE IBM 360\/65. ( R L CHAMBERLAIN, JULY 1968 )                   00908400\nC                                                                       00908500\nC      THE COMMANDS ARE                                                 00908600\nC   L2=1  (UNIFORM)                                                     00908700\nC     AURANDOM  (,, ,++) ,,X,,                                          00908800\nC     AURANDOM  (,, ,++) ,,X,,  STARTING WITH ,,                        00908900\nC                                                                       00909000\nC   L2=2                                                                00909100\nC        (NORMAL)                                                       00909200\nC     ANRANDOM  (,, ,++) ,,X,,                                          00909300\nC     ANRANDOM  (,, ,++) ,,X,,  STARTING WITH                           00909400\nC                                                                       00909500\nC                                                                       00909600\nC     REF.  MATH NOTE NO. 551, BOEING SCIENTIFIC RESEARCH LABS          00909700\nC       MARSAGLIA AND BRAY, ONE-LINE RANDOM NUMBER GENERATORS           00909800\nC                                                                       00909900\nC                                                                       00910000\n      COMMON \/ BLOCKF \/ NCTOP                                           00910100\n      COMMON \/BLOCKC\/KIO,INUNIT,ISCRAT,KBDOUT,KRDKNT                    00910200\n      DOUBLE PRECISION DEN                                              00910300\n      COMMON \/BLOCKD\/ RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX, 00910400\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00910500\n      COMMON\/BLOCKE\/NAME(4),L1,L2,ISRFLG                                00910600\n      COMMON \/ RNDOM \/ INITX,LAMBDA                                     00910700\n      IF ( IST .EQ. 0 ) GO TO 500                                       00910800\n      L = 2**35-1                                                       00910900\n      DEN=2**35                                                         00911000\n      GO TO (10,10,30,40,50 ),NARGS                                     00911100\n   10 K=9                                                               00911200\n   15 CALL ERROR( K )                                                   00911300\n      RETURN                                                            00911400\n   30 IF ( KIND(1) + KIND(2) + KIND(3) .EQ. 0 ) GO TO 31                00911500\n      K=3                                                               00911600\n      GO TO 15                                                          00911700\n   31 CONTINUE                                                          00911800\n      IARGS(4)=IARGS(3)                                                 00911900\n      KIND(4)=0                                                         00912000\n      GO TO 60                                                          00912100\n   40 IF ( KIND(1) + KIND(2) + KIND(3) + KIND(4) .EQ. 0 ) GO TO 41      00912200\n      K=3                                                               00912300\n      GO TO 15                                                          00912400\n   41 CONTINUE                                                          00912500\n      GO TO 60                                                          00912600\n   50 IF ( KIND(1) + KIND(2) + KIND(3) + KIND(4) + KIND(5) .EQ. 0 )     00912700\n     1 GO TO 51                                                         00912800\n      K=3                                                               00912900\n      GO TO 15                                                          00913000\n   51 INITX = IARGS( 5 )                                                00913100\n   60 IF ( (IARGS(4) + IARGS(2) - 1) .LE. NCOL ) GO TO 62               00913200\n   61 K=16                                                              00913300\n      GO TO 15                                                          00913400\n   62 IF ( (IARGS(1) + IARGS(3) - 1) .GT.(NROW - NCTOP + 1) ) GO TO 61  00913500\n      NNN=IARGS(4)                                                      00913600\n      NNM=IARGS(3)                                                      00913700\n      IF ( NERROR .NE. 0 ) RETURN                                       00913800\n      DO 100 I=1,NNN                                                    00913900\n      CALL ADRESS( 2, MMM )                                             00914000\n      IF ( L2 .EQ. 1 ) GO TO 65                                         00914100\n      IF (MOD(NNM,2) .NE. 0) NNM=NNM-1                                  00914200\n   65 DO 90 I2=1,NNM                                                    00914300\n      INITX = MOD( INITX*LAMBDA , L )                                   00914400\n      RC( MMM + I2 - 1 ) = FLOAT( INITX ) \/ DEN                         00914500\n      GO TO (90,70),L2                                                  00914600\n   70 L1=1+MOD(I2,2)                                                    00914700\n      GO TO (80,90),L1                                                  00914800\n   80 J1=MMM+I2-1                                                       00914900\n      J2=J1-1                                                           00915000\n      XY=SQRT(-2.0*ALOG(RC(J2)) )                                       00915100\n      RC(J2)= COS(6.283185*RC(J1))*XY                                   00915200\n      RC(J1)= SIN(6.283185*RC(J1))*XY                                   00915300\n   90 CONTINUE                                                          00915400\n      IF ( L2 . EQ. 1 ) GO TO 100                                       00915500\n      IF (MOD(IARGS(3),2) .EQ. 0) GO TO 100                             00915600\n      INITX = MOD( INITX*LAMBDA , L )                                   00915700\n      TEMP1 = FLOAT( INITX ) \/ DEN                                      00915800\n      INITX = MOD( INITX*LAMBDA , L )                                   00915900\n      TEMP2 = FLOAT( INITX ) \/ DEN                                      00916000\n      XY = SQRT(-2.0*ALOG(TEMP1))                                       00916100\n      TEMP1 = COS(6.283185*TEMP2)*XY                                    00916200\n      MM1 = J1 + 1                                                      00916300\n      RC(MM1) = TEMP1                                                   00916400\n      NNM = NNM + 1                                                     00916500\n  180 FORMAT(\/\/\/20X,\"SYSTEMS DESIGN AND PROGRAMMING OMNITAB VERSION OF A00916600\n     1UG.16,1968\"\/20X,\"NAVAL AIR TEST CENTER,PATUXENT RIVER,MD.\"\/1H1)   00916700\n  100 IARGS( 2 ) = IARGS( 2 ) + 1                                       00916800\n      WRITE(ISCRAT,200) INITX                                           00916900\n  200 FORMAT( 40H     **** THE LAST INTEGER GENERATED WAS,I12,5H ****,  00917000\n     1 27X )                                                            00917100\n      RETURN                                                            00917200\nC                                                                       00917300\nC     INITIALIZATION                                                    00917400\nC                                                                       00917500\n  500 CONTINUE                                                          00917600\n      LAMBDA=5**13                                                      00917700\n      INITX=LAMBDA                                                      00917800\n      RETURN                                                            00917900\n      END                                                               00918000\nC 118  14   SUBROUTINE XDUMP                                            00918100\n      SUBROUTINE XDUMP                                                  00918200\n      COMMON\/BLOCKD\/RC(10100),IARGS(100),KIND(100),ARGTAB(100),NRMAX,   00918300\n     1 NROW,NCOL,NARGS,VWXYZ(8),NERROR                                  00918400\n      COMMON \/ HEADER \/NMCARD(72),ITLE(64,6),IHEAD(4,50),IFMT(17,6),    00918500\n     1 IFMTX(4),LNCNT,IPRINT,NPAGE,IPUNCH                               00918600\n      IF(IARGS(1) .GT. 0 .AND. IARGS(1) .LE. 10000 ) GO TO 10           00918700\n      IARGS(1) = 1000                                                   00918800\n   10 CALL PAGE(0)                                                      00918900\n      WRITE(IPRINT,100) IARGS(1)                                        00919000\n  100 FORMAT(\/\/10H THE FIRST,I10,30H LOCATIONS OF THE SCRATCH AREA\/)    00919100\n      CALL PNT( IARGS(1) )                                              00919200\n      RETURN                                                            00919300\n      END                                                               00919400\n                                                                        00919500\n                                                                        00919600\n                                                                        99999999\n","avg_line_length":80.9911946951,"max_line_length":80,"alphanum_fraction":0.2797575426,"licenses":["MIT"],"repository_name":"retro-software\/B5500-software","path":"CUBE-Library-13\/Files\/OMNITAB-Z300002.for","size":745038,"lang":"FORTRAN"}
{"content":"FROM python:3.8-slim-buster\n\nENV HOME \/api\/\n\nWORKDIR ${HOME}\n\nCOPY .\/requirements.txt ${HOME}\/\nRUN pip install --upgrade pip \\\n    && pip install --no-cache-dir -r ${HOME}\/requirements.txt\n\nADD .\/ ${HOME}\nRUN python .\/adcusers_gen.py\n\n#ENTRYPOINT [\"python\", \".\/main.py\", \"--ip\", \"0.0.0.0\", \"--p\", \"4280\", \"--anonymous\"]\n#ENTRYPOINT [\"gunicorn\", \"-b\", \"0.0.0.0:4280\", \"main:app\"]\nENTRYPOINT [\".\/entry.sh\"]\n\n","avg_line_length":22.5555555556,"max_line_length":84,"alphanum_fraction":0.6206896552,"licenses":["BSD-3-Clause"],"repository_name":"dasadc\/adc2019","path":"server\/Dockerfile","size":406,"lang":"Dockerfile"}
{"content":"! SUMMA - Structure for Unifying Multiple Modeling Alternatives\n! Copyright (C) 2014-2015 NCAR\/RAL\n!\n! This file is part of SUMMA\n!\n! For more information see: http:\/\/www.ral.ucar.edu\/projects\/summa\n!\n! This program is free software: you can redistribute it and\/or modify\n! it under the terms of the GNU General Public License as published by\n! the Free Software Foundation, either version 3 of the License, or\n! (at your option) any later version.\n!\n! This program is distributed in the hope that it will be useful,\n! but WITHOUT ANY WARRANTY; without even the implied warranty of\n! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n! GNU General Public License for more details.\n!\n! You should have received a copy of the GNU General Public License\n! along with this program.  If not, see <http:\/\/www.gnu.org\/licenses\/>.\n\nmodule var_derive_module\nUSE nrtype\nimplicit none\nprivate\npublic::calcHeight\npublic::rootDensty\npublic::satHydCond\npublic::fracFuture\npublic::v_shortcut\ncontains\n\n\n ! **********************************************************************************************************\n ! public subroutine calcHeight: compute snow height\n ! **********************************************************************************************************\n subroutine calcHeight(&\n                       ! input\/output: data structures\n                       indx_data,   & ! intent(in): layer type\n                       prog_data,   & ! intent(inout): model variables for a local HRU\n                       ! output: error control\n                       err,message)\n ! access named variables for snow and soil\n USE globalData,only:iname_snow     ! named variables for snow\n USE globalData,only:iname_soil     ! named variables for soil\n ! access to the derived types to define the data structures\n USE data_types,only:var_ilength    ! x%var(:)%dat (i4b)\n USE data_types,only:var_dlength    ! x%var(:)%dat (dp)\n ! provide access to named variables defining elements in the data structures\n USE var_lookup,only:iLookPROG,iLookINDEX  ! named variables for structure elements\n implicit none\n ! ----------------------------------------------------------------------------------\n ! dummy variables\n ! input\/output: data structures\n type(var_ilength),intent(in)       :: indx_data      ! type of model layer\n type(var_dlength),intent(inout)    :: prog_data      ! model variables for a local HRU\n ! output: error control\n integer(i4b),intent(out)           :: err            ! error code\n character(*),intent(out)           :: message        ! error message\n ! local variables\n integer(i4b)                       :: iLayer         ! loop through layers\n integer(i4b)                       :: ixLower(1)     ! index of the lower bound\n ! ----------------------------------------------------------------------------------\n ! initialize error control\n err=0; message='calcHeight\/'\n ! ----------------------------------------------------------------------------------\n ! associate variables in data structure\n associate(&\n ! associate the model index structures\n nLayers        => indx_data%var(iLookINDEX%nLayers)%dat(1),  &   ! total number of layers\n layerType      => indx_data%var(iLookINDEX%layerType)%dat,   &   ! layer type (iname_soil or iname_snow)\n ! associate the values in the model variable structures\n mLayerDepth    => prog_data%var(iLookPROG%mLayerDepth)%dat,  &   ! depth of the layer (m)\n mLayerHeight   => prog_data%var(iLookPROG%mLayerHeight)%dat, &   ! height of the layer mid-point (m)\n iLayerHeight   => prog_data%var(iLookPROG%iLayerHeight)%dat  &   ! height of the layer interface (m)\n ) ! end associate\n ! ----------------------------------------------------------------------------------\n\n ! initialize layer height as the top of the snowpack -- positive downward\n ixLower=lbound(iLayerHeight); if(ixLower(1) > 0)then; err=20; message=trim(message)\/\/'unexpected lower bound for iLayerHeight'; return; endif\n iLayerHeight(0) = -sum(mLayerDepth, mask=layerType==iname_snow)\n\n ! loop through layers\n do iLayer=1,nLayers\n  ! compute the height at the layer midpoint\n  mLayerHeight(iLayer) = iLayerHeight(iLayer-1) + mLayerDepth(iLayer)\/2._dp\n  ! compute the height at layer interfaces\n  iLayerHeight(iLayer) = iLayerHeight(iLayer-1) + mLayerDepth(iLayer)\n end do ! (looping through layers)\n\n !print*, 'layerType   = ',  layerType\n !print*, 'mLayerDepth = ',  mLayerDepth\n !print*, 'mLayerHeight = ', mLayerHeight\n !print*, 'iLayerHeight = ', iLayerHeight\n !print*, '************** '\n\n ! end association to variables in the data structure\n end associate\n\n end subroutine calcHeight\n\n\n ! **********************************************************************************************************\n ! public subroutine rootDensty: compute vertical distribution of root density\n ! **********************************************************************************************************\n subroutine rootDensty(mpar_data,indx_data,prog_data,diag_data,err,message)\n ! model decision structures\n USE globalData,only:model_decisions        ! model decision structure\n USE var_lookup,only:iLookDECISIONS         ! named variables for elements of the decision structure\n ! look-up values for the choice of the rooting profile\n USE mDecisions_module,only: &\n powerLaw,                   & ! simple power-law rooting profile\n doubleExp                     ! the double exponential function of Xeng et al. (JHM 2001)\n ! look-up values for the choice of groundwater parameterization\n USE mDecisions_module,only: &\n bigBucket,                  & ! a big bucket (lumped aquifer model)\n noExplicit                    ! no explicit groundwater parameterization\n ! named variables\n USE var_lookup,only:iLookPARAM,iLookINDEX,iLookPROG,iLookDIAG        ! named variables for structure elements\n ! data types\n USE data_types,only:var_dlength    ! x%var(:)%dat (dp)\n USE data_types,only:var_ilength    ! x%var(:)%dat (i4b)\n implicit none\n ! declare input variables\n type(var_dlength),intent(in)    :: mpar_data       ! data structure of model parameters for a local HRU\n type(var_ilength),intent(in)    :: indx_data       ! data structure of model indices for a local HRU\n type(var_dlength),intent(in)    :: prog_data       ! data structure of model prognostic (state) variables for a local HRU\n type(var_dlength),intent(inout) :: diag_data       ! data structure of model diagnostic variables for a local HRU\n ! declare output variables\n integer(i4b),intent(out)        :: err             ! error code\n character(*),intent(out)        :: message         ! error message\n ! declare local variables\n integer(i4b)                    :: iLayer          ! loop through layers\n real(dp)                        :: fracRootLower   ! fraction of the rooting depth at the lower interface\n real(dp)                        :: fracRootUpper   ! fraction of the rooting depth at the upper interface\n real(dp), parameter             :: rootTolerance = 0.05_dp ! tolerance for error in doubleExp rooting option\n real(dp)                        :: error           ! machine precision error in rooting distribution\n ! initialize error control\n err=0; message='rootDensty\/'\n\n ! ----------------------------------------------------------------------------------\n ! associate variables in data structure\n associate(&\n ! associate the model decisions\n ixRootProfile         =>model_decisions(iLookDECISIONS%rootProfil)%iDecision,  & ! choice of the rooting profile\n ixGroundwater         =>model_decisions(iLookDECISIONS%groundwatr)%iDecision,  & ! choice of groundwater parameterization\n ! associate the values in the model parameter structures\n rootScaleFactor1      =>mpar_data%var(iLookPARAM%rootScaleFactor1)%dat(1),     & ! 1st scaling factor (m-1)\n rootScaleFactor2      =>mpar_data%var(iLookPARAM%rootScaleFactor2)%dat(1),     & ! 2nd scaling factor (m-1)\n rootingDepth          =>mpar_data%var(iLookPARAM%rootingDepth)%dat(1),         & ! rooting depth (m)\n rootDistExp           =>mpar_data%var(iLookPARAM%rootDistExp)%dat(1),          & ! root distribution exponent (-)\n ! associate the model index structures\n nSoil                 =>indx_data%var(iLookINDEX%nSoil)%dat(1),                & ! number of soil layers\n nSnow                 =>indx_data%var(iLookINDEX%nSnow)%dat(1),                & ! number of snow layers\n nLayers               =>indx_data%var(iLookINDEX%nLayers)%dat(1),              & ! total number of layers\n iLayerHeight          =>prog_data%var(iLookPROG%iLayerHeight)%dat,             & ! height of the layer interface (m)\n ! associate the values in the model variable structures\n scalarAquiferRootFrac =>diag_data%var(iLookDIAG%scalarAquiferRootFrac)%dat(1), & ! fraction of roots below the soil profile (in the aquifer)\n mLayerRootDensity     =>diag_data%var(iLookDIAG%mLayerRootDensity)%dat         & ! fraction of roots in each soil layer (-)\n ) ! end associate\n ! ----------------------------------------------------------------------------------\n\n! print*, 'nSnow   = ', nSnow\n! print*, 'nLayers = ', nLayers\n\n ! compute the fraction of roots in each soil layer\n do iLayer=nSnow+1,nLayers\n\n  ! different options for the rooting profile\n  select case(ixRootProfile)\n\n   ! ** option 1: simple power-law profile\n   case(powerLaw)\n    if(iLayerHeight(iLayer-1)<rootingDepth)then\n     ! compute the fraction of the rooting depth at the lower and upper interfaces\n     if(iLayer==nSnow+1)then  ! height=0; avoid precision issues\n      fracRootLower = 0._dp\n     else\n      fracRootLower = iLayerHeight(iLayer-1)\/rootingDepth\n     end if\n     fracRootUpper = iLayerHeight(iLayer)\/rootingDepth\n     if(fracRootUpper>1._dp) fracRootUpper=1._dp\n     ! compute the root density\n     mLayerRootDensity(iLayer-nSnow) = fracRootUpper**rootDistExp - fracRootLower**rootDistExp\n   else\n    mLayerRootDensity(iLayer-nSnow) = 0._dp\n   end if\n\n   ! ** option 2: double expoential profile of Zeng et al. (JHM 2001)\n   case(doubleExp)\n    ! compute the cumulative fraction of roots at the top and bottom of the layer\n    fracRootLower = 1._dp - 0.5_dp*(exp(-iLayerHeight(iLayer-1)*rootScaleFactor1) + exp(-iLayerHeight(iLayer-1)*rootScaleFactor2) )\n    fracRootUpper = 1._dp - 0.5_dp*(exp(-iLayerHeight(iLayer  )*rootScaleFactor1) + exp(-iLayerHeight(iLayer  )*rootScaleFactor2) )\n    ! compute the root density\n    mLayerRootDensity(iLayer-nSnow) = fracRootUpper - fracRootLower\n    write(*,'(a,10(f11.5,1x))') 'mLayerRootDensity(iLayer-nSnow), fracRootUpper, fracRootLower = ', &\n                                 mLayerRootDensity(iLayer-nSnow), fracRootUpper, fracRootLower\n\n   ! ** check\n   case default; err=20; message=trim(message)\/\/'unable to identify option for rooting profile'; return\n\n  end select\n\n end do  ! (looping thru layers)\n\n ! check that root density is within some reaosnable version of machine tolerance\n ! This is the case when root density is greater than 1. Can only happen with powerLaw option.\n error = sum(mLayerRootDensity) - 1._dp\n if (error > 2._dp*epsilon(rootingDepth)) then\n  message=trim(message)\/\/'problem with the root density calaculation'\n  err=20; return\n else\n  mLayerRootDensity = mLayerRootDensity - error\/real(nSoil,kind(dp))\n end if\n\n ! compute fraction of roots in the aquifer\n if(sum(mLayerRootDensity) < 1._dp)then\n  scalarAquiferRootFrac = 1._dp - sum(mLayerRootDensity)\n else\n  scalarAquiferRootFrac = 0._dp\n end if\n \n ! check that roots in the aquifer are appropriate\n if ((ixGroundwater \/= bigBucket).and.(scalarAquiferRootFrac > 2._dp*epsilon(rootingDepth)))then\n  if(scalarAquiferRootFrac < rootTolerance) then\n   mLayerRootDensity = mLayerRootDensity + scalarAquiferRootFrac\/real(nSoil, kind(dp))\n   scalarAquiferRootFrac = 0._dp\n  else\n   select case(ixRootProfile)\n    case(powerLaw);  message=trim(message)\/\/'roots in the aquifer only allowed for the big bucket gw parameterization: check that rooting depth < soil depth'\n    case(doubleExp); message=trim(message)\/\/'roots in the aquifer only allowed for the big bucket gw parameterization: increase soil depth to alow for exponential roots'\n   end select\n   err=10; return\n  end if  ! if roots in the aquifer\n end if  ! if not the big bucket\n\n end associate\n\n end subroutine rootDensty\n\n\n ! **********************************************************************************************************\n ! public subroutine satHydCond: compute vertical profile of saturated hydraulic conductivity\n ! **********************************************************************************************************\n subroutine satHydCond(mpar_data,indx_data,prog_data,flux_data,err,message)\n ! model decision structures\n USE globalData,only:model_decisions        ! model decision structure\n USE var_lookup,only:iLookDECISIONS         ! named variables for elements of the decision structure\n ! look-up values for the choice of groundwater parameterization\n USE mDecisions_module,only: &\n  constant,                  & ! constant hydraulic conductivity with depth\n  powerLaw_profile             ! power-law profile\n ! named variables\n USE var_lookup,only:iLookPARAM,iLookINDEX,iLookPROG,iLookFLUX        ! named variables for structure elements\n ! data types\n USE data_types,only:var_dlength    ! x%var(:)%dat (dp)\n USE data_types,only:var_ilength    ! x%var(:)%dat (i4b)\n implicit none\n ! declare input variables\n type(var_dlength),intent(in)    :: mpar_data           ! data structure of model parameters for a local HRU\n type(var_ilength),intent(in)    :: indx_data           ! data structure of model indices for a local HRU\n type(var_dlength),intent(in)    :: prog_data           ! data structure of model prognostic (state) variables for a local HRU\n type(var_dlength),intent(inout) :: flux_data           ! data structure of model fluxes for a local HRU\n ! declare output variables\n integer(i4b),intent(out)        :: err                 ! error code\n character(*),intent(out)        :: message             ! error message\n ! declare local variables\n integer(i4b)                    :: iLayer              ! loop through layers\n real(dp)                        :: ifcDepthScaleFactor ! depth scaling factor (layer interfaces)\n real(dp)                        :: midDepthScaleFactor ! depth scaling factor (layer midpoints)\n ! initialize error control\n err=0; message='satHydCond\/'\n ! ----------------------------------------------------------------------------------\n ! associate variables in data structure\n associate(&\n ! associate the values in the parameter structures\n k_soil             => mpar_data%var(iLookPARAM%k_soil)%dat,            & ! saturated hydraulic conductivity at the compacted depth (m s-1)\n k_macropore        => mpar_data%var(iLookPARAM%k_macropore)%dat,       & ! saturated hydraulic conductivity at the compacted depth for macropores (m s-1)\n compactedDepth     => mpar_data%var(iLookPARAM%compactedDepth)%dat(1), & ! the depth at which k_soil reaches the compacted value given by CH78 (m)\n zScale_TOPMODEL    => mpar_data%var(iLookPARAM%zScale_TOPMODEL)%dat(1),& ! exponent for the TOPMODEL-ish baseflow parameterization (-)\n ! associate the model index structures\n nSnow              => indx_data%var(iLookINDEX%nSnow)%dat(1),          & ! number of snow layers\n nSoil              => indx_data%var(iLookINDEX%nSoil)%dat(1),          & ! number of soil layers\n nLayers            => indx_data%var(iLookINDEX%nLayers)%dat(1),        & ! total number of layers\n ! associate the coordinate variables\n mLayerHeight       => prog_data%var(iLookPROG%mLayerHeight)%dat,       & ! height at the mid-point of each layer (m)\n iLayerHeight       => prog_data%var(iLookPROG%iLayerHeight)%dat,       & ! height at the interface of each layer (m)\n ! associate the values in the model variable structures\n mLayerSatHydCondMP => flux_data%var(ilookFLUX%mlayersathydcondmp)%dat, & ! saturated hydraulic conductivity for macropores at the mid-point of each layer (m s-1)\n mLayerSatHydCond   => flux_data%var(ilookFLUX%mlayersathydcond)%dat,   & ! saturated hydraulic conductivity at the mid-point of each layer (m s-1)\n iLayerSatHydCond   => flux_data%var(ilookFLUX%ilayersathydcond)%dat    & ! saturated hydraulic conductivity at the interface of each layer (m s-1)\n ) ! end associate\n ! ----------------------------------------------------------------------------------\n\n ! loop through soil layers\n ! NOTE: could do constant profile with the power-law profile with exponent=1, but keep constant profile decision for clarity\n do iLayer=nSnow,nLayers\n  select case(model_decisions(iLookDECISIONS%hc_profile)%iDecision)\n\n   ! constant hydraulic conductivity with depth\n   case(constant)\n    ! - conductivity at layer interfaces \n    !   --> NOTE: Do we need a weighted average based on layer depth for interior layers?\n    if(iLayer==nSnow)then\n     iLayerSatHydCond(iLayer-nSnow) = k_soil(1)\n    else\n     if(iLayer==nLayers)then\n      iLayerSatHydCond(iLayer-nSnow) = k_soil(nSoil)\n     else\n      iLayerSatHydCond(iLayer-nSnow)   = 0.5_dp * (k_soil(iLayer-nSnow) + k_soil(iLayer+1-nSnow) )\n     endif\n     ! - conductivity at layer midpoints\n     mLayerSatHydCond(iLayer-nSnow)   = k_soil(iLayer-nSnow)\n     mLayerSatHydCondMP(iLayer-nSnow) = k_macropore(iLayer-nSnow)\n    end if ! if iLayer>nSnow\n\n   ! power-law profile\n   case(powerLaw_profile)\n    ! - conductivity at layer interfaces \n    !   --> NOTE: Do we need a weighted average based on layer depth for interior layers?\n    ifcDepthScaleFactor = ( (1._dp - iLayerHeight(iLayer)\/iLayerHeight(nLayers))**(zScale_TOPMODEL - 1._dp) ) \/ &\n                          ( (1._dp -       compactedDepth\/iLayerHeight(nLayers))**(zScale_TOPMODEL - 1._dp) ) \n    if(iLayer==nSnow)then\n     iLayerSatHydCond(iLayer-nSnow) = k_soil(1) * ifcDepthScaleFactor\n    else\n     if(iLayer==nLayers)then\n      iLayerSatHydCond(iLayer-nSnow) = k_soil(nSoil) * ifcDepthScaleFactor\n     else\n      iLayerSatHydCond(iLayer-nSnow)   = 0.5_dp * (k_soil(iLayer-nSnow) + k_soil(iLayer+1-nSnow) ) * ifcDepthScaleFactor\n     endif\n     ! - conductivity at layer midpoints\n     midDepthScaleFactor = ( (1._dp - mLayerHeight(iLayer)\/iLayerHeight(nLayers))**(zScale_TOPMODEL - 1._dp) ) \/ &\n                           ( (1._dp -       compactedDepth\/iLayerHeight(nLayers))**(zScale_TOPMODEL - 1._dp) )\n     mLayerSatHydCond(iLayer-nSnow)   = k_soil(iLayer-nSnow)      * midDepthScaleFactor\n     mLayerSatHydCondMP(iLayer-nSnow) = k_macropore(iLayer-nSnow) * midDepthScaleFactor\n     !print*, 'compactedDepth = ', compactedDepth\n     !print*, 'k_macropore    = ', k_macropore\n     !print*, 'mLayerHeight(iLayer) = ', mLayerHeight(iLayer)\n     !print*, 'iLayerHeight(nLayers) = ', iLayerHeight(nLayers)\n     !print*, 'iLayer, mLayerSatHydCondMP(iLayer-nSnow) = ', mLayerSatHydCondMP(iLayer-nSnow)\n    end if  ! if the mid-point of a layer\n\n   ! error check (errors checked earlier also, so should not get here)\n   case default\n    message=trim(message)\/\/\"unknown hydraulic conductivity profile [option=\"\/\/trim(model_decisions(iLookDECISIONS%hc_profile)%cDecision)\/\/\"]\"\n    err=10; return\n\n  end select\n  !if(iLayer > nSnow)& ! avoid layer 0\n  ! write(*,'(a,1x,i4,1x,2(f11.5,1x,e20.10,1x))') 'satHydCond: ', iLayer, mLayerHeight(iLayer), mLayerSatHydCond(iLayer-nSnow), iLayerHeight(iLayer), iLayerSatHydCond(iLayer-nSnow)\n end do  ! looping through soil layers\n !print*, trim(model_decisions(iLookDECISIONS%hc_profile)%cDecision)\n !print*, 'k_soil, k_macropore, zScale_TOPMODEL = ', k_soil, k_macropore, zScale_TOPMODEL\n !pause ' in satHydCond'\n end associate\n\n end subroutine satHydCond\n\n\n ! **********************************************************************************************************\n ! public subroutine fracFuture: compute the fraction of runoff in future time steps\n ! **********************************************************************************************************\n subroutine fracFuture(bpar_data,bvar_data,err,message)\n ! external functions\n USE soil_utils_module,only:gammp                     ! compute the cumulative probabilty based on the Gamma distribution\n ! model decision structures\n USE globalData,only:model_decisions                  ! model decision structure\n USE var_lookup,only:iLookDECISIONS                   ! named variables for elements of the decision structure\n ! look-up values for the sub-grid routing method\n USE mDecisions_module,only:      &\n  timeDelay,&  ! time-delay histogram\n  qInstant     ! instantaneous routing\n ! named variables \n USE globalData,only:data_step                        ! time step of forcing data\n USE var_lookup,only:iLookBVAR,iLookBPAR              ! named variables for structure elements\n ! data types\n USE data_types,only:var_dlength    ! x%var(:)%dat (dp)\n implicit none\n ! input variables\n real(dp),intent(in)             :: bpar_data(:)           ! vector of basin-average model parameters\n ! output variables\n type(var_dlength),intent(inout) :: bvar_data              ! data structure of basin-average model variables\n integer(i4b),intent(out)        :: err                    ! error code\n character(*),intent(out)        :: message                ! error message\n ! internal\n real(dp)                        :: dt                     ! data time step (s)\n integer(i4b)                    :: nTDH                   ! number of points in the time-delay histogram\n integer(i4b)                    :: iFuture                ! index in time delay histogram\n real(dp)                        :: aLambda                ! scale parameter in the Gamma distribution\n real(dp)                        :: tFuture                ! future time (end of step)\n real(dp)                        :: pSave                  ! cumulative probability at the start of the step\n real(dp)                        :: cumProb                ! cumulative probability at the end of the step\n real(dp)                        :: sumFrac                ! sum of runoff fractions in all steps\n real(dp),parameter              :: tolerFrac=0.01_dp      ! tolerance for fractional runoff\n ! initialize error control\n err=0; message='fracFuture\/'\n ! ----------------------------------------------------------------------------------\n ! associate variables in data structure\n associate(&\n ixRouting         => model_decisions(iLookDECISIONS%subRouting)%iDecision, & ! index for routing method\n routingGammaShape => bpar_data(iLookBPAR%routingGammaShape),               & ! shape parameter in Gamma distribution used for sub-grid routing (-)\n routingGammaScale => bpar_data(iLookBPAR%routingGammaScale),               & ! scale parameter in Gamma distribution used for sub-grid routing (s)\n runoffFuture      => bvar_data%var(iLookBVAR%routingRunoffFuture)%dat,     & ! runoff in future time steps (m s-1)\n fractionFuture    => bvar_data%var(iLookBVAR%routingFractionFuture)%dat    & ! fraction of runoff in future time steps (-)\n ) ! end associate\n ! ----------------------------------------------------------------------------------\n\n ! define time step\n dt =  data_step ! length of the data step (s)\n\n ! identify number of points in the time-delay histogram\n nTDH = size(runoffFuture)\n\n ! initialize runoffFuture\n runoffFuture(1:nTDH) = 0._dp\n\n !print*, 'nTDH = ', nTDH\n\n ! select option for sub-grid routing\n select case(ixRouting)\n\n  ! ** instantaneous routing\n  case(qInstant)\n   fractionFuture(1)      = 1._dp\n   fractionFuture(2:nTDH) = 0._dp\n\n  ! ** time delay histogram\n  case(timeDelay)\n   ! initialize\n   pSave   = 0._dp ! cumulative probability at the start of the step\n   aLambda = routingGammaShape \/ routingGammaScale\n   if(routingGammaShape <= 0._dp .or. aLambda < 0._dp)then\n    message=trim(message)\/\/'bad arguments for the Gamma distribution'\n    err=20; return\n   end if\n   ! loop through time steps and compute fraction of runoff in future steps\n   do iFuture = 1,nTDH\n    tFuture = real(iFuture, kind(dt))*dt                  ! future time (end of step)\n    cumProb = gammp(routingGammaShape,aLambda*tFuture)    ! cumulative probability at the end of the step\n    fractionFuture(iFuture) = max(0._dp, cumProb - pSave) ! fraction of runoff in the current step\n    pSave   = cumProb                                     ! save the cumulative probability for use in the next step\n    if(fractionFuture(iFuture) < tiny(dt))then\n     fractionFuture(iFuture:nTDH) = 0._dp\n     exit\n    end if\n    !write(*,'(a,1x,i4,1x,3(f20.10,1x))') trim(message), iFuture, tFuture, cumProb, fractionFuture(iFuture)\n   end do ! (looping through future time steps)\n   ! check that we have enough bins\n   sumFrac  = sum(fractionFuture)\n   if(abs(1._dp - sumFrac) > tolerFrac)then\n    message=trim(message)\/\/'not enough bins for the time delay histogram -- fix hard-coded parameter in alloc_bvar'\n    err=20; return\n   end if\n   ! ensure the fraction sums to one\n   fractionFuture = fractionFuture\/sumFrac\n\n  ! ** error checking\n  case default; err=20; message=trim(message)\/\/'cannot find option for sub-grid routing'; return\n\n end select ! (select option for sub-grid routing)\n\n end associate\n\n end subroutine fracFuture\n\n\n ! **********************************************************************************************************\n ! public subroutine v_shortcut: compute \"short-cut\" variables\n ! **********************************************************************************************************\n subroutine v_shortcut(mpar_data,diag_data,err,message)\n ! named variables\n USE var_lookup,only:iLookPARAM,iLookDIAG      ! named variables for structure elements\n ! data types\n USE data_types,only:var_dlength    ! x%var(:)%dat (dp)\n implicit none\n ! declare input variables\n type(var_dlength),intent(in)    :: mpar_data       ! data structure of model parameters for a local HRU\n type(var_dlength),intent(inout) :: diag_data       ! data structure of model variables for a local HRU\n ! declare output variables\n integer(i4b),intent(out)        :: err             ! error code\n character(*),intent(out)        :: message         ! error message\n ! initialize error control\n err=0; message='v_shortcut\/'\n ! ----------------------------------------------------------------------------------\n ! associate variables in data structure\n associate(&\n ! associate values in the parameter structures\n vGn_n          =>mpar_data%var(iLookPARAM%vGn_n)%dat,                  & ! van Genutchen \"n\" parameter (-)\n vGn_m          =>diag_data%var(iLookDIAG%scalarVGn_m)%dat              & ! van Genutchen \"m\" parameter (-)\n ) ! end associate\n ! ----------------------------------------------------------------------------------\n\n ! compute the van Genutchen \"m\" parameter\n vGn_m = 1._dp - 1._dp\/vGn_n\n end associate\n\n end subroutine v_shortcut\n\n\nend module var_derive_module\n","avg_line_length":53.322,"max_line_length":180,"alphanum_fraction":0.6355725592,"licenses":["Apache-2.0"],"repository_name":"Hyunglok-Kim\/LISF","path":"lis\/surfacemodels\/land\/summa.1.0\/engine\/var_derive_module.f90","size":26661,"lang":"FORTRAN"}
{"content":"Param()\n\n$branchName   = $env:BUILD_SOURCEBRANCHNAME\n$taskJsonPath = '.\\DedupeGitReposV0\\task.json'\n\nfunction ConvertTo-SemVer($version){\n    $version -match \"^(?<major>\\d+)(\\.(?<minor>\\d+))?(\\.(?<patch>\\d+))?(\\-(?<pre>[0-9A-Za-z\\-\\.]+))?(\\+(?<build>[0-9A-Za-z\\-\\.]+))?$\" | Out-Null\n    $major = [int]$matches['major']\n    $minor = [int]$matches['minor']\n    $patch = [int]$matches['patch']\n    \n    if($null -eq $matches['pre']){$pre = @()}\n    else{$pre = $matches['pre'].Split(\".\")}\n\n    New-Object PSObject -Property @{ \n        Major = $major\n        Minor = $minor\n        Patch = $patch\n        Pre = $pre\n        VersionString = $version\n        }\n}\n\n$taskJson     = Get-Content $taskJsonPath | ConvertFrom-Json\n$semVer       = ConvertTo-SemVer $branchName.TrimStart('v')\n\n$taskJson.version.Major = $semVer.Major\n$taskJson.version.Minor = $semVer.Minor\n$taskJson.version.Patch = $semVer.Patch\n$taskJson.preview       = $semVer.Pre.Length -gt 0\n\n$taskJson | ConvertTo-Json -Depth 5 | Set-Content $taskJsonPath","avg_line_length":31.75,"max_line_length":144,"alphanum_fraction":0.5984251969,"licenses":["MIT"],"repository_name":"OrbisInvestments\/azure-pipelines-custom-tasks","path":"UpdateTaskVersion.ps1","size":1016,"lang":"PowerShell"}
{"content":"module VCAP::CloudController\n  class LabelError < Struct.new(:is_valid?, :message)\n    def self.error(message)\n      LabelError.new(false, message)\n    end\n\n    def self.none\n      @none ||= LabelError.new(true)\n    end\n\n    def to_s\n      \"#<LabelError is_valid:#{is_valid?} message:#{message}\"\n    end\n  end\nend\n","avg_line_length":19.625,"max_line_length":61,"alphanum_fraction":0.6433121019,"licenses":["Apache-2.0"],"repository_name":"adobley\/cloud_controller_ng","path":"app\/models\/helpers\/label_error.rb","size":314,"lang":"Ruby"}
{"content":"#!\/usr\/bin\/env perl\n\n$hash_func = 'python \/Users\/sakane\/work\/lang\/python\/test_sha1.py';\n\n$prefix = 'http:\/\/fiap.tanu.org\/test\/alps';\n\n@id = qw\/e7 f1 f7 f6\/;\n@obj = qw@\ntemperature\ntemperature\/max\ntemperature\/min\ntemperature\/avr\nhumidity\nhumidity\/max\nhumidity\/min\nhumidity\/avr\npressure\nlight\nwater\nbattery\nrssi\n@;\n&pmap(\\@id, \\@obj);\n\n@id = (d6);\n@obj = qw@\ncurrent\ncurrent\/max\ncurrent\/min\ncurrent\/avr\nbattery\nrssi\n@;\n&pmap(\\@id, \\@obj);\n\nsub pmap\n{\n\tmy ($id, $obj) = @_;\n\n\tfor $i (@$id) {\n\t\tfor $j (@$obj) {\n\t\t\t$pid = sprintf(\"%s\/%s\/%s\", $prefix, $i, $j);\n\t\t\tchomp($hash = `$hash_func $pid`);\n\t\t\tprint <<EOD;\n{ \"$pid\",\n  \"$hash\" },\nEOD\n\t\t}\n\t}\n}\n","avg_line_length":12.6470588235,"max_line_length":66,"alphanum_fraction":0.6139534884,"licenses":["MIT"],"repository_name":"tanupoo\/kiwi","path":"tool\/make_keymap.pl","size":645,"lang":"Perl"}
{"content":"#!\/usr\/bin\/env python\nimport os\nimport sys\n\nif __name__ == \"__main__\":\n    os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"snippets_java.settings\")\n\n    from django.core.management import execute_from_command_line\n\n    execute_from_command_line(sys.argv)\n","avg_line_length":23.2727272727,"max_line_length":77,"alphanum_fraction":0.77734375,"licenses":["MIT"],"repository_name":"edilio\/snippets-javaos","path":"snippets_java\/manage.py","size":256,"lang":"Python"}
{"content":"\/*! jQuery UI - v1.10.3 - 2013-09-10\n* http:\/\/jqueryui.com\n* Copyright 2013 jQuery Foundation and other contributors; Licensed MIT *\/\n\n.ui-widget{font-family:Verdana,Arial,sans-serif;font-size:1.1em}.ui-widget .ui-widget{font-size:1em}.ui-widget input,.ui-widget select,.ui-widget textarea,.ui-widget button{font-family:Verdana,Arial,sans-serif;font-size:1em}.ui-widget-content{border:1px solid #a6c9e2;background:#fcfdfd url(images\/ui-bg_inset-hard_100_fcfdfd_1x100.png) 50% bottom repeat-x;color:#222}.ui-widget-content a{color:#222}.ui-widget-header{border:1px solid #4297d7;background:#2191c0 url(images\/ui-bg_gloss-wave_75_2191c0_500x100.png) 50% 50% repeat-x;color:#eaf5f7;font-weight:bold}.ui-widget-header a{color:#eaf5f7}.ui-state-default,.ui-widget-content .ui-state-default,.ui-widget-header .ui-state-default{border:1px solid #77d5f7;background:#0078ae url(images\/ui-bg_glass_45_0078ae_1x400.png) 50% 50% repeat-x;font-weight:normal;color:#fff}.ui-state-default a,.ui-state-default a:link,.ui-state-default a:visited{color:#fff;text-decoration:none}.ui-state-hover,.ui-widget-content .ui-state-hover,.ui-widget-header .ui-state-hover,.ui-state-focus,.ui-widget-content .ui-state-focus,.ui-widget-header .ui-state-focus{border:1px solid #448dae;background:#79c9ec url(images\/ui-bg_glass_75_79c9ec_1x400.png) 50% 50% repeat-x;font-weight:normal;color:#026890}.ui-state-hover a,.ui-state-hover a:hover,.ui-state-hover a:link,.ui-state-hover a:visited{color:#026890;text-decoration:none}.ui-state-active,.ui-widget-content .ui-state-active,.ui-widget-header .ui-state-active{border:1px solid #acdd4a;background:#6eac2c url(images\/ui-bg_gloss-wave_50_6eac2c_500x100.png) 50% 50% repeat-x;font-weight:normal;color:#fff}.ui-state-active a,.ui-state-active a:link,.ui-state-active a:visited{color:#fff;text-decoration:none}.ui-state-highlight,.ui-widget-content .ui-state-highlight,.ui-widget-header .ui-state-highlight{border:1px solid #fcd113;background:#f8da4e url(images\/ui-bg_glass_55_f8da4e_1x400.png) 50% 50% repeat-x;color:#915608}.ui-state-highlight a,.ui-widget-content .ui-state-highlight a,.ui-widget-header .ui-state-highlight a{color:#915608}.ui-state-error,.ui-widget-content .ui-state-error,.ui-widget-header .ui-state-error{border:1px solid #cd0a0a;background:#e14f1c url(images\/ui-bg_gloss-wave_45_e14f1c_500x100.png) 50% top repeat-x;color:#fff}.ui-state-error a,.ui-widget-content .ui-state-error a,.ui-widget-header .ui-state-error a{color:#fff}.ui-state-error-text,.ui-widget-content .ui-state-error-text,.ui-widget-header .ui-state-error-text{color:#fff}.ui-priority-primary,.ui-widget-content .ui-priority-primary,.ui-widget-header .ui-priority-primary{font-weight:bold}.ui-priority-secondary,.ui-widget-content .ui-priority-secondary,.ui-widget-header .ui-priority-secondary{opacity:.7;filter:Alpha(Opacity=70);font-weight:normal}.ui-state-disabled,.ui-widget-content .ui-state-disabled,.ui-widget-header .ui-state-disabled{opacity:.35;filter:Alpha(Opacity=35);background-image:none}.ui-state-disabled .ui-icon{filter:Alpha(Opacity=35)}.ui-icon{width:16px;height:16px}.ui-icon,.ui-widget-content .ui-icon{background-image:url(images\/ui-icons_0078ae_256x240.png)}.ui-widget-header .ui-icon{background-image:url(images\/ui-icons_d8e7f3_256x240.png)}.ui-state-default .ui-icon{background-image:url(images\/ui-icons_e0fdff_256x240.png)}.ui-state-hover .ui-icon,.ui-state-focus .ui-icon{background-image:url(images\/ui-icons_056b93_256x240.png)}.ui-state-active .ui-icon{background-image:url(images\/ui-icons_f5e175_256x240.png)}.ui-state-highlight .ui-icon{background-image:url(images\/ui-icons_f7a50d_256x240.png)}.ui-state-error .ui-icon,.ui-state-error-text .ui-icon{background-image:url(images\/ui-icons_fcd113_256x240.png)}.ui-icon-blank{background-position:16px 16px}.ui-icon-carat-1-n{background-position:0 0}.ui-icon-carat-1-ne{background-position:-16px 0}.ui-icon-carat-1-e{background-position:-32px 0}.ui-icon-carat-1-se{background-position:-48px 0}.ui-icon-carat-1-s{background-position:-64px 0}.ui-icon-carat-1-sw{background-position:-80px 0}.ui-icon-carat-1-w{background-position:-96px 0}.ui-icon-carat-1-nw{background-position:-112px 0}.ui-icon-carat-2-n-s{background-position:-128px 0}.ui-icon-carat-2-e-w{background-position:-144px 0}.ui-icon-triangle-1-n{background-position:0 -16px}.ui-icon-triangle-1-ne{background-position:-16px -16px}.ui-icon-triangle-1-e{background-position:-32px -16px}.ui-icon-triangle-1-se{background-position:-48px -16px}.ui-icon-triangle-1-s{background-position:-64px -16px}.ui-icon-triangle-1-sw{background-position:-80px -16px}.ui-icon-triangle-1-w{background-position:-96px -16px}.ui-icon-triangle-1-nw{background-position:-112px -16px}.ui-icon-triangle-2-n-s{background-position:-128px -16px}.ui-icon-triangle-2-e-w{background-position:-144px -16px}.ui-icon-arrow-1-n{background-position:0 -32px}.ui-icon-arrow-1-ne{background-position:-16px -32px}.ui-icon-arrow-1-e{background-position:-32px -32px}.ui-icon-arrow-1-se{background-position:-48px -32px}.ui-icon-arrow-1-s{background-position:-64px -32px}.ui-icon-arrow-1-sw{background-position:-80px -32px}.ui-icon-arrow-1-w{background-position:-96px -32px}.ui-icon-arrow-1-nw{background-position:-112px -32px}.ui-icon-arrow-2-n-s{background-position:-128px -32px}.ui-icon-arrow-2-ne-sw{background-position:-144px -32px}.ui-icon-arrow-2-e-w{background-position:-160px -32px}.ui-icon-arrow-2-se-nw{background-position:-176px -32px}.ui-icon-arrowstop-1-n{background-position:-192px -32px}.ui-icon-arrowstop-1-e{background-position:-208px -32px}.ui-icon-arrowstop-1-s{background-position:-224px -32px}.ui-icon-arrowstop-1-w{background-position:-240px -32px}.ui-icon-arrowthick-1-n{background-position:0 -48px}.ui-icon-arrowthick-1-ne{background-position:-16px -48px}.ui-icon-arrowthick-1-e{background-position:-32px -48px}.ui-icon-arrowthick-1-se{background-position:-48px -48px}.ui-icon-arrowthick-1-s{background-position:-64px -48px}.ui-icon-arrowthick-1-sw{background-position:-80px -48px}.ui-icon-arrowthick-1-w{background-position:-96px -48px}.ui-icon-arrowthick-1-nw{background-position:-112px -48px}.ui-icon-arrowthick-2-n-s{background-position:-128px -48px}.ui-icon-arrowthick-2-ne-sw{background-position:-144px -48px}.ui-icon-arrowthick-2-e-w{background-position:-160px -48px}.ui-icon-arrowthick-2-se-nw{background-position:-176px -48px}.ui-icon-arrowthickstop-1-n{background-position:-192px -48px}.ui-icon-arrowthickstop-1-e{background-position:-208px -48px}.ui-icon-arrowthickstop-1-s{background-position:-224px -48px}.ui-icon-arrowthickstop-1-w{background-position:-240px -48px}.ui-icon-arrowreturnthick-1-w{background-position:0 -64px}.ui-icon-arrowreturnthick-1-n{background-position:-16px -64px}.ui-icon-arrowreturnthick-1-e{background-position:-32px -64px}.ui-icon-arrowreturnthick-1-s{background-position:-48px -64px}.ui-icon-arrowreturn-1-w{background-position:-64px -64px}.ui-icon-arrowreturn-1-n{background-position:-80px -64px}.ui-icon-arrowreturn-1-e{background-position:-96px -64px}.ui-icon-arrowreturn-1-s{background-position:-112px -64px}.ui-icon-arrowrefresh-1-w{background-position:-128px -64px}.ui-icon-arrowrefresh-1-n{background-position:-144px -64px}.ui-icon-arrowrefresh-1-e{background-position:-160px -64px}.ui-icon-arrowrefresh-1-s{background-position:-176px -64px}.ui-icon-arrow-4{background-position:0 -80px}.ui-icon-arrow-4-diag{background-position:-16px -80px}.ui-icon-extlink{background-position:-32px -80px}.ui-icon-newwin{background-position:-48px -80px}.ui-icon-refresh{background-position:-64px -80px}.ui-icon-shuffle{background-position:-80px -80px}.ui-icon-transfer-e-w{background-position:-96px -80px}.ui-icon-transferthick-e-w{background-position:-112px -80px}.ui-icon-folder-collapsed{background-position:0 -96px}.ui-icon-folder-open{background-position:-16px -96px}.ui-icon-document{background-position:-32px -96px}.ui-icon-document-b{background-position:-48px -96px}.ui-icon-note{background-position:-64px -96px}.ui-icon-mail-closed{background-position:-80px -96px}.ui-icon-mail-open{background-position:-96px -96px}.ui-icon-suitcase{background-position:-112px -96px}.ui-icon-comment{background-position:-128px -96px}.ui-icon-person{background-position:-144px -96px}.ui-icon-print{background-position:-160px -96px}.ui-icon-trash{background-position:-176px -96px}.ui-icon-locked{background-position:-192px -96px}.ui-icon-unlocked{background-position:-208px -96px}.ui-icon-bookmark{background-position:-224px -96px}.ui-icon-tag{background-position:-240px -96px}.ui-icon-home{background-position:0 -112px}.ui-icon-flag{background-position:-16px -112px}.ui-icon-calendar{background-position:-32px -112px}.ui-icon-cart{background-position:-48px -112px}.ui-icon-pencil{background-position:-64px -112px}.ui-icon-clock{background-position:-80px -112px}.ui-icon-disk{background-position:-96px -112px}.ui-icon-calculator{background-position:-112px -112px}.ui-icon-zoomin{background-position:-128px -112px}.ui-icon-zoomout{background-position:-144px -112px}.ui-icon-search{background-position:-160px -112px}.ui-icon-wrench{background-position:-176px -112px}.ui-icon-gear{background-position:-192px -112px}.ui-icon-heart{background-position:-208px -112px}.ui-icon-star{background-position:-224px -112px}.ui-icon-link{background-position:-240px -112px}.ui-icon-cancel{background-position:0 -128px}.ui-icon-plus{background-position:-16px -128px}.ui-icon-plusthick{background-position:-32px -128px}.ui-icon-minus{background-position:-48px -128px}.ui-icon-minusthick{background-position:-64px -128px}.ui-icon-close{background-position:-80px -128px}.ui-icon-closethick{background-position:-96px -128px}.ui-icon-key{background-position:-112px -128px}.ui-icon-lightbulb{background-position:-128px -128px}.ui-icon-scissors{background-position:-144px -128px}.ui-icon-clipboard{background-position:-160px -128px}.ui-icon-copy{background-position:-176px -128px}.ui-icon-contact{background-position:-192px -128px}.ui-icon-image{background-position:-208px -128px}.ui-icon-video{background-position:-224px -128px}.ui-icon-script{background-position:-240px -128px}.ui-icon-alert{background-position:0 -144px}.ui-icon-info{background-position:-16px -144px}.ui-icon-notice{background-position:-32px -144px}.ui-icon-help{background-position:-48px -144px}.ui-icon-check{background-position:-64px -144px}.ui-icon-bullet{background-position:-80px -144px}.ui-icon-radio-on{background-position:-96px -144px}.ui-icon-radio-off{background-position:-112px -144px}.ui-icon-pin-w{background-position:-128px -144px}.ui-icon-pin-s{background-position:-144px -144px}.ui-icon-play{background-position:0 -160px}.ui-icon-pause{background-position:-16px -160px}.ui-icon-seek-next{background-position:-32px -160px}.ui-icon-seek-prev{background-position:-48px -160px}.ui-icon-seek-end{background-position:-64px -160px}.ui-icon-seek-start{background-position:-80px -160px}.ui-icon-seek-first{background-position:-80px -160px}.ui-icon-stop{background-position:-96px -160px}.ui-icon-eject{background-position:-112px -160px}.ui-icon-volume-off{background-position:-128px -160px}.ui-icon-volume-on{background-position:-144px -160px}.ui-icon-power{background-position:0 -176px}.ui-icon-signal-diag{background-position:-16px -176px}.ui-icon-signal{background-position:-32px -176px}.ui-icon-battery-0{background-position:-48px -176px}.ui-icon-battery-1{background-position:-64px -176px}.ui-icon-battery-2{background-position:-80px -176px}.ui-icon-battery-3{background-position:-96px -176px}.ui-icon-circle-plus{background-position:0 -192px}.ui-icon-circle-minus{background-position:-16px -192px}.ui-icon-circle-close{background-position:-32px -192px}.ui-icon-circle-triangle-e{background-position:-48px -192px}.ui-icon-circle-triangle-s{background-position:-64px -192px}.ui-icon-circle-triangle-w{background-position:-80px -192px}.ui-icon-circle-triangle-n{background-position:-96px -192px}.ui-icon-circle-arrow-e{background-position:-112px -192px}.ui-icon-circle-arrow-s{background-position:-128px -192px}.ui-icon-circle-arrow-w{background-position:-144px -192px}.ui-icon-circle-arrow-n{background-position:-160px -192px}.ui-icon-circle-zoomin{background-position:-176px -192px}.ui-icon-circle-zoomout{background-position:-192px -192px}.ui-icon-circle-check{background-position:-208px -192px}.ui-icon-circlesmall-plus{background-position:0 -208px}.ui-icon-circlesmall-minus{background-position:-16px -208px}.ui-icon-circlesmall-close{background-position:-32px -208px}.ui-icon-squaresmall-plus{background-position:-48px -208px}.ui-icon-squaresmall-minus{background-position:-64px -208px}.ui-icon-squaresmall-close{background-position:-80px -208px}.ui-icon-grip-dotted-vertical{background-position:0 -224px}.ui-icon-grip-dotted-horizontal{background-position:-16px -224px}.ui-icon-grip-solid-vertical{background-position:-32px -224px}.ui-icon-grip-solid-horizontal{background-position:-48px -224px}.ui-icon-gripsmall-diagonal-se{background-position:-64px -224px}.ui-icon-grip-diagonal-se{background-position:-80px -224px}.ui-corner-all,.ui-corner-top,.ui-corner-left,.ui-corner-tl{border-top-left-radius:5px}.ui-corner-all,.ui-corner-top,.ui-corner-right,.ui-corner-tr{border-top-right-radius:5px}.ui-corner-all,.ui-corner-bottom,.ui-corner-left,.ui-corner-bl{border-bottom-left-radius:5px}.ui-corner-all,.ui-corner-bottom,.ui-corner-right,.ui-corner-br{border-bottom-right-radius:5px}.ui-widget-overlay{background:#aaa url(images\/ui-bg_flat_75_aaaaaa_40x100.png) 50% 50% repeat-x;opacity:.3;filter:Alpha(Opacity=30)}.ui-widget-shadow{margin:5px 0 0 5px;padding:0;background:#999 url(images\/ui-bg_flat_55_999999_40x100.png) 50% 50% repeat-x;opacity:.45;filter:Alpha(Opacity=45);border-radius:5px}","avg_line_length":2740.0,"max_line_length":13565,"alphanum_fraction":0.7909489051,"licenses":["MIT"],"repository_name":"ldsink\/ScholarshipManagementSystem","path":"ScholarshipManagementSystem\/Content\/jquery-ui-1.10.3.start\/development-bundle\/themes\/start\/minified\/jquery.ui.theme.min.css","size":13700,"lang":"CSS"}
{"content":"# $NetBSD: Makefile,v 1.8 2021\/05\/24 19:50:37 wiz Exp $\n\nDISTNAME=\tExtUtils-CChecker-0.10\nPKGNAME=\tp5-${DISTNAME}\nPKGREVISION=\t4\nCATEGORIES=\tdevel\nMASTER_SITES=\t${MASTER_SITE_PERL_CPAN:=..\/..\/authors\/id\/P\/PE\/PEVANS\/}\n\nMAINTAINER=\tpkgsrc-users@NetBSD.org\nHOMEPAGE=\thttps:\/\/metacpan.org\/pod\/ExtUtils::CChecker\nCOMMENT=\tPerl5 configure-check utilities\nLICENSE=\t${PERL5_LICENSE}\n\nPERL5_MODULE_TYPE=\tModule::Build\nPERL5_PACKLIST=\t\tauto\/ExtUtils\/CChecker\/.packlist\nUSE_LANGUAGES=\t\tc\n\n.include \"..\/..\/lang\/perl5\/module.mk\"\n.include \"..\/..\/mk\/bsd.pkg.mk\"\n","avg_line_length":27.35,"max_line_length":69,"alphanum_fraction":0.7531992687,"licenses":["Unlicense"],"repository_name":"Scottx86-64\/dotfiles-1","path":"source\/pkgsrc\/devel\/p5-ExtUtils-CChecker\/Makefile","size":547,"lang":"Makefile"}
{"content":"\\hypertarget{classglm_1_1dont__care}{}\\section{glm\\+:\\+:dont\\+\\_\\+care Class Reference}\n\\label{classglm_1_1dont__care}\\index{glm\\+::dont\\+\\_\\+care@{glm\\+::dont\\+\\_\\+care}}\n\n\n{\\ttfamily \\#include $<$hint.\\+hpp$>$}\n\n\n\n\\subsection{Detailed Description}\n\n\nDefinition at line 35 of file hint.\\+hpp.\n\n\n\nThe documentation for this class was generated from the following file\\+:\\begin{DoxyCompactItemize}\n\\item \nthird-\\\/party\/include\/glm\/detail\/\\hyperlink{hint_8hpp}{hint.\\+hpp}\\end{DoxyCompactItemize}\n","avg_line_length":26.0526315789,"max_line_length":99,"alphanum_fraction":0.7333333333,"licenses":["MIT"],"repository_name":"Exomus\/LaraCraft","path":"documentation\/latex\/classglm_1_1dont__care.tex","size":495,"lang":"TeX"}
{"content":"package vald\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\/ioutil\"\n\t\"os\"\n\t\"os\/signal\"\n\t\"path\/filepath\"\n\t\"strings\"\n\t\"sync\"\n\t\"syscall\"\n\t\"time\"\n\n\ttmEvents \"github.com\/axelarnetwork\/tm-events\/events\"\n\t\"github.com\/axelarnetwork\/tm-events\/pubsub\"\n\t\"github.com\/axelarnetwork\/utils\/jobs\"\n\t\"github.com\/cosmos\/cosmos-sdk\/client\"\n\tsdkClient \"github.com\/cosmos\/cosmos-sdk\/client\"\n\t\"github.com\/cosmos\/cosmos-sdk\/client\/flags\"\n\t\"github.com\/cosmos\/cosmos-sdk\/client\/tx\"\n\t\"github.com\/cosmos\/cosmos-sdk\/codec\"\n\t\"github.com\/cosmos\/cosmos-sdk\/server\"\n\tsdk \"github.com\/cosmos\/cosmos-sdk\/types\"\n\tsdkerrors \"github.com\/cosmos\/cosmos-sdk\/types\/errors\"\n\t\"github.com\/spf13\/cobra\"\n\t\"github.com\/tendermint\/tendermint\/libs\/log\"\n\trpcclient \"github.com\/tendermint\/tendermint\/rpc\/client\"\n\n\t\"github.com\/axelarnetwork\/axelar-core\/cmd\/axelard\/cmd\/vald\/config\"\n\n\t\"github.com\/axelarnetwork\/axelar-core\/app\"\n\t\"github.com\/axelarnetwork\/axelar-core\/cmd\/axelard\/cmd\/utils\"\n\t\"github.com\/axelarnetwork\/axelar-core\/cmd\/axelard\/cmd\/vald\/broadcaster\"\n\tbroadcasterTypes \"github.com\/axelarnetwork\/axelar-core\/cmd\/axelard\/cmd\/vald\/broadcaster\/types\"\n\t\"github.com\/axelarnetwork\/axelar-core\/cmd\/axelard\/cmd\/vald\/evm\"\n\tevmRPC \"github.com\/axelarnetwork\/axelar-core\/cmd\/axelard\/cmd\/vald\/evm\/rpc\"\n\t\"github.com\/axelarnetwork\/axelar-core\/cmd\/axelard\/cmd\/vald\/tss\"\n\tutils2 \"github.com\/axelarnetwork\/axelar-core\/utils\"\n\tevmTypes \"github.com\/axelarnetwork\/axelar-core\/x\/evm\/types\"\n\t\"github.com\/axelarnetwork\/axelar-core\/x\/tss\/tofnd\"\n\ttssTypes \"github.com\/axelarnetwork\/axelar-core\/x\/tss\/types\"\n)\n\n\/\/ RW grants -rw------- file permissions\nconst RW = 0600\n\n\/\/ RWX grants -rwx------ file permissions\nconst RWX = 0700\n\nvar once sync.Once\nvar cleanupCommands []func()\n\n\/\/ GetValdCommand returns the command to start vald\nfunc GetValdCommand() *cobra.Command {\n\tcmd := &cobra.Command{\n\t\tUse: \"vald-start\",\n\t\tPreRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\tserverCtx := server.GetServerContextFromCmd(cmd)\n\t\t\tif !cmd.Flags().Changed(flags.FlagFrom) {\n\t\t\t\tif err := cmd.Flags().Set(flags.FlagFrom, serverCtx.Viper.GetString(\"broadcast.broadcaster-account\")); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\tserverCtx := server.GetServerContextFromCmd(cmd)\n\t\t\tlogger := serverCtx.Logger.With(\"module\", \"vald\")\n\n\t\t\t\/\/ in case of panic we still want to try and cleanup resources,\n\t\t\t\/\/ but we have to make sure it's not called more than once if the program is stopped by an interrupt signal\n\t\t\tdefer once.Do(cleanUp)\n\n\t\t\tsigs := make(chan os.Signal, 1)\n\t\t\tsignal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)\n\n\t\t\tgo func() {\n\t\t\t\tsig := <-sigs\n\t\t\t\tlogger.Info(fmt.Sprintf(\"captured signal \\\"%s\\\"\", sig))\n\t\t\t\tonce.Do(cleanUp)\n\t\t\t}()\n\n\t\t\tcliCtx, err := sdkClient.GetClientTxContext(cmd)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t\/\/ dynamically adjust gas limit by simulating the tx first\n\t\t\ttxf := tx.NewFactoryCLI(cliCtx, cmd.Flags()).WithSimulateAndExecute(true)\n\n\t\t\tvaldConf := config.DefaultValdConfig()\n\t\t\tif err := serverCtx.Viper.Unmarshal(&valdConf); err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\n\t\t\tvalAddr := serverCtx.Viper.GetString(\"validator-addr\")\n\t\t\tif _, err := sdk.ValAddressFromBech32(valAddr); err != nil {\n\t\t\t\treturn sdkerrors.Wrap(err, \"invalid validator operator address\")\n\t\t\t}\n\n\t\t\tvaldHome := filepath.Join(cliCtx.HomeDir, \"vald\")\n\t\t\tif _, err := os.Stat(valdHome); os.IsNotExist(err) {\n\t\t\t\tlogger.Info(fmt.Sprintf(\"folder %s does not exist, creating...\", valdHome))\n\t\t\t\terr := os.Mkdir(valdHome, RWX)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar recoveryJSON []byte\n\t\t\trecoveryFile := serverCtx.Viper.GetString(\"tofnd-recovery\")\n\t\t\tif recoveryFile != \"\" {\n\t\t\t\trecoveryJSON, err = ioutil.ReadFile(recoveryFile)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif len(recoveryJSON) == 0 {\n\t\t\t\t\treturn fmt.Errorf(\"JSON file is empty\")\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfPath := filepath.Join(valdHome, \"state.json\")\n\t\t\tstateSource := NewRWFile(fPath)\n\n\t\t\tlogger.Info(\"start listening to events\")\n\t\t\tlisten(cliCtx, txf, valdConf, valAddr, recoveryJSON, stateSource, logger)\n\t\t\tlogger.Info(\"shutting down\")\n\t\t\treturn nil\n\t\t},\n\t}\n\tsetPersistentFlags(cmd)\n\tflags.AddTxFlagsToCmd(cmd)\n\tvalues := map[string]string{\n\t\tflags.FlagGasAdjustment: \"4\",\n\t\tflags.FlagGasPrices:     \"0.05uaxl\",\n\t}\n\tutils.OverwriteFlagDefaults(cmd, values, true)\n\n\t\/\/ Only set default, not actual value, so it can be overwritten by env variable\n\tutils.OverwriteFlagDefaults(cmd, map[string]string{\n\t\tflags.FlagBroadcastMode:  flags.BroadcastBlock,\n\t\tflags.FlagChainID:        app.Name,\n\t\tflags.FlagKeyringBackend: \"file\",\n\t}, false)\n\n\treturn cmd\n}\n\nfunc cleanUp() {\n\tfor _, cmd := range cleanupCommands {\n\t\tcmd()\n\t}\n}\n\nfunc setPersistentFlags(cmd *cobra.Command) {\n\tdefaultConf := tssTypes.DefaultConfig()\n\tcmd.PersistentFlags().String(\"tofnd-host\", defaultConf.Host, \"host name for tss daemon\")\n\tcmd.PersistentFlags().String(\"tofnd-port\", defaultConf.Port, \"port for tss daemon\")\n\tcmd.PersistentFlags().String(\"tofnd-recovery\", \"\", \"json file with recovery request\")\n\tcmd.PersistentFlags().String(\"validator-addr\", \"\", \"the address of the validator operator, i.e axelarvaloper1..\")\n\tcmd.PersistentFlags().String(flags.FlagChainID, app.Name, \"The network chain ID\")\n}\n\nfunc listen(ctx sdkClient.Context, txf tx.Factory, axelarCfg config.ValdConfig, valAddr string, recoveryJSON []byte, stateSource ReadWriter, logger log.Logger) {\n\tencCfg := app.MakeEncodingConfig()\n\tcdc := encCfg.Amino\n\tsender, err := ctx.Keyring.Key(ctx.From)\n\tif err != nil {\n\t\tpanic(sdkerrors.Wrap(err, \"failed to read broadcaster account info from keyring\"))\n\t}\n\tctx = ctx.\n\t\tWithFromAddress(sender.GetAddress()).\n\t\tWithFromName(sender.GetName())\n\n\tbc := createBroadcaster(txf, ctx, axelarCfg, logger)\n\n\ttmClient, err := ctx.GetNode()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t\/\/ in order to subscribe to events, the client needs to be running\n\tif !tmClient.IsRunning() {\n\t\tif err := tmClient.Start(); err != nil {\n\t\t\tpanic(fmt.Errorf(\"unable to start client: %v\", err))\n\t\t}\n\t}\n\n\tstateStore := NewStateStore(stateSource)\n\tstartBlock, err := getStartBlock(stateStore, tmClient, logger)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\teventBus := createEventBus(tmClient, startBlock, logger)\n\n\ttssMgr := createTSSMgr(bc, ctx, axelarCfg, logger, valAddr, cdc)\n\tif len(recoveryJSON) > 0 {\n\t\tif err = tssMgr.Recover(recoveryJSON); err != nil {\n\t\t\tpanic(fmt.Errorf(\"unable to perform tss recovery: %v\", err))\n\t\t}\n\t}\n\n\tevmMgr := createEVMMgr(axelarCfg, ctx, bc, logger, cdc)\n\n\t\/\/ we have two processes listening to block headers\n\tblockHeaderForTSS := tmEvents.MustSubscribeBlockHeader(eventBus)\n\tblockHeaderForStateUpdate := tmEvents.MustSubscribeBlockHeader(eventBus)\n\n\tsubscribe := func(eventType, module, action string) tmEvents.FilteredSubscriber {\n\t\treturn tmEvents.MustSubscribeWithAttributes(eventBus,\n\t\t\teventType, module, sdk.Attribute{Key: sdk.AttributeKeyAction, Value: action})\n\t}\n\n\tqueryHeartBeat := createNewBlockEventQuery(tssTypes.EventTypeHeartBeat, tssTypes.ModuleName, tssTypes.AttributeValueSend)\n\theartbeat, err := tmEvents.Subscribe(eventBus, queryHeartBeat)\n\tif err != nil {\n\t\tpanic(fmt.Errorf(\"unable to subscribe with ack event query: %v\", err))\n\t}\n\n\tkeygenStart := subscribe(tssTypes.EventTypeKeygen, tssTypes.ModuleName, tssTypes.AttributeValueStart)\n\n\tquerySign := createNewBlockEventQuery(tssTypes.EventTypeSign, tssTypes.ModuleName, tssTypes.AttributeValueStart)\n\tsignStart, err := tmEvents.Subscribe(eventBus, querySign)\n\tif err != nil {\n\t\tpanic(fmt.Errorf(\"unable to subscribe with sign event query: %v\", err))\n\t}\n\n\tkeygenMsg := subscribe(tssTypes.EventTypeKeygen, tssTypes.ModuleName, tssTypes.AttributeValueMsg)\n\tsignMsg := subscribe(tssTypes.EventTypeSign, tssTypes.ModuleName, tssTypes.AttributeValueMsg)\n\n\tevmNewChain := subscribe(evmTypes.EventTypeNewChain, evmTypes.ModuleName, evmTypes.AttributeValueUpdate)\n\tevmChainConf := subscribe(evmTypes.EventTypeChainConfirmation, evmTypes.ModuleName, evmTypes.AttributeValueStart)\n\tevmGatewayDeploymentConf := subscribe(evmTypes.EventTypeGatewayDeploymentConfirmation, evmTypes.ModuleName, evmTypes.AttributeValueStart)\n\tevmDepConf := subscribe(evmTypes.EventTypeDepositConfirmation, evmTypes.ModuleName, evmTypes.AttributeValueStart)\n\tevmTokConf := subscribe(evmTypes.EventTypeTokenConfirmation, evmTypes.ModuleName, evmTypes.AttributeValueStart)\n\tevmTraConf := subscribe(evmTypes.EventTypeTransferKeyConfirmation, evmTypes.ModuleName, evmTypes.AttributeValueStart)\n\n\teventCtx, cancelEventCtx := context.WithCancel(context.Background())\n\t\/\/ stop the jobs if process gets interrupted\/terminated\n\tcleanupCommands = append(cleanupCommands, func() {\n\t\tlogger.Info(\"stopping listening for blocks...\")\n\t\tblockHeaderForTSS.Close()\n\t\tlogger.Info(\"block listener stopped\")\n\t\tlogger.Info(\"stop listening for events...\")\n\t\tcancelEventCtx()\n\t\t<-eventBus.Done()\n\t\tlogger.Info(\"event listener stopped\")\n\t})\n\n\tfetchEvents := func(errChan chan<- error) { errChan <- <-eventBus.FetchEvents(eventCtx) }\n\tjs := []jobs.Job{\n\t\tfetchEvents,\n\t\ttmEvents.Consume(blockHeaderForStateUpdate, tmEvents.OnlyBlockHeight(stateStore.SetState)),\n\t\ttmEvents.Consume(blockHeaderForTSS, tmEvents.OnlyBlockHeight(func(height int64) error {\n\t\t\ttssMgr.ProcessNewBlockHeader(height)\n\t\t\treturn nil\n\t\t})),\n\t\ttmEvents.Consume(heartbeat, tssMgr.ProcessHeartBeatEvent),\n\t\ttmEvents.Consume(keygenStart, tssMgr.ProcessKeygenStart),\n\t\ttmEvents.Consume(keygenMsg, tssMgr.ProcessKeygenMsg),\n\t\ttmEvents.Consume(signStart, tssMgr.ProcessSignStart),\n\t\ttmEvents.Consume(signMsg, tssMgr.ProcessSignMsg),\n\t\ttmEvents.Consume(evmNewChain, evmMgr.ProcessNewChain),\n\t\ttmEvents.Consume(evmChainConf, evmMgr.ProcessChainConfirmation),\n\t\ttmEvents.Consume(evmGatewayDeploymentConf, evmMgr.ProcessGatewayDeploymentConfirmation),\n\t\ttmEvents.Consume(evmDepConf, evmMgr.ProcessDepositConfirmation),\n\t\ttmEvents.Consume(evmTokConf, evmMgr.ProcessTokenConfirmation),\n\t\ttmEvents.Consume(evmTraConf, evmMgr.ProcessTransferKeyConfirmation),\n\t}\n\n\t\/\/ errGroup runs async processes and cancels their context if ANY of them returns an error.\n\t\/\/ Here, we don't want to stop on errors, but simply log it and continue, so errGroup doesn't cut it\n\tlogErr := func(err error) { logger.Error(err.Error()) }\n\tmgr := jobs.NewMgr(logErr)\n\tmgr.AddJobs(js...)\n\tmgr.Wait()\n}\n\nfunc getStartBlock(stateStore StateStore, tmClient rpcclient.Client, logger log.Logger) (int64, error) {\n\tstartBlock, err := stateStore.GetState()\n\tif err != nil {\n\t\tlogger.Error(err.Error())\n\n\t\treturn 0, nil\n\t}\n\n\trpcCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\tstatus, err := tmClient.Status(rpcCtx)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\t\/\/ TODO: Make it configurable instead of a hardcoded 100\n\tif status.SyncInfo.LatestBlockHeight-startBlock > 100 {\n\t\tlogger.Info(fmt.Sprintf(\"block in state %d is too old and will start from the latest instead\", startBlock))\n\n\t\treturn 0, nil\n\t}\n\n\treturn startBlock + 1, nil\n}\n\nfunc createNewBlockEventQuery(eventType, module, action string) tmEvents.Query {\n\treturn tmEvents.Query{\n\t\tTMQuery: tmEvents.NewBlockHeaderEventQuery(eventType).MatchModule(module).MatchAction(action).Build(),\n\t\tPredicate: func(e tmEvents.Event) bool {\n\t\t\treturn e.Type == eventType && e.Attributes[sdk.AttributeKeyModule] == module && e.Attributes[sdk.AttributeKeyAction] == action\n\t\t},\n\t}\n}\n\nfunc createEventBus(client rpcclient.Client, startBlock int64, logger log.Logger) *tmEvents.Bus {\n\tnotifier := tmEvents.NewBlockNotifier(tmEvents.NewBlockClient(client), logger).StartingAt(startBlock)\n\treturn tmEvents.NewEventBus(tmEvents.NewBlockSource(client, notifier), pubsub.NewBus, logger)\n}\n\nfunc createBroadcaster(txf tx.Factory, ctx sdkClient.Context, axelarCfg config.ValdConfig, logger log.Logger) broadcasterTypes.Broadcaster {\n\tpipeline := broadcaster.NewPipelineWithRetry(10000, axelarCfg.MaxRetries, utils2.LinearBackOff(axelarCfg.MinTimeout), logger)\n\treturn broadcaster.NewBroadcaster(txf, ctx, pipeline, axelarCfg.BatchThreshold, axelarCfg.BatchSizeLimit, logger)\n}\n\nfunc createTSSMgr(broadcaster broadcasterTypes.Broadcaster, cliCtx client.Context, axelarCfg config.ValdConfig, logger log.Logger, valAddr string, cdc *codec.LegacyAmino) *tss.Mgr {\n\tcreate := func() (*tss.Mgr, error) {\n\t\tconn, err := tss.Connect(axelarCfg.TssConfig.Host, axelarCfg.TssConfig.Port, axelarCfg.TssConfig.DialTimeout, logger)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tlogger.Debug(\"successful connection to tofnd gRPC server\")\n\n\t\t\/\/ creates clients to communicate with the external tofnd process service\n\t\tgg20client := tofnd.NewGG20Client(conn)\n\t\tmultiSigClient := tofnd.NewMultisigClient(conn)\n\n\t\ttssMgr := tss.NewMgr(gg20client, multiSigClient, cliCtx, 2*time.Hour, valAddr, broadcaster, logger, cdc)\n\n\t\treturn tssMgr, nil\n\t}\n\tmgr, err := create()\n\tif err != nil {\n\t\tpanic(sdkerrors.Wrap(err, \"failed to create tss manager\"))\n\t}\n\n\treturn mgr\n}\n\nfunc createEVMMgr(axelarCfg config.ValdConfig, cliCtx client.Context, b broadcasterTypes.Broadcaster, logger log.Logger, cdc *codec.LegacyAmino) *evm.Mgr {\n\trpcs := make(map[string]evmRPC.Client)\n\n\tfor _, evmChainConf := range axelarCfg.EVMConfig {\n\t\tif !evmChainConf.WithBridge {\n\t\t\tlogger.Debug(fmt.Sprintf(\"RPC connection is disabled for EVM chain %s. Skipping...\", evmChainConf.Name))\n\t\t\tcontinue\n\t\t}\n\n\t\tif _, found := rpcs[strings.ToLower(evmChainConf.Name)]; found {\n\t\t\tmsg := fmt.Errorf(\"duplicate bridge configuration found for EVM chain %s\", evmChainConf.Name)\n\t\t\tlogger.Error(msg.Error())\n\t\t\tpanic(msg)\n\t\t}\n\n\t\trpc, err := evmRPC.NewClient(evmChainConf.RPCAddr, evmChainConf.EnableRPCDetection)\n\t\tif err != nil {\n\t\t\terr = sdkerrors.Wrap(err, fmt.Sprintf(\"Failed to create an RPC connection for EVM chain %s. Verify your RPC config.\", evmChainConf.Name))\n\t\t\tlogger.Error(err.Error())\n\t\t\tpanic(err)\n\t\t}\n\t\t\/\/ clean up evmRPC connection on process shutdown\n\t\tcleanupCommands = append(cleanupCommands, rpc.Close)\n\n\t\trpcs[strings.ToLower(evmChainConf.Name)] = rpc\n\t\tlogger.Info(fmt.Sprintf(\"Successfully connected to EVM bridge for chain %s\", evmChainConf.Name))\n\t}\n\n\tevmMgr := evm.NewMgr(rpcs, cliCtx, b, logger, cdc)\n\treturn evmMgr\n}\n\n\/\/ RWFile implements the ReadWriter interface for an underlying file\ntype RWFile struct {\n\tpath string\n}\n\n\/\/ NewRWFile returns a new RWFile instance for the given file path\nfunc NewRWFile(path string) RWFile {\n\treturn RWFile{path: path}\n}\n\n\/\/ ReadAll returns the full content of the file\nfunc (f RWFile) ReadAll() ([]byte, error) { return os.ReadFile(f.path) }\n\n\/\/ WriteAll writes the given bytes to a file. Creates a new fille if it does not exist, overwrites the previous content otherwise.\nfunc (f RWFile) WriteAll(bz []byte) error { return os.WriteFile(f.path, bz, RW) }\n","avg_line_length":37.0176322418,"max_line_length":181,"alphanum_fraction":0.7474142624,"licenses":["Apache-2.0"],"repository_name":"Errorist79\/axelar-core","path":"cmd\/axelard\/cmd\/vald\/start.go","size":14696,"lang":"GO"}
